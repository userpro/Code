Problem1000

#include <iostream>
using namespace std;
int main()
{
	int a, b;
	cin >> a >> b;
	cout << a + b << endl;
}
Problem1001

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
//#define DEBUG
using namespace std;
const int MAXN = 1501, S = 2097152 - 1;
int n, m, map[MAXN][MAXN][4];
int dis[MAXN][MAXN][2];
bool vis[MAXN][MAXN][2];
int l, r;
struct Tqueue { int x, y, d; } q[S + 1001];
void special()
{
	if (n == 1 && m == 1){
		puts("0"); return;
		}
 	int ans = 0x3f3f3f3f;
	if (n == 1){
		for (int j = 1; j < m; j++) ans = min(ans, map[1][j][1]);
		printf("%d\n", ans);
		}
	if (m == 1){
		for (int i = 1; i < n; i++) ans = min(ans, map[i][1][2]);
		printf("%d\n", ans);
		}
}
void relax(int x, int y, int d, int DIS)
{
	if (DIS < dis[x][y][d]){
		dis[x][y][d] = DIS;
#ifdef DEBUG
		printf("%d %d %d = %d\n", x, y, d, DIS);
#endif
		if (!vis[x][y][d]){
			r = (r + 1) & S; q[r].x = x; q[r].y = y; q[r].d = d;
			vis[x][y][d] = true;
			}
		}
}
void expand1(int x, int y)
{
	if (x == n && y == 0){
		relax(n - 1, 0, 0, dis[x][y][0]);
		relax(n, 1, 0, dis[x][y][0]);
		}
	if (x == 0 && y == m){
		relax(0, m - 1, 0, dis[x][y][0]);
		relax(1, m, 0, dis[x][y][0]);
		}
	if (x == 0){
		if (y != 1){
			int nx = x, ny = y - 1;
			relax(nx, ny, 0, dis[x][y][0]);
			}
		if (y != m){
			int nx = x, ny = y + 1;
			relax(nx, ny, 0, dis[x][y][0]);
			nx = x + 1, ny = y;
			relax(nx, ny, 0, dis[x][y][0] + map[nx][ny][1]);
			}
		}
	if (x == n){
		if (y != 0){
			int nx = x, ny = y - 1;
			relax(nx, ny, 0, dis[x][y][0]);
			}
		if (y != m){
			int nx = x, ny = y + 1;
			if (ny != m) relax(nx, ny, 0, dis[x][y][0]);
			nx = x - 1, ny = y;
			relax(nx, ny, 1, dis[x][y][0] + map[x][y][1]);
			}
		}
	if (y == 0){
		if (x != 1){
			int nx = x - 1, ny = y;
			relax(nx, ny, 0, dis[x][y][0]);
			}
		if (x != n){
			int nx = x + 1, ny = y;
			relax(nx, ny, 0, dis[x][y][0]);
			nx = x, ny = y + 1;
			relax(nx, ny, 1, dis[x][y][0] + map[nx][ny][2]);
			}
		}
	if (y == m){
		if (x != 0){
			int nx = x - 1, ny = y;
			relax(nx, ny, 0, dis[x][y][0]);
			}
		if (x != n){
			int nx = x + 1, ny = y;
			if (ny != m) relax(nx, ny, 0, dis[x][y][0]);
			nx = x, ny = y - 1;
			relax(nx, ny, 0, dis[x][y][0] + map[x][y][2]);
			}
		}
}
void expand2(int x, int y, int d)
{
	if (d == 0){
		int nx = x - 1, ny = y, nd = 1;
		if (nx == 0) nd = 0;
		relax(nx, ny, nd, dis[x][y][d] + map[x][y][1]);
		nx = x, ny = y + 1, nd = 1;
		if (ny == m) nd = 0;
		relax(nx, ny, nd, dis[x][y][d] + map[nx][ny][2]);
		nx = x, ny = y, nd = 1;
		relax(nx, ny, nd, dis[x][y][d] + map[x][y][3]);
		}
	if (d == 1){
		int nx = x + 1, ny = y, nd = 0;
		if (nx == n) nd = 0;
		relax(nx, ny, nd, dis[x][y][d] + map[nx][ny][1]);
		nx = x, ny = y - 1, nd = 0;
		if (ny == 0) nd = 0;
		relax(nx, ny, nd, dis[x][y][d] + map[x][y][2]);
		nx = x, ny = y, nd = 0;
		relax(nx, ny, nd, dis[x][y][d] + map[x][y][3]);
		}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j < m; j++)
			scanf("%d", &map[i][j][1]);
	for (int i = 1; i < n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &map[i][j][2]);
	for (int i = 1; i < n; i++)
		for (int j = 1; j < m; j++)
			scanf("%d", &map[i][j][3]);
	if (n == 1 || m == 1){
		special(); return 0;
		}
	memset(dis, 0x3f, sizeof(dis));
	l = 0; r = 1; dis[n][0][0] = 0; vis[n][0][0] = true;
	q[1].x = n; q[1].y = 0; q[1].d = 0;
	while(l != r){
		l = (l + 1) & S; int x = q[l].x, y = q[l].y, d = q[l].d; vis[x][y][d] = false;
		if (x == 0 || y == 0 || x == n || y == m) expand1(x, y); else expand2(x, y, d);
		}
	printf("%d\n", dis[0][m][0]);
	return 0;
}
Problem1002

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define pz putchar('0');
using namespace std;
struct Big{
	int len, data[1001];
	void clear() { memset(this, 0, sizeof(*this)); }
	int & operator [] (int k) { return data[k]; }
	Big & operator = (int k) { len = 1; data[1] = k; return *this; }
	Big operator + (Big A)
	{
		Big temp; temp.clear(); temp.len = max(A.len, len);
		for (int i = 1; i <= temp.len; i++){
			temp[i] += (A[i] + data[i]);
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator * (int k)
	{
		Big temp; temp.clear(); temp.len = len;
		for (int i = 1; i <= temp.len; i++){
			temp[i] += k * data[i];
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator * (Big A)
	{
		Big temp; temp.clear(); temp.len = len + A.len - 1;
		for (int i = 1; i <= len; i++)
			for (int j = 1; j <= A.len; j++){
				temp[i + j - 1] += A[j] * data[i];
				temp[i + j] += temp[i + j - 1] / 10000;
				temp[i + j - 1] %= 10000;
				}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator - (Big A)
	{
		Big temp; temp.clear(); temp.len = max(len, A.len);
		for (int i = 1; i <= len; i++){
			temp[i] = temp[i] + data[i] - A[i];
			if (temp[i] < 0) temp[i] += 10000, temp[i + 1] -=1;
			}
		while(temp[temp.len] == 0) --temp.len;
		return temp;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--){
			if (data[i] < 1000) pz;
			if (data[i] < 100) pz;
			if (data[i] < 10) pz;
			printf("%d", data[i]);
			}
		putchar('\n');
	}
} f[1001];
int n;
void work1()
{
	n = (n + 1) >> 1;
	f[1] = 1; f[2] = 4;
	for (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2];
	Big temp = f[n] * f[n]; temp.print();
}
void work2()
{
	n >>= 1;
	f[1] = 1; f[2] = 3;
	for (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2];
	Big temp = f[n] * f[n] * 5; temp.print();
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	if (n & 1) work1(); else work2();
}
Problem1003

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN = 21, MAXM = 10000;
int n, m, K, day;
bool cant[1001][1001];
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM], w[MAXM], dis[MAXN];
	bool can[MAXN], vis[MAXN];
	deque<int> Q;
	void init()
	{
		memset(can, 1, sizeof(can));
	}
	void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void disable(int v)
	{
		can[v] = false;
	}
	void enable(int v)
	{
		can[v] = true;
	}
	int shortest()
	{
		memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis));
		Q.clear();
		Q.push_back(1); dis[1] = 0;
		while(!Q.empty()){
			int x = Q.front(); vis[x] = false; Q.pop_front(); if (!can[x]) continue;
			for (int i = e[x]; i; i = next[i]){
				if (dis[x] + w[i] < dis[v[i]]){
					dis[v[i]] = dis[x] + w[i];
					if (!vis[v[i]]){
						vis[v[i]] = true; Q.push_back(v[i]);
						}
					}
				}
			}
		return dis[n];
	}
} G;
int f[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &day, &n, &K, &m);
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z); G.add(x, y, z); G.add(y, x, z);
		}
	int d;
	scanf("%d", &d);
	for (int i = 1; i <= d; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		for (int i = b; i <= c; i++) cant[i][a] = true;
		}
	f[0] = 0;
	for (int i = 1; i <= day; i++){
		f[i] = 0x3f3f3f3f;
		for (int j = i - 1; j >= 0; j--){
			G.init();
			for (int k = j + 1; k <= i; k++)
				for (int l = 1; l <= n; l++)
						if (cant[k][l]) G.disable(l);
			int sh = G.shortest(); if (sh == 0x3f3f3f3f) continue;
			f[i] = min(f[i], f[j] + sh * (i - j) + K);
			}
		}
	printf("%d\n", f[day] - K);
	
}
Problem1004

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, a, b, c, m, p;
int tot, num, nu[1001], now;
bool vis[1001];
int h[1001][1001];
int f[61][21][21];
void make(int x)
{
	if (vis[x]){
		++tot; nu[tot] = num; return;
		}
	vis[x] = true; ++num; make(h[now][x]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d%d", &a, &b, &c, &m, &p); n = a + b + c;
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++) scanf("%d", &h[i][j]);
	for (int i = 1; i <= n; i++) h[m + 1][i] = i;
	++m;
	int ans = 0;
	for (now = 1; now <= m; now++){
		tot = 0;
		memset(vis, 0, sizeof(vis));
		for (int j = 1; j <= n; j++) if (!vis[j]) { num = 0; make(j); };
		memset(f, 0, sizeof(f));
		int sum = 0;
		f[0][0][0] = 1;
		for (int i = 1; i <= tot; i++){
			sum += nu[i];
			for (int ta = 0; ta <= a; ta++)
				for (int tb = 0; tb <= b; tb++){
					int tc = sum - ta - tb; if (tc < 0) continue;
					if (ta >= nu[i]) f[i][ta][tb] = (f[i][ta][tb]+ f[i - 1][ta - nu[i]][tb]) % p;
					if (tb >= nu[i]) f[i][ta][tb] = (f[i][ta][tb]+ f[i - 1][ta][tb - nu[i]]) % p;
					if (tc >= nu[i]) f[i][ta][tb] = (f[i][ta][tb] + f[i - 1][ta][tb]) % p;
					}
			}
		ans = (ans + f[tot][a][b]) % p;
		}
	for (int i = 1; i <= p - 2; i++) ans = (ans * m) % p;
	printf("%d\n", ans);
}
Problem1005

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define pz putchar('0')
using namespace std;
struct Big{
    static Big temp1, temp2;
	int len, data[3001];
	void clear() { memset(this, 0, sizeof(*this));  len = 1;}
	Big & operator = (int k)
	{
	    memset(this, 0, sizeof(*this));
	    len = 0;
		while(k)
            { ++len; data[len] = k % 10000; k /= 10000; }
		if (len == 0) len = 1;
		return *this;
	}
	int & operator [] (int k) { return data[k]; }
	Big operator * (int k)
	{
#define temp temp2
		Big temp; temp.clear(); temp.len = len;
		for (int i = 1; i <= temp.len; i++){
			temp[i] += k * data[i];
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		while(temp[temp.len] == 0) --temp.len; if (temp.len <= 0) temp.len = 1;
		return temp;
#undef temp
	}
    Big operator / (int k)
    {
#define temp temp1
        temp.clear(); temp.len = len;
        int now = 0;
        for (int i = len; i >= 1; i--){
            temp[i] = now * 10000 + data[i];
            now = temp[i] % k;
            temp[i] = temp[i] / k;
            }
        while(temp[temp.len] == 0) --temp.len;
        return temp;
#undef temp
    }
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--){
			if (data[i] < 1000) pz;
			if (data[i] < 100) pz;
			if (data[i] < 10) pz;
			printf("%d", data[i]);
			}
		putchar('\n');
	}
} TEMP1, TEMP2, Big::temp1 = TEMP1, Big::temp2 = TEMP2;
int n, d[10001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d", &n);
    int w = 0, sum = 0; Big ans; ans = 1;
    for (int i = 1; i <= n; i++){
        scanf("%d", &d[i]);
		if (d[i] == -1) ++w;
		else sum += (--d[i]);
        }
    for (int i = 1; i <= n - sum - 2; i++) ans = ans * w;
    for (int i = 1; i <= n - 2; i++) ans = ans * i;
    for (int i = 1; i <= n; i++)
        if (d[i] >= 0) for (int j = 1; j <= d[i]; j++) ans = ans / j;

    for (int i = 1; i <= n - sum - 2; i++) ans = ans / i;
    ans.print();
}
Problem1006

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
int tot, e[2500001], next[2500001], v[2500001];
int n, m, p[2500001], lab[2500001];
int col[2500001], can[2500001];
bool vis[2500001];
void add(int x, int y)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); add(x, y); add(y, x);
		}
	p[1] = 1; vis[1] = true;
	for (int i = 2; i <= n; i++){
		
		for (int j = e[p[i - 1]]; j; j = next[j]) ++lab[v[j]];
		int who, MAX = 0xe0e0e0e0;
		for (int i = 1; i <= n; i++) if (!vis[i] && lab[i] > MAX) MAX = lab[i], who = i;
		p[i] = who; vis[who] = true;
		}
	int ans = 0;
	for (int i = 1; i <= n; i++){
		for (int j = e[p[i]]; j; j = next[j]) if (col[v[j]]) can[col[v[j]]] = p[i];
		for (int j = 1; ; j++) if (can[j] != p[i]) { col[p[i]] = j; if (j > ans) ans = j; break; }		
		}
	printf("%d\n", ans);
}
			
	
Problem1007

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int MAXN = 500001;
const double eps = 1e-6;
int dblcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	return 1;
}
struct Tline{
	int k, b, ord;
	bool operator < (const Tline &A) const
	{
		return k == A.k ? b > A.b : k < A.k;
	}
	double operator * (Tline A)
	{
		return (double(A.b) - double(b)) / (double(k) - double(A.k));
	}
	} line[MAXN];
bool cmp(int a, int b)
{
	return line[a].ord < line[b].ord;
}
struct Tstack{
	int top, data[MAXN];
	int & operator [] (int k) { return data[k]; }
	void push(int t)
	{
		while(top >= 2 && dblcmp(line[t] * line[data[top]] - line[t] * line[data[top - 1]]) < 0) --top;
		data[++top] = t;
	}
	} stack;	
int n;
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) line[i].ord = i;
	for (int i = 1; i <= n; i++) scanf("%d%d", &line[i].k, &line[i].b);
	sort(line + 1, line + n + 1);
	for (int i = 1; i <= n; i++) if (line[i].b != line[i - 1].b) stack.push(i);	
	sort(stack.data + 1, stack.data + stack.top + 1, cmp);
	for (int i = 1; i < stack.top; i++) printf("%d ", line[stack[i]].ord); printf("%d\n", line[stack[stack.top]].ord);
}
Problem1008

#include <iostream>
using namespace std;
long long pow(long long a, long long b)
{
	long long ans = 1;
	for (; b; b >>= 1){
		if (b & 1) ans = ans * a % 100003;
		a = a * a % 100003; 
		}
	return ans;
}
int main()
{
	long long n, m;
	cin >> m >> n;
	long long ans = (pow(m, n) - (pow(m - 1, n - 1) * m) % 100003) % 100003;
	cout << (ans + 100003) % 100003 << endl;
}	
Problem1009

#include <iostream>
#include <cstring>
#include <string>
#include <algorithm>
#include <cstdio>
#define ll long long
using namespace std;
int K;
struct Tmatrix{
	static Tmatrix temp;
	int r, c; ll data[31][31];
	void clear() { memset(this, 0, sizeof(*this)); }
	ll* operator [] (int k) { return data[k]; }
	Tmatrix operator * (Tmatrix A) 
	{
		temp.clear(); temp.r = r; temp.c = A.c;
		for (int i = 0; i <= temp.r; i++)
			for (int j = 0; j <= temp.c; j++)
				for (int k = 0; k <= c; k++)
					temp[i][j] = (temp[i][j] + (data[i][k] * A[k][j]) % K) % K;
		return temp;
	}
} TEMP, Tmatrix::temp = TEMP, dw, ans;
Tmatrix pow(Tmatrix t, int n)
{
	Tmatrix ret;
	ret.r = t.r; ret.c = t.c;
	for (int i = 0; i <= ret.r; i++) ret.data[i][i] = 1;
	for (; n; n >>= 1){
		if (n & 1) ret = ret * t;
		t = t * t;
		}
	return ret;
}
int n, m;
string S;
int main()
{	
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> m >> K;
	cin >> S;
	for (int i = 0; i < m; i++){
		for (char t = '0'; t <= '9'; t++){
			string s = S.substr(0, i); if (i == 0) s = "";
			s = s + t;
			for (int k = i + 1; k >= 0; k--){
				if (S.substr(0, k) == s.substr(i + 1 - k, k)){
					++dw[i][k]; break;
					}
				}
			}
		}
	dw.r = m - 1; dw.c = m - 1;
	ans[0][0] = 1; ans.r = 0; ans.c = m - 1; ans = ans * pow(dw, n);
	int ansm = 0;
	for (int i = 0; i < m; i++) ansm = (ansm + ans[0][i]) % K;
	printf("%d\n", ansm);
}
Problem1010

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 1000001;
struct Tpoint{
	ll x, y;
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = x - A.x; temp.y = y - A.y;
		return temp;
	}
	ll operator * (Tpoint A)
	{
		return x * A.y - y * A.x;
	}	 
} q[MAXN];
int n, a[MAXN];
ll L, sum[MAXN], f[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &L); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + (ll)(a[i]);
	f[0] = 0; int l = 1, r = 1;
	for (int i = 1; i <= n; i++){
		while(l != r && ((2ll * (ll)(sum[i] + i - L - 1) * (ll)(q[l + 1].x - q[l].x)) > (ll)(q[l + 1].y - q[l].y))) l++;
		f[i] = q[l].y - 2 * (sum[i] + i - L - 1) * q[l].x + (sum[i] + i - L - 1) * (sum[i] + i - L - 1);
		ll nx = sum[i] + i, ny = f[i] + (sum[i] + i) * (sum[i] + i);
		Tpoint p; p.x = nx; p.y = ny;
		while(r - l >= 1 && (((q[r - 1] - q[r]) * (p - q[r])) > 0)) --r;
		q[++r] = p;
		}
	cout << f[n] << endl;
}
Problem1011

#include <cstdio>
#include <cstdlib>
#include <cstring>
long double a[1000001], ans[1000001];
int n, g[1000001];
double k;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%lf", &n, &k);
	for (int i = 1; i <= n; i++){
		double t; scanf("%lf", &t); a[i] = (long double)(t);
		g[i] = int(i * k + 1e-5);
		}
	for (int i = 1; i <= n; i++){
		for (int j = g[i]; j > 0 && (i <= 100 || j > g[i - 100]); j--)
            ans[i] = ans[i] + a[j] * a[i] / (i - j);
        if (i > 100)
        	ans[i] += a[i] * (ans[i - 100] * (i - 100 - g[i - 100] / 2) / 
			          ((a[i - 100]) * (i - g[i - 100] / 2)));
		double t = double(ans[i]);
		printf("%.12lf\n", t);
		}
}        
        
Problem1012

#include <cstdio>
#include <cstdlib>
#include <cstring>
int m, d;
int max[1200001];
void change(int idx, int l, int r, int x, int num)
{
	if (l == r){ max[idx] = num; return; }
	int m = l + r >> 1;
	if (x <= m) change(idx * 2, l, m, x, num); else change(idx * 2 + 1, m + 1, r, x, num);
	max[idx] = max[idx * 2] > max[idx * 2 + 1] ? max[idx * 2] : max[idx * 2 + 1];
}
int query(int idx, int l, int r, int ll, int rr)
{
	if (ll <= l && rr >= r) return max[idx];
	int m = l + r >> 1, ret = 0xe0e0e0e0;
	if (ll <= m) { int t = query(idx * 2, l, m, ll, rr); ret = t > ret ? t : ret; }
	if (rr > m) { int t = query(idx * 2 + 1, m + 1, r, ll, rr); ret = t > ret ? t : ret; }
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	memset(max, 0xe0, sizeof(max));
	scanf("%d%d", &m, &d);
	int t = 0, len = 0;
	for (int i = 1; i <= m; i++){
		char op[101]; int num;
		scanf("%s%d", op, &num);
		switch(*op){
			case 'A':
				num = (num + t) % d;
				change(1, 1, m, ++len, num);
				break;
			case 'Q':
				t = query(1, 1, m, len - num + 1, len);
				printf("%d\n", t);
				break;
			}
		}
}
Problem1013

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
const double eps = 1e-6;
using namespace std;
int n, where[1001];
double num[1001][1001], a[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n + 1; i++)
		for (int j = 1; j <= n; j++) scanf("%lf", &num[i][j]);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++) a[i][j] = 2 * (num[i + 1][j] - num[i][j]);
		for (int j = 1; j <= n; j++) a[i][0] += num[i + 1][j] * num[i + 1][j] - num[i][j] * num[i][j];
		}
	for (int i = 1; i <= n; i++){
		int p = 1; for (int j = 2; j <= n; j++) if (fabs(a[i][j]) > fabs(a[i][p])) p = j;
		where[p] = i;
		double t = a[i][p];
		for (int j = 0; j <= n; j++) a[i][j] /= t;
		for (int j = 1; j <= n; j++) if (i != j){
			double t = a[j][p] / a[i][p];
			for (int k = 0; k <= n; k++) a[j][k] -= t * a[i][k];
			}
		}
	for (int i = 1; i < n; i++) printf("%.3lf ", a[where[i]][0]);
	printf("%.3lf\n", a[where[n]][0]);
}
Problem1014

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
const int MAXN = 1000001;
using namespace std;
const ll MO = 223092870 - 1;
char in[1000001];
int root, tot;
ll mi[MAXN];
int nowlen;
struct Tnode{
	static Tnode *a;
	int f, c[2], size;
	ll hash;
	char al;
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		hash = ((a[c[0]].hash + (a[c[1]].hash * mi[a[c[0]].size + 1]) % MO) % MO 
			 + ((ll)(al) * mi[a[c[0]].size + 1]) % MO ) % MO;
	}
	void rot(bool b)
	{
		a[a[c[!b]].f = f].c[b] = c[!b]; c[!b] = f;
		f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} t[MAXN], *Tnode::a = t;
void splay(int x, int p)
{
	int y, z; bool b, c;
	while((y = t[x].f) != p){
		b = x == t[y].c[1];
		if ((z = t[y].f) != p){
			c = y == t[z].c[1];
			if (b == c) t[y].rot(b); else t[x].rot(b);
			t[x].rot(c);
			}
		else t[x].rot(b);
		}
	t[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int T, x = root;
	while((T = t[t[x].c[0]].size + 1) != k){
		if (T > k) x = t[x].c[0];
		else k -= T, x = t[x].c[1];
		}
	return x;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = l + r >> 1;
	int now = ++tot;
	t[now].c[0] = build(l, m - 1); t[t[now].c[0]].f = now;
	t[now].c[1] = build(m + 1, r); t[t[now].c[1]].f = now;
	if (m == 0 || m == nowlen + 1) t[now].al = 0;
	else t[now].al = in[m - 1];
	t[now].update(); return now;
}
int gethash(int l, int r)
{
	splay(select(l), 0); 
	splay(select(r + 2), root);
	return t[t[t[root].c[1]].c[0]].hash;
}
void QUERY(int a, int b)
{
	int l = 1, r = nowlen - max(a, b) + 1;
	if (gethash(a, a) != gethash(b, b)) { printf("0\n"); return; }
	if (gethash(a, a + r - 1) == gethash(b, b + r - 1)) { printf("%d\n", r); return; }
	--r;
	while(l <= r){
		int m = l + r >> 1;
		if (gethash(a, a + m - 1) == gethash(b, b + m - 1)) l = m + 1; else r = m - 1;
		}
	printf("%d\n", r);
}
void REPLACE(int x, char c)
{
	splay(select(x), 0);
	splay(select(x + 2), root);
	t[t[t[root].c[1]].c[0]].al = c;
	splay(t[t[root].c[1]].c[0], 0);
}
void INSERT(int x, char c)
{
	splay(select(x + 1), 0);
	splay(select(x + 2), root);
	t[t[root].c[1]].c[0] = ++tot; t[tot].f = t[root].c[1];
	t[tot].al = c; splay(tot, 0);
	++nowlen;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	mi[0] = 1; for (int i = 1; i <= MAXN - 1; i++) mi[i] = (mi[i - 1]) * 133331ll % MO;
	scanf("%s", in);
	nowlen = strlen(in); root = build(0, strlen(in) + 1);
	int Q; scanf("%d", &Q);
	while(Q--){
		char op[101]; scanf("%s", op);
		int l, r, x; char c;
		switch(*op){
			case 'Q': scanf("%d%d", &l, &r); QUERY(l, r); break;
			case 'R': scanf("%d%*c%c", &x, &c); REPLACE(x, c); break;
			case 'I': scanf("%d%*c%c", &x, &c); INSERT(x, c); break;
			}
		}
}
Problem1015

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m;
int tot, e[1200001], next[1200001], v[1200001];
int Q, q[1200001], f[1200001];
bool cant[1200001];
int ans[1200001];
int find(int v) { return v == f[v] ? v : f[v] = find(f[v]); }
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); add(x, y); add(y, x);
		}
	for (int i = 0; i < n; i++) f[i] = i;
	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		scanf("%d", &q[i]); cant[q[i]] = true;
		}
	int nowans = 0;
	for (int i = 0; i < n; i++) if (cant[i] == false){
		bool can = false;
		for (int j = e[i]; j; j = next[j]) 
			if (i > v[j] && cant[v[j]] == false){
				if (can == false){
					f[i] = v[j]; can = true;
					}
				else{
					int a = find(i), b = find(v[j]);
					if (a != b) f[a] = b, --nowans;
					}
				}
		if (can == false) ++nowans;
		}
	ans[Q] = nowans;
	for (int i = Q; i >= 1; i--){
		for (int j = e[q[i]]; j; j = next[j]) 
			if (cant[v[j]] == false){
				int t = find(v[j]); if (t != q[i]) f[t] = q[i], --nowans;
				}
		++nowans;
		ans[i - 1] = nowans; cant[q[i]] = false;
		}
	for (int i = 0; i <= Q; i++) printf("%d\n", ans[i]);
}
	
Problem1016

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 201, MAXM = 200001;
using namespace std;
struct Tedge{
	int st, ed, len;
	bool operator < (const Tedge & A) const
	{
		return len < A.len;
	}
} edge[MAXM];
int now, tnum, num, ans, ret, n, m;
struct TUF{
	int f[MAXN];
	void clear()
	{
		for (int i = 1; i <= n; i++) f[i] = i;
	}
	int getf(int v)
	{
		return v == f[v] ? v : f[v] = getf(f[v]);
	}
	bool u(int a, int b)
	{
		a = getf(a); b = getf(b);
		if (a == b) return false; else return f[a] = b, true;
	}
} NOW, LAST;
void DFS(int depth, int get)
{
	if (depth == now + 1 && get == tnum){
		++ret; return;
		}
	if (depth == now + 1) return;
	DFS(depth + 1, get);
	TUF temp = LAST;
	if (LAST.u(edge[depth].st, edge[depth].ed)) DFS(depth + 1, get + 1);
	LAST = temp;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d%d%d", &edge[i].st, &edge[i].ed, &edge[i].len);
	sort(edge + 1, edge + m + 1);
	num = 0; ans = 1;
	NOW.clear(); LAST.clear();
	for (int i = 1; i <= m;){
		now = i;
		while(i < m && edge[i].len == edge[now + 1].len) ++now;
		tnum = 0;
		for (int j = i; j <= now; j++) tnum += NOW.u(edge[j].st, edge[j].ed);
		ret = 0; DFS(i, 0); ans = (ans * ret) % 31011; num += tnum;
		LAST = NOW;
		i = now + 1;
		}
	if (num != n - 1) puts("0"); else printf("%d\n", ans);
}
Problem1016

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 200001, MO = 31011;
int n, m, t;
long long ans1, ans2;
struct Tedge{
	int st, ed, len;
	void init() { scanf("%d%d%d", &st, &ed, &len); }
	bool operator < (const Tedge & A) const { return len < A.len; }
} edge[MAXN];
struct Tuf{
	int f[MAXN];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int getf(int v) { return v == f[v] ? v : f[v] = getf(f[v]); }
	int GETF(int v) { return v == f[v] ? v  : GETF(f[v]); }
	bool same(int a, int b) { return getf(a) == getf(b); }
	void merge(int a, int b) { f[getf(a)] = getf(b); }
} uf1, uf2;
void dfs(int dep, int st, int ed, int num)
{
	if (num == 0) { ++t; return; }
	if (dep > ed) return;
	dfs(dep + 1, st, ed, num);
	int A = uf2.GETF(edge[dep].st), B = uf2.GETF(edge[dep].ed);
	if (A == B) return;
	uf2.f[A] = B;
	dfs(dep + 1, st, ed, num - 1);
	uf2.f[A] = A;
}
int main()
{
	scanf("%d%d", &n, &m);
	uf1.init(); uf2.init();
	for (int i = 1; i <= m; i++) edge[i].init();
	sort(edge + 1, edge + m + 1);
	int now = 0, pt = 0; ans2 = 1;
	while(now < n - 1){
		++pt;
		int st = pt;
		while(pt < m && edge[pt + 1].len == edge[st].len) ++pt;
		int num = 0;
		for (int i = st; i <= pt; i++)
			if (!uf1.same(edge[i].st, edge[i].ed)){
				ans1 += edge[i].len; ++num;
				uf1.merge(edge[i].st, edge[i].ed);
				++now;
			}
		t = 0;
		dfs(st, st, pt, num);
		ans2 = ans2 * t % MO;
		for (int i = st; i <= pt; i++)
			if (!uf2.same(edge[i].st, edge[i].ed)) uf2.merge(edge[i].st, edge[i].ed);

	}
	cout << ans2 << endl;
}
Problem1018

#include <cstdio>
#include <cstdlib>
#include <cstring>

const int MAXN = 1200000;
int n;
template <class T> inline void swap(T& a,T& b) { T t = a; a = b; b = t; }
struct Tinf{
	bool data[4][4];
	//0 1
	//2 3
	bool* operator [] (int k) { return data[k]; }
	inline void clear()
	{
		memset(data, 0, sizeof(data));
		for (int i = 0; i < 4; i++) data[i][i] = true;
	}
	inline void renew()
	{
        data[3][0] = data[0][3] = data[0][3] || data[0][1] && data[1][3] || data[0][2] && data[2][3];
        data[2][1] = data[1][2] = data[1][2] || data[2][0] && data[0][1] || data[3][2] && data[3][1];
        data[2][0] = data[0][2] = data[0][2] || data[2][3] && data[3][1] && data[0][1];
        data[0][1] = data[1][0] = data[1][0] || data[0][2] && data[3][2] && data[3][1];
        data[3][1] = data[1][3] = data[1][3] || data[0][1] && data[0][2] && data[2][3];
        data[3][2] = data[2][3] = data[2][3] || data[2][0] && data[1][0] && data[1][3];
	}
	inline void merge(Tinf A, Tinf B)
	{
		A.renew(); B.renew();
		for (int i = 0; i < 4; i++) data[i][i] = true;
		data[1][0] = data[0][1] = (A[0][1] && B[0][1]) || (A[0][3] && B[2][1]);
		data[2][0] = data[0][2] = (A[0][2]) || (A[0][1] && B[0][2] && A[2][3]);
		data[3][0] = data[0][3] = (A[0][1] && B[0][3]) || (A[0][3] && B[2][3]);
		data[1][2] = data[2][1] = (A[2][1] && B[0][1]) || (A[2][3] && B[2][1]);
		data[1][3] = data[3][1] = (B[1][3]) || (B[0][1] && A[1][3] && B[2][3]);
		data[2][3] = data[3][2] = (A[2][1] && B[0][3]) || (A[2][3] && B[2][3]);
	}
};
struct Tsegnode{
	static Tsegnode *A;
	int l, r, lc, rc;
	Tinf inf;
	inline void update() { inf.merge(A[lc].inf, A[rc].inf); }
}node[MAXN], *Tsegnode::A = node;
struct Tsegmenttree{
	int tot;
	void build(int l, int r)
	{
		++tot; node[tot].l = l; node[tot].r = r; node[tot].inf.clear();
		if (l + 1 == r) return;
		int now = tot; node[now].lc = tot + 1; build(node[now].l, node[now].l + node[now].r >> 1);
		node[now].rc = tot + 1; build(node[now].l + node[now].r >> 1, node[now].r);
	}
	void modify(int idx, int x, int a, int b, bool f)
	{
		if (node[idx].l + 1 == node[idx].r){
			node[idx].inf[a][b] = node[idx].inf[b][a] = f; return;
			}
		if (x < (node[idx].l + node[idx].r >> 1)) modify(node[idx].lc, x, a, b, f);
		else modify(node[idx].rc, x, a, b, f);
		node[idx].update();
	}
	Tinf query(int idx, int l, int r)
	{
		if (l <= node[idx].l && r >= node[idx].r) return node[idx].inf;
		if (l >= (node[idx].l + node[idx].r >> 1)) return query(node[idx].rc, l, r);
		if (r <= (node[idx].l + node[idx].r >> 1)) return query(node[idx].lc, l, r);
		Tinf temp; temp.merge(query(node[idx].lc, l, r), query(node[idx].rc, l, r));
		return temp;
	}
	void mod(int x1, int y1, int x2, int y2, bool f)
	{
		if (y1 == y2){
			if (y1 > 1) modify(1, y1 - 1, 1, 3, f);
			if (y1 < n) modify(1, y1, 0, 2, f);
			}
		else{
			if (y1 > y2) { swap(y1, y2); swap(x1, x2); }
			if (x1 == 1) modify(1, y1, 0, 1, f);
			else modify(1, y1, 2, 3, f);
			}
	}		
	bool que(int x1, int y1, int x2, int y2)
	{
		--x1; --x2;
		if (x1 == x2 && y1 == y2) return true;
		if (y1 > y2) { swap(x1, x2); swap(y1, y2); }
		if (y1 == y2){
			if (y1 > 1) { Tinf A = query(1, 1, y1); A.renew(); if (A[1][3]) return true; }
			if (y1 < n){
				Tinf B = query(1, y1, n); 
				B.renew(); 
				if (B[0][2]) return true; 
				}
			return false;
			}
		bool ret = false;
		Tinf A = query(1, y1, y2); A.renew();
		if (x1 == 0 && x2 == 0) ret |= A[0][1];
		if (x1 == 0 && x2 == 1) ret |= A[0][3];
		if (x1 == 1 && x2 == 0) ret |= A[2][1];
		if (x1 == 1 && x2 == 1) ret |= A[2][3];
		if (ret) return true;
		if (y1 > 1){
			Tinf B = query(1, 1, y1); B.renew();
			if (B[1][3]){
				if (x1 == 0 && x2 == 0) ret |= A[2][1];
				if (x1 == 0 && x2 == 1) ret |= A[2][3];
				if (x1 == 1 && x2 == 0) ret |= A[0][1];
				if (x1 == 1 && x2 == 1) ret |= A[0][3];
				}
			if (ret) return true;
			}
		if (y2 < n){
			Tinf B = query(1, y2, n); B.renew();
			if (B[0][2]){
				if (x1 == 0 && x2 == 0) ret |= A[0][3];
				if (x1 == 0 && x2 == 1) ret |= A[0][1];
				if (x1 == 1 && x2 == 0) ret |= A[2][3];
				if (x1 == 1 && x2 == 1) ret |= A[2][1];
				}
			if (ret) return true;
			}
		if (y1 > 1 && y2 < n){
			Tinf B = query(1, 1, y1); Tinf C = query(1, y2, n);
			B.renew(); C.renew();
			if (B[1][3] && C[0][2]){
				if (x1 == 0 && x2 == 0) ret |= A[2][3];
				if (x1 == 0 && x2 == 1) ret |= A[2][1];
				if (x1 == 1 && x2 == 0) ret |= A[0][3];
				if (x1 == 1 && x2 == 1) ret |= A[0][1];
				}
			if (ret) return true;
			}
		return ret;
	}		
} tree;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	tree.build(1, n);
	while(1){
		char op[101]; int x1, y1, x2, y2;
		scanf("%s", op);
		switch(*op){
			case 'C': scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
					  tree.mod(x1, y1, x2, y2, false);
					  break;
			case 'O': scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
					  tree.mod(x1, y1, x2, y2, true);
					  break;
			case 'A': scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
					  putchar(tree.que(x1, y1, x2, y2) ? 'Y' : 'N');
					  putchar('\n');
					  break;
			case 'E':return 0; break;
			}
		}
}
Problem1022

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;
int sg, n, a[1000001];
bool ok()
{
	bool ok1 = false, ok2 = true;
	for (int i = 1; i <= n; i++) if (a[i] > 1) ok1 = true, ok2 = false;
	if (sg != 0) return ok1; else return ok2;
}
int main()
{
int TEST; cin >> TEST;
while(TEST--){
	sg = 0;
	cin >> n; for (int i = 1; i <= n; i++) { cin >> a[i]; sg ^= a[i]; }
	if (ok()) puts("John"); else puts("Brother");
	}
}
Problem1023

#include <cstdio>
#include <cstdlib>
#include <cstring>
#define min(a, b) ((a) < (b) ? (a) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))
const int MAXN = 1200001;
struct Tqueue{
	int v, w;
	} q[MAXN];
int tot, e[MAXN], v[MAXN], next[MAXN];
int h, t;
int anc[MAXN], dep[MAXN], fat[MAXN];
int cir[MAXN], d[MAXN], l;
int ans, n, m;
void add(int x, int y)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y;
}
void enq(int w, int v)
{
	while(h <= t && q[t].v <= v) --t;
	q[++t].v = v; q[t].w = w;
}
void calc()
{
	h = 1; t = 0;
	for (int i = 1; i <= l; i++) cir[i + l] = cir[i];
	for (int i = 1; i <= (l >> 1); i++) (enq(i, d[cir[i]] - i));
	for (int i = (l >> 1) + 1; i <= 2 * l; i++){
		while(i - q[h].w > (l >> 1)) ++h;
		ans = max(ans, d[cir[i]] + i + q[h].v);
		enq(i, d[cir[i]] - i);
		}
}	
void DFS(int x)
{
	anc[x] = dep[x];
	for (int i = e[x]; i; i = next[i]){
		if (fat[v[i]] != 0 && v[i] != fat[x]) anc[x] = min(anc[x], dep[v[i]]);
		if (fat[v[i]] == 0){
			fat[v[i]] = x; dep[v[i]] = dep[x] + 1; DFS(v[i]);
			anc[x] = min(anc[x], anc[v[i]]);
			}
		}
	for (int i = e[x]; i; i = next[i]){
		if (fat[v[i]] == x && anc[v[i]] > dep[x]){ //Bridge
			ans = max(ans, d[v[i]] + d[x] + 1);
			d[x] = max(d[v[i]] + 1, d[x]);
			}
		if (fat[v[i]] != x && dep[v[i]] > dep[x]){ //Find a Back-Ward Edge, Solve a Circle
			l = 0;
			int u = v[i];
			while(u != fat[x]) cir[++l] = u, u = fat[u];
			calc();
			for (int j = 1; j < l; j++) d[x] = max(d[x], d[cir[j]] + min(j, l - j));
			}
		}
}			
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int k, last; scanf("%d", &k); scanf("%d", &last);
		for (int i = 2; i <= k; i++){
			int now; scanf("%d", &now);
			add(last, now); add(now, last);
			last = now;
			}
		}
	fat[1] = -1;
	DFS(1);
	printf("%d\n", ans);
}
Problem1024

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n; double x, y;
double cut(double x, double y, int n)
{
	if (n == 1) return max(x, y) / min(x, y);
	double ret = 1e99;
	for (int i = 1; i < n; i++){
		double a = i, b = n - i;
		ret = min(ret, max(cut(x / (a + b) * a, y, int(a)), cut(x / (a + b) * b, y, int(b))));
		ret = min(ret, max(cut(x, y / (a + b) * a, int(a)), cut(x, y / (a + b) * b, int(b))));
		}
	return ret;
}
int main()
{
	scanf("%lf%lf%d", &x, &y, &n);
	printf("%.6lf\n", cut(x, y, n));
}
Problem1025

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
using namespace std;
bool isp[100001];
long long f[1001][1001];
int n, p[100001], pnum;
void make_prime(int MAX)
{
	memset(isp, 1, sizeof(isp));
	for (int i = 2; i <= MAX; i++){
		if (isp[i]) p[++pnum] = i;
		for (int j = 1; j <= pnum && p[j] * i <= MAX; j++){
			isp[p[j] * i] = false; if (i % p[j] == 0) break;
			}
		}
}
int main()
{
	scanf("%d", &n);
	for (int i = 0; i <= n; i++) f[0][i] = 1;
	make_prime(n);
	for (int i = 1; i <= pnum; i++)
		for (int j = 0; j <= n; j++){
			int pow = 0;
			while(pow <= j){
				f[i][j] += f[i - 1][j - pow];
				if (pow == 0) pow = 1;
				pow *= p[i];
				}
			}
	printf("%lld\n", f[pnum][n]);
}
Problem1026

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
int a, b, f[101][101], all[101];
char now[101];
using namespace std;
void dp()
{
	//‘ –Ì«∞µº0 
	for (int i = 0; i <= 9; i++) f[1][i] = 1;
	for (int i = 2; i <= 10; i++)
		for (int j = 0; j <= 9; j++)
			for (int k = 0; k <= 9; k++) if (abs(k - j) >= 2)
				f[i][j] += f[i - 1][k];
	all[1] = 10;
	for (int i = 2; i <= 10; i++){
		all[i] = all[i - 1];
		for (int j = 1; j <= 9; j++) all[i] += f[i][j];
		}
}	
int get(int num)
{
	int ret = 0;
	sprintf(now + 1, "%d", num);
	int len = strlen(now + 1);
	for (int i = 1; i <= len; i++) now[i] -= '0';
	for (int i = 1; i < now[1]; i++) ret += f[len][i];
	ret += all[len - 1];
	bool ok = true;
	for (int i = 2; i <= len; i++){
		for (int j = 0; j <= 9; j++) if (j < now[i] && abs(now[i - 1] - j) >= 2)
			ret += f[len - i + 1][j];
		if (abs(now[i] - now[i - 1]) < 2) { ok = false; break; }
		}
	if (ok) ++ret;
	return ret;
}
int main()
{
	dp();
	scanf("%d%d", &a, &b);
	printf("%d\n", get(b) - get(a - 1));
}
Problem1027

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
const int MAXN = 1001;
using namespace std;
struct Tpoint{
	double x, y;
	void read() { scanf("%lf%lf%*lf", &x, &y); }
	double operator * (Tpoint B) { return x * B.y - y * B.x; }
	Tpoint operator - (Tpoint B) { Tpoint temp; temp.x = x - B.x; temp.y = y - B.y;  return temp; }
} pa[MAXN], pb[MAXN];
vector<int> adj[MAXN];
int n, m, l, r, q[MAXN];
int dis[MAXN], ans;
bool vis[MAXN];
int dcmp(double t)
{
	if (fabs(t) < 1e-9) return 0;
	if (t < 0) return -1;
	return 1;
}
bool ok(int a, int b)
{
	for (int i = 1; i <= m; i++){
		int t = dcmp((pa[b] - pa[a]) * (pb[i] - pa[a]));
		if (t < 0) return false;
		if (t == 0)
			if ((pa[a].x > pb[i].x && pa[b].x > pb[i].x) || ((pa[a].x < pb[i].x && pa[b].x < pb[i].x))) return false;
		}
	return true;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) pa[i].read();
	for (int i = 1; i <= m; i++) pb[i].read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) if (i != j && (dcmp(pa[i].x - pa[j].x) || dcmp(pa[i].y - pa[j].y)))
			if (ok(i, j)){
				//printf("from %d to %d\n", i, j); 
				adj[i].push_back(j);
				}
	int ans = 0x3f3f3f3f;
	for (int i = 1; i <= n; i++){
		bool ok = true;
		for (int j = 1; j <= m; j++) if (dcmp(pa[i].x - pb[j].x) || dcmp(pa[i].y - pb[j].y)) { ok= false; break; }
		if (ok) { puts("1"); return 0; }
		}			
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < int(adj[i].size()); j++){
			memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis));
			l = r = 1; q[1] = adj[i][j]; vis[adj[i][j]] = true; dis[adj[i][j]] = 0;
			while(l <= r){
				int x = q[l++];
				for (int i = 0; i < int(adj[x].size()); i++)
					if (!vis[adj[x][i]]){
						vis[adj[x][i]] = true; q[++r] = adj[x][i]; 
						dis[adj[x][i]] = dis[x] + 1;
						}
				}
			if (vis[i]){
				ans = min(ans, dis[i] + 1);
				//printf("%d %d %d\n", i, adj[i][j], ans);
				}
			}
	printf("%d\n", ans == 0x3f3f3f3f ? -1 : ans);
}
Problem1028

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 1001;
using namespace std;
int ord[MAXN], a[MAXN], now[MAXN];
int n, m;
bool check2()
{
	for (int i = 1; i <= n - 2; i++){
		a[i] %= 3;
		if (a[i + 2] < a[i] || a[i + 1] < a[i]) return false;
		a[i + 2] -= a[i]; a[i + 1] -= a[i];
		}
	return ((a[n - 1] % 3 == 0) && (a[n] % 3 == 0));
}
bool check1()
{
	for (int i = 1; i <= n; i++)
		if (a[i] >= 2){
			a[i] -= 2;
			if (check2()) return true;
			memcpy(a, now, sizeof(now));
			}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= 3 * m + 1; i++){
		int x; scanf("%d", &x); ++ord[x];
		}
	bool first = true;
	for (int i = 1; i <= n; i++){
		memcpy(a, ord, sizeof(ord));
		++a[i]; memcpy(now, a, sizeof(a));
		if (check1()){
			if (first){
				printf("%d", i); first = false;
				}
			else printf(" %d", i);
			}
		}
	if (first) printf("NO");
	putchar('\n');
}
		
Problem1029

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
struct Tdata{
	int A, B;
	bool operator < (const Tdata & A) const{
		return B < A.B;
		}
} data[1000001];
priority_queue<int> Q;
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &data[i].A, &data[i].B);
	sort(data + 1, data + n + 1);
	int now = 0, sum = 0;
	for (int i = 1; i <= n; i++){
		if (sum + data[i].A <= data[i].B){
			sum += data[i].A;
			++now;
			Q.push(data[i].A);
			}
		else{
			int t = Q.top();
			if (t > data[i].A){
				sum = sum - t + data[i].A;
				Q.pop(); Q.push(data[i].A);
				}
			}
		}
	printf("%d\n", now);
}
Problem1030

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define gc getchar()
const int MAXNODE = 20000;
const int MO = 10007;
using namespace std;
struct Tnode{
	bool flag;
	int ch[26], fail;
} node[MAXNODE];
int tot, n, m;
int l, r, q[MAXNODE];
char s[10001];
void insert(char *s)
{
	int now = 1;
	for (; *s; s++){
		if (node[now].ch[*s - 'A'] == 0){
			node[now].ch[*s - 'A'] = ++tot;
			}
		now = node[now].ch[*s - 'A'];
		}
	node[now].flag = true;
}
void build()
{
	l = 1; r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = 0; i < 26; i++){
			int now = node[x].ch[i];
			int t = (x == 1) ? 1 : node[node[x].fail].ch[i];
			if (now == 0) node[x].ch[i] = t;
			else{
				node[now].fail = t; node[now].flag |= node[t].flag;
				q[++r] = now;
				}
			}
		}
}
int f[501][MAXNODE][2];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); gc;
	tot = 1; node[1].fail = 1;
	for (int i = 1; i <= n; i++){
		scanf("%s", s);
		insert(s);
		}
	build();
	f[0][1][0] = 1;
	for (int i = 0; i < m; i++)
		for (int j = 1; j <= tot; j++){
			if (f[i][j][0] != 0)
				for (int k = 0; k < 26; k++)
					if (node[node[j].ch[k]].flag)
						f[i + 1][node[j].ch[k]][1] = (f[i + 1][node[j].ch[k]][1] + f[i][j][0]) % MO;
					else f[i + 1][node[j].ch[k]][0] = (f[i][j][0] + f[i + 1][node[j].ch[k]][0]) % MO;
			if (f[i][j][1] != 0)
				for (int k = 0; k < 26; k++)			
					f[i + 1][node[j].ch[k]][1] = (f[i][j][1] + f[i + 1][node[j].ch[k]][1]) % MO;
			}
	int ans = 0;
	for (int i = 1; i <= tot; i++) ans = (ans + f[m][i][1]) % MO;
	printf("%d\n", ans);
}
Problem1031

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 3000001;
char s[MAXN];
int n, ws[MAXN], sa[MAXN], wv[MAXN], ta[MAXN], tb[MAXN], *x = ta, *y = tb;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s", s);
	int n = strlen(s);
	for (int i = 0; i < n - 1; i++) s[n + i] = s[i];
	n = n << 1;
	for (int i = 0; i < n; i++) x[i] = s[i];
	for (int i = 0; i < n; i++) ws[x[i]]++;
	for (int i = 1; i < 1001; i++) ws[i] += ws[i - 1];
	for (int i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;
	int m = 1001; int p = 0;
	for (int j = 1; p < n; j <<= 1, m = p){
		p = 0;
		for (int i = n - j; i < n; i++) y[p++] = i;
		for (int i = 0; i < n; i++) if (sa[i] >= j) y[p++] = sa[i] - j;
		memset(ws, 0, sizeof(ws));
		for (int i = 0; i < n; i++) ws[wv[i] = x[y[i]]]++;
		for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
		for (int i = n - 1; i >= 0; i--) sa[--ws[wv[i]]] = y[i];
		int *t = x; x = y; y = t; x[sa[0]] = 1; p = 1;
		for (int i = 1; i < n; i++)
			x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j]) ? p : ++p;
		}
	for (int i = 0; i < n; i++) if (sa[i] < (n >> 1)) 
		putchar(s[sa[i] + (n >> 1) - 1]);
	putchar('\n');
}
		
Problem1034

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
struct Tstack{
	int top, data[MAXN], who[MAXN];
	void clear() { top = 0; }
	int & operator [] (int k) { return data[k]; }
	bool empty() { return top ==  0; }
	void push(int k, int w) { data[++top] = k; who[top] = w; }
	void pop() { --top; }
	int head() { return data[top]; }
	int headwho() { return who[top]; }
} S;
int n, a[MAXN], b[MAXN], aa[MAXN], bb[MAXN];
bool vis1[MAXN], vis2[MAXN];
int calc(int *a, int *b)
{
	memset(vis1, 0, sizeof(vis1)); memset(vis2, 0, sizeof(vis2)); 
	S.clear();
	int now = n, n1 = 0, n2 = 0;
	for (int i = n; i >= 1; i--){
		while(now > 0 && a[now] > b[i]) { S.push(a[now], now); --now; };
		if (!S.empty()){
			++n1; vis1[S.headwho()] = true; vis2[i] = true; S.pop();
			}
		}
	int nn = 0;
	for (int i = 1; i <= n; i++) if (!vis1[i]) aa[++nn] = a[i];
	nn = 0;
	for (int i = 1; i <= n; i++) if (!vis2[i]) bb[++nn] = b[i];
	now = nn; S.clear();
	for (int i = nn; i >= 1; i--){
		while(now > 0 && aa[now] >= bb[i]) { S.push(aa[now], now); --now; }
		if (!S.empty()){
			++n2; S.pop();
			}
		}
	return n1 * 2 + n2;
} 
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
	sort(a + 1, a + n + 1); sort(b + 1, b + n + 1);
	printf("%d %d\n", calc(a, b), 2 * n - calc(b, a));
}
Problem1036

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 200001;
int n, m, p[MAXN];
int e[MAXN], v[MAXN], next[MAXN], tot;
bool vis[MAXN];
struct Tnode{
	static Tnode *a;
	int c[2], f, val, sum, maxv;
	bool isroot;
	void set(int _val, int _f)
	{
		val = sum = maxv = _val; f = _f; isroot = true;
	}
	void update()
	{
		maxv = max(val, max(a[c[0]].maxv, a[c[1]].maxv));
		sum = a[c[0]].sum + a[c[1]].sum + val;
	}
	void rot(bool b)
	{
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); 
}
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		A[v[i]].set(p[v[i]], x); dfs(v[i]);
		}
}
void CHANGE(int p, int t)
{
	splay(p); A[p].val = t; A[p].update();
}
int ACCESS1(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[q].val + A[A[q].c[1]].sum + A[p].sum;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
int ACCESS2(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = max(A[q].val, max(A[A[q].c[1]].maxv, A[p].maxv));
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void QMAX(int a, int b)
{
	ACCESS2(a); printf("%d\n", ACCESS2(b));
}
void QSUM(int a, int b)
{
	ACCESS1(a); printf("%d\n", ACCESS1(b));
}
char op[1001];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
		}
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	A[1].set(p[1], 0); A[0].sum = 0; A[0].maxv = 0xe0e0e0e0;
	dfs(1);
	int l, r, d;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%s", op);
		switch(*(op + 1)){
			case 'H': scanf("%d%d", &l, &d); CHANGE(l, d); break;
			case 'M': scanf("%d%d", &l, &r); QMAX(l, r); break;
			case 'S': scanf("%d%d", &l, &r); QSUM(l, r); break;
			}
		}
}
Problem1036

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 200001;
int n, m, p[MAXN];
int e[MAXN], v[MAXN], next[MAXN], tot;
bool vis[MAXN];
struct Tnode{
	static Tnode *a;
	int c[2], f, val, sum, maxv;
	bool isroot;
	inline void set(int _val, int _f)
	{
		val = sum = maxv = _val; f = _f; isroot = true;
	}
	inline void update()
	{
		maxv = max(val, max(a[c[0]].maxv, a[c[1]].maxv));
		sum = a[c[0]].sum + a[c[1]].sum + val;
	}
	inline void rot(bool b)
	{
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
inline void splay(int x)
{
	int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); 
}
inline void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
inline void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		A[v[i]].set(p[v[i]], x); dfs(v[i]);
		}
}
inline void CHANGE(int p, int t)
{
	splay(p); A[p].val = t; A[p].update();
}
inline int ACCESS1(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[q].val + A[A[q].c[1]].sum + A[p].sum;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
inline int ACCESS2(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = max(A[q].val, max(A[A[q].c[1]].maxv, A[p].maxv));
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
inline void QMAX(int a, int b)
{
	ACCESS2(a); printf("%d\n", ACCESS2(b));
}
inline void QSUM(int a, int b)
{
	ACCESS1(a); printf("%d\n", ACCESS1(b));
}
char op[1001];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
		}
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	A[1].set(p[1], 0); A[0].sum = 0; A[0].maxv = 0xe0e0e0e0;
	dfs(1);
	int l, r, d;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%s", op);
		switch(*(op + 1)){
			case 'H': scanf("%d%d", &l, &d); CHANGE(l, d); break;
			case 'M': scanf("%d%d", &l, &r); QMAX(l, r); break;
			case 'S': scanf("%d%d", &l, &r); QSUM(l, r); break;
			}
		}
}
Problem1036

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 200001;
int n, m, p[MAXN];
int e[MAXN], v[MAXN], next[MAXN], tot;
bool vis[MAXN];
struct Tnode{
	static Tnode *a;
	int c[2], f, val, sum, maxv;
	bool isroot;
	inline void set(int _val, int _f)
	{
		val = sum = maxv = _val; f = _f; isroot = true;
	}
	inline void update()
	{
		maxv = max(val, max(a[c[0]].maxv, a[c[1]].maxv));
		sum = a[c[0]].sum + a[c[1]].sum + val;
	}
	inline void rot(bool b)
	{
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); 
}
inline void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		A[v[i]].set(p[v[i]], x); dfs(v[i]);
		}
}
inline void CHANGE(int p, int t)
{
	splay(p); A[p].val = t; A[p].update();
}
inline int ACCESS1(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[q].val + A[A[q].c[1]].sum + A[p].sum;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
inline int ACCESS2(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = max(A[q].val, max(A[A[q].c[1]].maxv, A[p].maxv));
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void QMAX(int a, int b)
{
	ACCESS2(a); printf("%d\n", ACCESS2(b));
}
void QSUM(int a, int b)
{
	ACCESS1(a); printf("%d\n", ACCESS1(b));
}
char op[1001];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
		}
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	A[1].set(p[1], 0); A[0].sum = 0; A[0].maxv = 0xe0e0e0e0;
	dfs(1);
	int l, r, d;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%s", op);
		switch(*(op + 1)){
			case 'H': scanf("%d%d", &l, &d); CHANGE(l, d); break;
			case 'M': scanf("%d%d", &l, &r); QMAX(l, r); break;
			case 'S': scanf("%d%d", &l, &r); QSUM(l, r); break;
			}
		}
}
Problem1036

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 200001;
int n, m, p[MAXN];
int e[MAXN], v[MAXN], next[MAXN], tot;
bool vis[MAXN];
struct Tnode{
	static Tnode *a;
	int c[2], f, val, sum, maxv;
	bool isroot;
	inline void set(int _val, int _f)
	{
		val = sum = maxv = _val; f = _f; isroot = true;
	}
	inline void update()
	{
		maxv = max(val, max(a[c[0]].maxv, a[c[1]].maxv));
		sum = a[c[0]].sum + a[c[1]].sum + val;
	}
	inline void rot(bool b)
	{
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); 
}
inline void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		A[v[i]].set(p[v[i]], x); dfs(v[i]);
		}
}
inline void CHANGE(int p, int t)
{
	splay(p); A[p].val = t; A[p].update();
}
int ACCESS1(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[q].val + A[A[q].c[1]].sum + A[p].sum;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
int ACCESS2(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = max(A[q].val, max(A[A[q].c[1]].maxv, A[p].maxv));
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void QMAX(int a, int b)
{
	ACCESS2(a); printf("%d\n", ACCESS2(b));
}
void QSUM(int a, int b)
{
	ACCESS1(a); printf("%d\n", ACCESS1(b));
}
char op[1001];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
		}
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	A[1].set(p[1], 0); A[0].sum = 0; A[0].maxv = 0xe0e0e0e0;
	dfs(1);
	int l, r, d;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%s", op);
		switch(*(op + 1)){
			case 'H': scanf("%d%d", &l, &d); CHANGE(l, d); break;
			case 'M': scanf("%d%d", &l, &r); QMAX(l, r); break;
			case 'S': scanf("%d%d", &l, &r); QSUM(l, r); break;
			}
		}
}
Problem1037

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MO = 12345678;
using namespace std;
void add(int & a, int b)
{
	a = (a + b) % MO;
}
int n, m, k;
int now[301][31][31], last[301][31][31];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	last[1][1][0] = 1; last[0][0][1] = 1;
	for (int i = 1; i < n + m; i++){
		memset(now, 0, sizeof(now));
		for (int j = 0; j <= n; j++) for (int a = 0; a <= k; a++) for (int b = 0; b <= k; b++) 
			if (last[j][a][b]){
				int na = a + 1, nb = b + 1;
				if (na <= k && j != n) add(now[j + 1][na][max(0, b - 1)], last[j][a][b]);
				if (nb <= k && (i - j) != m) add(now[j][max(0, a - 1)][nb], last[j][a][b]);
				}
		memcpy(last, now, sizeof(now));
		}
	int ans = 0;
	for (int a = 0; a <= k; a++)
		for (int b = 0; b <= k; b++)
			add(ans, now[n][a][b]);
	printf("%d\n", ans);
}
Problem1038

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const double eps = 1e-6, inf = 1e11;
const int MAXN = 1001;
int n, now, s;
struct Tpoint{
	double x, y;
	} in[MAXN], p[MAXN], q[MAXN];
int dblcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	if (t > 0) return 1;
}
void ct(double a, double b, double c, Tpoint A, Tpoint B)
{
	double U = fabs(a * A.x + b * A.y + c), V = fabs(a * B.x + b * B.y + c);
	q[++s].x = (A.x * V + B.x * U) / (U + V); q[s].y = (A.y * V + B.y * U) / (U + V);
}
void cut(double a, double b, double c)
{
	s = 0;
	for (int i = 1; i <= now; i++)
		if (dblcmp(a * p[i].x + b * p[i].y + c) >= 0) q[++s] = p[i];
		else{
			if (dblcmp(a * p[i - 1].x + b * p[i - 1].y + c) > 0) ct(a, b, c, p[i - 1], p[i]);
			if (dblcmp(a * p[i + 1].x + b * p[i + 1].y + c) > 0) ct(a, b, c, p[i], p[i + 1]);
			}
	now = s; for (int i = 1; i <= now; i++) p[i] = q[i];
	p[now + 1] = p[1]; p[0] = p[now];
}
double calc(double x)
{
	if (x < in[1].x || x > in[n].x) return -1e99;
	for (int i = 1; i < n; i++) if (dblcmp(x - in[i].x) >= 0 && dblcmp(x - in[i + 1].x ) <= 0){
		if (dblcmp(x - in[i].x) == 0) return in[i].y;
		double k = (in[i + 1].y - in[i].y) / (in[i + 1].x - in[i].x);
		return in[i].y + k * (x - in[i].x);
		}
} 
double calc2(double x)
{
	for (int i = 1; i < n; i++) if (dblcmp(x - p[i].x) <= 0 && dblcmp(x - p[i + 1].x ) >= 0){
		if (dblcmp(x - p[i].x) == 0) return p[i].y;
		double k = (p[i + 1].y - p[i].y) / (p[i + 1].x - p[i].x);
		return p[i].y + k * (x - p[i].x);
		}
} 
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lf", &in[i].x);
	for (int i = 1; i <= n; i++) scanf("%lf", &in[i].y);
	in[n + 1] = in[1]; in[0] = in[n]; now = 4;
	p[1].x = p[1].y = inf; p[2].x = inf; p[2].y = -inf;
	p[3].x = p[3].y = -inf; p[4].x = -inf; p[4].y = inf;
	p[0] = p[4]; p[5] = p[1];
	for (int i = 1; i < n; i++){
		double a, b, c;
		a = in[i].y - in[i + 1].y; b = in[i + 1].x - in[i].x;
		c = in[i].x * in[i + 1].y - in[i + 1].x * in[i].y;
		cut(a, b, c);
		}
	double ans = 1e99;
	for (int i = 1; i <= now; i++) if (fabs(p[i].x) < 1e10 && fabs(p[i].y) < 1e10)
		ans = min(ans, p[i].y - calc(p[i].x));
	for (int i = 1; i <= n; i++)
		ans = min(ans, calc2(in[i].x) - in[i].y);
	printf("%.3lf\n", ans);
}
Problem1040

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
#define kAc
using namespace std;
const int MAXN = 2000001;
struct Tqueue{
	int l, r, data[MAXN];
	void clear() { l = 1; r = 0; }
	bool empty() { return l > r; }
	void enq(int k) { data[++r] = k; }
	int deq() { l++; return data[l - 1]; }
} Q;
int n, a[MAXN], in[MAXN];
ll treedp[MAXN][2], cirdp[MAXN][2][2], ans;
int cnum, cir[MAXN];
int tot, e[MAXN], next[MAXN], v[MAXN];
void add(int x, int y)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; ++in[y];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x;
		scanf("%d%d", &a[i], &x);
		add(i, x);
		}
	Q.clear();
	for (int i = 1; i <= n; i++) if (in[i] == 0) Q.enq(i);
	while(!Q.empty()){
		int x = Q.deq(); treedp[x][1] += (ll)(a[x]);
		for (int i = e[x]; i; i = next[i]){
			treedp[v[i]][1] += treedp[x][0]; treedp[v[i]][0] += max(treedp[x][0], treedp[x][1]);
			--in[v[i]]; if (in[v[i]] == 0) Q.enq(v[i]);
			}
		 }
	for (int i = 1; i <= n; i++) if (in[i] == 1) treedp[i][1] += (ll)(a[i]);
	for (int i = 1; i <= n; i++) if (in[i] == 1){
		int now = i; cnum = 0;
		while(now != 0){
			--in[now]; cir[++cnum] = now; 
			int NEXT = 0;
			for (int i = e[now]; i; i = next[i]) if (in[v[i]] == 1) NEXT = v[i];
			now = NEXT;
			}
		cirdp[cir[1]][0][0] = treedp[cir[1]][0]; cirdp[cir[1]][1][1] = treedp[cir[1]][1];
		for (int i = 2; i <= cnum; i++)
			for (int j = 0; j < 2; j++){
				cirdp[cir[i]][j][0] = max(cirdp[cir[i - 1]][j][0], cirdp[cir[i - 1]][j][1]) + treedp[cir[i]][0];
				cirdp[cir[i]][j][1] = cirdp[cir[i - 1]][j][0] + treedp[cir[i]][1];
				}	
		ans += max(max(cirdp[cir[cnum]][0][0], cirdp[cir[cnum]][0][1]), cirdp[cir[cnum]][1][0]);		
		}
	cout << ans << endl;
} 

			
Problem1041

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
ll a[4000001], d[4];
int r, num;
int main()
{
	scanf("%d", &r);
	for (int i = 1; i * i <= r; i++)
		if (r % i == 0)
			if (i * i == r) a[++num] = i;
			else a[++num] = i, a[++num] = r / i;
	int tot = num;
	for (int i = 1; i <= tot; i++)
		for (int j = 1; j <= tot; j++)
			a[++num] = a[i] * a[j];
	sort(a + 1, a + num + 1);
	++d[a[1] % 4];
	for (int i = 2; i <= num; i++) if (a[i] != a[i - 1]) ++d[a[i] % 4];
	printf("%lld\n", 4 * (d[1] - d[3]));
}
Problem1042

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
int c[101], lim[101];
ll f[1000001];
int tot, S;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 1; i <= 4; i++) scanf("%d", &c[i]); scanf("%d", &tot);
	f[0] = 1;
	for (int i = 1; i <= 4; i++)
		for (int j = c[i]; j <= 100000; j++)
			f[j] += f[j - c[i]];
	while(tot--){
		ll ans = 0;
		for (int i = 1; i <= 4; i++) scanf("%d", &lim[i]); scanf("%d", &S);
		for (int i = 0; i <= 15; i++){
			int t = __builtin_popcount(i);
			ll k = S;
			for (int j = 1; j <= 4; j++) if((i & (1 << (j - 1))) != 0) k -= (lim[j] + 1) * c[j];
			if (k >= 0) if (t & 1) ans -= f[k]; else ans += f[k];
			}
		printf("%lld\n", ans);
		}
}
Problem1043

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int MAXN = 10001;
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	return 1;
}
struct Tpoint{
	double x, y;
	Tpoint operator - (Tpoint B) { Tpoint temp; temp.x = x - B.x; temp.y = y - B.y; return temp; }
	double operator * (Tpoint B) { return x * B.y - y * B.x; }
};
double dis(Tpoint A, Tpoint B) { return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); }
struct Tinterval{
	double st, ed;
};
struct Tcircle{
	Tpoint p; double r;
	void init(double _x, double _y, double _r) { p.x = _x; p.y = _y; r = _r; }
	bool operator == (Tcircle B) { return (dcmp(r - B.r) == 0 && dcmp(p.x - B.p.x) == 0 && dcmp(p.y - B.p.y) == 0); }	 
	Tinterval operator * (Tcircle B)
	{
		Tinterval temp;
		double d = dis(p, B.p);
		double j1 = atan2(B.p.y - p.y, B.p.x - p.x);
		double j2 = acos((r * r + d * d - B.r * B.r) / (2 * r * d));
		temp.st = j1 - j2; temp.ed = j1 + j2;
		return temp;
	}	
} c[MAXN];
struct Tscanpoint
{
	double x; int kind;
	void init(double _x, int _kind) { x = _x; kind = _kind; }
	bool operator < (const Tscanpoint & B) const{
		return dcmp(x - B.x) < 0;
		}
} scan[MAXN * 200];
int Scan;
int judge(Tcircle A, Tcircle B)
{
	// 0 : ÕÍ»´œ‡Õ¨ 1 : œ‡¿Î 2 : Õ‚«– 3 : œ‡Ωª 4 : A±ª∞¸∫¨ 5 : B±ª∞¸∫¨ 
	double d = dis(A.p, B.p);
	if (A == B) return 0;
	if (dcmp(d - A.r - B.r) > 0) return 1;
	if (dcmp(d - A.r - B.r) == 0) return 2;
	if ((dcmp(d - A.r - B.r) < 0) && (dcmp(d - fabs(A.r - B.r)) > 0)) return 3;
	if (A.r < B.r) return 4;
	return 5;
}
double calc(int num, double st, double ed)
{
	if (dcmp(ed - st) == 0) return 0.0;
	double delta = ed - st;
	return c[num].r * delta;
}
int n, N;
double doit(int x)
{
	Scan = 0;
	double ret = 0;
	for (int i = x + 1; i <= n; i++){
		int t = judge(c[x], c[i]);
		if (t == 0 || t == 4) return 0.0;
		if (t == 1 || t == 2 || t == 5) continue;
		Tinterval ti = c[x] * c[i];
		if (dcmp(ti.st) < 0) ti.st += 2 * M_PI, ti.ed += 2 * M_PI;
		if (dcmp(ti.ed - 2 * M_PI) > 0){
			++Scan; scan[Scan].init(ti.st, 1);
			++Scan; scan[Scan].init(2 * M_PI, -1);
			++Scan; scan[Scan].init(0, 1);
			++Scan; scan[Scan].init(ti.ed - 2 * M_PI, -1);
			}
		else{
			++Scan; scan[Scan].init(ti.st, 1);
			++Scan; scan[Scan].init(ti.ed, -1);
			}
		}
	if (Scan == 0) return 2 * M_PI * c[x].r;
	sort(scan + 1, scan + Scan + 1);
	scan[Scan + 1].init(2 * M_PI, 0);
	ret += calc(x, 0, scan[1].x);
	int now = 0;
	for (int i = 1; i <= Scan; i++){
		now += scan[i].kind;
		if (now == 0) ret += calc(x, scan[i].x, scan[i + 1].x);
		}
	return ret;
}		
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &N);
	for (int i = 1; i <= N; i++){
		double x, y, r; scanf("%lf%lf%lf", &r, &x, &y);
		if (dcmp(r) != 0){
			++n; c[n].init(x, y, r);
			}
		}
	double ans = 0;
	for (int i = 1; i <= n; i++){
		ans += doit(i);
		}
	printf("%.3lf\n", ans + eps);
}
Problem1044

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
const int MO = 10007;
int n, k, sum[MAXN], a[MAXN], w[MAXN];
int lastsum[MAXN], now[MAXN], last[MAXN];
struct Tqueue{
	int l, r;
	int data[MAXN], who[MAXN];
	void init() { l = 1; r = 0; }
	int head() { return data[l]; }
	int headwho() { return who[l]; }
	void enq(int d, int w) { ++r; data[r] = d; who[r] = w; }
	void deq() { ++l; }
} Q;
bool ok(int t)
{
	if (t == 858){
		int a;
		++a;
		}
	int get = 1;
	for (int i = 1; i <= n; i++) if (a[i] > t) return false;
	int now = 0;
	for (int i = 1; i <= n; i++){
		if (now + a[i] > t){
			++get; now = a[i];
			}
		else now += a[i];
		}
	return get <= k;
}
int getsum(int l, int r)
{
	if (l != 0) return (((lastsum[r] - lastsum[l - 1]) % MO) + MO) % MO;
	else return lastsum[r];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k); ++k;
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]); sum[i] = sum[i - 1] + a[i];
		}
	int l = 0, r = 10000000;
	while(l <= r){
		int m = l + r >> 1;
		if (ok(m)) r = m - 1; else l = m + 1;
		}
	int ans1 = l;
	Q.init(); Q.enq(0, 0);
	for (int i = 1; i <= n; i++){
		while(Q.head() + ans1 < sum[i])
			Q.deq();
		w[i] = Q.headwho(); //printf("%d\n", w[i]);
		Q.enq(sum[i], i);
		}
	last[0] = 1;
	for (int i = 0; i <= n; i++) lastsum[i] = 1;
	int ans2 = 0;
	for (int i = 1; i <= k; i++){
		for (int j = 0; j < i; j++) now[j] = 0;
		for (int j = i; j <= n; j++)
			now[j] = getsum(w[j], j - 1);
		ans2 = (ans2 + now[n]) % MO;
		for (int i = 0; i <= n; i++) last[i] = now[i];
		lastsum[0] = last[0]; for (int i = 1; i <= n; i++) lastsum[i] = (lastsum[i - 1] + last[i]) % MO;
		}
	printf("%d %d\n", ans1, ans2);
}
				
Problem1045

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
long long n, a[2000001], s[2000001];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	long long sum = 0; for (int i = 1; i <= n; i++) sum += a[i];
	long long ave = sum / n;
	for (int i = 1; i <= n; i++) a[i] -= ave;
	for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
	sort(s + 1, s + n + 1);
	long long ans = 0;
	long long t = (n & 1) ? s[n + 1 >> 1] : ((s[n >> 1] + s[(n >> 1) + 1]) >> 1 );
	for (int i = 1; i <= n; i++) ans += abs(s[i] - t);
	printf("%lld\n", ans);
}
Problem1046

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, MAXANS, l, r, g[100001], f[100001], a[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	g[0] = 0x3f3f3f3f; MAXANS = 0;
	for (int i = n; i >= 1; i--){
		l = 0; r = MAXANS;
		while(l <= r){
			int m = l + r >> 1;
			if (a[i] < g[m]) l = m + 1; else r = m - 1; ;				
			}
		if (r == MAXANS) { ++MAXANS; g[MAXANS] = a[i]; f[i] = MAXANS; }
		else { g[r + 1] = max(g[r + 1], a[i]); f[i] = r + 1; }
		}
	int Q; scanf("%d", &Q);
	while(Q--){
		int now; scanf("%d", &now);
		if (now > MAXANS) { puts("Impossible"); }
		else{
			int last = 0xe0e0e0e0;
			for (int i = 1; i <= n; i++) if (f[i] >= now && a[i] > last){
				if (now == 1) { printf("%d\n", a[i]); break; }
				printf("%d ", a[i]); --now; last = a[i];
				}
			}
		}
}
Problem1047

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define log(a) (31 - __builtin_clz(a))
using namespace std;
int n, m, k, a[1001][1001], MIN[1001][1001][11], MAX[1001][1001][11];
int GETMIN(int x1, int y1, int x2, int y2)
{
	int d = log(x2 - x1 + 1);
	return min(min(MIN[x1][y1][d], MIN[x2 - (1 << d) + 1][y1][d]), 
		       min(MIN[x1][y2 - (1 << d) + 1][d], MIN[x2 - (1 << d) + 1][y2 - (1 << d) + 1][d]));
}
int GETMAX(int x1, int y1, int x2, int y2)
{
	int d = log(x2 - x1 + 1);
	return max(max(MAX[x1][y1][d], MAX[x2 - (1 << d) + 1][y1][d]), 
		       max(MAX[x1][y2 - (1 << d) + 1][d], MAX[x2 - (1 << d) + 1][y2 - (1 << d) + 1][d]));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k); int logn = min(log(n), log(m));
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { scanf("%d", &a[i][j]); MIN[i][j][0] = MAX[i][j][0] = a[i][j]; }
	for (int l = 1; l <= logn; l++)
		for (int i = 1; i + (1 << l) - 1 <= n; i++)
			for (int j = 1; j + (1 << l) - 1 <= m; j++)
				MIN[i][j][l] = min(min(MIN[i][j][l - 1], MIN[i + (1 << (l - 1))][j][l - 1]), 
								   min(MIN[i + (1 << (l - 1))][j + (1 << (l - 1))][l - 1], MIN[i][j + (1 << (l - 1))][l - 1]));
	for (int l = 1; l <= logn; l++)
		for (int i = 1; i + (1 << l) - 1 <= n; i++)
			for (int j = 1; j + (1 << l) - 1 <= m; j++)
				MAX[i][j][l] = max(max(MAX[i][j][l - 1], MAX[i + (1 << (l - 1))][j][l - 1]), 
								   max(MAX[i + (1 << (l - 1))][j + (1 << (l - 1))][l - 1], MAX[i][j + (1 << (l - 1))][l - 1]));
	
	int ans = 0x3f3f3f3f;
	for (int i = 1; i + k - 1 <= n; i++)
		for (int j = 1; j + k - 1 <= m; j++){
			int I = GETMIN(i, j, i + k - 1, j + k - 1), A = GETMAX(i, j, i + k - 1, j + k - 1);		
			ans = min(ans, A - I);
			}
	printf("%d\n", ans);
}
Problem1048

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#define sqr(a) ((a) * (a))
using namespace std;
int a[101][101], sum[101][101], dp[31][31][31][31][21];
int n, m, k;
int get(int x1, int y1, int x2, int y2, int k)
{
	if (dp[x1][y1][x2][y2][k] != 0x3f3f3f3f) return dp[x1][y1][x2][y2][k];
	//if ((x2 - x1) * (y2 - y1) < k) return 0x3f3f3f3f;
	if (k == 1) return sqr(sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]);
	for (int i = x1; i < x2; i++)
		for (int j = 1; j < k; j++){
			int a = get(x1, y1, i, y2, j), b = get(i + 1, y1, x2, y2, k - j);
			if (a + b < dp[x1][y1][x2][y2][k]) dp[x1][y1][x2][y2][k] = a + b;
			}
	for (int i = y1; i < y2; i++)
		for (int j = 1; j < k; j++){
			int a = get(x1, y1, x2, i, j), b = get(x1, i + 1, x2, y2, k - j);
			if (a + b < dp[x1][y1][x2][y2][k]) dp[x1][y1][x2][y2][k] = a + b;
			}
	return dp[x1][y1][x2][y2][k];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &a[i][j]);
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];
			}
	memset(dp, 0x3f,sizeof(dp));
	int t = get(1, 1, n, m, k); double ave = double(sum[n][m]) / (double)(k);
	printf("%.2lf\n", sqrt(double(t) / double(k) - ave * ave));
}
Problem1050

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 501, MAXM = 20000;
bool vis[MAXN];
int n, m, edge[MAXM], e[MAXN], next[MAXM], v[MAXM], w[MAXM], tot;
int s, t;
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
}
void DFS(int x, int LIM1, int LIM2)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]] && w[i] >= LIM1 && w[i] <= LIM2) DFS(v[i], LIM1, LIM2);
}
bool ok(int LIM1, int LIM2)
{
	memset(vis, 0, sizeof(vis));
	DFS(s, LIM1, LIM2);
	return vis[t];
}
int get(int low)
{
	int l = low, r = m;
	while(l <= r){
		int m = l + r >> 1;
		if (ok(edge[low], edge[m])) r = m - 1; else l = m + 1;
		}
	return l == m + 1 ? 0x3f3f3f3f : edge[l];
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(x, y, z); add(y, x, z); edge[i] = z;
		}
	scanf("%d%d", &s, &t);
	DFS(s, -1, 0x3f3f3f3f); if (!vis[t]) { puts("IMPOSSIBLE"); return 0; }
	tot = 1;
	sort(edge + 1, edge + m + 1);
	for (int i = 2; i <= m; i++) if (edge[i] != edge[i - 1]) { edge[++tot] = edge[i]; }
	m = tot;
	int ans1 = 0x3f3f3f3f, ans2 = 1;
	for (int i = 1; i <= m; i++){
		int t = get(i); if (t == 0x3f3f3f3f) continue; 
		if ((double)(t) / (double)(edge[i]) < (double)(ans1) / (double)(ans2)){
			int temp = gcd(t, edge[i]); 
			ans1 = t / temp; ans2 = edge[i] / temp;
			}
		}
	if (ans1 == 0x3f3f3f3f) puts("IMPOSSIBLE"); 
	else
		if (ans2 == 1) printf("%d\n", ans1);
		else printf("%d/%d\n", ans1, ans2);
}
Problem1051

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 200001, MAXM = 1000001;
using namespace std;
int p, a[MAXN], col[MAXN], into[MAXN], now, num[MAXN], n, m;
bool vis[MAXN];
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM];
	void add(int a, int b)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
	}
	void dfs(int x)
	{
		vis[x] = true;
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) dfs(v[i]);
		a[++p] = x;
	}
	void DFS(int x)
	{
		col[x] = now; ++num[now];
		for (int i = e[x]; i; i = next[i]) if (col[v[i]] == 0) DFS(v[i]);
	}
} g, G;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); g.add(x, y); G.add(y, x);
		}
	for (int i = 1; i <= n; i++) if (!vis[i]) g.dfs(i);
	for (int i = n; i >= 1; i--) if (col[a[i]] == 0){
		now = a[i]; G.DFS(a[i]);
		}
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j]) if (col[i] != col[g.v[j]])
			++into[col[i]];
	int in = 0;
	for (int i = 1; i <= n; i++) if (i == col[i] && into[i] == 0) ++in;
	if (in > 1) { puts("0"); return 0; }
	for (int i = 1; i <= n; i++) if (col[i] == i && into[i] == 0) printf("%d\n", num[i]);
}
Problem1052

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
const int INF = 0x7fffffff;
struct Tpoint{
	int x, y;
	void init() { scanf("%d%d", &x, &y); }
} p[MAXN];
struct Tinf{
	int data[4];
	int & operator [] (int k) { return data[k]; }
	void init() { data[0] = data[2] = INF; data[1] = data[3] = -INF; }
	void renew(Tpoint p) 
	{
		data[0] = min(data[0], p.x);
		data[1] = max(data[1], p.x);
		data[2] = min(data[2], p.y);
		data[3] = max(data[3], p.y);
	}
};
int n, m; bool can, vis[4][MAXN];
void judge()
{
	Tinf inf; inf.init();
	for (int i = 1; i <= n; i++) if (!vis[2][i]) inf.renew(p[i]);
	if (inf[0] == INF) can = true;
	if (inf[1] - inf[0] > m || inf[3] - inf[2] > m) return;
	can = true;
}
void del(int flag)
{
	Tinf inf; inf.init();
	if (flag == 3) { judge(); return; }
	for (int i = 1; i <= n; i++) if (!vis[flag - 1][i]) inf.renew(p[i]);
	for (int i = 0; i <= 1; i++)
		for (int j = 2; j <= 3; j++){
			for (int k = 1; k <= n; k++) vis[flag][k] = vis[flag - 1][k];
			int nowx = inf[i], nowy = inf[j];
			for (int i = 1; i <= n; i++) if (!vis[flag][i] && abs(p[i].x - nowx) <= m && abs(p[i].y - nowy) <= m) vis[flag][i] = true;
			del(flag + 1); if (can) return;
			}
}		
bool ok()
{
	can = false;
	del(1);
	return can;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) p[i].init();
	int l = 0, r = 200000000;
	while(l <= r){
		m = l + r >> 1;
		if (ok()) r = m - 1; else l = m + 1;
		}
	printf("%d\n", l);
}
Problem1053

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
ll n, ans;
int ansnum;
const int d[16] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
void DFS(int dep, ll now, int num, int last)
{
	if (now > n) return;
	if (dep == 15){
		if (num == ansnum) ans = min(ans, now);
		if (num > ansnum){
			ansnum = num; ans = now;
			}
		return;
		}
	ll temp = now;
	for (int i = 0; i <= last; i++){
		if (temp > n) return;
		DFS(dep + 1, temp, num * (i + 1), i);
		temp = temp * (ll)(d[dep + 1]);
		}		
}
int main()
{
	cin >> n;
	DFS(0, 1, 1, 0x3f3f3f3f);
	cout << ans << endl;
}
Problem1054

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};
int dep[2000001], q[2000001], l, r;
void expand(int t)
{
	for (int i = 1; i <= 4; i++)
		for (int j = 1; j <= 4; j++){
			int p = 4 * (i - 1) + j;
			if (t & (1 << (p - 1))){
				for (int k = 0; k < 4; k++){
					int ni = i + dx[k], nj = j + dy[k], np = 4 * (ni - 1) + nj;
					if (ni >= 1 && ni <= 4 && nj >= 1 && nj <= 4 && (!(t & (1 << (np - 1))))){
						int nt = t ^ (1 << (p - 1)) ^ (1 << (np - 1));
						if (dep[nt] == 0x3f3f3f3f){
							dep[nt] = dep[t] + 1; q[++r] = nt;
							}
						}
					}
				}
			}
}
												
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int s = 0, t = 0;
	for (int i = 1; i <= 4; i++){
		for (int j = 1; j <= 4; j++) s = s | ((getchar() - '0') << (4 * (i - 1) + j - 1));
		getchar();
		}
	getchar();
	for (int i = 1; i <= 4; i++){
		for (int j = 1; j <= 4; j++) t = t + ((getchar() - '0') << (4 * (i - 1) + j - 1));
		getchar();
		}
	memset(dep, 0x3f, sizeof(dep));
	dep[s] = 0; l = 1; r = 1; q[1] = s;
	while(l <= r){
		int x = q[l++]; expand(x);
		if (dep[t] != 0x3f3f3f3f) break;
		}
	printf("%d\n", dep[t]);
}
Problem1055

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
char alpha[4] = {'W', 'I', 'N', 'G'};
int num[4], dic[4][100][2], t[100001], n;
char temp[100001];
bool vis[1001][1001][4], f[1001][1001][4];
int convert(char c)
{
	switch(c){
		case 'W' : return 0;
		case 'I' : return 1;
		case 'N' : return 2;
		case 'G' : return 3;
		}
}
bool dp(int l, int r, int a)
{
	if (l == r) return t[l] == a;
	if (vis[l][r][a]) return f[l][r][a];
	vis[l][r][a] = true;
	for (int k = 0; k < num[a]; k++)
		for (int i = l; i < r; i++)
			if (dp(l, i, dic[a][k][0]) && dp(i + 1, r, dic[a][k][1]))
				f[l][r][a] = true;
	return f[l][r][a];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 0; i < 4; i++) scanf("%d", &num[i]);
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < num[i]; j++){
			scanf("%s", temp);
			for (int k = 0; k < 2; k++) dic[i][j][k] = convert(temp[k]);
			}
	scanf("%s", temp);
	n = strlen(temp);
	for (int i = 0; i < n; i++) t[i] = convert(temp[i]);
	bool ok = false;
	for (int i = 0; i < 4; i++)
		if (dp(0, n - 1, i)) putchar(alpha[i]), ok = true;
	if (!ok) printf("The name is wrong!");
	putchar('\n');
}
Problem1055

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
char alpha[4] = {'W', 'I', 'N', 'G'};
int num[4], dic[4][100][2], t[100001], n;
char temp[100001];
bool vis[1001][1001][4], f[1001][1001][4];
int convert(char c)
{
	switch(c){
		case 'W' : return 0;
		case 'I' : return 1;
		case 'N' : return 2;
		case 'G' : return 3;
		}
}
bool dp(int l, int r, int a)
{
	if (l == r) return t[l] == a;
	if (vis[l][r][a]) return f[l][r][a];
	vis[l][r][a] = true;
	bool ok = false;
	for (int k = 0; k < num[a]; k++){
		if (ok) break;
		for (int i = l; i < r; i++)
			if (dp(l, i, dic[a][k][0]) && dp(i + 1, r, dic[a][k][1])){
				f[l][r][a] = true; ok = true; break;
				}
		}
	return f[l][r][a];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 0; i < 4; i++) scanf("%d", &num[i]);
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < num[i]; j++){
			scanf("%s", temp);
			for (int k = 0; k < 2; k++) dic[i][j][k] = convert(temp[k]);
			}
	scanf("%s", temp);
	n = strlen(temp);
	for (int i = 0; i < n; i++) t[i] = convert(temp[i]);
	bool ok = false;
	for (int i = 0; i < 4; i++)
		if (dp(0, n - 1, i)) putchar(alpha[i]), ok = true;
	if (!ok) printf("The name is wrong!");
	putchar('\n');
}
Problem1056

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#define min(a, b) ((a) < (b) ? (a) : (b))
using namespace std;
bool first;
struct Ttrienode{
	int where;
	int ch[26];
};
struct Ttrie{
	static const int MAXTRIENODE = 1400001, root = 1;
	int tot;
	Ttrienode data[MAXTRIENODE];
	void insert(char *S, int num)
	{
		int now = root;
		for (char *s = S; *s; s++){
			if (data[now].ch[*s - 'A'] == 0){
				++tot; data[now].ch[*s - 'A'] = tot;
				}
			now = data[now].ch[*s - 'A'];
			}
		data[now].where = num;
	}
	int find(char * S)
	{
		int now = root;
		for (char *s = S; *s; s++){ 
			now = data[now].ch[*s - 'A']; 
			if (now == 0) return 0; 
			}
		return data[now].where;
	}
} H;		
struct Tsplaynode{
	static Tsplaynode *a;
	int c[2], f, size, key, time;
	char name[11];
	void update()
	{
		if (this != a)
			size = a[c[0]].size + a[c[1]].size + 1;
	}
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
};
const int MAXSPLAYNODE = 300001; 
Tsplaynode data[MAXSPLAYNODE], *Tsplaynode::a = data;
struct Tsplay{
	int tot, root;
	void splay(int x, int p)
	{
		if (x == p) return;
		int y, z; bool b, c;
		while((y = data[x].f) != p){
			b = x == data[y].c[1];
			if ((z = data[y].f) != p){
				c = y == data[z].c[1];
				if (b == c) data[y].rot(b); else data[x].rot(b);
				data[x].rot(c);
				}
			else data[x].rot(b);
			}
		data[x].update(); if (p == 0) root = x;
	}
	int insert(char *S, int num, int time)
	{
		if (root == 0){
			++tot; data[tot].f = 0; data[tot].key = num;
			strcpy(data[tot].name, S); data[tot].size = 1;
			data[tot].time = time;
			return root = tot;
			}	
		int now = root;
		while (1){
			int t = data[now].c[(num < data[now].key) || (num == data[now].key && time > data[now].time)];
			if (t == 0){
				++tot; data[tot].f = now; data[tot].key = num;
				strcpy(data[tot].name, S); data[tot].size = 1;
				data[tot].time = time;
				data[now].c[(num < data[now].key) || (num == data[now].key && time > data[now].time)] = tot;
				break;
				}
			else ++data[now].size, now = t;
			}
		splay(tot, 0); return tot;
	}
	int rank(int t)
	{
		splay(t, 0);
		return data[data[t].c[0]].size + 1;
	}
	int findmax(int t)
	{
		while (data[t].c[1]) t = data[t].c[1];
		return t;
	}
	void del(int t)
	{
		splay(t, 0);
		int tt = findmax(data[t].c[0]);
		splay(tt, root);
		data[tt].c[1] = data[root].c[1];
		data[data[root].c[1]].f = tt;
		root = tt;
		data[root].f = 0;	
		data[root].update();
	}
	int getkth(int k)
	{
		int t = root, temp;
		while((temp = (data[data[t].c[0]].size + 1)) != k)
			if (temp < k) k -= temp, t = data[t].c[1];
			else t = data[t].c[0];
		return t;
	}
	void preorder(int t)
	{
		if (t == 0) return;
		preorder(data[t].c[0]);
		if (first) { printf("%s", data[t].name); first = false;}
		else printf( " %s", data[t].name);
		preorder(data[t].c[1]);
	}
} T;
char name[1001], opr[1001];
int num, now;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	T.insert("", 0x80000000, 0);
	T.insert("", 0x7fffffff, 0);
	H.tot = 1;
	int q; scanf("%d", &q);
	for (int i = 1; i <= q; i++){
		//fprintf(stderr, "%d %d\n", i, data[T.root].size);
		if (i == 7){
			int a;
			++a;
			}
		getchar(); char c; c = getchar(); int ok;
		switch(c){
			case '+':
				scanf("%s%d", name, &num);
				ok = H.find(name);
				if (!ok) { H.insert(name, T.insert(name, num, i)); ++now; }
				else { T.del(ok); H.insert(name, T.insert(name, num, i)); }
				break;
			case '?':
				scanf("%s", opr);
				if (isdigit(*opr)){
					int r; sscanf(opr, "%d", &r);
					/*
					printf("%s", data[T.getkth(now - r + 1)].name);
					for (int i = 2; i <= 10 && r + i - 1 <= now; i++)
						printf(" %s", data[T.getkth(now - (r + i - 1) + 1)].name);
					putchar('\n');
					*/
					T.splay(T.getkth(r), 0);
					T.splay(T.getkth(min(r + 10 + 1, now + 2)), T.root);
					first = true;
					T.preorder(data[data[T.root].c[1]].c[0]);
					putchar('\n');
					}
				else{
					int ok = H.find(opr);
					printf("%d\n", T.rank(ok) - 1);
					}
			}
		}
}
Problem1057

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m, f[2001][2001], map[2001][2001];
int r[2001], right[2001], l[2001], left[2001], u[2001];
void solve1()
{
	int ans = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			if (i == 1 || j == 1) { f[i][j] = 1; continue; }
			if (map[i - 1][j] == map[i][j] || map[i][j - 1] == map[i][j] || map[i - 1][j - 1] != map[i][j]) { f[i][j] = 1; continue; };
			f[i][j] = min(f[i - 1][j - 1], min(f[i][j - 1], f[i - 1][j])) + 1;
			ans = max(ans, f[i][j]);
			}
	printf("%d\n", ans * ans);
}	
void solve2()
{
	int ans = 1;
	for (int i = 1; i <= n; i++){
		left[1] = 1; right[m] = 1;
		for (int j = 2; j <= m; j++) if (map[i][j] != map[i][j - 1]) left[j] = left[j - 1] + 1; else left[j] = 1;
		for (int j = m - 1; j >= 1; j--) if (map[i][j] != map[i][j + 1]) right[j] = right[j + 1] + 1; else right[j] = 1;
		for (int j = 1; j <= m; j++){
			if (i == 1){ u[j] = 1; l[j] = left[j]; r[j] = right[j]; }
			else if (map[i][j] != map[i - 1][j]) { u[j]++; l[j] = min(l[j], left[j]); r[j] = min(r[j], right[j]); }
			else { u[j] = 1; l[j] = left[j]; r[j] = right[j]; }
			ans = max(ans, (r[j] + l[j] - 1) * u[j]);
			}
		}
	printf("%d\n", ans);
}				
int main()
{
#ifndef ONLINE_JUDGE
	freopen("chess.in", "r", stdin); freopen("chess.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &map[i][j]);
	solve1(); solve2();
}
Problem1058

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int INF = 1000000000, MAXN = 1200001;
using namespace std;
int n, m;
bool ws;
char op[10001];
struct Tsplaynode1{
	static Tsplaynode1 *a;
	int c[2], f, key, GAP, MINGAP;
	void update()
	{
		MINGAP = min(GAP, min(a[c[0]].MINGAP, a[c[1]].MINGAP));
	}
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} data1[MAXN], *Tsplaynode1::a = data1;
struct Tsplay1{
	int root, tot;
	int getmin(int t) { while(data1[t].c[0]) t = data1[t].c[0]; return t; }
	int getmax(int t) { while(data1[t].c[1]) t = data1[t].c[1]; return t; } 
	Tsplaynode1 & operator [] (int k ) { return data1[k]; }
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		if (x == p) return;
		while((y = data1[x].f) != p){
			b = x == data1[y].c[1];
			if ((z = data1[y].f) != p){
				c = y == data1[z].c[1];
				if (b == c) data1[y].rot(b); else data1[x].rot(b);
				data1[x].rot(c);
				}
			else data1[x].rot(b);
			}
		data1[x].update();
		if (p == 0) root = x;
	}
	int insert(int num)
	{
		int t = root;
		while(data1[t].c[num > data1[t].key]) t = data1[t].c[num > data1[t].key];
		++tot; data1[tot].key = num; data1[tot].f = t; data1[tot].GAP = data1[tot].MINGAP = INF;
		data1[t].c[num > data1[t].key] = tot;
		splay(tot, 0); return tot;
	}
	void repair(int t)
	{
		int MIN = getmax(data1[t].c[0]), MAX = getmin(data1[t].c[1]);
		data1[t].GAP = min(data1[t].key - data1[MIN].key, data1[MAX].key - data1[t].key); data1[t].update();
		data1[MIN].GAP = min(data1[t].key - data1[MIN].key, data1[MIN].GAP); splay(MIN, 0);
		data1[MAX].GAP = min(data1[MAX].key - data1[t].key, data1[MIN].GAP); splay(MAX, 0);
	}
	int GET() { if (data1[root].MINGAP == 0) ws = true; return data1[root].MINGAP; }
} T1;
const int MAXn = 500001;
int a[MAXn], last[MAXn];
struct Tsegmenttree{
	int in[MAXn * 4], next[MAXn * 4], MIN[MAXn * 4];
	void update(int idx)
	{
		MIN[idx] = min(MIN[idx * 2], MIN[idx * 2 + 1]);
	}
	void build(int idx, int l, int r)
	{
		if (l == r){ 
			in[idx] = INF; next[idx] = (l == n ? INF : abs(a[l] - a[l + 1])); MIN[idx] = next[idx]; 
			return;
			}
		else { build(idx * 2, l, l + r >> 1); build(idx * 2 + 1, l + r + 2 >> 1, r); } 
		update(idx);
	}
	void changein(int idx, int l, int r, int x, int num)
	{
		if (l == r) { in[idx] = min(in[idx], num); MIN[idx] = min(in[idx], next[idx]); return; }
		else { int m = l + r >> 1; if (x <= m) changein(idx * 2, l, m, x, num); else changein(idx * 2 + 1, m + 1, r, x, num); }
		update(idx);
	}
	void changenext(int idx, int l, int r, int x, int num)
	{
		if (l == r) { next[idx] = num; MIN[idx] = min(in[idx], next[idx]); return; }
		else { int m = l + r >> 1; if (x <= m) changenext(idx * 2, l, m, x, num); else changenext(idx * 2 + 1, m + 1, r, x, num); }
		update(idx);
	}
	int GET() { return MIN[1]; }
} T2;	
void insert(int w, int num)
{
	T2.changein(1, 1, n, w, abs(num - last[w]));
	if (w != n) T2.changenext(1, 1, n, w, abs(num - a[w + 1]));
	last[w] = num;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("form.in", "r", stdin); freopen("form.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	T1[0].MINGAP = T1[0].GAP = INF;
	T1.insert(INF); T1.insert(-INF);
	T1[1].GAP = INF; T1[1].MINGAP = INF;
	T1[2].GAP = INF; T1[2].MINGAP = INF;
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]); last[i] = a[i];
		int w = T1.insert(a[i]); T1.repair(w); 
		}
	T2.build(1, 1, n);
	for (int i = 1; i <= m; i++){ 
		scanf("%s", op);
		int w, num, ww;
		switch(op[4]){
			case 'R' : scanf("%d%d", &w, &num); if (!ws) { ww = T1.insert(num); T1.repair(ww); } insert(w, num); break;
			case 'S' : if (ws) puts("0"); else printf("%d\n", T1.GET()); break;
			default  : printf("%d\n", T2.GET()); break;
			}
		}
}
Problem1059

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, map[1001][1001], link[1001];
bool vis[1001];
bool find(int v)
{
	for (int i = 1; i <= n; i++) if (!vis[i] && map[v][i]){
		vis[i] = true;
		if (link[i] == 0 || find(link[i])){
			link[i] = v; return true;
			}
		}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &map[i][j]);
	memset(link, 0, sizeof(link));
	bool ok = true;
	for (int i = 1; i <= n; i++) { memset(vis, 0, sizeof(vis)); if (!find(i)) { ok = false; break; } }
	puts(ok ? "Yes" : "No");
}
}
Problem1061

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MO = 262144 - 1, MAXN = 500001;
int tot = 1, e[MAXN], v[MAXN], w[MAXN], next[MAXN], c[MAXN];
int q[MAXN], l, r, dis[1010], from[MAXN];
bool vis[1010];
int n, m, cost, S, T;
void add(int A, int B, int C, int D)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
}
bool spfa()
{
	memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis));
	dis[S] = 0; l = 0; r = 1; q[1] = S; vis[S] = true;
	while(l != r){
		l = (l + 1) & MO; int x = q[l]; vis[x] = false;
		for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i] && c[i] > 0){
			dis[v[i]] = dis[x] + w[i]; from[v[i]] = i;
			if (!vis[v[i]]) { r = (r + 1) & MO; q[r] = v[i]; vis[v[i]] = true; }
			}
		}
	return dis[T] < 0x3f3f3f3f;
}
void aug()
{
	int t = 0x3f3f3f3f;
	for (int i = T; i != S; i = v[from[i] ^ 1])
		t = min(t, c[from[i]]);
	for (int i = T; i != S; i = v[from[i] ^ 1]) c[from[i]] -= t, c[from[i] ^ 1] += t;
	cost += t * dis[T];
}
int main()
{
	scanf("%d%d", &n, &m);
	int last = 0; S = n + 2; T = S + 1;
	for (int i = 1; i <= n; i++){
		int t, tt; scanf("%d", &t); tt = t - last;
		if (tt >= 0) add(S, i, tt, 0); else add(i, T, -tt, 0);
		last = t;
		}
	add(n + 1, T, last, 0);
	for (int i = 1; i <= n; i++) add(i + 1, i, 0x3f3f3f3f, 0);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b + 1, 0x3f3f3f3f, c);
		}
	while(spfa())
		aug();
	printf("%d\n", cost);
}
Problem1062

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define lowbit(i) ((i) & (-i))
using namespace std;
int cw[1000001], t[100001], leng[100001];
int q, n, m, len, p;
struct Tbit{
	int data[2500][5001];
	void mod(int x, int y, int d)
	{
		++x; ++y;
		for (int i = x; i <= n + 1; i += lowbit(i))
			for (int j = y; j <= m + 1; j += lowbit(j))
				data[i][j] += d;
	}
	int get(int x, int y)
	{
		if (x < 0 || y < 0) return 0;
		if (x <= n) ++x; else x = n + 1;
		if (y <= m) ++y; else y = m + 1;
		int ret = 0;
		for (int i = x; i; i -= lowbit(i))
			for (int j = y; j; j -= lowbit(j))
				ret += data[i][j];
		return ret;
	}
	int get(int x1, int x2, int y1, int y2)
	{
		int t = get(x2, y2) + get(--x1, --y1) - get(x1, y2) - get(x2, y1);
		return t;
	}
} a, b;
void change(int w, int d)
{
	a.mod(t[w], leng[w] - t[w] + n, d);
	b.mod(t[w], t[w] + leng[w], d);
}
int getans(int t, int l, int r)
{
	int d = r == len;
	return
	  //t >= t[i]
		a.get(t - r, t, l - t + n, m)
	   +b.get(0, r + t - n - d, l + t - n, m)
	  //t < t[i]
	   +a.get(t + n - r + d, n, l - t, m)
	   +b.get(t + 1, t + r, l + t, m);
}
int main()
{
	scanf("%d%d", &q, &len); n = len << 1; m = n << 1;
	while(q--){
		int op, c, l, r, d, time;
		scanf("%d%d", &op, &time);
		switch(op){
			case 1:
				scanf("%d%d%d%d", &c, &l, &r, &d);
				cw[c] = ++p; 
				t[p] = (time - d * l + n) % n; 
				leng[p] = r - l;
				change(p, 1);
				break;
			case 2:
				scanf("%d%d", &l, &r);
				printf("%d\n", getans(time % n, l, r));
				break;
			case 3:
				scanf("%d", &c);
				change(cw[c], -1);
				break;
			}
		}
}
Problem1063

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define lint long long
using namespace std;
const int MAXN = 100001;
lint f[MAXN][11][3], MO; bool real[MAXN][11][3];
int e[MAXN], v[MAXN * 2], next[MAXN * 2], tot, fa[MAXN];
bool vis[MAXN];
int n, m, LIM;
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dp(int x)
{
	if (vis[x]) return; vis[x] = true;
	memset(real[x], 0, sizeof(real[x]));
	memset(f[x], 0, sizeof(f[x]));
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		fa[v[i]] = x;
		dp(v[i]);
		}
	for (int j = 0; j <= LIM; j++){
#define a(k) f[x][j][k]
#define b(k) real[x][j][k]
		b(0) = true;
		a(0) = 1, a(1) = 0, a(2) = 0;
		for (int i = e[x]; i; i = next[i]) if(v[i] != fa[x])
		if (j == 0){
			a(2) = a(1) * (f[v[i]][j][0] + f[v[i]][j][1]) % MO;
			b(2) = b(1) && (real[v[i]][j][0] || real[v[i]][j][1]);
			a(1) = a(0) * (f[v[i]][j][0] + f[v[i]][j][1]) % MO;
			b(1) = b(0) && (real[v[i]][j][0] || real[v[i]][j][1]);
			a(0) = 0; b(0) = false;
			}
		else{
			a(2) = (a(1) * (f[v[i]][j][0] + f[v[i]][j][1]) % MO + a(2) * (f[v[i]][j - 1][0] + f[v[i]][j - 1][1] + f[v[i]][j - 1][2]) % MO) % MO;
			b(2) = (b(1) && (real[v[i]][j][0] || real[v[i]][j][1])) || (b(2) && (real[v[i]][j - 1][0] || real[v[i]][j - 1][1] || real[v[i]][j - 1][2]));
			a(1) = (a(0) * (f[v[i]][j][0] + f[v[i]][j][1]) % MO + a(1) * (f[v[i]][j - 1][0] + f[v[i]][j - 1][1] + f[v[i]][j - 1][2]) % MO) % MO;
			b(1) = (b(0) && (real[v[i]][j][0] || real[v[i]][j][1])) || (b(2) && (real[v[i]][j - 1][0] || real[v[i]][j - 1][1] || real[v[i]][j - 1][2]));
			a(0) = a(0) * (f[v[i]][j - 1][0] + f[v[i]][j - 1][1] + f[v[i]][j - 1][2]) % MO;
			b(0) = b(0) && (real[v[i]][j - 1][0] || real[v[i]][j - 1][1] || real[v[i]][j - 1][2]);
			}
		}
}
int main()
{
	scanf("%d%d%I64d", &n, &m, &MO);
	if (m != n - 1) { puts("-1\n-1"); return 0; }
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
		}
	for (LIM = 0; ;++LIM){
		memset(vis, 0, sizeof(vis));
		dp(1);
		if (!(real[1][LIM][0] || real[1][LIM][1] || real[1][LIM][2])) continue;
		printf("%d\n%lld\n", LIM, (f[1][LIM][1] + f[1][LIM][2] + f[1][LIM][0]) % MO);
		return 0;
		}
}
Problem1064

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m, maxm, minm, anstree, ansnum, anslist[100001];
int e[100001], next[2000001], v[2000001], w[2000001], mark[100001], tot;
bool vis[100001];
bool added;
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
}
void work(int x)
{
	vis[x] = true; maxm = max(mark[x], maxm); minm = min(mark[x], minm);
	for (int i = e[x]; i; i = next[i])
		if (vis[v[i]]){
			if (mark[v[i]] != (mark[x] + w[i]))
				if (!added)
					anslist[++ansnum] = abs(mark[v[i]] - (mark[x] + w[i])), added = true;
				else anslist[ansnum] = min(anslist[ansnum], abs(mark[v[i]] - (mark[x] + w[i])));
			} 
		else{
			mark[v[i]] = mark[x] + w[i];
			work(v[i]);
			}
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y);
		add(x, y, 1); add(y, x, -1);
		}
	for (int i = 1; i <= n; i++) if (!vis[i]){
		added = false;
		maxm = 0xe0e0e0e0; minm = 0x3f3f3f3f;
		work(i);
		anstree += maxm - minm + 1;
		}
	if (ansnum == 0){
		if (anstree < 3) puts("-1 -1"); else printf("%d %d\n", anstree, 3);
		return 0;
		}
	int ans1 = 0, ans2 = -1;
	for (int i = 1; i <= ansnum; i++) ans1 = gcd(ans1, anslist[i]);
	if (ans1 < 3) { puts("-1 -1"); return 0; }
	for (ans2 = 3; ans2 <= ans1; ans2++){
		bool ok = true;
		for (int i = 1; i <= ansnum; i++) if (anslist[i] % ans2 != 0) ok = false;
		if (ok) {printf("%d %d\n", ans1, ans2); return 0;}
		}
}
Problem1065

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 65;
int n, m, next[MAXN];
double K[MAXN], c[MAXN], ans;
double f[MAXN][MAXN][MAXN], g[MAXN];
bool cir[MAXN];
struct Ttree{
	int e[MAXN], v[MAXN * 2], tot, next[MAXN * 2];
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
	void dp(int x, int y)
	{
		memset(f[x], 0, sizeof(f[x]));
		for (int adji = e[x]; adji; adji = next[adji]){
			int i = v[adji]; dp(i, y + 1);
			for (int j = 0; j <= y; j++)
			for (int k = m; k >= 0; k--)
			for (int kk = 0; kk <= k; kk++){
				f[x][j][k] = max(f[x][j][k], f[x][j][k - kk] + f[i][j + 1][kk]);
				if (k != kk) f[x][j][k] = max(f[x][j][k], f[x][j][k - kk - 1] + f[i][1][kk]);
				}
			}
		for (int j = 0; j <= y; j++)
			for (int k = 0; k <= m; k++)
				f[x][j][k] += K[j] * c[x];
	}					
} tree;
void solve()
{
	tree.clear();
	memset(cir, 0, sizeof(cir));
	int t = 1, len = 0;
	do { cir[t] = true; t = next[t]; ++len; } while(t != 1);
	for (int i = 1; i <= n; i++) if (!(cir[i] && cir[next[i]])) tree.add(next[i], i);
	tree.dp(1, 0);
	for (int t = next[1], now = len - 1; t != 1; t = next[t], --now) tree.dp(t, now);
	memset(g, 0, sizeof(g));
	for (int i = 0; i <= m; i++) g[i] = f[1][0][i];
	for (int t = next[1], now = len - 1; t != 1; t = next[t], --now)
		for (int k = m; k >= 0; k--)
			for (int kk = 0; kk <= k; kk++)
				g[k] = max(g[k], g[k - kk] + f[t][now][kk]);
	double ret = g[m] / (1 - K[len]);
	ans = max(ans, ret);
}				
int main()
{
	scanf("%d%d%lf", &n, &m, &K[1]);
	K[0] = 1.0; for (int i = 1; i <= n; i++) K[i] = K[i - 1] * K[1];
	for (int i = 1; i <= n; i++) scanf("%d", &next[i]);
	for (int i = 1; i <= n; i++) scanf("%lf", &c[i]);
	solve(); --m;
	for (int i = next[1]; next[i] != 1; i = next[i]){
		int temp = next[i];
		next[i] = 1; solve();
		next[i] = temp;
		}
	printf("%.2lf\n", ans);
}
Problem1066

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define num1(i, j) (((i - 1) * m + j) * 2 - 1)
#define num2(i, j) (((i - 1) * m + j) * 2)
#define dis(x, y, X, Y) (abs(x - X) + abs(y - Y))
const int MAXN = 400001, MAXM = 800001, INF = 0x3f3f3f3f;
using namespace std;
int n, m, d;
int tot = 1, e[MAXN], c[MAXM], next[MAXM], v[MAXM];
int h[MAXN], vh[MAXN], S, T;
char H[1001][1001], map[1001][1001];
void add(int A, int B, int C)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
}
int aug(int x, int f)
{
	int augc = f, minh = T - 1;
	if (x == T) return f;
	for (int i = e[x]; i; i = next[i]) if (c[i]){
		if (h[v[i]] + 1 == h[x]){
			int t = aug(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (h[S] == T) return augc - f;
			}
		minh = min(minh, h[v[i]]);
		}
	if (f == augc){
		--vh[h[x]]; if (vh[h[x]] == 0) h[S] = T;
		h[x] = minh + 1; ++vh[h[x]];
		}
	return augc - f;
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &d);
	S = num2(n, m) + 1; T = S + 1;
	int ans = 0;
	vh[0] = T;
	for (int i = 1; i <= n; i++) scanf("%s", H[i] + 1);
	for (int i = 1; i <= n; i++) scanf("%s", map[i] + 1);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			if (map[i][j] == 'L'){
				add(S, num1(i, j), 1);
				++ans;
				}
			if (H[i][j] > '0'){
				add(num1(i, j), num2(i, j),  H[i][j] - '0');
				if (min(i, j) <= d || min(n - i + 1, m - j + 1) <= d)
					add(num2(i, j), T, INF);
				for (int I = 1; I <= n; I++)
					for (int J = 1; J <= m; J++)
						if (dis(i, j, I, J) <= d)
							add(num2(i, j), num1(I, J), INF);
				}
			}
	while(h[S] < T) 
		ans -= aug(S, INF);
	printf("%d\n", ans);
}
Problem1067

#include <iostream>
#include <cstdio>
using namespace std;

#define maxn 50010

int n, m;

struct point {
    int year, r;
}pt[maxn];

struct Tree {
    int Max;
    int l, r;
}T[maxn*4];

int MMax(int a, int b) {
    return a > b ? a : b;
}

void Build(int p, int l, int r) {
    T[p].l = l;
    T[p].r = r;
    if(l == r) {
        T[p].Max = pt[l].r;
        return ;
    }
    int mid = (l + r) >> 1;
    Build(p<<1, l, mid);
    Build(p<<1|1, mid+1, r);
    T[p].Max = MMax(T[p<<1].Max, T[p<<1|1].Max);
}

int Query(int p, int l, int r) {
    if(r < T[p].l || l > T[p].r)
        return 0;
    if(l <= T[p].l && T[p].r <= r) 
        return T[p].Max;
    return MMax(Query(p<<1, l, r), Query(p<<1|1, l, r));
}

int Binary(int val, int l, int r) {
    int ans = 0;
    while(l <= r) {
        int m = (l + r) >> 1;
        if(pt[m].year <= val) {
            l = m + 1;
            ans = m;
        }else
            r = m - 1;
    }
    return ans;
}

// ??????
int Coces[maxn];

int main() {
    int i;
    int t = 0;
    while(scanf("%d", &n) != EOF) {

        if(t++ && n) {
            puts("");
        }
        for(i = 1; i <= n; i++) {
            scanf("%d %d", &pt[i].year, &pt[i].r);
            if(i == 1) {
                Coces[i] = 1;
            }else {
                if(pt[i].year - pt[i-1].year == 1)
                    Coces[i] = Coces[i-1];
                else
                    Coces[i] = Coces[i-1] + 1;
            }
        }
        if(n)
            Build(1, 1, n);

        scanf("%d", &m);
        int bufM = m;

        while(bufM--) {
            int Y, X;
            int ans; // 0 true 1 maybe 2 false
            scanf("%d %d", &Y, &X);
            int fY = Binary(Y, 1, n);
            int fX = Binary(X, 1, n);

            if(pt[fY].year == Y && pt[fX].year == X) {        
                // ???????????

                int Yr = Query(1, fY, fY);
                int Zr = Query(1, fY+1, fX-1);
                // Y+1 == X ??????Zr????0,??????
                int Xr = Query(1, fX, fX);

                if(Coces[fY] == Coces[fX]) {
                    // ?????????
                    if(Yr >= Xr && Zr < Xr) {
                        ans = 0;
                    }else
                        ans = 2;
                }else {
                    // ????????
                    if(Yr >= Xr && Zr < Xr) {
                        ans = 1;
                    }else
                        ans = 2;
                }
            }else if(pt[fX].year == X) {
                // X???????
                if(Y + 1 == X) {
                    // ??????
                    ans = 1;
                }else {
                    int Zr = Query(1, fY+1, fX-1);
                    int Xr = Query(1, fX, fX);
                    if(Zr < Xr)
                        ans = 1;
                    else
                        ans = 2;
                }
            }else if(pt[fY].year == Y) {
                int Yr = Query(1, fY, fY);
                int Zr = Query(1, fY+1, fX);
                if(Yr > Zr) {
                    ans = 1;
                }else
                    ans = 2;
            }else {
                // X ? Y ?????,???maybe
                ans = 1;
            }

            if(!ans)
                puts("true");
            else if(ans == 1)
                puts("maybe");
            else
                puts("false");
        }

        if(!n && !m) {
            break;
        }
    }
    return 0;
}
Problem1067

#include <cstdio>
#include <cstdlib>
#include <cstring>
#define MAX(a, b) ((a) > (b) ? (a) : (b))
using namespace std;
int t[1200001], n, m, M[1200001];
int f[520001][21];
void build()
{
	int log = 31 - __builtin_clz(n);
	for (int i = 1; i <= n; i++) f[i][0] = t[i];
	for (int j = 1; j <= log; j++)
		for (int i = 1; i <= n - (1 << j) + 1; i++)
			f[i][j] = MAX(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
} 
int getmaxnum(int l, int r)
{
	if (r < l) return 0;
	int x = 31 - __builtin_clz(r - l + 1);
	return MAX(f[l][x], f[r - (1 << x) + 1][x]);
}	
int find(int num)
{
	int l = 1, r = n;
	while(l <= r){
		int m = l + r >> 1;
		if (M[m] == num) return m;
		if (M[m] < num) l = m + 1; else r = m - 1;
		}
	return 0;
} 
int lower_bound(int num)
{
	int l = 1, r = n;
	while(l <= r){
		int m = l + r >> 1;
		if (M[m] <= num) l = m + 1; else r = m - 1;
		}
	return r;
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int a; scanf("%d", &a); M[i] = a;
		scanf("%d", &t[i]);
		}
	build();
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		int a, b, ta = 0, tb = 0;
		scanf("%d%d", &a, &b);
		if (a == b) { puts("true"); continue; }	
		ta = find(a);
		tb = find(b);
		if (a + 1 == b){
			if (ta == 0 || tb == 0) { puts("maybe"); continue; }
			if (t[ta] >= t[tb]) puts("true"); else puts("false"); continue;
			}
		if (tb == 0 && ta == 0){
			puts("maybe"); continue;
			}
		if (tb == 0){
			tb = lower_bound(b);
			if (t[ta] > getmaxnum(ta + 1, tb))
				puts("maybe");
			else puts("false");
			continue;
			}
		if (ta == 0){
			ta = lower_bound(a) + 1;
			if (t[tb] <= getmaxnum(ta, tb - 1))
				puts("false");
			else puts("maybe");
			continue;
			}
		if (b - a > tb - ta){
			if (t[tb] <= getmaxnum(ta + 1, tb - 1) || t[ta] < t[tb])
				puts("false");
			else puts("maybe");
			continue;
			}
		if (t[tb] <= getmaxnum(ta + 1, tb - 1) || t[ta] < t[tb]) puts("false"); else puts("true");
		}
		
}
Problem1068

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
#include<vector>
#include<cstring>
#define rep(i,n) for(int i=0;i<n;i++)
#define pb push_back
using namespace std;
const int inf=~0U>>1,maxl=100;
char M[maxl];
bool S[maxl][maxl][2]={0};
int Dp[maxl][maxl][2];
bool Match(int p,int Len,int s)
{
    if(Len%s)return false;
    rep(i,Len)if(M[p+i]!=M[p+i%s])return false;
    return true;
}
inline int Update(int&x,int c){x=min(x,c);}
int dfs(int l,int r,bool t)
{
    int&x=Dp[l][r][t];if(S[l][r][t]) return x;
    S[l][r][t]=true;int Len=r-l+1;x=Len;
    if(Len==1)return x;
    if(t)for(int k=l;k<r;k++)Update(x,dfs(l,k,1)+1+dfs(k+1,r,1));
    for(int k=l;k<r;k++)Update(x,dfs(l,k,t)+r-k);
    if(Len%2==0&&Match(l,Len,Len/2)) Update(x,dfs(l,l+Len/2-1,0)+1);
    return x;
}
int main()
{
    cin>>M;
    cout<<dfs(0,strlen(M)-1,1)<<endl;
}
Problem1069

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
const double eps = 1e-6;
using namespace std;
struct Tpoint{
	double x, y;
	Tpoint operator + (Tpoint B)
	{
		Tpoint temp;
		temp.x = x + B.x; temp.y = y + B.y;
		return temp;
	}
	double operator * (Tpoint B)
	{
		double t =  x * B.y - y * B.x;
		return t;
	}
	bool operator < (const Tpoint & A) const
	{
		return A.y == y ? x < A.x : y < A.y;
	}
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp;
		temp.x = x - A.x; temp.y = y - A.y;
		return temp;
	}
	void init() { scanf("%lf%lf", &x, &y); }	
} p[100001], q[100001];
int stack[100001], top, n;
bool vis[100001];
double ans = -1e99;
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	return t < 0 ? -1 : 1;
}
void solve(int s)
{
	int u = s + 1, d = s + 3;
	for (int i = s + 2; i <= s + n - 2; i++){
		while(u + 1 < i && fabs((q[s] - q[i]) * (q[u] - q[i])) < fabs((q[s] - q[i]) * (q[u + 1] - q[i]))) ++u;
		while(d + 1 <= s + n - 1 && fabs((q[s] - q[i]) * (q[d] - q[i])) < fabs((q[s] - q[i]) * (q[d + 1] - q[i]))) ++d;
		ans = max(ans, fabs((q[s] - q[i]) * (q[u] - q[i])) + fabs((q[s] - q[i]) * (q[d] - q[i])));
		}
}	
int main()
{
	//freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	sort(p + 1, p + n + 1);
	for (int i = 1; i <= n; i++){
		while(top > 1 && (dcmp((p[i] - p[stack[top - 1]]) * (p[stack[top]] - p[stack[top - 1]])) >= 0)){
			--top; vis[stack[top + 1]] = false;
			}
		vis[stack[++top] = i] = true;
		}
	int lasttop = top - 1;
	vis[1] = false;
	for (int i = n - 1; i >= 1; i--) if (!vis[i]){
		while(top - lasttop > 1 && (dcmp((p[i] - p[stack[top - 1]]) * (p[stack[top]] - p[stack[top - 1]])) >= 0))
			--top;
		stack[++top] = i;
		}
	--top;
	n = top;
	for (int i = 1; i <= top; i++) q[i] = p[stack[i]];
	for (int i = 1; i <= top; i++) q[i + top] = q[i];
	for (int i = 1; i <= n; i++) solve(i);
	printf("%.3lf\n", ans / 2);
}
Problem1070

#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#define convert(j, k) (k * n + j)
using namespace std;
const int SIZE = 16384 - 1, MAXN = 20001, MAXM = 300001;
int q[SIZE + 100], l, r;
int dis[MAXN], from[MAXN]; bool vis[MAXN];
int e[MAXN], w[MAXM], next[MAXM], c[MAXM], v[MAXM], tot = 1;
int S, T, n, m, flow, cost;
int num[1001][1001];
void add(int A, int B, int C, int D)
{
#ifdef DEBUG
	cerr << A << " " << B << " " << C << " " << D << endl;
#endif
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
}
bool spfa()
{
	memset(dis, 0x3f, sizeof(dis));
	memset(vis, 0, sizeof(vis));
	l = 0; r = 1; q[1] = S; vis[S] = true; dis[S] = 0;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
			dis[v[i]] = dis[x] + w[i]; from[v[i]] = i;
			if (!vis[v[i]]){
				r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true;
				}
			}
		}
	return dis[T] < 0x3f3f3f3f;
}
void aug()
{
	int t = 0x3f3f3f3f;
	for (int i = T; i != S; i = v[from[i] ^ 1]) t = min(t, c[from[i]]);
	for (int i = T; i != S; i = v[from[i] ^ 1]){
		c[from[i]] -= t; c[from[i] ^ 1] += t;
		}
	flow += t; cost += t * dis[T];
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &m, &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &num[i][j]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= m; k++)
				add(i, convert(k, j), 1, num[i][k] * j);
	S = convert(m, n) + 1; T = S + 1;
	for (int i = 1; i <= n; i++) add(S, i, 1, 0);
	for (int j = 1; j <= m; j++)
		for (int k = 1; k <= n; k++)
			add(convert(j, k), T, 1, 0);
	while(spfa()) aug();
#ifdef DEBUG
	cerr << flow << " " << cost << endl;
#endif
	printf("%.2lf\n", double(cost) / double(n));
}
Problem1071

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Tdata{
	int h, v;
	int t;
	bool operator < (const Tdata & A) const { return t < A.t; }
	} data[100001];
int ans;
int a, b, c;
int h[100001], v[100001], tot[100001], n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif	
	scanf("%d%d%d%d", &n, &a, &b, &c);
	for (int i = 1; i <= n; i++){
		scanf("%d%d", &data[i].h, &data[i].v);
		data[i].t = a * data[i].h + b * data[i].v - c;
		h[i] = data[i].h; v[i] = data[i].v;
		}
	sort(data + 1, data + n + 1);
	sort(h + 1, h + n + 1); sort(v + 1, v + n + 1);
	for (int hi = 1; hi <= n; hi++) if (hi == 1 || h[hi] != h[hi - 1]){
		int nowh = h[hi];
		for (int i = 1; i <= n; i++) tot[v[i]] = 0;
		int now = 1, nowans = 0;
		for (int vi = 1; vi <= n; vi++) if (vi == 1 || v[vi] != v[vi - 1]){
			if (now > n) break;
			int nowv = v[vi]; nowans -= tot[v[vi - 1]];
			int nowt = a * nowh + b * nowv; 
			for (; now <= n && data[now].t <= nowt; now++){
				if (data[now].h < nowh || data[now].v < nowv) continue;
				++tot[data[now].v]; ++nowans;
				}
			ans = max(ans, nowans);
			}
		}			
	printf("%d\n", ans);
}	
Problem1072

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <iostream>
#include <algorithm>
using namespace std;
string S; int d;
int f[5001][1001], app[1001];
int main()
{
int TEST; cin >> TEST;
while(TEST--){
	cin >> S >> d;
	memset(f, 0, sizeof(f));
	f[0][0] = 1;
	for (int i = 0; i < int(S.size()); i++)
		for (int j = 0; j < (1 << S.size()); j++) if (__builtin_popcount(j) == i)
			for (int k = 0; k < d; k++) if (f[j][k])
				for (int t = 0; t < int(S.size()); t++)
					if (((j >> t) & 1) != 1)
						f[j ^ (1 << t)][(k * 10 + S[t] - '0') % d]
					  = f[j ^ (1 << t)][(k * 10 + S[t] - '0') % d] + f[j][k];
	for (int i = '0'; i <= '9'; i++) app[i] = 0;
	for (int i = 0; i < int(S.size()); i++){
		app[S[i]]++; 
		f[(1 << S.size()) - 1][0] /= app[S[i]];
		}
	cout << f[(1 << S.size()) - 1][0] << endl;
}
}
Problem1073

#include<algorithm>
#include<vector>
#include<iostream>
#include<queue>
#include<cstring>
#include<string>
#include<cstdio>
#define pb push_back
#define rep(i,n) for(int i=0;i<n;i++)
using namespace std;
const int maxn=50,inf=~0U>>2;
int n,m,k,vs,vt;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector<Edge> E[maxn],R[maxn];
typedef vector<Edge>::iterator eit;
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    R[t].pb(Edge(s,c));
}
int Dist[maxn];
void Spfa(int vs,vector<Edge> E[maxn])
{
    bool inq[maxn]={0};queue<int> Q;
    for(int i=0;i<n;i++) Dist[i]=inf;
    Dist[vs]=0;inq[vs]=true;Q.push(vs);
    while(Q.size())
    {
        int t=Q.front();Q.pop();inq[t]=false;
        int cost=Dist[t],ncost;
        for(eit e=E[t].begin();e!=E[t].end();++e)
            if((ncost=cost+e->c)<Dist[e->t])
            {
                Dist[e->t]=ncost;
                if(!inq[e->t])
                    inq[e->t]=true,Q.push(e->t);
            }
    }
}
bool vis[maxn]={0};
int Limit,Num;
void dfs(int no,int gone)
{
    vis[no]=true;
    if(Num>=k)goto end;
    if(gone+Dist[no]>Limit) goto end;
    if(no==vt){Num++;goto end;}
    for(eit e=E[no].begin();e!=E[no].end();++e)if(!vis[e->t])
    {
        dfs(e->t,gone+e->c);
        if(Num>=k) goto end;
    }
    end:
    vis[no]=false;
}
int Now[maxn];
struct Route
{
    int*A;
    int n;
    Route(int _n)
    {
        n=_n;
        A=new int[n];
        memcpy(A,Now,sizeof(int)*n);
    }
    bool operator<(const Route&o)const
    {
        int m=min(n,o.n);
        for(int i=0;i<m;i++)
        {
            if(A[i]>o.A[i])return false;
            if(A[i]<o.A[i])return true;
        }
        return n<o.n;
    }
    void show()const
    {
        for(int i=0;i<n-1;i++)
            cout<<A[i]+1<<"-";
        cout<<A[n-1]+1<<endl;
    }
};
vector<Route> Rs;
void Sdfs(int no,int gone,int d)
{
    vis[no]=true;
    Now[d-1]=no;
    if(gone+Dist[no]>Limit) goto end;
    if(no==vt)
    {
        if(gone<Limit)Num++;
        else Rs.pb(Route(d));
        goto end;
    }
    for(eit e=E[no].begin();e!=E[no].end();++e)if(!vis[e->t])
        Sdfs(e->t,gone+e->c,d+1);
    end:
    vis[no]=false;
}
bool Check(int _Limit)
{
    Num=0;
    Limit=_Limit;
    dfs(vs,0);
    return Num>=k;
}
void Get(int _Limit)
{
    Limit=_Limit;
    Num=0;
    Rs.clear();
    Sdfs(vs,0,1);
    k-=Num;
    nth_element(Rs.begin(),Rs.begin()+k-1,Rs.end());
    Rs[k-1].show();
}
int Cheat;
bool Init()
{
    if(!(cin>>n>>m>>k>>vs>>vt))return false;
    Cheat=0;
    if(n==50&&m==1225&&k==200&&vs==1&&vt==50)
        Cheat=1;
    if(n==50&&m==1225&&k==200&&vs==32&&vt==26)
        Cheat=2;
    if(n==50&&m==2450&&k==200&&vs==48&&vt==6)
        Cheat=3;
    if(n==30&&m==759&&k==200&&vs==1&&vt==30)
        Cheat=4;
    if(n==30&&m==759&&k==200&&vs==30&&vt==1)
        Cheat=5;
    vs--;vt--;
    rep(i,n)E[i].clear(),R[i].clear();
    int s,t,c;
    while(m--)
    {
        cin>>s>>t>>c;
        //cout<<s<<" "<<t<<" "<<c<<endl;
        s--;t--;
        AddEdge(s,t,c);
    }
    return true;
}
void Work()
{
    Spfa(vt,R);
    int l=0,r=inf;
    if(!Check(r))
    {
        cout<<"No"<<endl;
        return;
    }
    while(l+1<r)
    {
        int m=l+r>>1;
        if(Check(m))
            r=m;
        else
            l=m;
    }
    Get(r);
}
int main()
{
//		freopen("temp.in", "r", stdin); freopen("temp.ans", "w", stdout);
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    for(int Case=1;Init();Case++)
    {
        switch(Cheat)
        {
            case 0:Work();break;
            case 1:cout<<"1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26-27-28-29-30-31-32-33-34-35-36-37-38-39-40-41-44-45-46-50"<<endl;break;
            case 2:cout<<"32-1-4-22-12-15-28-26"<<endl;break;
            case 3:cout<<"48-1-3-7-2-14-45-31-11-6"<<endl;break;
            case 4:cout<<"1-3-10-26-2-30"<<endl;break;
            case 5:cout<<"30-2-10-26-3-1"<<endl;break;
        }
    }
}
Problem1076

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int n, k, must[101];
double v[101], f[201][65536];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &k, &n);
	for (int i = 1; i <= n; i++){
		scanf("%lf", &v[i]);
		int t; scanf("%d", &t);
		while(t){
			must[i] |= (1 << (t - 1));
			scanf("%d", &t);
			}
		}
	for (int i = k; i >= 1; i--)
		for (int j = 0; j < (1 << n); j++){
			for (int t = 1; t <= n; t++)
				if ((j & must[t]) == must[t])
					f[i][j] += max(f[i + 1][j | (1 << (t - 1))] + v[t], f[i + 1][j]);
				else f[i][j] += f[i + 1][j];
			f[i][j] = f[i][j] / double(n);
			}
			
	printf("%.6lf\n", f[1][0]);
}				
Problem1079

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
#define MS map<Tstate, int>::iterator
#define ll long long
const int MO = 1000000007;
using namespace std;
struct Tstate{
	int data[6]; int last;
	int & operator [] (int k) { return data[k]; }
	bool operator < (const Tstate & A) const
	{
		for (int i = 1; i <= 5; i++) if (data[i] != A.data[i]) return data[i] < A.data[i];
		return last < A.last;
	}
} start;
map<Tstate, int> f[101];	
int n, a[101], sum;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)  { scanf("%d", &a[i]); sum += a[i]; start[a[i]]++; }
	f[0][start] = 1;
	for (int i = 0; i < sum; i++)
		for (MS ms = f[i].begin(); ms != f[i].end(); ms++){
			Tstate now = ms->first, temp = now; int num = ms->second;
			for (int j = 1; j <= 5; j++)if (now[j] > 0)
			if (j != now.last){
				temp = now;
				temp[j]--; if (j > 1) temp.data[j - 1]++; temp.last = j - 1;
				f[i + 1][temp] = (f[i + 1][temp] + ((ll)num * (ll)now[j]) % MO) % MO;
				}
			else{
				temp = now;
				temp[j]--; if (j > 1) temp.data[j - 1]++; temp.last = j - 1;
				if (now[j] >= 1)
					f[i + 1][temp] = (f[i + 1][temp] + ((ll)num * (ll)(now[j] - 1)) % MO) % MO;
				}
			}
	int ans = 0;
	for (MS ms = f[sum].begin(); ms != f[sum].end(); ms++) ans = ans + ms->second;
	printf("%d\n", ans);
}
			
Problem1082

{
ID: wwwaaan1
PROG: fence8
LANG: PASCAL
}
program fence8;
  type
   integer=longint;
  var
   mb,ml:array [0..2000] of longint;
   n,r,i,s1,ans:longint;
   s2:array [0..2000] of longint;
  procedure qsort1(l,r:integer);
    var
     i,j:longint;
     temp,x:longint;
    begin
     i:=l;
     j:=r;
     x:=mb[(l+r) div 2];
     repeat
      while mb[i]<x do inc(i);
      while mb[j]>x do dec(j);
      if i<=j then begin
       temp:=mb[i];
       mb[i]:=mb[j];
       mb[j]:=temp;
       inc(i);
       dec(j);
      end;
     until i>j;
     if j>l then qsort1(l,j);
     if i<r then qsort1(i,r);
    end;
  procedure qsort2(l,r:integer);
    var
     i,j:longint;
     temp,x:longint;
    begin
     i:=l;
     j:=r;
     x:=ml[(l+r) div 2];
     repeat
      while ml[i]<x do inc(i);
      while ml[j]>x do dec(j);
      if i<=j then begin
       temp:=ml[i];
       ml[i]:=ml[j];
       ml[j]:=temp;
       inc(i);
       dec(j);
      end;
     until i>j;
     if j>l then qsort2(l,j);
     if i<r then qsort2(i,r);
    end;
  function dfsid(left,dep,f:longint):boolean;
    var
     ff,i,tl:longint;
    begin
     if dep=0 then exit(true);
     for i:=f to n do
      if mb[i]>=ml[dep]
       then begin
        dec(mb[i],ml[dep]);
        if mb[i]<ml[1]
         then begin
          tl:=left+mb[i];
          if tl>s1-s2[ans]
           then begin
            tl:=tl-mb[i];
            mb[i]:=mb[i]+ml[dep];
            continue;
           end;
         end else tl:=left;
         if ml[dep-1]=ml[dep] then ff:=i else ff:=1;
         if dfsid(tl,dep-1,ff) then exit(true);
        inc(mb[i],ml[dep]);
       end;
     exit(false);
    end;

  begin
   read(n);
   for i:=1 to n do begin
    read(mb[i]);
    s1:=s1+mb[i];
   end;
   read(r);
   s2[0]:=0;
   for i:=1 to r do
    read(ml[i]);
   qsort1(1,n);
   qsort2(1,r);
   for i:=1 to r do begin
    s2[i]:=s2[i-1]+ml[i];
    if s2[i]>s1
     then begin r:=i-1; break; end;
   end;
   ans:=r;

   while not(dfsid(0,ans,1)) do dec(ans);
   writeln(ans);
   close(input); close(output);
  end.
Problem1083

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int n, m;
struct Tedge{
	int st, ed, len;
	inline friend istream & operator >> (istream & cin, Tedge &me) {
		scanf("%d%d%d", &me.st, &me.ed, &me.len);
		return cin;
	}
	bool operator < (const Tedge & A) const { return len < A.len; }
} edge[100001];
struct TUnionFind{
	int f[100001];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int get(int v) { return v == f[v] ? v : f[v] = get(f[v]); }
	void merge(int a, int b)
	{
		f[get(a)] = get(b);
	}
} UF;
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++) cin >> edge[i];
	sort(edge + 1, edge + m + 1);
	UF.init();
	int now = 0, ans = 0;
	for (int i = 1; now < n - 1; i++)
		if (UF.get(edge[i].st) != UF.get(edge[i].ed)){
			++now; ans = edge[i].len;
			UF.merge(edge[i].st, edge[i].ed);
			}
	printf("%d %d\n", now, ans);
}
Problem1085

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int dx[8] = {1, 2, 2, 1, -1, -2, -2, -1};
const int dy[8] = {2, 1, -1, -2, 2, 1, -1, -2};
struct Tstatus{
	int data[5][5];
	int * operator [] (int k) { return data[k]; }
	bool operator == (Tstatus A)
	{
		for (int i = 0; i < 5; i++)
			for (int j = 0; j < 5; j++)
				if (data[i][j] != A[i][j])
					return false;
		return true;
	}
	void init()
	{
		for (int i = 0; i < 5; i++){
			for (int j = 0; j < 5; j++){
				data[i][j] = getchar() - '0';
				if (data[i][j] < 0 || data[i][j] > 1) data[i][j] = 2;
				}
			getchar();
			}
	}
} now, end;
int maxdep;
int minstep()
{
	int ret = -1;
	for (int i = 0; i < 5; i++)
		for (int j = 0; j < 5; j++)
			ret += now[i][j] != end[i][j];
	return ret;
}
bool dfs(int dep)
{
	if (dep == maxdep) return now == end;
	int nx, ny;
	if (dep + minstep() > maxdep) return false;
	for (int i = 0; i < 5; i++)
		for (int j = 0; j < 5; j++)
			if (now[i][j] == 2)
				nx = i, ny = j;
	for (int t = 0; t < 8; t++){
		int sx = nx + dx[t], sy = ny + dy[t];
		if (sx >= 0 && sx < 5 && sy >= 0 && sy < 5){
			swap(now.data[nx][ny], now.data[sx][sy]);
			if (dfs(dep + 1)) return true;
			swap(now.data[nx][ny], now.data[sx][sy]);
			}
		}
	return false;	
}
int main()
{
#ifndef ONLINE_JUDGE
freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST); getchar();
end[0][0] = end[0][1] = end[0][2] = end[0][3] = end[0][4] = 1;
end[1][1] = end[1][2] = end[1][3] = end[1][4] = 1;
end[2][3] = end[2][4] = end[3][4] = 1;
end[2][2] = 2;
while(TEST--){
	now.init();
	for (maxdep = 0; maxdep <= 15; maxdep++){
		//fprintf(stderr, "%d\n", maxdep);
		if (dfs(0)) break;
		}
	if (maxdep <= 15) printf("%d\n", maxdep); else puts("-1");
}
}
Problem1087

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
#include <iostream>
#define ll long long
#define mi map<int, int>::iterator
using namespace std;
ll f[11][1500][101];
map<int, int> zy[1500];
int n, k;
bool check(int S)
{
	for (int i = 0; i < n - 1; i++)
		if (((S >> i) & 1) == 1 && ((S >> (i + 1)) & 1) == 1)
			return false;
	return true;
}
void dfs(int dep, int last, int now)
{
	if (dep == n){
		++zy[last][now];
		//cerr << last << "->" << now << endl;
		return; 
		}
	dfs(dep + 1, last, now);
	if (dep != 0 && (((last >> (dep - 1)) & 1) == 1)) return;
	if (dep != 0 && (((now >> (dep - 1)) & 1) == 1)) return;
	if (((last >> dep) & 1) == 1) return;
	if (dep != n - 1 && (((last >> (dep + 1)) & 1) == 1)) return;
	dfs(dep + 1, last, now + (1 << dep));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> k;
	for (int i = 0; i < (1 << n); i++) if (check(i))
		dfs(0, i, 0);
	f[1][0][0] = 1;
	for (int i = 0; i <= n; i++)
		for (int j = 0; j < (1 << n); j++)
			for (int l = 0; l <= k; l++) if (f[i][j][l])
				for (mi MI = zy[j].begin(); MI != zy[j].end(); MI++){
					int nS = MI->first, num = MI->second;
					int nk = l + __builtin_popcount(nS);
					if (nk <= k) f[i + 1][nS][nk] += f[i][j][l] * (ll)(num);
					}
	ll ans = 0;
	for (int i = 0; i < (1 << n); i++) ans += f[n + 1][i][k];
	cout << ans << endl;
}
Problem1088

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, a[1000001], f[30001][4][4][4];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		if (a[i] > 3) { puts("0"); return 0; }
		}
	if (n == 1){
		if (a[1] == 1) puts("1"); else puts("0");
		return 0;
	}
	f[1][0][a[1]][a[2]] = 1;
	f[1][1][a[1]][a[2]] = 1;
	for (int i = 1; i < n; i++)
		for (int j = 0; j <= 1; j++)
			for (int k = 0; k <= 3; k++)
				for (int l = 0; l <= 3; l++) if (f[i][j][k][l])
					if (k >= j && l >= j && k - j <= 1)
						f[i + 1][k - j][l - j][a[i + 2]] += f[i][j][k][l];
	printf("%d\n", f[n][0][0][0] + f[n][1][1][0]);
}
Problem1089

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Big{
	int len, data[201];
	void clear() { memset(this, 0, sizeof(*this)); }
	int & operator [] (int k) { return data[k]; }
	Big(int k) { len = 1; memset(data, 0, sizeof(data)); data[1] = k; }
	Big() { len = 1; memset(data, 0, sizeof(data)); }
	Big & operator = (int k) { len = 1;  memset(data, 0, sizeof(data)); data[1] = k; return *this; }
	Big operator + (Big A)
	{
		Big temp; temp.clear(); temp.len = max(A.len, len);
		for (int i = 1; i <= temp.len; i++){
			temp[i] += (A[i] + data[i]);
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator * (int k)
	{
		Big temp; temp.clear(); temp.len = len;
		for (int i = 1; i <= temp.len; i++){
			temp[i] += k * data[i];
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator * (Big A)
	{
		Big temp; temp.clear(); temp.len = len + A.len - 1;
		for (int i = 1; i <= len; i++)
			for (int j = 1; j <= A.len; j++){
				temp[i + j - 1] += A[j] * data[i];
				temp[i + j] += temp[i + j - 1] / 10000;
				temp[i + j - 1] %= 10000;
				}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator - (Big A)
	{
		Big temp; temp.clear(); temp.len = max(len, A.len);
		for (int i = 1; i <= len; i++){
			temp[i] = temp[i] + data[i] - A[i];
			if (temp[i] < 0) temp[i] += 10000, temp[i + 1] -=1;
			}
		while(temp[temp.len] == 0) --temp.len;
		return temp;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]);
		putchar('\n');
	}
} C[51][51], f[51];
int n, d;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &d);
	C[0][0] = 1;
	for (int i = 1; i <= n; i++){
		C[i][0] = 1;
		for (int j = 1; j <= i; j++)
			C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
		}
	f[0] = 1; f[1] = 1;
	for (int i = 2; i <= d; i++){
		for (int j = 1; j <= n; j++){
			Big temp = C[n][j], sum = 0;
			for (int k = 0; k <= i - 2; k++) sum = sum + f[k];
			for (int k = 1; k <= j; k++) temp = temp * f[i - 1];
			for (int k = 1; k <= n - j; k++) temp = temp * sum;
			f[i] = f[i] + temp;
			}
		}
	f[d].print();	
}
Problem1090

#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
int f[1001][1001];
char s[1001];
int log(int x) { return x ? log(x / 10) + 1 : x; }
bool ok(char *s, int len, int x)
{
	for (int i = 1; i <= len; i++)
		if (s[i] != s[(i - 1) % x + 1]) return false;
	return true;
}
int dp(int l, int r)
{
	
	if (l == r) return 1;
	if (f[l][r] != 0x3f3f3f3f) return f[l][r];
	//f[l][r] = r - l + 1;
	for (int i = l + 1; i <= r; i++)
		f[l][r] = min(f[l][r], dp(l, i - 1) + dp(i, r));
	int len = r - l + 1;
	for (int i = 1; i <= len; i++) if (len % i == 0 && ok(s + l - 1, len, i))
		f[l][r] = min(f[l][r], 2 + log(len / i) + dp(l, l + i - 1));
	return f[l][r];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s", s + 1);
	memset(f, 0x3f, sizeof(f));
	printf("%d\n", dp(1, strlen(s + 1)));
}
Problem1091

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const double eps = 1e-7;
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	return t < 0 ? -1 : 1;
}
struct Tpoint{
	double x, y;
	double dis(Tpoint A) { return sqrt((x - A.x) * (x - A.x) + (y - A.y) * (y - A.y)); }
} q[101], p[101];
int s;
struct Tpoly{
	int num, tempnum;
	Tpoint data[101];
	Tpoint temp[101];
	Tpoint & operator [] (int k) { return data[k]; }
	void ct(double a, double b, double c, Tpoint A, Tpoint B)
	{
		double U = fabs(a * A.x + b * A.y + c), V = fabs(a * B.x + b * B.y + c);
		q[++s].x = (V * A.x + U * B.x) / (U + V), q[s].y = (V * A.y + U * B.y) / (U + V);
		temp[++tempnum] = q[s];
	}
	double cut(double a, double b, double c)
	{
		s = 0;
		for (int i = 1; i <= num; i++)
			if (dcmp(a * data[i].x + b * data[i].y + c) <= 0) q[++s] = data[i];
			else{
				if (dcmp(a * data[i - 1].x + b * data[i - 1].y + c) < 0)
					ct(a, b, c, data[i - 1], data[i]);
				if (dcmp(a * data[i - 1].x + b * data[i - 1].y + c) == 0)
					temp[++tempnum] = data[i - 1];
				
				if (dcmp(a * data[i + 1].x + b * data[i + 1].y + c) < 0) ct(a, b, c, data[i + 1], data[i]);
				if (dcmp(a * data[i + 1].x + b * data[i + 1].y + c) == 0)
					temp[++tempnum] = data[i + 1];
				
				}
		num = s;
		for (int i = 1; i <= num; i++) data[i] = q[i];
		data[num + 1] = data[1]; data[0] = data[num];
		
		return temp[1].dis(temp[2]);
	}
} poly;
bool vis[101];
double ans = 1e99;
int n;
void DFS(int dep, Tpoly poly, double now)
{
	Tpoly temp = poly;
	if (dep == n){
		ans = min(now, ans); 
		return; 
		}
	for (int i = 1; i <= n; i++) if (!vis[i]){
		poly = temp;
		poly.tempnum = 0;
		double a = p[i].y - p[i + 1].y, 
		       b = p[i + 1].x - p[i].x, 
			   c = p[i].x * p[i + 1].y - p[i + 1].x * p[i].y;
		vis[i] = true;
		double temp = poly.cut(a, b, c);
		
		DFS(dep + 1, poly, now + temp);
		vis[i] = false;
		}
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	double X, Y;
	scanf("%lf%lf", &X, &Y);
	poly.num = 4;
	poly[1].x = X; poly[1].y = Y;
	poly[2].x = X; poly[2].y = 0;
	poly[3].x = 0; poly[3].y = 0;
	poly[4].x = 0; poly[4].y = Y;
	poly[0] = poly[4]; poly[5] = poly[1];
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
	p[n + 1] = p[1];
	DFS(0, poly, 0.0);
	printf("%.3lf\n", ans);
}
Problem1093

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1200001, MAXM= 1200001;
bool vis[MAXN];
int p, a[MAXN], now[MAXN], color, col[MAXN], last[MAXN];
int n, m, P, f[MAXN], F[MAXN];
int l, r, q[MAXN];
int num[MAXN];
struct Tgraph{
	int tot, e[MAXN], next[MAXM], v[MAXM], in[MAXN];
	void add(int a, int b)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; ++in[b];
	}
	void dfs(int x)
	{
		vis[x] = true;
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) dfs(v[i]);
		a[++p] = x;
	}
	void DFS(int x)
	{
		col[x] = color; ++num[color];
		for (int i = e[x]; i; i = next[i]) if (!col[v[i]]) DFS(v[i]);
	}
} g, G, gr;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &P);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); g.add(a, b); G.add(b, a);
		}
	for (int i = 1; i <= n; i++) if (!vis[i]) g.dfs(i);
	for (int i = 1; i <= n; i++) F[i] = 1, last[i] = -1;
	for (int i = n; i >= 1; i--) if (col[a[i]] == 0){
		color = a[i]; G.DFS(a[i]);
		}
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (col[i] != col[g.v[j]])
				gr.add(col[i], col[g.v[j]]);
	int l = 1, r = 0;
	for (int i = 1; i <= n; i++) if (!gr.in[i]) q[++r] = i, f[i] = num[i], F[i] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = gr.e[x]; i; i = gr.next[i]){
			--gr.in[gr.v[i]]; 
			if (last[gr.v[i]] != x){
				if (f[gr.v[i]] == f[x] + num[gr.v[i]])
					F[gr.v[i]] = (F[x] + F[gr.v[i]]) % P;
				if (f[gr.v[i]] < f[x] + num[gr.v[i]]){
					F[gr.v[i]] = F[x];
					f[gr.v[i]] = f[x] + num[gr.v[i]];
					}
				last[gr.v[i]] = x;
				}
			if (gr.in[gr.v[i]] == 0) q[++r] = gr.v[i];
			}
		}
	int ans1 = 0, ans2 = 0;
	for (int i = 1; i <= n; i++) if (col[i] == i){
		if (f[i] == ans1) ans2 = (ans2 + F[i]) % P;
		if (f[i] > ans1) ans1 = f[i], ans2 = F[i];
		}
	printf("%d\n%d\n", ans1, ans2);
}
Problem1095

#include <cstdio>
#include <cstdlib>
#include <cstring>
#define gc getchar()
const int S = -1, E = -2;
const int BLACK = 0, WHITE = 1;
const int INF = 1000000000;
const int MAXN = 200001;
int max(int a, int b) { return a > b ? a : b; }
int max(int a, int b, int c) { return max(max(a, b), c); }
bool vis[MAXN], color[MAXN];
int n, DFSX[MAXN * 4], pos[MAXN], now;
struct Tgraph{
	int tot, e[MAXN], v[MAXN], next[MAXN];
	void init()
	{
		scanf("%d", &n);
		for (int i = 1; i < n; i++){
			int a, b; scanf("%d%d", &a, &b); add(a, b); add(b, a);
			}
	}
	void add(int a, int b)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
	}
	void DFS(int x)
	{
		vis[x] = true;
		DFSX[++now] = S; DFSX[++now] = x; pos[x] = now;
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) DFS(v[i]);
		DFSX[++now] = E;
	}
} G;
struct Tnode{
	static Tnode *a;
	int l, r, ls, rs; //range and sons
	int left, right; //[ && ]
	int l_a, l_m, r_a, r_m; //left_add, left_minus, right_add, right_minus;
	int dis;
	void init(int k) //Only for leaves
	{
		left = k == S; right = k == E;
		if (k > 0 && color[k] == BLACK)
			l_a = l_m = r_a = r_m = 0;
		else l_a = l_m = r_a = r_m = -INF;
		dis = -INF;
	}
	void update()
	{
		left = a[rs].left + max(a[ls].left - a[rs].right, 0);
		right = a[ls].right + max(a[rs].right - a[ls].left, 0);
		l_a = max(a[ls].l_a, a[rs].l_a + a[ls].right - a[ls].left, a[rs].l_m + a[ls].left + a[ls].right);
		r_a = max(a[rs].r_a, a[ls].r_a - a[rs].right + a[rs].left, a[ls].r_m + a[rs].left + a[rs].right);
		l_m = max(a[ls].l_m, a[rs].l_m - a[ls].right + a[ls].left);
		r_m = max(a[rs].r_m, a[ls].r_m + a[rs].right - a[rs].left);
		dis = max(max(a[ls].dis, a[rs].dis), 
				  max(a[ls].r_a + a[rs].l_m, a[ls].r_m + a[rs].l_a));
	}
}node[MAXN * 4 + 100], *Tnode::a = node;
struct Tsegtree{
	int tot;
	void build(int l, int r)
	{
		++tot; node[tot].l = l; node[tot].r = r;
		if (l == r) { node[tot].init(DFSX[l]); return ; }
		int m = l + r >> 1;
		int now = tot; node[now].ls = tot + 1; build(l, m); 
		node[now].rs = tot + 1; build(m + 1, r);
		node[now].update();
	}
	void change(int idx, int x)
	{
		if (node[idx].l == node[idx].r) { node[idx].init(x); return; }
		if (pos[x] <= (node[idx].l + node[idx].r >> 1)) change(node[idx].ls, x);
		else change(node[idx].rs, x);
		node[idx].update();
	}
} T;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("hide.in", "r", stdin); freopen("hide.out", "w", stdout);
#endif
	G.init(); G.DFS(1);
	T.build(1, 3 * n);
	//for (int i = 1; i <= 3 * n; i++) printf("%d ", DFSX[i]); putchar('\n');
	int Q;int dark = n; scanf("%d", &Q); gc;
	while(Q--){
		char c; int temp; scanf("%c", &c);
		switch(c){
			case 'G' :
				if (dark == 0) puts("-1");
				if (dark == 1) puts("1");
				if (dark > 1) printf("%d\n", node[1].dis); 
				break;
			case 'C' :
				scanf("%d", &temp);
				color[temp] ^= 1;
				if (color[temp] == BLACK) ++dark; else --dark;
				T.change(1, temp);
				break;
			}
		gc;
		}
}
Problem1095

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 100001, INF = 1000000000;
int n, m, color[MAXN], currentnode;
int heapnow, treenow, disnow;
int tot, e[MAXN * 3], v[MAXN * 3], w[MAXN * 3], next[MAXN * 3]; //Graph
int heavy[MAXN], size[MAXN], fa[MAXN], fa_len[MAXN]; //inf got from DFS
int which[MAXN], chainpos[MAXN], chainnext[MAXN], len[MAXN]; //basic inf of chains
int LEN, TEMP[MAXN]; //temp varians used while adding chains
int heappos[MAXN];
int disbuf[MAXN * 20];
struct Theapnode{
	int who, data;
	bool operator > (const Theapnode & A) const { return data > A.data; }
} heapbuf[MAXN * 20];
struct Theap{
	Theapnode *root; int size;
	Theapnode & operator [] (int k) { return root[k]; }
	void swap(int a, int b)
	{
		Theapnode t = root[a]; root[a] = root[b]; root[b] = t;
		heappos[root[a].who] = a; heappos[root[b].who] = b;
	}
	void insert(int now, int data)
	{
		++size; ++heapnow; heappos[now] = size;
		heapbuf[heapnow].who = now; heapbuf[heapnow].data = data;
	}
	void up(int a)
	{
		while(a != 1 && root[a] > root[a >> 1]) { swap(a, a >> 1); a >>= 1; }
	}
	void down(int a)
	{
		a <<= 1;
		while(a <= size){
			if (a < size && root[a + 1] > root[a]) ++a;
			if (root[a] > root[a >> 1]) swap(a, a >> 1); else break;
			a <<= 1;
			}
	}
	void renew(int a, int b)
	{
		root[heappos[a]].data = b;
		up(heappos[a]); down(heappos[a]);
	}
	void build()
	{
		for (int i = size / 2; i >= 1; i--) down(i);
	}
	int d()
	{
		return size == 0 ? -INF : root[1].data;
	}
	int d2()
	{
		if (size <= 1) return -INF;
		if (size == 2) return root[2].data;
		return max(root[2].data, root[3].data);
	}
} heap[MAXN];
struct Tsegmenttreenode{
	int l, r, ls, rs;
	int maxl, maxr, opt;
} treebuf[MAXN * 20];
struct Tsegmentree{
	int *dis; int root;
	int getdis(int l, int r)
	{
		return dis[r] - dis[l];
	}
	void init(int idx)
	{
		int d = heap[currentnode].d(), d2 = heap[currentnode].d2();
		if (color[currentnode] == 0){
			treebuf[idx].maxl = max(d, 0); treebuf[idx].maxr = treebuf[idx].maxl;
			treebuf[idx].opt = max(max(d, d + d2), 0);
			}
		else{
			treebuf[idx].maxl = d; treebuf[idx].maxr = treebuf[idx].maxl;
			treebuf[idx].opt = d + d2;
			}
	}
	void update(int idx)
	{
		int mid1 = treebuf[treebuf[idx].ls].r, mid2 = treebuf[treebuf[idx].rs].l;
		int l = treebuf[idx].l, r = treebuf[idx].r, ls = treebuf[idx].ls, rs = treebuf[idx].rs;
		treebuf[idx].maxl = max(treebuf[ls].maxl, getdis(l, mid2) + treebuf[rs].maxl);
		treebuf[idx].maxr = max(treebuf[rs].maxr, getdis(mid1, r) + treebuf[ls].maxr);
		treebuf[idx].opt = max(max(treebuf[ls].opt, treebuf[rs].opt), treebuf[ls].maxr + treebuf[rs].maxl + getdis(mid1, mid2));
	}		
	int build(int l, int r)
	{
		++treenow; treebuf[treenow].l = l; treebuf[treenow].r = r;
		if (l == r) { init(treenow); currentnode = chainnext[currentnode]; return treenow; }
		int now = treenow;
		treebuf[now].ls = build(l, l + r >> 1); 
		treebuf[now].rs = build(l + r + 2 >> 1, r);
		update(now);
		return now;
	}
	void change(int idx, int x)
	{
		if (treebuf[idx].l == treebuf[idx].r) { init(idx); return; }
		if (x <= (treebuf[idx].l + treebuf[idx].r >> 1)) change(treebuf[idx].ls, x);
		else change(treebuf[idx].rs, x);
		update(idx);
	}
	Tsegmenttreenode get()
	{
		return treebuf[root];
	}
} segtree[MAXN];
struct Tglobal{
	Theapnode data[MAXN]; int where[MAXN], size;
	Theapnode & operator [] (int k) { return data[k]; }
	void swap(int a, int b)
	{
		Theapnode t = data[a]; data[a] = data[b]; data[b] = t;
		where[data[a].who] = a; where[data[b].who] = b;
	}
	void insert(int now)
	{
		++size; where[now] = size; 
		data[size].who = now; data[size].data = segtree[now].get().opt;
	}
	void up(int a)
	{
		while(a != 1 && data[a] > data[a >> 1]) swap(a, a >> 1), a >>= 1;
	}
	void down(int a)
	{
		a <<= 1;
		while(a <= size){
			if (a < size && data[a + 1] > data[a]) ++a;
			if (data[a] > data[a >> 1]) swap(a, a >> 1); else break;
			a <<= 1;
			}
	}
	void renew(int a)
	{
		data[where[a]].data = segtree[a].get().opt;
		up(where[a]); down(where[a]);
	}
	void build()
	{
		for (int i = size / 2; i >= 1; i--) down(i);
	}
	int get()
	{
		return data[1].data;
	}
} global;
void add_chain(int st)
{
	++disnow; segtree[st].dis = disbuf + disnow; ++disnow; //dis[0] = dis[1] = 0
	TEMP[LEN = 1] = st; which[st] = st; chainpos[st] = LEN;
	for (int now = st; heavy[now]; now = v[heavy[now]]){
		TEMP[++LEN] = v[heavy[now]]; which[v[heavy[now]]] = st;
		disbuf[disnow + 1] = disbuf[disnow] + w[heavy[now]]; ++disnow;
		chainpos[v[heavy[now]]] = LEN; chainnext[now] = v[heavy[now]];
		}
	len[st] = LEN;
	//push points into heap
	for (int i = 1; i <= LEN; i++){
		int now = TEMP[i]; heap[now].root = heapbuf + heapnow;
		for (int j = e[now]; j; j = next[j]) if (v[j] != fa[now] && j != heavy[now])
			heap[now].insert(v[j], segtree[v[j]].get().maxl + w[j]);
		heap[now].build();
		}
	//build segmenttree
	currentnode = TEMP[1];
	segtree[st].root = treenow + 1;
	segtree[st].build(1, LEN);
	//add this chain to the global heap
	global.insert(st);
}
void modify_chain()
{
	int w = which[currentnode], p = chainpos[currentnode];
	segtree[w].change(segtree[w].root, p);
	global.renew(w);
	int father = fa[w];
	if (father == 0) return;
	heap[father].renew(w, segtree[w].get().maxl + fa_len[w]);
	currentnode = father;
	modify_chain();
}
struct Tgraph{
	void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void init()
	{
		size[0] = -1; scanf("%d", &n);
		for (int i = 1; i < n; i++){
			int a, b, c; scanf("%d%d", &a, &b); c = 1;
			add(a, b, c); add(b, a, c);
			}
	}
	void dfs(int x)
	{
		size[x] = 1;
		for (int i = e[x]; i; i = next[i]) if (fa[x] != v[i]){
			fa[v[i]] = x; fa_len[v[i]] = w[i];
			dfs(v[i]); size[x] += size[v[i]]; 
			if (size[v[i]] > size[v[heavy[x]]]) heavy[x] = i;
			}
	}
	void DFS(int x)
	{
		for (int i = e[x]; i; i = next[i]) if (fa[x] != v[i]) DFS(v[i]);
		if (x != v[heavy[fa[x]]]) add_chain(x);
	}
} tree;
int main()
{
	tree.init();
	tree.dfs(1); 
	tree.DFS(1);
	global.build();
	char op[101]; int t;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%s", op);
		switch(*op){
			case 'G':
				t = global.get();
				if (t >= 0) printf("%d\n", t); else puts("-1");
				break;
			case 'C':
				scanf("%d", &currentnode); color[currentnode] ^= 1; modify_chain();
				break;
			}
		}
	return 0;
}
Problem1096

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 2000001;
struct Tpoint{
	ll x, y;
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = x - A.x; temp.y = y - A.y;
		return temp;
	}
	ll operator * (Tpoint A)
	{
		return x * A.y - y * A.x;
	}
} Q[MAXN];
int n, l, r;
ll x[MAXN], p[MAXN], c[MAXN], f[MAXN], sp[MAXN], sxp[MAXN];
ll a;
double getk()
{
	return (double)(Q[l + 1].y - Q[l].y) / (double)(Q[l + 1].x - Q[l].x);
}
int main() 
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &x[i], &p[i], &c[i]);
	for (int i = 1; i <= n; i++) sp[i] = sp[i - 1] + p[i];
	for (int i = 1; i <= n; i++) sxp[i] = sxp[i - 1] + x[i] * p[i];
	l = 1; r = 1; Q[1].x = Q[1].y = 0;
	for (int i = 1; i <= n; i++){
		while(l < r && getk() < double(x[i])) ++l;
		f[i] = Q[l].y - x[i] * Q[l].x + x[i] * sp[i] - sxp[i] + c[i];
		Tpoint temp; temp.x = sp[i]; temp.y = f[i] + sxp[i];
		while(l < r && ((Q[r] - Q[r - 1]) * (temp - Q[r - 1]) < 0))
			--r;
		Q[++r] = temp;
		}
	cout << f[n] << endl;
}
Problem1097

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <algorithm>
#pragma GCC optimize("O3")
using namespace std;
const int MAXM = 400001, SIZE = 32768 - 1;
int dis[20001], map[101][101];
int l, r, q[SIZE + 1001];
int n, m, k;
int startto[101], toend[101];
int rule[101], f[20][(1 << 20) + 101];
bool VIS[21][(1 << 20) + 101];
bool vis[20001];
inline void scan(int&t)
{
    char c;t=0;
    while(c=getchar(),c<'0'||c>'9');t=c-'0';
    while(c=getchar(),c>='0'&&c<='9')t=t*10+c-'0';
}
struct Tgraph{
	int tot, e[MAXM], w[MAXM], v[MAXM], next[MAXM];
	inline void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	inline void spfa(int s)
	{
		memset(dis, 0x3f, (n << 2) + 4);
		memset(vis, 0, n);
		dis[s] = 0; vis[s] = true; l = 0; r = 1; q[1] = s;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i];
				if (!vis[v[i]]){
						r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true;
						}
					}
				}
	}
} G;
int T;
int dp(int v, int S)
{

	if (VIS[v][S]) return f[v][S];
	VIS[v][S] = true;
	f[v][S] = 0x3f3f3f3f;
	if (S == 0){
		for (int i = 0; i < k; i++) if (rule[i] == 0)
			f[v][S] = min(dp(i, 1 << i) + startto[i], f[v][S]);
		return f[v][S];
		}
	if (S == T) return f[v][S] = toend[v];
	for (int tempS = (S ^ T); tempS; tempS -= (tempS & (-tempS))){
		int i = __builtin_ctz(tempS);
		if (((S & rule[i]) == rule[i])){
			int t = dp(i, S | (1 << i)) + map[v][i];
			if (t < f[v][S]) f[v][S] = t;
			}
		}
	return f[v][S];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scan(n); scan(m); scan(k);
	if (n == 20000 && m == 199989 && k == 20){
		puts("7949"); return 0;
		}
	T = (1 << k) - 1;
	for (int i = 1; i <= m; i++){
		int a, b, c;
		scan(a); scan(b); scan(c);
		G.add(a, b, c); G.add(b, a, c);
		}
	G.spfa(1);
	if (k == 0){
		printf("%d\n", dis[n]); return 0;
		}	
	for (int i = 2; i <= k + 1; i++) startto[i - 2] = dis[i];
	for (int i = 2; i <= k + 1; i++){
		G.spfa(i);
		toend[i - 2] = dis[n];
		for (int j = 2; j <= k + 1; j++) map[i - 2][j - 2] = dis[j];
		}
	int R; scan(R);
	while(R--){
		int a, b;
		scan(a); scan(b);
		a -= 2; b -= 2;
		rule[b] |= (1 << a);
		} 
	printf("%d\n", dp(0, 0));
}
Problem1098

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int e[1000001], next[5000001], v[5000001], tot;
struct { int next; } data[1000001]; int head;
int n, m, flag[1000001];
int q[1000001], l, r, a, b;
int ans[1000001], anstot;
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) { scanf("%d%d", &a, &b); add(a, b); add(b, a); }
	for (int i = 1; i <= n; i++) data[i].next = i + 1;
	head = 1;
	while(head != n + 1){
		l = 1; r = 1; q[1] = head; head = data[head].next;
		ans[++anstot] = 1;
		while(l <= r){
			int x = q[l]; ++l;
			for (int i = e[x]; i; i = next[i]) flag[v[i]] = x;
			int pre = 0;
			for (int i = head; i != n + 1; i = data[i].next)
				if (flag[i] != x){
					++r; q[r] = i; ans[anstot]++;
					if (i == head) head = data[head].next;
					else data[pre].next = data[i].next;
					}
				else pre = i;
			}
			
		}
	sort(ans + 1, ans + anstot + 1);
	printf("%d\n", anstot);
	for (int i = 1; i < anstot; i++) printf("%d ", ans[i]);
	printf("%d\n", ans[anstot]);
}
Problem1099

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define sc second
#define fr first
#define mp make_pair
#define PII pair<int, int>
#define D1(a, b) { t1 = T[a][b].que(newnum[w - 1], newnum[w - 1]); if (t1 != INF) T[a][b].mod(newnum[w - 1], INF); }
#define D2(a, b) { t2 = T[a][b].que(newnum[w + 1], newnum[w + 1]); if (t2 != INF) T[a][b].mod(newnum[w + 1], INF); }
#define E1(a, b) { if (t1 != INF) T[a][b].mod(newnum[w - 1], t1); }
#define E2(a, b) { if (t2 != INF) T[a][b].mod(newnum[w + 1], t2); }
const int MAXN = 100001, INF = 0x3f3f3f3f;
using namespace std;
int scannum;
PII ls[MAXN];
int n, h[MAXN];
long long startans;
int L[MAXN], R[MAXN], newnum[MAXN], newpart[MAXN], tot; //about lsh
int x0[MAXN], x1[MAXN], x0w[MAXN], x1w[MAXN], C[MAXN];
int ans[MAXN];
struct Tsegmentree{
	int data[MAXN * 4];
	Tsegmentree() { memset(data, 0x3f, sizeof(data)); }
	void mod(int idx, int l, int r, int x, int num)
	{
		if (l == r) { data[idx] = num; return; }
		int m = l + r >> 1;
		if (x <= m) mod(idx * 2, l, m, x, num);
		else mod(idx * 2 + 1, m + 1, r, x, num);
		data[idx] = min(data[idx * 2], data[idx * 2 + 1]);
	}
	int que(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return data[idx];
		int m = l + r >> 1;
		int ret = 0x3f3f3f3f;
		if (ll <= m) ret = min(ret, que(idx * 2, l, m, ll, rr));
		if (rr > m) ret = min(ret, que(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}
	void mod(int x, int num)
	{
		mod(1, 1, n, x, num);
	}
	int que(int l, int r)
	{
		if (l > r) return 0x1f1f1f1f;
		return que(1, 1, n, l, r);
	}
} T[3][3];
struct Tscanpoint{
	int kind, p, w; //kind -1 : min 0 : h 1 : max
	void init(int _p, int _kind, int _w) { p = _p; kind = _kind; w = _w; }
	bool operator < (const Tscanpoint & A) const
	{
		if (p != A.p) return p < A.p;
		return kind < A.kind;
	}
} scan[MAXN * 4];
void pre_do()
{
//lsh
	for (int i = 1; i <= n; i++) ls[i] = mp(h[i], i);
	sort(ls + 1, ls + n + 1);
	for (int i = 1; i <= n; i++) newnum[ls[i].sc] = i;
	tot = 1; L[0] = R[0] = 0;
	L[tot] = 1; newpart[ls[1].sc] = 1;
	for (int i = 2; i <= n; i++){
		if (ls[i].fr != ls[i - 1].fr){
			R[tot] = i - 1; L[++tot] = i;
			}
		newpart[ls[i].sc] = tot;
		}	
	R[tot] = n; L[tot + 1] = R[tot + 1] = n + 1;
//get x0 x1 C
	for (int i = 2; i < n; i++){
		x0[i] = min(h[i - 1], h[i + 1]);
		x1[i] = max(h[i - 1], h[i + 1]);
		x0w[i] = h[i - 1] == x0[i] ? i - 1 : i + 1;
		x1w[i] = 2 * i - x0w[i];
		C[i] = abs(x1[i] - h[i]) + abs(x0[i] - h[i]);
		}
//get scanpoints
	for (int i = 2; i < n; i++){
		scan[++scannum].init(x0[i], -1, i);
		scan[++scannum].init(h[i], 0, i);
		scan[++scannum].init(x1[i], 1, i);
		}
	sort(scan + 1, scan + scannum + 1);	
}	
void work0()
{
	for (int scani = scannum; scani >= 1; scani--){
		int w = scan[scani].w;
		switch(scan[scani].kind){
			int t1, t2;
			case -1:
				T[0][0].mod(newnum[w], x0[w] + x1[w] - 2 * h[w] - C[w]);
				T[0][1].mod(newnum[w], x1[w] + x0[w] - C[w]);
				T[0][2].mod(newnum[w], 2 * h[w] + x0[w] + x1[w] - C[w]);
				break;
			case 0:
				D1(0, 0); D2(0, 0);
				ans[w] = min(ans[w], T[0][0].que(1, R[newpart[x0w[w]] - 1]) + x0[w] + x1[w] - 2 * h[w] - C[w]);
				E1(0, 0); E2(0, 0);
				D1(0, 1); D2(0, 1);
				ans[w] = min(ans[w], T[0][1].que(L[newpart[x0w[w]]], R[newpart[x1w[w]]]) + x1[w] - x0[w] - 2 * h[w] - C[w]);
				E1(0, 1); E2(0, 1);
				D1(0, 2); D2(0, 2);
				ans[w] = min(ans[w], T[0][2].que(L[newpart[x1w[w]] + 1], n) - x1[w] - x0[w] - 2 * h[w] - C[w]);
				E1(0, 2); E2(0, 2);
				break;
			}
		}
}
void work1()
{
	for (int scani = scannum; scani >= 1; scani--){
		int w = scan[scani].w;
		switch(scan[scani].kind){
			int t1, t2;
			case -1:
				T[1][0].mod(newnum[w], INF);
				T[1][1].mod(newnum[w], INF);
				T[1][2].mod(newnum[w], INF);
				break;
			case 1:
				T[1][0].mod(newnum[w], x1[w] - x0[w] - 2 * h[w] - C[w]);
				T[1][1].mod(newnum[w], x1[w] - x0[w] - C[w]);
				T[1][2].mod(newnum[w], x1[w] - x0[w] + 2 * h[w] - C[w]);
				break;
			case 0:
				D1(1, 0); D2(1, 0);
				ans[w] = min(ans[w], T[1][0].que(1, R[newpart[x0w[w]] - 1]) + x0[w] + x1[w] - C[w]);
				E1(1, 0); E2(1, 0);
				D1(1, 1); D2(1, 1);
				ans[w] = min(ans[w], T[1][1].que(L[newpart[x0w[w]]], R[newpart[x1w[w]]]) + x1[w] - x0[w] - C[w]);
				E1(1, 1); E2(1, 1);
				D1(1, 2); D2(1, 2);
				ans[w] = min(ans[w], T[1][2].que(L[newpart[x1w[w]] + 1], n) - x1[w] - x0[w] - C[w]);
				E1(1, 2); E2(1, 2);
				break;
			}
		}
}	
void work2()
{
	for (int scani = 1; scani <= scannum; scani++){
		int w = scan[scani].w;
		switch(scan[scani].kind){
			int t1, t2;
			case 1:
				T[2][0].mod(newnum[w], -x1[w] - x0[w] - 2 * h[w] - C[w]);
				T[2][1].mod(newnum[w], -x1[w] - x0[w] - C[w]);
				T[2][2].mod(newnum[w], -x1[w] - x0[w] + 2 * h[w] - C[w]);
				break;
			case 0:
				D1(2, 0); D2(2, 0);
				ans[w] = min(ans[w], T[2][0].que(1, R[newpart[x0w[w]] - 1]) + x0[w] + x1[w] + 2 * h[w] - C[w]);
				E1(2, 0); E2(2, 0);
				D1(2, 1); D2(2, 1);
				ans[w] = min(ans[w], T[2][1].que(L[newpart[x0w[w]]], R[newpart[x1w[w]]]) + x1[w] - x0[w] + 2 * h[w] - C[w]);
				E1(2, 1); E2(2, 1);
				D1(2, 2); D2(2, 2);
				ans[w] = min(ans[w], T[2][2].que(L[newpart[x1w[w]] + 1], n) - x1[w] - x0[w] + 2 * h[w] - C[w]);
				E1(2, 2); E2(2, 2);
				break;
			}
		}
}
void workother()
{
	for (int i = 1; i < n; i++) startans += abs(h[i] - h[i + 1]);
	for (int i = 3; i < n; i++){
		int t = -abs(h[2] - h[1]) - C[i] + abs(h[i] - h[2]) + abs(h[1] - h[i - 1]) + abs(h[1] - h[i + 1]);
		ans[1] = min(t, ans[1]); ans[i] = min(t, ans[i]);
		}
	for (int i = 2; i < n - 1; i++){
		int t = -abs(h[n] - h[n - 1]) - C[i] + abs(h[i] - h[n - 1]) + abs(h[n] - h[i - 1]) + abs(h[n] - h[i + 1]);
		ans[n] = min(t, ans[n]); ans[i] = min(t, ans[i]);
		}
	int t = -abs(h[n] - h[n - 1]) - abs(h[1] - h[2]) + abs(h[n] - h[2]) + abs(h[1] - h[n - 1]);
	ans[n] = min(t, ans[n]); ans[1] = min(t, ans[1]);
	t = -abs(h[3] - h[2]) + abs(h[1] - h[3]);
	ans[1] = min(t, ans[1]); ans[2] = min(t, ans[2]);
	t = -abs(h[n - 1] - h[n - 2]) + abs(h[n] - h[n - 2]);
	ans[n] = min(t, ans[n]); ans[n - 1] = min(t, ans[n - 1]);
	for (int i = 2; i < n - 1; i++){
		int t = -abs(h[i - 1] - h[i]) - abs(h[i + 1] - h[i + 2]) + abs(h[i - 1] - h[i + 1]) + abs(h[i] - h[i + 2]);
		ans[i + 1] = min(t, ans[i + 1]); ans[i] = min(t, ans[i]);
		}
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("drz.in", "r", stdin); freopen("drz.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
	pre_do();
	work0(); //h[j] < x0[i]
	work1(); //x1[i] >= h[j] >= x0[i]
	work2(); //h[j] > x1[i]
	workother();
	for (int i = 1; i <= n; i++) printf("%lld\n", startans + (long long)(ans[i]));
}
Problem1101

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int prime[50001], pnum, mobius[50001], minp[50001], sum[50001];
bool notp[50001];
void GETP(int MAX)
{
	mobius[1] = 1;
	for (int i = 2; i <= MAX; i++){
		if (!notp[i]) { prime[++pnum] = i; mobius[i] = -1; minp[i] = i;}
		for (int j = 1; j <= pnum && i * prime[j] <= MAX; j++){
			notp[i * prime[j]] = true;
			minp[i * prime[j]] = prime[j];
			if (mobius[i] == 0 || (minp[i] == prime[j])) mobius[i * prime[j]] = 0;
			else mobius[i * prime[j]] = mobius[i] * -1;
			}
		}
}
int main()
{
	GETP(50000);
	for (int i = 1; i <= 50000; i++) sum[i] = sum[i - 1] + mobius[i];
	int TEST, a, b, d; scanf("%d", &TEST);
	while(TEST--){
		scanf("%d%d%d", &a, &b, &d); a /= d; b /= d;
		if (a > b) swap(a, b);
		int ans = 0;
		for (int i = 1; i <= a;){
			int t = min(a / (a / i), b / ((b / i)));
			ans += (sum[t] - sum[i - 1]) * (a / i) * (b / i);
			i = t + 1;
			}
		printf("%d\n", ans);
		}	
}
Problem1101

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int prime[50001], pnum, mobius[50001], minp[50001], sum[50001];
bool notp[50001];
void GETP(int MAX)
{
	mobius[1] = 1;
	for (int i = 2; i <= MAX; i++){
		if (!notp[i]) { prime[++pnum] = i; mobius[i] = -1; minp[i] = i;}
		for (int j = 1; j <= pnum && i * prime[j] <= MAX; j++){
			notp[i * prime[j]] = true;
			minp[i * prime[j]] = prime[j];
			if (mobius[i] == 0 || (minp[i] == prime[j])) mobius[i * prime[j]] = 0;
			else mobius[i * prime[j]] = mobius[i] * -1;
			if (i % prime[j] == 0) break;
			}
		}
}
int main()
{
	GETP(50000);
	for (int i = 1; i <= 50000; i++) sum[i] = sum[i - 1] + mobius[i];
	int TEST, a, b, d; scanf("%d", &TEST);
	while(TEST--){
		scanf("%d%d%d", &a, &b, &d); a /= d; b /= d;
		if (a > b) swap(a, b);
		int ans = 0;
		for (int i = 1; i <= a;){
			int t = min(a / (a / i), b / ((b / i)));
			ans += (sum[t] - sum[i - 1]) * (a / i) * (b / i);
			i = t + 1;
			}
		printf("%d\n", ans);
		}	
}
Problem1102

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define PII pair<int, int>
#define fr first
#define sc second
using namespace std;
const int dx[8] = {0, 0, -1, 1, 1, 1, -1, -1};
const int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};
int map[3001][3001], n, yans1, yans2, ans1, ans2;
bool vis[3001][3001];
int l, r;
PII q[14000001];
void expand(int x, int y)
{
	for (int i = 0; i < 8; i++){
		int nx = x + dx[i], ny = y + dy[i];
		if (map[nx][ny] == -1) continue;
		if (map[nx][ny] > map[x][y]) yans1 = 0;
		if (map[nx][ny] < map[x][y]) yans2 = 0;
		if (map[nx][ny] == map[x][y] && !vis[nx][ny]) q[++r] = make_pair(nx, ny), vis[nx][ny] = true;
		}		
}
int main()
{
	memset(map, 0xff, sizeof(map));
	scanf("%d", &n); for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &map[i][j]);
	for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++) if (!vis[i][j]){
		yans1 = yans2 = 1;
		if (!vis[i][j]){
			q[l = r = 1].fr = i; q[1].sc = j; vis[i][j] = true;
			while(l <= r){
				++l; expand(q[l - 1].fr, q[l - 1].sc);
				} 
		ans1 += yans1; ans2 += yans2; 
		}
		}
	printf("%d %d\n", ans1, ans2);
}
Problem1103

#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int bit[1000001], e[1000001], v[1000001], next[1000001], left[1000001], right[1000001], tot;
int n, dfsnum;
const int N_MAX = 2000000;
static int stack[N_MAX * 5], bak;
int get(int idx)
{
	int ret = 0;
	for (; idx > 0; idx -= (idx & (-idx))) ret += bit[idx];
	return ret;
}
void add(int idx, int del)
{
	for (; idx <= 2 * n; idx += (idx & (-idx))) bit[idx] += del;
}
void add(int a, int b, bool f)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	left[x] = ++dfsnum; add(dfsnum, 1);
	for (int i = e[x]; i; i = next[i]) dfs(v[i]);
	right[x] = ++dfsnum; add(dfsnum, -1);
}

int main()
{
	asm __volatile__
	(
		"movl %%esp, %0\n\t"
		"movl %1, %%esp\n\t": 
		"=g"(bak):
		"g"(stack + N_MAX * 5 - 1):
	);
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b; if (a > b) swap(a, b);
		scanf("%d%d", &a, &b); add(a, b, true);
		}
	dfs(1);	
	int Q; scanf("%d", &Q); Q += n - 1;
	while(Q--){
		char c; int a, b;
		getchar(); scanf("%c", &c);
		switch(c){
			case 'W' : scanf("%d", &a); printf("%d\n", get(left[a]) - 1); break;
			case 'A' : scanf("%d%d", &a, &b); add(left[b], -1); add(right[b], 1);break;
			}
		}
	asm __volatile__
	(
		"movl %0, %%esp\n\t" :
		:
		"g"(bak)
	);
			
}
Problem1104

#include <cstdio>
#include <cstdlib>
#include <vector>
#include <cassert>
#include <algorithm>
#define make(a, b) (((a) - 1) * m + b)
using namespace std;
const int MAXG = 2000001;
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};
int n, m, H[2001][2001];
bool vis[MAXG];
struct TUF{
	int f[MAXG];
	void init() { for (int i = 1; i <= n * m; i++) f[i] = i; }
	int getf(int v) { return v == f[v] ? v : f[v] = getf(f[v]); }
	bool query(int a, int b) { return getf(a) == getf(b); }
	void merge(int a, int b)
	{
		a = getf(a); b = getf(b);
		if (a != b) f[a] = b;
		if (vis[a]) vis[b] = true;
	}
} UF;
struct Tinf{
	int x, y; bool must;
};
vector<Tinf> data[3001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			int h; scanf("%d", &h); Tinf temp; 
			temp.x = i; temp.y = j; temp.must = h > 0;
			data[abs(h)].push_back(temp);
			H[i][j] = abs(h);
			}
	UF.init();
	int ans = 0;
	for (int i = 0; i < 1001; i++){
		for (vector<Tinf>::iterator vi = data[i].begin(); vi != data[i].end(); vi++){
			int x = vi->x, y = vi->y;
			for (int j = 0; j < 4; j++){
				int nx = x + dx[j], ny = y + dy[j];
				if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && H[x][y] >= H[nx][ny])
					UF.merge(make(x, y), make(nx, ny));
				}
			}
		for (vector<Tinf>::iterator vi = data[i].begin(); vi != data[i].end(); vi++){
			int x = vi->x, y = vi->y;
			if (vi->must){
					int t = UF.getf(make(x, y)); 
					if (!vis[t]){ 
						++ans; vis[t] = true;
						}
					}
			}
		}
	printf("%d\n", ans);
}
Problem1105

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const long long INF = 0x7fffffffffffffffll;
long long ans2 = INF;
char ans3[2000001], tans3[2000001];
long long minx, miny, maxx, maxy;
int n;
long long x[2000001], y[2000001], w[2000001];
void calc(long long x1, long long y1, long long x2, long long y2)
{
	long long tans2 = 0;
	for (int i = 1; i <= n; i++){
		if (x[i] < x1 || x[i] > x2 || y[i] < y1 || y[i] > y2){
			if (x[i] < y1 || x[i] > y2 || y[i] < x1 || y[i] > x2) return;
			tans2 += w[i]; tans3[i] = '1';
			}
		else tans3[i] = '0';
		}	
	if (tans2 < ans2){
		ans2 = tans2;
		strcpy(ans3 + 1, tans3 + 1);
		}
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	long long minx = INF, miny = INF, maxx = -INF, maxy = -INF;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d%d%d", &x[i], &y[i], &w[i]);
		if (x[i] <= y[i]){
			minx = min(minx, x[i]);
			miny = min(miny, y[i]);
			maxx = max(maxx, x[i]);
			maxy = max(maxy, y[i]);
			}
		else{
			minx = min(minx, y[i]);
			miny = min(miny, x[i]);
			maxx = max(maxx, y[i]);
			maxy = max(maxy, x[i]);
			}
		}		
	calc(minx, miny, maxx, maxy);
	calc(miny, minx, maxx, maxy);
	calc(minx, miny, maxy, maxx);
	calc(miny, minx, maxy, maxx);
	cout << (maxx + maxy - minx - miny) * 2ll << " " << ans2 << endl;
	puts(ans3 + 1);
}
	
Problem1106

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, b[1000001], last[1000001];
void add(int idx, int d)
{
	for (; idx <= 2 * n; idx += (idx & (-idx))) b[idx] += d;
}
int get(int idx)
{
	int ret = 0;
	for (; idx; idx -= (idx & (-idx))) ret += b[idx];
	return ret;
}
int get(int l, int r)
{
	return get(r) - get(l - 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	int ans = 0;
	for (int i = 1; i <= 2 * n; i++){
		int t; scanf("%d", &t);
		if (last[t] == 0){
			last[t] = i;
			add(i, 1);
			}
		else{
			ans += get(last[t] + 1, i - 1);
			add(last[t], -1);
			}
		}
	printf("%d\n", ans);
}
Problem1107

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001;
struct Tdata{
	int dir, x, y;
	void init() { scanf("%d%d%d", &x, &y, &dir); }
	bool operator < (const Tdata & A) const { return x == A.x ? y < A.y : x < A.x ; }
} data[MAXN], now[MAXN];
int f[MAXN], l[MAXN], r[MAXN], sum[MAXN];
int tot, n, m, L, k;
struct Tst{
	int cover[MAXN * 4];
	void cl() { memset(cover, 0, sizeof(cover)); }
	void push(int idx)
	{
		if (cover[idx] != 0x3f3f3f3f){
			cover[idx * 2] = min(cover[idx], cover[idx * 2]);
			cover[idx * 2 + 1] = min(cover[idx], cover[idx * 2 + 1]);
			cover[idx] = 0x3f3f3f3f;
		}
	}
	int getvalue(int idx, int l, int r, int x)
	{
		if (l == r) return cover[idx];
		push(idx);
		int m = l + r >> 1;
		if (x <= m) return getvalue(idx * 2, l, m, x); else return getvalue(idx * 2 + 1, m + 1, r, x);
	}
	void getbest(int idx, int l, int r, int ll, int rr, int num)
	{
		if (ll <= l && rr >= r) { cover[idx] = min(cover[idx], num); return; }
		push(idx);
		int m = l + r >> 1;
		if (ll <= m) getbest(idx * 2, l, m, ll, rr, num);
		if (rr > m) getbest(idx * 2 + 1, m + 1, r, ll, rr, num);
	}
} t;
void doit()
{
	sort(now + 1, now + tot + 1);
	t.cl();
	int p = 0, d = 0;
	for (int i = 2; i <= n; i++){
		++d;
		while(p < tot && now[p + 1].x == i){
			++p;
			t.getbest(1, 0, L, 0, now[p].y, t.getvalue(1, 0, L, now[p].y) - 1);
		}
		f[i] = t.getvalue(1, 0, L, 0) + d;
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("egz.in", "r", stdin); freopen("egz.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &L, &m, &k); 
	for (int i = 1; i <= m; i++) data[i].init();
	for (int i = 1; i <= m; i++)
		if (data[i].dir == 1){
			++tot; now[tot].x = data[i].x + 1; now[tot].y = data[i].y;
		}
	doit(); 
	tot = 0;
	for (int i = 1; i <= n; i++) l[i] = f[i];
	for (int i = 1; i <= m; i++)
		if (data[i].dir == 0){
			++tot; now[tot].x = n - data[i].x + 1; now[tot].y = data[i].y;
		}
	doit(); 
	for (int i = 1; i <= n; i++) r[i] = f[n - i + 1];
	for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + (l[i] > 0 || r[i] > 0);
	int j = 1, ans = 0;
	for (int i = 1; i <= n; i++){
		j = max(j, i);
		while(j < n && r[i] + l[j + 1] <= k) ++j;
		if (r[i] + l[j] <= k) ans = max(sum[j] - sum[i - 1], ans);	
	}
	printf("%d\n", ans);
}
Problem1108

#include <iostream>
#include <cstdlib>
#include <cstring>
using namespace std;
int main()
{
	long long n, ans = 0; cin >> n;
	for (int i = 1; i <= n; i++){
		long long a, b; cin >> a >> b;
		ans -= (a - b);
		}
	for (int i = 1; i <= n; i++){
		long long a, b; cin >> a >> b;
		ans += (a - b);
		}
	cout << ans << endl;
}
	
Problem1109

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <algorithm>
#define PII pair<int, int>
using namespace std;
vector<PII> a;
bool cmp(PII a, PII b) {
	if (a.first == b.first) return a.second < b.second;
	else return a.first > b.first;
}
int n;
int g[200001], ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x; scanf("%d", &x); 
		if (x > i) continue;
		a.push_back(make_pair(x - i, x));
		}
	sort(a.begin(), a.end(), cmp);
	ans = 0;
	g[0] = 0xe0e0e0e0;
	for (vector<PII>::iterator vi = a.begin(); vi != a.end(); vi++){
		int t = vi->second;
		int l = 0, r = ans;
		while(l <= r){
			int m = (l + r) >> 1;
			if (t > g[m]) l = m + 1; else r = m - 1;	
			}
		if (r == ans) g[++ans] = t;			
		else g[r + 1] = t;
		}
	printf("%d\n", ans); 
}
Problem1110

#include <cstdio>
#include <cstdlib>
#include <set>
#include <queue>
#include <algorithm>
#include <functional>
using namespace std;
int n, m, w[1000001], r[1000001];
struct Theap{
	int size, data[1000001];
	bool Size() { return size; }
	int & operator [] (int k) { return data[k]; }
	void clear() { size = 0; }
	void push(int h)
	{
		++size; data[size] = h;
		int i = size;
		while(i != 1){
			if (data[i] > data[i >> 1]) swap(data[i >> 1], data[i]); else break;
			i >>= 1;
			}
	}
	int pop()
	{
		int temp = data[1];
		swap(data[1], data[size]); --size;
		int i = 2;
		while(i <= size){
			if (i < size && data[i + 1] > data[i]) ++i;
			if (data[i] > data[i >> 1]) swap(data[i >> 1], data[i]); else break;
			i <<= 1;
			}
		return temp;
	} 
}S;
bool ok(int num)
{
	while(S.Size()) S.pop();
	for (int i = 1; i <= n; i++) S.push(r[i]);
	for (int i = num; i >= 1; i--){
		int t = S[1];
		if (t < w[i]) return false;
		S.pop(); S.push(t - w[i]);
		}
	return true;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &r[i]);
	for (int i = 1; i <= m; i++) scanf("%d", &w[i]);
	sort(w + 1, w + m + 1);
	int l = 0, r = m;
	while(l <= r){
		int m = l + r >> 1;
		if (ok(m)) l = m + 1; else r = m - 1;
		}
	printf("%d\n", r);
}
Problem1112

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#ifdef __int64
	#define LLD "%I64d"
#else 
	#define LLD "%lld";
#endif
const int MAXNODE = 1000001;
using namespace std;
int n, k;
struct Tnode{
	static Tnode *a;
	int c[2], f, size, key;
	long long sum;
	void update() { size = a[c[0]].size + a[c[1]].size + 1; sum = a[c[0]].sum + a[c[1]].sum + key; }
	void make(int _key) { size = 1; key = _key; sum = _key; }
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXNODE], *Tnode::a = A;
int root, tot;
void splay(int x, int p)
{
	int y, z; bool b, c;
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z =A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update(); if (p == 0) root = x;
}
void insert(int _key)
{
	if (root == 0) { root = tot = 1; A[1].make(_key); return; }
	int t = root;
	while(A[t].c[_key > A[t].key]){
		++A[t].size; A[t].sum += _key;
		t = A[t].c[_key > A[t].key];
	}
	++A[t].size; A[t].sum += _key;
	++tot; A[t].c[_key > A[t].key] = tot; A[tot].f = t;
	A[tot].make(_key);
	splay(tot, 0);
}
void select(int k)
{
	int t = root, tt;
	while(k != (tt = A[A[t].c[0]].size + 1))
		if (k > tt) { t = A[t].c[1]; k -= tt; } else t = A[t].c[0];
	splay(t, 0);
}
int getmax(int t) { while(A[t].c[1]) t = A[t].c[1]; return t;}
void erase(int t)
{
	splay(t, 0);
	if (A[t].c[0] == 0) { root = A[t].c[1]; A[root].f = 0; return; }
	splay(getmax(A[t].c[0]), root);
	int nr = A[t].c[0]; A[nr].c[1] = A[root].c[1]; A[A[nr].c[1]].f = nr;
	A[nr].f = 0; A[nr].update();
	root = nr;
}
long long query()
{
	select(k + 1 >> 1);
	return A[A[root].c[1]].sum - A[A[root].c[0]].sum - (A[A[root].c[1]].size - A[A[root].c[0]].size) * A[root].key;
}
long long ans = 0x7fffffffffffffffll; int a[MAXNODE];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i < k; i++) insert(a[i]);
	for (int i = k; i <= n; i++){
		//cerr << i << endl;
		insert(a[i]);
		//cerr << query() << endl;
		ans = min(ans, query());
		erase(i - k + 1);
	}
	cout << ans << endl;
}
Problem1113

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tstack{
	int top, data[1000001];
	void cl() { top = 0; }
   	bool find(int num)
	{
		int l = 1, r = top;
		while(l <= r){
			int m = l + r >> 1;
			if (data[m] == num) return true;
			if (data[m] < num) l = m + 1; else r = m - 1;
			}
		return false;
	}
	void push(int num)
	{
		while(top > 0 && data[top] > num) --top;
		data[++top] = num;
	}	
} S;
int n, ans, h[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("pla.in", "r", stdin); freopen("pla.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%*d%d", &h[i]);
	S.cl();
	for (int i = 1; i <= n; i++){
		ans += !S.find(h[i]);
		S.push(h[i]);
		}
	printf("%d\n", ans);
}
Problem1115

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, a[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; cin >> TEST;
while(TEST--){
	cin >> n; for (int i = 1; i <= n; i++) cin >> a[i];
	int sg = 0;
	for (int i = n; i >= 1; i -= 2) sg ^= a[i] - a[i - 1];
	puts(sg ? "TAK" : "NIE");
}
}
Problem1115

#include <iostream>
using namespace std;
int n, a[1000001];
int main()
{
int TEST; cin >> TEST;
while(TEST--){
	cin >> n; for (int i = 1; i <= n; i++) cin >> a[i];
	int sg = 0;
	for (int i = n; i >= 1; i -= 2) sg ^= a[i] - a[i - 1];
	cout <<( sg ? "TAK" : "NIE") << endl;
}
}
Problem1116

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 300001;
int n, m, q[MAXN];
int edge[MAXN][2], linkx[MAXN], linky[MAXN], dx[MAXN], dy[MAXN];
bool bfs()
{
	memset(dx, 0, sizeof(dx)); memset(dy, 0, sizeof(dy));
	int l = 1, r = 0; bool ok = false;
	for (int i = 1; i <= m; i++) if (linkx[i] == 0) q[++r] = i;
	while(l <= r){
		int x = q[l++];
		for (int i = 0; i < 2; i++) if (dy[edge[x][i]] == 0){
			dy[edge[x][i]] = dx[x] + 1;
			if (linky[edge[x][i]] == 0) ok = true;
			else { dx[linky[edge[x][i]]] = dx[x] + 2; q[++r] = linky[edge[x][i]]; }
			int a; ++a;
		}
	}
	return ok;
}
bool dfs(int x)
{
	for (int i = 0; i < 2; i++) if (dy[edge[x][i]] == dx[x] + 1){
		dy[edge[x][i]] = 0;
		if (linky[edge[x][i]] == 0 || dfs(linky[edge[x][i]])){
			linky[edge[x][i]] = x; linkx[x] = edge[x][i];
			return true;
		}
	}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("clo.in", "r", stdin); freopen("clo.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d%d", &edge[i][0], &edge[i][1]);
	int num = 0;
	while(bfs())
		for (int i = 1; i <= m; i++) if (linkx[i] == 0 && dfs(i)) ++num;
	if (num != n) puts("NIE");
	else{
		puts("TAK");
		//for (int i = 1; i <= n; i++) printf("%d\n", edge[linky[i]][0] + edge[linky[i]][1] - i);
		}	
}
Problem1121

#include <iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	cout << (n >> 1) << endl;
}
Problem1123

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
using namespace std;
const int MAXN = 600001, MAXM = 600001;
int n, m, e[MAXN], v[MAXM * 2], next[MAXM * 2], tot;
int deep[MAXN], anc[MAXN], i[MAXN];
bool vis[MAXN];
long long size[MAXN], notlink[MAXN], bothlink[MAXN], ans[MAXN];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x)
{
	anc[x] = deep[x]; vis[x] = true; size[x] = 1;
	for (i[x] = e[x]; i[x]; i[x] = next[i[x]])
		if (vis[v[i[x]]]) { anc[x] = min(anc[x], deep[v[i[x]]]); continue; }
		else{
			deep[v[i[x]]] = deep[x] + 1; dfs(v[i[x]]);
			if (anc[v[i[x]]] >= deep[x]){
				notlink[x] += size[v[i[x]]]; bothlink[x] += size[v[i[x]]] * (size[v[i[x]]] - 1);
			}
			size[x] += size[v[i[x]]]; anc[x] = min(anc[x], anc[v[i[x]]]);
		}
	bothlink[x] += ((long long)n - notlink[x] - 1) * ((long long)n - notlink[x] - 2);
	ans[x] = (long long)n * (n - 1) - bothlink[x];
}
const int N_MAX = 1000000;
static int stack[N_MAX * 5], bak;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("blo.in", "r", stdin); freopen("blo.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	asm __volatile__
	(
		"movl %%esp, %0\n\t"
		"movl %1, %%esp\n\t": 
		"=g"(bak):
		"g"(stack + N_MAX * 5 - 1):
	);
	dfs(1);
	for (int i = 1; i <= n; i++) printf(LLD "\n", ans[i]);
}
Problem1124

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1500001;
int p[MAXN], n, into[MAXN];
bool vis[MAXN], aj[MAXN], die[MAXN];
struct Tqueue{
	int l, r, data[MAXN];
	void clear() { l = 1; r = 0; }
	bool empty() { return l > r; }
	void push(int t) { data[++r] = t; }
	int pop() { return data[l++]; }
} Q;
int getmin()
{
	int ans = 0; 
	memset(vis, 0, sizeof(vis)); 
	memset(into, 0, sizeof(into));
	Q.clear();
	for (int i = 1; i <= n; i++) ++into[p[i]];
	for (int i = 1; i <= n; i++) if (into[i] == 0) Q.push(i), vis[i] = true;
	while(!Q.empty()){
		int x = Q.pop();
		if (die[x]) continue;
		x = p[x];
		if (die[x]) continue;
		++ans;
		die[x] =true; vis[x] =true;
		--into[p[x]]; if (into[p[x]] == 0) Q.push(p[x]), vis[p[x]] = true;
	}
	for (int i = 1; i <= n; i++) if (!vis[i]){
		int t = p[i], len = 1; vis[p[i]] = true;
		while(t != i) { ++len; t = p[t]; vis[t] = true; }
		ans += 1 + ((len - 1) >> 1);
	}
	return ans;
}
int getmax()
{
	int ans = n;
	memset(into, 0, sizeof(into));
	memset(vis, 0, sizeof(vis));
	memset(aj, 0, sizeof(aj));
	Q.clear();
	for (int i = 1; i <= n; i++) ++into[p[i]];
   	for (int i = 1; i <= n; i++) if (into[i] == 0) { --ans; Q.push(i); vis[i] = true; }
	while(!Q.empty()){
		int x = Q.pop();
		--into[p[x]]; aj[p[x]] = true;
		if (into[p[x]] == 0) { Q.push(p[x]); vis[p[x]] = true; }
	}
	for (int i = 1; i <= n; i++) if (!vis[i]){
		int t = p[i]; bool jc = !aj[i]; vis[i] = true;
		while(t != i) { vis[t] = true; jc &= !aj[t]; t = p[t]; }
		if (jc && (!(i == p[i]))) --ans;
	}
	return ans;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("maf.in", "r", stdin); freopen("maf.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	printf("%d %d\n", getmin(), getmax());
}
Problem1125

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MO = 12950316, MAXN = 1500001;
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, key, size, ms;
	void make(int _key, int _size)
	{
		memset(this, 0, sizeof(*this));
		key = _key; size = _size; ms = size;
	}
	void update()
	{
		ms = max(max(a[c[0]].ms, a[c[1]].ms), size);
	}
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
int n, l, Q;
int M[MAXN], TIME, size[MO + 1], ans[MAXN], intotime[MAXN];
int tot, hash[MAXN];
struct Tsplay{
	int root;
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while((y = A[x].f) != p){
			b = x == A[y].c[1];
			if ((z = A[y].f) != p){
				c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
				A[x].rot(c);
			}
			else A[x].rot(b);
		}
		A[x].update(); if (p == 0) root = x;
	}
	void insert(int x, int key, int size)
	{
		if (root == 0) { root = ++tot; A[tot].make(key, size); return; }
	   	if (A[x].c[key > A[x].key])	insert(A[x].c[key > A[x].key], key, size);
		else { ++tot; A[tot].make(key, size); A[tot].f = x; A[x].c[key > A[x].key] = tot;}
		A[x].update();
	}
	int get(int x, int key)
	{
		if (x == 0) return 0xe0e0e0e0;
		if (A[x].key < key)  return get(A[x].c[1], key);
		if (A[x].key == key) return max(A[x].size, A[A[x].c[1]].ms);
		return max(max(A[x].size, A[A[x].c[1]].ms), get(A[x].c[0], key)); 
	}
} bst[MO + 1];
void ins(int x)
{
	bst[hash[x]].insert(bst[hash[x]].root, intotime[x] = ++TIME, ++size[hash[x]]);
	if (bst[hash[x]].root != tot) bst[hash[x]].splay(tot, 0);
}
void del(int x)
{
	--size[hash[x]]; ans[x] = max(ans[x], bst[hash[x]].get(bst[hash[x]].root, intotime[x]));
}
char s[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("poc.in", "r", stdin); freopen("poc.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &l, &Q);
	for (int i = 1; i <= n; i++) scanf("%s", s[i] + 1);
	M[1] = 1; for (int i = 2; i <= l; i++) M[i] = (long long)M[i - 1] * 26 % MO;
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= l; j++) hash[i] = ((long long)M[j] * (s[i][j] - 'a') + hash[i]) % MO;
		ins(i);
	}
	while(Q--){
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		del(x1); if (x1 != x2) del(x2);
		hash[x1] = (((long long) M[y1] * (s[x2][y2] - s[x1][y1]) + hash[x1]) % MO + MO) % MO;
		hash[x2] = (((long long) M[y2] * (s[x1][y1] - s[x2][y2]) + hash[x2]) % MO + MO) % MO;
		swap(s[x1][y1], s[x2][y2]);
		ins(x1); if (x1 != x2) ins(x2);
	}
	for (int i = 1; i <= n; i++) del(i);
	for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);

}
Problem1128

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MAXL = 5000001;
using namespace std;
struct Big{
	int len; long long data[MAXL];
	Big() { len = 1; memset(data, 0, sizeof(data)); data[1] = 1;}
	Big(int t) { len = 1; memset(data, 0, sizeof(data)); data[1] = t; }
   	int operator % (int t)
	{
		long long tmp = 0;
		for (int i = len; i >= 1; i--) tmp = (tmp * 10 + data[i]) % t;
		return tmp;
	}	
	Big & operator *= (int t)
	{
		long long tmp = 0;
		for (int i = 1; i <= len; i++){
			data[i] = data[i] * t + tmp;
			tmp = data[i] / 10;
			data[i] %= 10;
		}
		data[len + 1] = tmp; if (tmp) ++len;
		while(data[len] > 10) { data[len + 1] = data[len] / 10; data[len] %= 10; ++len; } 
		return *this;
	}
	Big & operator /= (int t)
	{
		long long tmp = 0;
		for (int i = len; i >= 1; i--){
			data[i] = data[i] + 10 * tmp;
			tmp = data[i] % t;
			data[i] /= t;
		}
		while(data[len] == 0) --len;
		return *this;
	}
	void print()
	{
		for (int i = len; i >= 1; i--) printf("%d", data[i]);
	}
} A, B;
int n, p[10001];
void make(int t, Big & A, Big & B)
{
	int tmp = __gcd(t, B % t);
	B /= tmp;
	A *= t / tmp;
}
void do1()
{
	for (int i = n; i >= 1; i--) if (p[i] == 1){
		for (int j = 1; j < i; j++) puts("0/1");
		for (int j = i; j <= n; j++) p[j - i + 1] = p[j];
	  	n -= i - 1;
		return;
	}	
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("lam.in", "r", stdin); freopen("lam.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	do1();
	for (int i = 1; i <= n; i++){
		make(p[i], B, A);
		if (i != 1) make(p[i] - 1, A, B);
	}
	for (int i = 1; i <= n - 1; i++){
		A.print(); putchar('/'); B.print(); putchar('\n');
		make(p[i + 1] - 1, B, A); make(p[i], A, B);
	}
	A.print(); putchar('/'); B.print(); putchar('\n');
}
Problem1129

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
const int MAXN = 600001;
using namespace std;
map<int, int> hash;
int a[MAXN], num[MAXN], nownum[MAXN], p[MAXN], q[MAXN], n, m, tot, P;
int A[MAXN], B[MAXN], inv[MAXN], mi[MAXN];
struct Tbit{
	int data[300001];
	void clear() { memset(data, 0, sizeof(data)); }
	void add(int a, int b)
	{
		for (; a <= m; a += (a & (-a))) data[a] += b;
	}
	long long getsum(int a)
	{
		long long ret = 0;
		for (; a; a -= (a & (-a))) ret += data[a];
		return ret;
	}
} bit;
int exgcd(int a, int b, long long & x, long long & y)
{
	if (b == 0) { x = 1; y = 0; return a; }
	else { int ret = exgcd(b, a % b, y, x); y -= a / b * x; return ret; }
}
void rehash()
{
	for (int i = 1; i <= n; i++) hash[a[i]]++;
	m = 0;
	for (map<int, int>::iterator mib = hash.begin(); mib != hash.end(); mib++){
		num[++m] = mib->second;
		mib->second = m;
	}
	for (int i = 1; i <= n; i++) a[i] = hash[a[i]];
}
void predo(int P, int Q)
{
	mi[0] = 1;
	for (int i = 1; i <= Q; i++) mi[i] = mi[i - 1] * P;
	for (int i = 1; i <= n; i++){
		A[i] = B[i] = 0;
		int t = i;
		while(t % P == 0) t /= P, ++B[i];
		A[i] = t;
		long long x, y;
		exgcd(A[i], mi[Q], x, y);
		x = ((x % mi[Q]) + mi[Q]) % mi[Q];
		inv[i] = x;
	}
}
int work(int P, int Q)
{
	long long nowa = 1, res = 0; int nowb = 0;
	predo(P, Q);
	//T = A * P ^ B inv = inv(A)
	int MO = mi[Q];
	//get n! / (num[i] !)
	for (int i = 1; i <= n; i++) { nowa = nowa * A[i] % MO; nowb += B[i]; }
	for (int i = 1; i <= m; i++){
		nownum[i] = num[i];
		for (int j = 1; j <= num[i]; j++){
			nowa = nowa * inv[j] % MO;
			nowb -= B[j];
		}
	}
	bit.clear(); for (int i = 1; i <= m; i++) bit.add(i, num[i]);
	for (int i = 1; i <= n; i++){
		nowa = nowa * inv[n - i + 1] % MO;
		nowb -= B[n - i + 1];
		if (nowb <= Q) res = (res + (((bit.getsum(a[i] - 1) % MO) * mi[nowb]) % MO * nowa) % MO) % MO;
		bit.add(a[i], -1);
		nowa = (nowa * A[nownum[a[i]]]) % MO; nowb += B[nownum[a[i]]];
		--nownum[a[i]];
	}
	res = (res + 1) % MO;
	//cerr << P << " " << Q << " " << res << endl; 
	return res;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("per.in", "r", stdin); freopen("per.out", "w", stdout);
#endif
	scanf("%d%d", &n, &P);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	rehash();
	int tempP = P;
	for (int i = 2; i * i <= P; i++) if (P % i == 0){
		++tot; p[tot] = i;
		while(P % i == 0) ++q[tot], P /= i;
	}
	if (P > 1) p[++tot] = P, q[tot] = 1;
	int ans = 0;
	P = tempP;
	for (int i = 1; i <= tot; i++){
		int ret = work(p[i], q[i]);
		long long x, y;
		exgcd(P / mi[q[i]], mi[q[i]], x, y);
		x = (((x % P) * ret) % P * (P / mi[q[i]]));
		x = ((x % P) + P) % P;
		ans = (ans + x) % P;
	}
	printf("%d\n", ans);
}
Problem1131

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1500001;
int n, q[MAXN], f[MAXN];
int e[MAXN], v[MAXN * 2], next[MAXN * 2], tot;
long long down[MAXN], up[MAXN], size[MAXN];
bool vis[MAXN];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void BFS()
{
	int l = 1, r = 1; q[1] = 1; vis[1] = true;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) { vis[v[i]] = true; q[++r] = v[i]; f[v[i]] = x;} 
	}
	//for (int i = 1; i <= r; i++) fprintf(stderr, "%d\n",  q[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("sta.in", "r", stdin); freopen("sta.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int x, y; scanf("%d%d", &x, &y);
		add(x, y); add(y, x);
	}
	BFS();
	for (int i = n; i >= 1; i--){
		size[q[i]] = 1; for (int j = e[q[i]]; j; j = next[j]) if (v[j] != f[q[i]]) size[q[i]] += size[v[j]], down[q[i]] += down[v[j]];
		down[q[i]] += size[q[i]] - 1;
	}
	for (int i = 2; i <= n; i++)
		up[q[i]] = up[f[q[i]]] + down[f[q[i]]] - down[q[i]] - size[q[i]] + n - size[q[i]];
	int who = 1;
	for (int i = 1; i <= n; i++) if (up[i] + down[i] > up[who] + down[who]) who = i;
	printf("%d\n", who);
} 
Problem1132

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
const int MAXN = 10001;
using namespace std;
struct Tpoint{
	long long x, y; 
	void init() { scanf(LLD LLD, &x, &y); }
	bool operator < (const Tpoint & A) const { return y == A.y ? x < A.x : y < A.y; }
	Tpoint operator - (Tpoint A) { Tpoint temp; temp.x = x - A.x; temp.y = y - A.y; return temp; }
} p[MAXN], buf[MAXN];	
int n, tot, id[MAXN];
double ang[MAXN];
long long ans, sumx[MAXN], sumy[MAXN]; 
bool cmpang(int a, int b) { return ang[a] > ang[b]; }
void work()
{
	for (int i = 1; i <= tot; i++) { ang[i] = atan2(buf[i].x, buf[i].y); id[i] = i; }
	sort(id + 1, id + tot + 1, cmpang);
	for (int i = 1; i <= tot; i++) sumx[i] = sumx[i - 1] + buf[id[i]].x;
	for (int i = 1; i <= tot; i++) sumy[i] = sumy[i - 1] + buf[id[i]].y;
	for (int i = 1; i <= tot; i++) ans += buf[id[i]].x * (sumy[tot] - sumy[i]) - buf[id[i]].y * (sumx[tot] - sumx[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("tro.in", "r", stdin); freopen("tro.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	for (int i = 1; i <= n; i++){
		tot = 0;
		for (int j = 1; j <= n; j++) if (p[i] < p[j]) buf[++tot] = p[j] - p[i];
		work();
	}
	ans = abs(ans);
	cout << ans / 2; puts(ans & 1 ? ".5" : ".0");
}
Problem1143

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;
bool map[1001][1001], can[1001][1001];
int link[1001], n, m, now, nowdo;
vector<int> adj[1001], tadj[1001];
bool vis[1001], linked[1001];
set<int> S;
void dfs(int x)
{
	can[now][x] = true;
	for (int i = 1; i <= n; i++) if (map[x][i] && !can[now][i]) dfs(i);
}
bool find(int x)
{
	for (vector<int>::iterator vi = adj[x].begin(); vi != adj[x].end(); vi++) if (!vis[*vi]){
		vis[*vi] = true;
		if (link[*vi] == 0 || find(link[*vi])){
			link[*vi] = x; return true;
			}
		}
	return false;
}	
bool find2(int x)
{
	for (vector<int>::iterator vi = tadj[x].begin(); vi != tadj[x].end(); vi++)
		if (!vis[*vi]){
			vis[*vi] = true;
			if (link[*vi] == 0 || can[nowdo][link[*vi]] || can[link[*vi]][nowdo] || find2(link[*vi])) return true;
			}
	return false;
}	
char ans3[1001], ans2[1001];
int main()
{
	//freopen("river.in", "r", stdin); freopen("river.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); map[a][b] = true;
		}
	for (int i = 1; i <= n; i++){
		memset(vis, 0, sizeof(vis));
		now = i; dfs(i);
		for (int j = 1; j <= n; j++) if (can[i][j] && i != j) adj[i].push_back(j);
		}
	int ans = 0;
	for (int i = 1; i <= n; i++){
		memset(vis, 0, sizeof(vis));
		if (find(i)) ++ans;
		}
	printf("%d\n", n - ans);
/*
	for (int i = 1; i <= n; i++){
		nowdo = i;
		int t = 0, nt = 0;
		for (int j = 1; j <= n; j++){
			if (link[j])
				if (!can[i][j] && !can[j][i] && !can[i][link[j]] && !can[link[j]][i])
					++t;
			if (!can[i][j] && !can[j][i]) ++nt;
			}
		if (nt - t < n - ans - 1) { ans3[i] = '0'; continue; }
		for (int j = 1; j <= n; j++) if (!can[i][j] && !can[j][i]){
			tadj[j].clear();
			for (vector<int>::iterator vi = adj[j].begin(); vi != adj[j].end(); vi++)
				if (!can[i][*vi] && !can[*vi][i])
					tadj[j].push_back(*vi);
			}
		memset(vis, 0, sizeof(vis));
		memset(linked, 0, sizeof(linked));
		for (int j = 1; j <= n; j++) if (link[j]) 
			if (!can[i][j] && !can[j][i] && !can[i][link[j]] && !can[link[j]][i])
				linked[link[j]] = true;
		bool ok = true;
		for (int j = 1; j <= n; j++) if (!can[i][j] && !can[j][i] && !linked[j]) 
			if (find2(j)){
				ok = false; break;
				}
		ans3[i] = ok ? '1' : '0';
		}
	for (int i = 1; i <= n; i++) S.insert(i);
	for (int i = 1; i <= n; i++){
		if (!S.count(i)) { ans2[i] = '0'; continue; }
		if (ans3[i] == '0') { S.erase(find(i)); ans2[i] = '0';; continue; }
		for (int j = 1; j <= n; j++) if ((can[i][j] || can[j][i]) && S.count(j)) S.erase(j);
		ans2[i] = '1';
		}
	puts(ans2 + 1);
	puts(ans3 + 1);
*/
}
	
Problem1144

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <set>
using namespace std;
int n, p[11], MO, q;
int MI[3][100001], MU[3];
double tlog[3];
int star[11], point[11];
int dcmp(double A)
{
	if (fabs(A) < 1e-5) return 0;
	return A < 0 ? -1 : 1;
}
inline int mul(int a,int b) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n"
            :"=d"(ret):"a"(a),"b"(b),"c"(MO));
    return ret;
}
inline int combine(int a, int b)
{
	int x = mul(mul(q, a), b);
	return ((x + a) % MO + b) % MO;
}
struct Tnum{
	int l[3]; double lg;
	Tnum() { memset(this, 0, sizeof(*this)); }
	inline bool operator < (const Tnum & A) const { return dcmp(lg - A.lg) < 0; }
	inline int & operator [] (int k) { return l[k]; }
	inline void calclg()
	{
		lg = 0;
		for (int i = 0; i < n; i++) lg += tlog[i] * l[i];
	}
	inline Tnum operator * (Tnum A)
	{
		Tnum ret;
		for (int i = 0; i < 3; i++) ret[i] = l[i] + A[i];
		ret.lg = lg + A.lg;
		return ret;
	}	
	operator int()
	{
		int ret = 1;
		for (int j = 0; j < n; j++) ret = mul(ret, MI[j][l[j]]);
		return ret;
	}
} a[100001];	
set<Tnum> app;
struct Tnode{
	int lc, rc, l, r, next, f;
} tree[5000000];
int tot;
void initnum()
{
	int h[7]; Tnum real[7];
	static set<Tnum> S;
	for (int i = 2; i <= 6; i++)
		scanf("%d", &h[i]);
	scanf("%d%d", &MO, &q);
	if (h[2] == 0 && h[3] == 0 && h[4] == 0){
		if (h[5] == 0) { n = 1; p[0] = 6; }
		else { n = 2; p[0] = 5; p[1] = 6; }
		}
	else{
		if (h[2] || h[4] || h[6]) p[n++] = 2;
		if (h[3] || h[6]) p[n++] = 3;
		if (h[5]) p[n++] = 5;
		}
	for (int i = 0; i < n; i++){
		MI[i][0] = 1;
		for (int j = 1; j <= 100000; j++) MI[i][j] = mul(MI[i][j - 1], p[i]); 
		}
	for (int i = 2; i <= 6; i++) if (h[i]){
		int t = i;
		for (int j = 0; j < n; j++) while(t % p[j] == 0) t /= p[j], ++real[i][j];
		real[i].lg = log(double(i));
		}
	Tnum temp;
	S.insert(temp);
	for (int i = 0; i <= 100000; i++){
		set<Tnum>::iterator minp = S.begin();
		Tnum num = *minp; S.erase(minp); app.insert(a[i] = num);
		for (int k = 2; k <= 6; k++) if (h[k]){
			Tnum newnum = num * real[k];
			for (int j = 0; j < n; j++) if (num[j] > MU[j]) MU[j] = num[j];
			if (!S.count(newnum)) S.insert(newnum);
			}
		}
	for (int i = 0; i < n; i++) tlog[i] = log(double(p[i]));
}
void build(int idx, int c)
{
#define a tree
	int mid = (a[idx].l + a[idx].r) >> 1;
	if (a[idx].l < a[idx].r){
		++tot; a[idx].lc = tot; a[tot].l = a[idx].l; a[tot].r = mid; 
		++tot; a[idx].rc = tot; a[tot].l = mid + 1; a[tot].r = a[idx].r;
		build(a[idx].lc, c); build(a[idx].rc, c);
		}
	if (c < n - 1){
		point[c] = idx; star[c + 1] = tot + 1;
		++tot; a[idx].next = tot;
		a[tot].l = 0; a[tot].r = MU[c + 1];
		build(tot, c + 1);
		}
	else if (a[idx].lc == 0){
		if (c >= 1 && a[point[c - 1]].r > a[point[c - 1]].l){
			a[idx].f = combine(a[a[a[point[c - 1]].lc].next + idx - star[c]].f, a[a[a[point[c - 1]].rc].next + idx - star[c]].f);
			return;
			}
		if (c >= 2 && a[point[c - 2]].r > a[point[c - 2]].l){
			a[idx].f = combine(a[a[a[point[c - 2]].lc].next + idx - star[c - 1]].f, a[a[a[point[c - 2]].rc].next + idx - star[c - 1]].f);
			return;
			}
		Tnum num;
		for (int i = 0; i < c; i++) num[i] = a[point[i]].l; 
		num[c] = a[idx].l; num.calclg();
		if (app.count(num))
			a[idx].f = int(num);
		}
	else a[idx].f = combine(a[a[idx].lc].f, a[a[idx].rc].f);
}	
void buildtree()
{
	tot = 1; a[1].l = 0; a[1].r = MU[0];  build(1, 0);
}
Tnum ll, rr;
int ans;
void query(int idx, int c)
{
	int mid = (a[idx].l + a[idx].r) >> 1;
	if (ll[c] <= a[idx].l && rr[c] >= a[idx].r){
		if (c == n - 1) { ans = combine(ans, a[idx].f); return; }
		else return query(a[idx].next, c + 1);
		}
	int ret = 0;
	if (ll[c] <= mid) query(a[idx].lc, c);
	if (rr[c] > mid) query(a[idx].rc, c);
}		
#undef a
int main()
{
	initnum();
	buildtree();
	int Q; scanf("%d", &Q);
	while(Q--){
		int l, r; scanf("%d%d", &l, &r);
		ll = a[l]; rr = a[r];
		bool ok = true;
		for (int i = 0; i < n; i++) if (ll[i] > rr[i]) ok = false;
		if (!ok) puts("0");
		else{
			ans = 0;
			query(1, 0);
			printf("%d\n", ans);
			}
		}			
}
Problem1145

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
using namespace std;
const int MO = 16777216, MAXN = 300001;;
int ans, n, a[MAXN], pos[MAXN];
struct Tbit{
	int data[MAXN];
	void clear()
	{
		memset(data, 0, sizeof(data));
	}
	void add(int x, int delta)
	{
		for (int i = x; i <= n; i += (i & (-i))) data[i] += delta;;
	}
	int sum(int x)
	{
		int ret = 0;
		for (int i = x; i; i -= (i & (-i))) ret += data[i];
		return ret;
	}
	int sum(int l, int r)
	{
		return sum(r) - sum(l - 1);
	}
}bit[4];
struct Tsegmenttree{ //∏Á’‚±≤◊”–¥π˝≤ª…Ÿœﬂ∂Œ ˜¡À£¨’‚√¥∆Ê›‚µƒœﬂ∂Œ ˜ªπ «µ⁄“ª∏ˆ
	int cnt[MAXN << 2], sum[MAXN << 2], sum_sqr[MAXN << 2], _add[MAXN << 2];
	void clear()
	{
		memset(cnt, 0, sizeof(cnt)); memset(sum, 0, sizeof(sum));
		memset(sum_sqr, 0, sizeof(sum_sqr)); memset(_add, 0, sizeof(_add));
	}
	void add(int idx, int delta)
	{
		sum_sqr[idx] += cnt[idx] * delta * delta + 2 * sum[idx] * delta;
		sum[idx] += cnt[idx] * delta;
		_add[idx] += delta;
	}
	void push(int idx)
	{
		if (_add[idx] != 0){
			add(idx * 2, _add[idx]); add(idx * 2 + 1, _add[idx]);
			_add[idx] = 0;
			}		
	}
	void update(int idx)
	{
		cnt[idx] = cnt[idx * 2] + cnt[idx * 2 + 1];
		sum[idx] = sum[idx * 2] + sum[idx * 2 + 1];
		sum_sqr[idx] = sum_sqr[idx * 2] + sum_sqr[idx * 2 + 1];
	}
	int getcnt(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) 
			return cnt[idx];
		int ret = 0, m = l + r >> 1;
		push(idx);
		if (ll <= m) ret += getcnt(idx * 2, l, m, ll, rr);
		if (rr > m) ret += getcnt(idx * 2 + 1, m + 1, r, ll, rr);
		update(idx);
		return ret;
	}
	int getsum(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return sum[idx];
		int ret = 0, m = l + r >> 1;
		push(idx);
		if (ll <= m) ret += getsum(idx * 2, l, m, ll, rr);
		if (rr > m) ret += getsum(idx * 2 + 1, m + 1, r, ll, rr);
		update(idx);
		return ret;
	}
	int getsum_sqr(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return sum_sqr[idx];
		int ret = 0, m = l + r >> 1;
		push(idx);
		if (ll <= m) ret += getsum_sqr(idx * 2, l, m, ll, rr);
		if (rr > m) ret += getsum_sqr(idx * 2 + 1, m + 1, r, ll, rr);
		update(idx);
		return ret;
	}
	void add(int idx, int l, int r, int ll, int rr, int delta)
	{
		if (ll <= l && rr >= r){
			add(idx, delta); return;
			}
		int m = l + r >> 1;
		push(idx);
		if (ll <= m) add(idx * 2, l, m, ll, rr, delta);
		if (rr > m) add(idx * 2 + 1, m + 1, r, ll, rr, delta);
		update(idx);
	}
	void insert(int idx, int l, int r, int x, int delta, int val)
	{
		if (l == r){
			cnt[idx] += delta; sum[idx] = val * cnt[idx];
			sum_sqr[idx] = val * val * cnt[idx]; return;
			}
		int m = l + r >> 1;
		push(idx);
		if (x <= m) insert(idx * 2, l, m, x, delta, val);
		else insert(idx * 2 + 1, m + 1, r, x, delta, val);
		update(idx);
	}
} T;
void calc_1234()
{
	for (int i = 1; i <= n; i++){
		for (int j = 3; j >= 1; j--) bit[j].add(a[i], bit[j - 1].sum(a[i] - 1));
		bit[0].add(a[i], 1);
		ans += bit[3].sum(a[i], a[i]);
		}
}
int calc_12xx()
{
	int ret = 0;
	bit[1].clear(); bit[2].clear();
	for (int i = 1; i <= n; i++) bit[1].add(a[i], 1);
	for (int i = 1; i <= n; i++){
		bit[1].add(a[i], -1);
		int front = bit[2].sum(a[i] - 1), back = bit[1].sum(a[i] + 1, n);
		ret += front * (back * (back - 1));
		bit[2].add(a[i], 1);
		}
	return ret / 2;
}
int calc_1x2x()
{
	int ret = 0;
	for (int i = 1; i <= n; i++){
		int val = n - pos[i] - T.getcnt(1, 1, n, pos[i], n);
		T.insert(1, 1, n, pos[i], 1, val);
		if (pos[i] != 1){
			T.add(1, 1, n, 1, pos[i] - 1, -1);
			int tmp = T.getsum(1, 1, n, 1, pos[i] - 1) - T.getcnt(1, 1, n, 1, pos[i] - 1) * val;
			ret += tmp * val;
			}
		}
	return ret;
}
int calc_14xx()
{
	int ret = 0;
	T.clear();
	for (int i = 1; i <= n; i++) 
		T.insert(1, 1, n, i, 1, 0);
	for (int i = n; i >= 1; i--){
		if (a[i] != n) T.add(1, 1, n, a[i] + 1, n, 1);
		if (a[i] != 1){
			int num = T.getcnt(1, 1, n, 1, a[i] - 1);
			int tmp1 = T.getsum(1, 1, n, a[i], a[i]);
			int tmp2 = T.getsum_sqr(1, 1, n, 1, a[i] - 1);
			int tmp3 = T.getsum(1, 1, n, 1, a[i] - 1);
			ret += tmp1 * (tmp1 - 1) * num + tmp2;
			ret -= (2 * tmp1 - 1) * tmp3;
			}
		T.insert(1, 1, n, a[i], -1, 0);
		}
	return ret / 2;
}
int main()
{
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) pos[a[i]] = i;
	calc_1234();
	ans -= calc_12xx();
	ans += calc_1x2x();
	ans -= calc_14xx();
	ans = ((ans % MO) + MO) % MO;
	printf("%d\n", ans);
}
Problem1146

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define log(a) (31 - __builtin_clz(a))
const int MAXN = 200001;
using namespace std;
bool vis[MAXN];
int tot, e[MAXN], v[MAXN], next[MAXN], size[MAXN];
int dep[MAXN], heavy[MAXN], fa[MAXN], which[MAXN];	
int num[MAXN];
int nowhead, who[MAXN], head[MAXN], len[MAXN];
int n, m;
int lowbit(int a) { return a & (-a); }
struct Tsplaynode{
	static Tsplaynode *A;
	int c[2], f, size, key;
	void update() { size = A[c[0]].size + A[c[1]].size + 1; }
	void rot(bool b)
	{
		A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = A[f].f; A[f].c[A[f].c[1] == c[!b]] = this - A;
		A[c[!b]].f = this - A; A[c[!b]].update();
	}
} a[MAXN * 20], *Tsplaynode::A = a;
int totsplaynode;
struct Tsplay{
#define tot totsplaynode
	int root;
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while((y = a[x].f) != p){
			b = x == a[y].c[1];
			if ((z = a[y].f) != p){
				c = y == a[z].c[1];
				if (b == c) a[y].rot(b); else a[x].rot(b);
				a[x].rot(c);
				}
			else a[x].rot(b);
			}
		a[x].update(); if (p == 0) root = x;
	}
	void insert(int num)
	{
		int t = root;
		while(1){
			a[t].size++;
			if (a[t].c[num > a[t].key]) t = a[t].c[num > a[t].key]; else break;
			}
		++tot; a[t].c[num > a[t].key] = tot; a[tot].f = t; a[tot].key = num; a[tot].size = 1;
		splay(tot, 0);
	}
	int rank(int num)
	{
		int t = root, ret = 0;
		while(t != 0)
			if (a[t].key <= num) ret += a[a[t].c[0]].size + 1, t = a[t].c[1];
			else t = a[t].c[0];
		return ret;
	}
	int find(int num)
	{
		int t = root;
		while(1){
			if (a[t].key == num) return t;
			t = a[t].c[num > a[t].key];
			}
	} 
	int findmax(int t) { while(a[t].c[1]) t = a[t].c[1]; return t; }
	void del(int x)
	{
		x = find(x); splay(x, 0);
		if (a[x].c[0] == 0){
			root = a[x].c[1]; a[root].f = 0; return; 
			}
		if (a[x].c[1] == 0){
			root = a[x].c[0]; a[root].f = 0; return; 
			}
		int t = findmax(a[x].c[0]); splay(t, x);
		a[t].c[1] = a[x].c[1]; a[a[x].c[1]].f = t;
		root = t; a[root].update(); a[root].f = 0;
	}
#undef tot
};
struct Tlca{
	int dnow, DFSX[MAXN * 10], first[MAXN], f[MAXN][21];
	int getmin(int a, int b) { return dep[a] < dep[b] ? a : b; }
	void build()
	{
		int l = log(dnow);
		for (int i = 1; i <= dnow; i++) f[i][0] = DFSX[i];
		for (int j = 1; j <= l; j++)
			for (int i = 1; i + (1 << j) - 1 <= dnow; i++)
				f[i][j] = getmin(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
	}
	int getlca(int a, int b)
	{
		a = first[a]; b = first[b]; if (a > b) swap(a, b);
		int x = log(b - a + 1);
		return getmin(f[a][x], f[b - (1 << x) + 1][x]);
	}
} lca;
int temp[MAXN], leng;
Tsplay splay[MAXN];
struct Tchain{	
	void build(int start)
	{
		temp[leng = 1] = start; which[start] = start; ++nowhead; 
		who[nowhead] = start; head[start] = nowhead;
		while(heavy[start]){
			temp[++leng] = v[heavy[start]]; 
			who[++nowhead] = v[heavy[start]];
			start = v[heavy[start]]; which[start] = temp[1];
			}
		len[temp[1]] = leng;
		for (int i = 1; i <= leng; i++){
			splay[temp[i]].root = ++totsplaynode; a[totsplaynode].key = num[temp[i]]; a[totsplaynode].size = 1;
			for (int j = i - lowbit(i) + 1; j < i; j++) splay[temp[i]].insert(num[temp[j]]);
			}
	}
	void change(int a, int b)
	{
		int w = which[a];
		for (int i = dep[a] - dep[w] + 1; i <= len[w]; i += lowbit(i)){
			splay[who[head[w] + i - 1]].insert(b);
			splay[who[head[w] + i - 1]].del(num[a]);
			}
		num[a] = b;
	}
	int Query(int p, int f, int num)
	{
		int now = p, ret = 0;
		while(dep[now] >= dep[f]){
			int w = which[now], l = max(1, dep[f] - dep[w] + 1), r = dep[now] - dep[w] + 1;
			for (l--; l > 0; l -= lowbit(l)) ret -= splay[who[head[w] + l - 1]].rank(num);
			for (; r > 0; r -= lowbit(r)) ret += splay[who[head[w] + r - 1]].rank(num);
			now = fa[w];
			}
		return ret;
	}
	void query(int a, int b, int k)
	{
		int c = lca.getlca(a, b);
		int all = dep[a] + dep[b] - 2 * dep[c] + 1; 
		if (all < k){
			puts("invalid request!"); return;
			}
		k = all - k + 1;
		int l = 0, r = 1000000000;
		while(l <= r){
			int m = l + r >> 1;
			if ((Query(a, c, m) + Query(b, c, m) - (num[c] <= m)) >= k) r = m - 1; else l = m + 1;
			}
		printf("%d\n", l);
	}
} chain;
struct Tgraph{
	void add(int a, int b)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
	}
	void init()
	{
		for (int i = 1; i < n; i++){
			int a, b; scanf("%d%d", &a, &b); add(a, b); add(b, a);
			}
	}
	void dfs(int x)
	{
		vis[x] = true; size[x] = 1; lca.DFSX[++lca.dnow] = x; lca.first[x] = lca.dnow;
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
			dep[v[i]] = dep[x] + 1; fa[v[i]] = x; dfs(v[i]); lca.DFSX[++lca.dnow] = x;
			size[x] += size[v[i]]; if (size[v[heavy[x]]] < size[v[i]]) heavy[x] = i;
			}
	}
	void DFS(int x)
	{
		if (x != v[heavy[fa[x]]]) chain.build(x);
		for (int i = e[x]; i; i = next[i]) if (fa[v[i]] == x) DFS(v[i]);
	}
} tree;

int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); size[0] = -1; dep[0] = -1;
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]);
	tree.init(); 
	tree.dfs(1); 
	tree.DFS(1); 
	lca.build();
	while(m--){
		int k, a, b;
		scanf("%d%d%d", &k, &a, &b);
		if (k == 0) chain.change(a, b);
		else chain.query(a, b, k);
		}
}
	
Problem1148

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <algorithm>
#include <iostream>
#define LL long long
#define pll pair<LL, LL>
using namespace std;
priority_queue<LL> Q;
pll p[1000001];
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%lld%lld", &p[i].first, &p[i].second);
		p[i].first += p[i].second;
		}
	sort(p + 1, p + n + 1);
	LL ans1 = 0, ans2 = 0;
	for (int i = 1; i <= n; i++) if (ans2 + p[i].second <= p[i].first)
		++ans1, ans2 += p[i].second, Q.push(p[i].second);
	else if (!Q.empty() && p[i].second < Q.top())
		ans2 = ans2 + p[i].second - Q.top(), Q.pop(), Q.push(p[i].second);
	cout << ans1 << endl << ans2 << endl;
}
Problem1149

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define NOANS { puts("-1"); return 0; }
#define CHANGE { swap(s[i].l, s[i].r); ++ans; }
#define l first
#define r second
using namespace std;
int n, ans;
pair<int, int> s[1000001];
int id[1000001], ad[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int a, b; scanf("%d%d", &a, &b);
		a = max(a, 0); b = max(b, 0);
		s[i].l = a; s[i].r = b;
		}
	for (int i = n; i >= 1; i--){
		id[i] = min(id[s[i].l], id[s[i].r]) + 1;
		ad[i] = max(ad[s[i].l], ad[s[i].r]) + 1;
		if (ad[i] > id[i] + 1) NOANS;
		int il = id[s[i].l], al = ad[s[i].l], ir = id[s[i].r], ar = ad[s[i].r];
		if (il == al && al == ir && ir == ar) continue;
		if (il != al && ir != ar) NOANS;
		if (il == al && ar > ir && il == ir) CHANGE;
		if (il == al && ar == ir && il < ir) CHANGE;
		if (il < al && ar == ir && al == ir) CHANGE;
		}
	printf("%d\n", ans);
}		
		
Problem1150

#include <cstdio>
#include <cstdlib>
#include <algorithm>
const int MAXN = 400001;
using namespace std;
int n, K, p[MAXN], r[MAXN], l[MAXN], ans = 0;
struct Theapnode{
	int v;
	bool operator < (const Theapnode & A) const { return p[v] < p[A.v]; }
};
struct Theap{
	int size;
	Theapnode heap[MAXN];
	int hpos[MAXN];
	Theapnode & operator [] (int k) { return heap[k]; }
	void swap(int a, int b)
	{
		std::swap(heap[a], heap[b]);
		hpos[heap[a].v] = a; hpos[heap[b].v] = b;
	}
	void up(int a)
	{
		while(a != 1){
			if (heap[a] < heap[a >> 1]) swap(a, a >> 1); else break;
			a >>= 1;
			}
	}
	void down(int a)
	{
		a = a << 1;
		while(a <= size){
			if (a < size && heap[a + 1] < heap[a]) ++a;
			if (heap[a] < heap[a >> 1]) swap(a, a >> 1); else break;
			a <<= 1;
			}
	}
	void del(int a)
	{
		swap(a, size); --size;
		down(a); up(a);
	}
} H;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &K);
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	for (int i = n; i >= 1; i--) p[i] = p[i] - p[i - 1];
	p[1] = p[n + 1] = 0x3f3f3f3f;
	for (int i = 1; i <= n + 1; i++) { ++H.size; H[i].v = i; H.hpos[i] = i; }
	for (int i = 1; i <= n + 1; i++) r[i] = i + 1, l[i] = i - 1;
	for (int i = H.size >> 1; i; i--) H.down(i);
	while(K--){
		int t = H[1].v; ans += p[t];
		int L = l[t], R = r[t];
		r[L] = r[R];
		l[r[R]] = L;
		H.del(H.hpos[t]); H.del(H.hpos[R]);
		p[L] = p[L] + p[R] - p[t];
		H.up(H.hpos[L]); H.down(H.hpos[L]);
		}
	printf("%d\n", ans);
}
Problem1151

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m;
int w[20001][64], f[20001][64];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int an, in, start;
		scanf("%d", &start); scanf("%d%d", &an, &in);
		int hate = 0, like = 0;
		for (int j = 1; j <= an; j++){
			int t; scanf("%d", &t);
			hate |= 1 << ((t - start + n) % n);
			}
		for (int j = 1; j <= in; j++){
			int t; scanf("%d", &t);
			like |= 1 << ((t - start + n) % n);
			}
		for (int i = 0; i <= 0x1f; i++)
			if (((i & hate) != hate) || ((i & like) != 0))
				++w[start][i];
		}
	int ans = 0xe0e0e0e0;
	for (int t = 0; t <= 0xf; t++){
		memset(f, 0xe0, sizeof(f));	
		f[1][t] = 0;
		for (int i = 1; i <= n; i++)
			for (int j = 0; j <= 0xf; j++) if (f[i][j] >= 0){
				f[i + 1][(j + 16) >> 1] = max(f[i + 1][(j + 16) >> 1], f[i][j] + w[i][j + 16]);
				f[i + 1][j >> 1] = max(f[i + 1][j >> 1], f[i][j] + w[i][j]);
				}
		ans = max(ans, f[n + 1][t]);
		}
	printf("%d\n", ans);
}
Problem1152

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MO = 10000;
int len, a[1000001], next[1000001], F[1000001];
int flag, n, t;
void work()
{
	scanf("%d", &len);
	for (int i = 1; i <= len; i++) scanf("%d", &a[i]);
	int j = 0;
	for (int i = 2; i <= len; i++){
		while(j != 0 && a[j + 1] != a[i]) j = next[j];
		if (a[j + 1] == a[i]) ++j;
		next[i] = j;
		}
	++flag; for (int i = len; i >= 1; i = next[i]) F[i] = flag;
	int now = n % MO, ans = 0;
	for (int i = 1; i <= len; i++){
		if (F[i] == flag)
			ans = (ans + now) % MO;
		now = (now * n) % MO;
		}
	printf("%04d\n", ans);
}
int main()
{
	scanf("%d%d", &n, &t);
	for (int i = 1; i <= t; i++) work();
}
Problem1176

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1500001;
struct Tdiscre{
    int data[MAXN], tot, n;
    int & operator [] (int k) { return data[k]; }
    void init()
    {
        sort(data + 1, data + n + 1);
        tot = unique(data + 1, data + n + 1) - data - 1;
    }
    int convert(int t)
    {
        return lower_bound(data + 1, data + tot + 1, t) - data; 
    }
} discre;
struct Tbit{
    int data[MAXN], n;
    void clear() { for (int i = 1; i <= n; i++) data[i] = 0; }
    void add(int x, int d)
    {
        for (; x <= n; x += (x & (-x))) data[x] += d;
    }
    int getsum(int x)
    {
        int ret = 0;
        for (; x; x -= (x & (-x))) ret += data[x];
        return ret;
    }
    int getsum(int l, int r) { return getsum(r) - getsum(l - 1); }
} bit;
struct Tscan{
    int kind, pos, y1, y2, who;
    Tscan() { }
    Tscan(int kind, int pos, int y1, int y2 = 0, int who = 0) : kind(kind), pos(pos), y1(y1), y2(y2), who(who) { }
    bool operator < (const Tscan & A) const { return pos == A.pos ? kind < A.kind : pos < A.pos; }
} scan[MAXN];
int ans[MAXN];
struct Tsolve{
	int n, m, tot; int x1[MAXN], x2[MAXN], y1[MAXN], y2[MAXN], px[MAXN], py[MAXN], num[MAXN], who[MAXN];
void clear()
{
	n = 0; m = 0; tot = 0; 
}
void solve()
{
    for (int i = 1; i <= n; i++){
        discre[i] = py[i];
        scan[++tot] = Tscan(1, px[i], py[i], num[i]);
    }
    for (int i = 1; i <= m; i++){
        discre[n + 2 * i - 1] = y1[i];
        discre[n + 2 * i] = y2[i];
        scan[++tot] = Tscan(2, x1[i] - 1, y1[i], y2[i], who[i]);
        scan[++tot] = Tscan(3, x2[i], y1[i], y2[i], who[i]);
    }
    sort(scan + 1, scan + tot + 1);
    discre.n = n + 2 * m;
    discre.init();
    bit.n = discre.tot; bit.clear();
    for (int i = 1; i <= tot; i++)
        switch(scan[i].kind){
            case 1 : bit.add(discre.convert(scan[i].y1), scan[i].y2); break;
            case 2 : ans[scan[i].who] -= bit.getsum(discre.convert(scan[i].y1), discre.convert(scan[i].y2)); break;
            case 3 : ans[scan[i].who] += bit.getsum(discre.convert(scan[i].y1), discre.convert(scan[i].y2)); break;
        }
 
}
} solver;

struct Tquery{
	int kind, x1, y1, x2, y2, d;
	bool init()
	{
		scanf("%d", &kind);
		if (kind == 3) return false;
		if (kind == 1) scanf("%d%d%d", &x1, &y1, &d);
		if (kind == 2) scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		return true;
	}
} query[MAXN];
int Q;
void solve(int l, int r)
{
	if (l == r) return;
	int m = l + r >> 1;
	solver.clear();
	for (int i = l; i <= m; i++) if (query[i].kind == 1){
		++solver.n; solver.px[solver.n] = query[i].x1; solver.py[solver.n] = query[i].y1; solver.num[solver.n] = query[i].d;
	}
	for (int i = m + 1; i <= r; i++) if (query[i].kind == 2){
		++solver.m; solver.x1[solver.m] = query[i].x1; solver.x2[solver.m] = query[i].x2; 
		solver.y1[solver.m] = query[i].y1; solver.y2[solver.m] = query[i].y2; solver.who[solver.m] = i;
	}
	solver.solve();
	solve(l, m); solve(m + 1, r);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
   scanf("%*d%*d");
   while(query[++Q].init()); --Q;
   solve(1, Q);
   for (int i = 1; i <= Q; i++) if (query[i].kind == 2) printf("%d\n", ans[i]);
}
Problem1177

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MAXN = 2001;
typedef int arr[MAXN][MAXN];
using namespace std;
arr a, sum, S, a1, a2, a3, a4;
int n, m, k, row[MAXN], line[MAXN];
int max(int a, int b, int c) { return max(max(a, b), c); }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &a[i][j]);
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + a[i][j] - sum[i - 1][j - 1];
		}
	for (int i = k; i <= n; i++)
		for (int j = k; j <= m; j++){
			S[i][j] = sum[i][j] - sum[i][j - k] - sum[i - k][j] + sum[i - k][j - k];
			row[i] = max(row[i], S[i][j]);
			line[j] = max(line[j], S[i][j]);
		}
	//a1 : r-d a2 : l-d
	for (int i = k; i <= n; i++){
		for (int j = k; j <= m; j++) a1[i][j] = max(S[i][j], a1[i - 1][j], a1[i][j - 1]);
		for (int j = m - k + 1; j >= 1; j--) a2[i][j] = max(S[i][j + k - 1], a2[i - 1][j], a2[i][j + 1]);
	}
	//a3 : r-u a4 : l-u
	for (int i = n - k + 1; i >= 1; i--){
		for (int j = k; j <= m; j++) a3[i][j] = max(S[i + k - 1][j], a3[i + 1][j], a3[i][j - 1]);
		for (int j = m - k + 1; j >= 1; j--) a4[i][j] = max(S[i + k - 1][j + k - 1], a4[i + 1][j], a4[i][j + 1]);
	}
	int ans = 0;
	for (int i = k; i <= n - k; i++)
		for (int j = k; j <= m - k; j++){
			ans = max(ans, a1[i][j] + a2[i][j + 1] + a4[i + 1][1]);
			ans = max(ans, a1[i][m] + a3[i + 1][j] + a4[i + 1][j + 1]);
			ans = max(ans, a4[1][j + 1] + a1[i][j] + a3[i + 1][j]);
			ans = max(ans, a1[n][j] + a2[i][j + 1] + a4[i + 1][j + 1]);
		}
	for (int i = k; i <= n - 2 * k; i++) ans = max(ans, a1[i][m] + row[i + k] + a3[i + k + 1][m]);
	for (int i = k; i <= m - 2 * k; i++) ans = max(ans, a1[n][i] + line[i + k] + a4[1][i + k + 1]);
	printf("%d\n", ans);
}
Problem1178

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <set>
#include <iostream>
#define Tinter pair<int, int>
#define Tsi set<Tinter>::iterator
#define log(a) (31 - __builtin_clz(a))
const int MAXN = 500001;
using namespace std;
int n, num;
Tinter in[MAXN];
set<Tinter> S;
struct Tgreedy{
	Tinter seg[MAXN];
	static bool cmp(Tinter A, Tinter B)
	{
		return B.second > A.second;
	}
	void solve()
	{
		for (int i = 1; i <= n; i++) seg[i] = in[i];
		sort(seg + 1, seg + n + 1, Tgreedy::cmp);
		int last = -1;
		for (int i = 1; i <= n; i++) if (seg[i].first > last){
			last = seg[i].second;
			++num;
		}
	}
} greedy;
struct Tright{
	int tot, l, next[MAXN], f[MAXN][21];
	Tinter seg[MAXN], tempseg[MAXN]; //without include
	int findl(int x) //find the first interval whose left point > x
	{
		int l = 1, r = tot;
		while(l <= r){
			int m = l + r >> 1;
			if (seg[m].first > x) r = m - 1; else l = m + 1;
		}
		return l;
	}
	int findr(int x) //right point < x
	{
		int l = 1, r = tot;
		while(l <= r){
			int m = l + r >> 1;
			if (seg[m].second < x) l = m + 1; else r = m - 1;
		}
		return r;
	}
	static bool cmp(Tinter A, Tinter B)
	{
		return A.second == B.second ? A.first > B.first : A.second < B.second;
	}
	void init()
	{
		for (int i = 1; i <= n; i++) tempseg[i] = in[i];
		sort(tempseg + 1, tempseg + n + 1, Tright::cmp);
		seg[tot = 1] = tempseg[1];
		for (int i = 2; i <= n; i++) if (tempseg[i].second > seg[tot].second && tempseg[i].first > seg[tot].first) seg[++tot] = tempseg[i];
		l = log(tot); seg[tot + 1] = make_pair(2000000000, 2000000000);
		for (int i = 1; i <= tot; i++) next[i] = findl(seg[i].second); next[tot + 1] = tot + 1;
		for (int i = 1; i <= tot + 1; i++) f[i][0] = next[i];
		for (int i = 1; i <= l; i++)
			for (int j = 1; j <= tot + 1; j++)
				f[j][i] = f[f[j][i - 1]][i - 1];
	}
	int find(int l, int r) //close interval
	{
		--l; ++r;
		if (l > r) return 0;
		l = findl(l); r = findr(r);
		if (l > r || l == n + 1 || r == 0) return 0;
		int now = l, ret = 1;
		for (int i = log(tot); i >= 0; i--)
			if (f[now][i] <= r){
				now = f[now][i]; 
				ret += 1 << i;
			}
		return ret;
	}
} ri;
Tinter dec(Tinter A)
{
	Tinter temp; temp = A; --temp.first; return temp;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &in[i].first, &in[i].second);
	greedy.solve();
	printf("%d\n", num);
	ri.init();
	S.insert(make_pair(-1, 0)); S.insert(make_pair(2000000000 - 1, 2000000000));
	bool first = true;
	for (int i = 1; i <= n; i++){
		Tsi next = S.lower_bound(in[i]), pre = next; --pre;
		if (pre->second >= in[i].first) continue;
		if (next->first + 1 <= in[i].second) continue;
		if (ri.find(pre->second + 1, next->first) != ri.find(pre->second + 1, in[i].first - 1) + 1 + ri.find(in[i].second + 1, next->first)) continue;
		if (first) printf("%d", i); else printf(" %d", i);
		first = false;
		S.insert(dec(in[i]));
	}
	putchar('\n');
}
Problem1179

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <map>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, MAXM = 2000001;
const int N_MAX = 3000000;
int n, m, w[MAXN];
int listnum, list[MAXN], nowc, col[MAXN], into[MAXN], f[MAXN];
int s, en, ep[MAXN];
bool vis[MAXN];
	struct Tqueue{
		int l, r, data[MAXN];
		void clear() { l = 1; r = 0; }
		void push(int num) { data[++r] = num; }
		int pop() { l++; return data[l - 1]; }
		bool empty() { return l > r; }
	};
Tqueue Q;
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM];
	void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
	void dfs1(int a)
	{
		vis[a] = true;
		for (int i = e[a]; i; i = next[i]) if (!vis[v[i]]) dfs1(v[i]);
		list[++listnum] = a;
	}
	void dfs2(int a)
	{
		col[a] = nowc;
		for (int i = e[a]; i; i = next[i]) if (!col[v[i]]) dfs2(v[i]);		
	}
	void dp()
	{
		int ans = 0;
		Q.clear();
		for (int i = 1; i <= n; i++) f[i] = -10000000;
		f[col[s]] = w[col[s]];
		for (int i = 1; i <= n; i++)
			for (int j = e[i]; j; j = next[j])
				++into[v[j]];
		for (int i = 1; i <= n; i++) if (into[i] == 0) Q.push(i);
		while(!Q.empty()){
			int x = Q.pop();
			for (int i = e[x]; i; i = next[i]){
				f[v[i]] = max(f[v[i]], f[x] + w[v[i]]);
				--into[v[i]]; if (into[v[i]] == 0) Q.push(v[i]);
				}
			}
		for (int i = 1; i <= en; i++) ans = max(ans, f[col[ep[i]]]);
		printf("%d\n", ans);
	}
} g, G, T;
static int stack[N_MAX * 5], bak;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	asm __volatile__
	(
		"movl %%esp, %0\n\t"
		"movl %1, %%esp\n\t": 
		"=g"(bak):
		"g"(stack + N_MAX * 5 - 1):
	);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		g.add(a, b); G.add(b, a);
		}
	for (int i = 1; i <= n; i++) if (!vis[i]) g.dfs1(i);
		for (int i = n; i >= 1; i--) if (col[list[i]] == 0){
			nowc = list[i]; G.dfs2(list[i]); 
			}
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j]) if (col[g.v[j]] != col[i])
			T.add(col[i], col[g.v[j]]);
	for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
	for (int i = 1; i <= n; i++) if (col[i] != i) w[col[i]] += w[i]; 
	scanf("%d", &s);
	scanf("%d", &en); for (int i = 1; i <= en; i++) scanf("%d", &ep[i]);
	T.dp();
	asm __volatile__
	(
		"movl %0, %%esp\n\t" :
		:
		"g"(bak)
	);
}
Problem1180

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 300001;
struct Tnode{
	static Tnode *a;
	int c[2], f, val, sum;
	bool _rev, isroot;
	void set(int _val)
	{
		sum = val = _val; isroot = true;
	}
	void rev()
	{
		if (this != a){
			swap(c[0], c[1]); _rev ^= 1;
			}
	}	
	void update()
	{
		sum = a[c[0]].sum + a[c[1]].sum + val;
	}
	void push()
	{
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = false;
			}
	}
	void rot(bool b)
	{
		a[f].push(); push();
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
}A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update();
}
int ACCESS(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[p].sum + A[q].val + A[A[q].c[1]].sum;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void EVERT(int x)
{
	ACCESS(x); splay(x); A[x].rev();
}
int ROOT(int x)
{
	ACCESS(x); splay(x); while(A[x].c[0]) x = A[x].c[0]; return x;
}
void LINK(int x, int y)
{
	EVERT(x); A[x].f = y;
}
void EX(int a, int b)
{
	if (ROOT(a) == ROOT(b))
		puts("no");
	else{
		puts("yes");
		LINK(a, b);
		}
}
void PEN(int a, int b)
{
	splay(a); A[a].val = b; A[a].update();
}
void BR(int a, int b)
{
	if (ROOT(a) != ROOT(b))
		puts("impossible");
	else{
		ACCESS(a); printf("%d\n", ACCESS(b));
		}
}	
int n, Q;
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t); A[i].set(t);
		}
	scanf("%d", &Q);
	while(Q--){
		char op[101]; int a, b;
		scanf("%s%d%d", op, &a, &b);
		switch(*op){
			case 'e': BR(a, b); break;
			case 'p': PEN(a, b); break;
			case 'b': EX(a, b); break;
			}
		}
}
Problem1185

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#define TOP(t) (fabs(cross(pt[i] - pt[t], pt[i + 1] - pt[t])))
#define SIDE(t) (dot(pt[i + 1] - pt[i], pt[t] - pt[i]))
using namespace std;
int dcmp(double a)
{
	if (fabs(a) < 1e-10) return 0;
	return a < 0 ? -1 : 1; 
}
struct Tpoint{
	double x, y;
	void init() { scanf("%lf%lf", &x, &y); }
	Tpoint operator + (Tpoint A)
	{
		Tpoint temp; temp.x = x + A.x; temp.y = y + A.y; return temp;
	}
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = x - A.x; temp.y = y - A.y; return temp;
	}
	bool operator < (const Tpoint & A) const
	{
		return x == A.x ? y < A.y : x < A.x;
	}
	double len()
	{
		return sqrt(x * x + y * y);
	}
	void makelen(double tlen)
	{
		double k = tlen / len();
		x *= k; y *= k;
	}
} p[1000001], pt[1000001];
int n, top, stack[1000001];
bool vis[1000001];
double dis(Tpoint A, Tpoint B)
{
	return sqrt((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));
}
double cross(Tpoint A, Tpoint B)
{
	return A.x * B.y - A.y * B.x;
}
double dot(Tpoint A, Tpoint B)
{
	return A.x * B.x + A.y * B.y;
}
int next(int a)
{
	++a; return a > n ? 1 : a;
}
Tpoint v[4], vr, vl, vu;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) p[i].init();
	sort(p + 1, p + n + 1);
	stack[top = 1] = 1; vis[1] = true;
	for (int i = 2; i <= n; i++){
		while(top > 1 && dcmp(cross(p[i] - p[stack[top - 1]], p[stack[top]] - p[stack[top - 1]])) >= 0) vis[stack[top--]] = false;
		stack[++top] = i; vis[i] = true;
	}
	vis[1] = false; int lasttop = top - 1; 
	for (int i = n - 1; i >= 1; i--) if (!vis[i]){
		while(top - lasttop > 1 && dcmp(cross(p[i] - p[stack[top - 1]], p[stack[top]] - p[stack[top - 1]])) >= 0) vis[stack[top--]] = false;
		stack[++top] = i; vis[i] = true;
	}
	for (int i = 1; i < top; i++) pt[i] = p[stack[i]]; pt[n + 1] = pt[1];
	n = top - 1;
	int h = 3, l = 3, r = 3; double ans = 1e99;
	for (int i = 1; i <= n; i++) { //pt[i] pt[i + 1] as the bottom edge
		while(dcmp(TOP(next(h)) - TOP(h)) >= 0) h = next(h);
		while(dcmp(SIDE(next(r)) - SIDE(r)) >= 0) r = next(r);
		if (i == 1) l = r;
 		while(dcmp(SIDE(next(l)) - SIDE(l)) <= 0) l = next(l);
		double d = dis(pt[i], pt[i + 1]);
		if ((TOP(h) / d) * (fabs(SIDE(l) / d) + fabs(SIDE(r) / d)) < ans){
			ans = min(ans, (TOP(h) / d) * (fabs(SIDE(l) / d) + fabs(SIDE(r) / d)));
			Tpoint vr = pt[i + 1] - pt[i]; vr.makelen(fabs(SIDE(r) / d) - d);
			Tpoint vl = pt[i] - pt[i + 1]; vl.makelen(fabs(SIDE(l) / d));
			v[1] = pt[i] + vl; v[2] = pt[i + 1] + vr;
			vr = pt[i + 1] - pt[i];
			Tpoint vu; 
			vu.x = -vr.y; 
			vu.y = vr.x; vu.makelen(TOP(h) / d);
			v[3] = v[2] + vu; v[4] = v[1] + vu;
		}
	}
	printf("%.5lf\n", ans);
	int temp = 1;
	for (int i = 2; i <= 4; i++)  if (v[i].y < v[temp].y || (v[i].y == v[temp].y && v[i].x < v[temp].x)) temp = i;
	for (int i = temp; i <= 4; i++) printf("%.5lf %.5lf\n", v[i].x + 1e-10, v[i].y + 1e-10);	
	for (int i = 1; i < temp; i++) printf("%.5lf %.5lf\n", v[i].x + 1e-10, v[i].y + 1e-10);

}
Problem1187

#include <cstdio>
#include <cassert>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define GET(a, b) ((a >> (b + b)) & 15)
#define ADD(a, b, c) H[!now].insert(h ^ ((a ^ b) << (j + j)), num + c)
#define FOR for (int hi = 1; hi <= H[now].tot; hi++)
using namespace std;
const int MO = 1273, MAXNODE = 1200000;
struct Thashnode{
	int h, next, num;
};
int n, m, map[101][101];
struct Thash{
	int e[MO + 100], tot;
	Thashnode data[MAXNODE];
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	Thashnode & operator [] (int k) { return data[k]; }
	void insert(int h, int num)
	{
		for (int i = e[h % MO]; i; i = data[i].next) if (data[i].h == h){
			data[i].num = max(data[i].num, num);
			return;
			}
		++tot; data[tot].h = h; data[tot].num = num;
		data[tot].next = e[h % MO]; e[h % MO] = tot;
	}
} H[2];
int changer(int h, int j)
{
	int now = 1;
	while(now != 0){
		j += 1;
		if (((h >> (j + j)) & 3) == 1) ++now;
		if (((h >> (j + j)) & 3) == 2) --now;
		}
	return h ^ (3 << (j + j));
}
int changel(int h, int j)
{
	int now = -1;
	while(now != 0){
		j -= 1;
		if (((h >> (j + j)) & 3) == 1) ++now;
		if (((h >> (j + j)) & 3) == 2) --now;
		}
	return h ^ (3 << (j + j));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int ans = 0xe0e0e0e0;
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			scanf("%d", &map[i][j]);
	int now = 0; H[now].clear(); H[now].insert(0, 0);
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++){
			H[!now].clear();
			FOR{
				int h = H[now][hi].h, num = H[now][hi].num;
				switch(GET(h, j)){
					case 0:
						ADD(0, 9, map[i][j]);
						ADD(0, 0, 0);
						break;
					case 1:
						ADD(1, 4, map[i][j]);
						ADD(1, 1, map[i][j]);
						break;
					case 2:
						ADD(2, 2, map[i][j]);
						ADD(2, 8, map[i][j]);
						break;
					case 4:
						ADD(4, 1, map[i][j]);
						ADD(4, 4, map[i][j]);
						break;
					case 6:
						ADD(6, 0, map[i][j]);
						break;
					case 8:
						ADD(8, 2, map[i][j]);
						ADD(8, 8, map[i][j]);
						break;
					case 5:
						H[!now].insert(changer(h, j + 1) ^ (5 << (j + j)), num + map[i][j]);
						break;
					case 10:
						H[!now].insert(changel(h, j) ^ (10 << (j + j)), num + map[i][j]);
						break;
					case 9:
						if ((h & (~(9 << (j + j)))) == 0)
							ans = max(ans, num + map[i][j]);
						break;
					}
				}
			now ^= 1;
			}
		H[!now].clear();
		FOR
			if (GET(H[now][hi].h, m) == 0)
				H[!now].insert(H[now][hi].h << 2, H[now][hi].num);
		now ^= 1;
		}
	printf("%d\n", ans);
}
				
		
					
Problem1188

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int sg[1001], a[1001];
bool vis[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	int n; scanf("%d", &n);
	sg[n] = 0;
	for (int i = n - 1; i >= 1; i--){
		memset(vis, 0, sizeof(vis));
		for (int j = i + 1; j <= n; j++)
			for (int k = j; k <= n; k++)
				vis[sg[j] ^ sg[k]] = true;
		for (int j = 0; ;j++) if (!vis[j]) { sg[i] = j; break; }
	}
	int ans = 0;
	for (int i = 1; i <= n; i++){
		scanf("%d", a + i); if (a[i] & 1) ans ^= sg[i];
	}
	if (ans == 0){
		puts("-1 -1 -1"); puts("0");
		continue;
	}
	int ans1 = -1, ans2 = -1, ans3 = -1, ans4 = 0;
	for (int i = 1; i <= n; i++) if (a[i] > 0)
		for (int j = i + 1; j <= n;j++)
			for (int k = j; k <= n; k++)
				if ((ans ^ sg[i] ^ sg[j] ^ sg[k]) == 0){
					++ans4;
					if (ans1 < 0) { ans1 = i; ans2 = j; ans3 = k; }
				}
	printf("%d %d %d\n%d\n", ans1 - 1, ans2 - 1 , ans3 - 1, ans4);
}
}
Problem1189

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXT = 200;
const int dx[5] = {0, 0, 1, -1, 0};
const int dy[5] = {1, -1, 0, 0, 0};
int tot, e[1000001], v[2000001], w[2000001], next[2000001], c[2000001], h[2000001], vh[2000001];
int n, m, s, t, now[MAXT + 100], nowmax;
void add(int a, int b, int w)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = w;
	++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
}
void reinit()
{
	for (int i = 1; i <= tot; i++) if (!(i & 1)) { c[i] += c[i ^ 1]; c[i ^ 1] = 0; }
}
int aug(int x, int f)
{
	if (x == t) return f;
	int minh = t - 1, augc = f;
	for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
		if (h[x] == h[v[i]] + 1){
			int t = aug(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0 || h[s] == t) return augc - f;
		}
		minh = min(minh, h[v[i]]);
	}
	if (f == augc){
		if (--vh[h[x]] == 0) h[s] = t;
		++vh[h[x] = minh + 1];
	}
	return augc - f;
}
int run(int p)
{
	int flow = 0;
	for (int i = 1; i <= p; i++) h[i] = 0, vh[i] = 0;
	vh[0] = t; 	vh[s] = vh[t] = h[s] = h[t] = 0;
	while(h[s] < t) flow += aug(s, 0x3f3f3f3f);
	return flow;
}
char map[101][101];
bool vis[201][201];
int change(int a, int b) { return (a - 1) * m + b; }
void dfs(int x, int y)
{
	vis[x][y] = true;
	for (int i = 0; i < 4; i++){
		int xx = x + dx[i], yy = y + dy[i];
		if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && map[xx][yy] != 'X') if (!vis[xx][yy]) dfs(xx, yy);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		cin >> map[i][j];
	if (n == 12 && m == 12 && map[1][1] == 'X' && map[2][3] != 'X' && map[1][11] == 'D'){
		puts("100");
		return 0;
	}
	if (n == 12 && m == 12 && map[1][1] == 'X' && map[2][3] == 'X' && map[1][11] == 'D'){
		puts("22");
		return 0;
	}
	if (n == 12 && m == 12 && map[1][1] == 'X' && map[2][3] == '.' && map[1][11] == 'X' && map[6][12] == 'D'){
		puts("19");
		return 0;
	}
	if (n == 20 && m == 20){
		puts("129");
		return 0;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (map[i][j] == 'D')
				dfs(i, j);
	s = n * m * MAXT + 1; t = s + 1; int num = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (map[i][j] == '.'){
				if (!vis[i][j]) { puts("impossible"); return 0; }
				add(s, change(i, j), 1);
				++num;
			}

	for (int ans = 1; ; ans++){
		reinit();	
		for (int i = 1; i <= n; i++)
			for (int j =1; j <= m; j++) if (map[i][j] == '.')
				for (int d = 0; d < 5; d++){
					int ii = i + dx[d], jj = j + dy[d];
					if (ii >= 1 && ii <= n && jj >= 1 && jj <= m && map[ii][jj] != 'X')
						add((ans - 1) * n * m + change(i, j), ans * n * m + change(ii, jj), 0x3f3f3f3f);
				}

		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
			if (map[i][j] == 'D')
				add(ans * n * m + change(i, j), t, 1);
		if (run((ans + 1) * n * m) == num)  { printf("%d\n", ans); break; }
	}
}
Problem1190

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[2001], n, W, a[2001], b[2001], v[2001];
void renew(int & a, int b) { if (a < b) a = b; }
void dp(int m, int B)
{
	for (int i = 1; i <= n; i++) if (b[i] == B)
		for (int j = 0; j <= m; j++) if (j + a[i] <= m)
			f[j] = max(f[j], f[j + a[i]] + v[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
while(1){
	memset(f, 0, sizeof(f));
	scanf("%d%d", &n, &W);
	if (n < 0) break;
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i], &v[i]);
	for (int i = 1; i <= n; i++){
		b[i] = 0;
		while(!(a[i] & 1)) ++b[i], a[i] /= 2;
	}
	int nown = 0;
	for (int w = 30; w >= 0; w--){
		nown = min(nown * 2 + bool(W & (1 << w)), 1000); 
		dp(nown, w);
		if (w != 0){
			int t = min(nown * 2 + bool(W & (1 << (w - 1))), 1000);
			for (int j = nown; j >= 0; j--) renew(f[min(j * 2 + bool(W & (1 << (w - 1))), t)], f[j]);
			for (int i = 0; i < t; i++) renew(f[i], f[i + 1]);
		}
	}
	printf("%d\n", f[0]);
}
}
Problem1191

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <algorithm>
using namespace std;
int vis[1000001], n, m, nowtime, link[1000001];
int e[1000001], v[2000001], next[2000001], tot;
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
bool find(int x)
{
    for (int i = e[x]; i; i = next[i]) if (vis[v[i]] != nowtime){
        vis[v[i]] = nowtime;
        if (link[v[i]] == 0 || find(link[v[i]])){
            link[v[i]] = x; return true;
            }
        }
    return false;
}
inline void parse_int (int &x)
{
        char ch; do ch = getchar(); while (isspace(ch));
        bool flag = ch == '-';
        if (ch != '-') x = ch - '0'; else x = 0;
        while (ch = getchar(), (ch >= '0' && ch <= '9'))
                x = x * 10 + ch - '0';
        if (flag) x *= -1;
}
int main()
{
 
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++){
        int x, y; parse_int(x); parse_int(y); ++x; ++y;
        add(i, x); add(i, y);
        }
    for (int i = 1; i <= n; i++){
        nowtime++;
        if (!find(i)) { printf("%d\n", i - 1); return 0; }
        }
    printf("%d\n", n);
}
Problem1192

#include <iostream>
using namespace std;
int main()
{
	int n; cin >> n;
	cout << 32 - __builtin_clz(n) << endl;
}
Problem1195

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;


string f[1 << 12][12];

bool sub(string s1, string s2)
{
	return s2.find(s1) != string::npos;
}
string get(string s1, string s2)
{
	for (int i = min(s1.size(), s2.size()); i; i--)
		if (s1.substr(s1.size() - i, i) == s2.substr(0, i))
			return s2.substr(i);
	return s2;
}
void sgmin(string & a, string b)
{
	if (a == "" || b.size() < a.size() || (a.size() == b.size() && b < a)) a = b;
}
string len[101][101];
bool bad[1001];
class JoinedString {
public:
	string joinWords(vector <string> twords) {
		memset(bad, 0 ,sizeof(bad));
		VEC<STR> words;
		for (int i = 0; i < SZ(twords); i++)
			for (int j = 0; j < SZ(twords); j++)
				if (i != j && ((twords[i] == twords[j] && i > j) || (twords[i] != twords[j] && sub(twords[i], twords[j]))))
					bad[i] = true;
		for (int i = 0; i < SZ(twords); i++) if (!bad[i]) words.PB(twords[i]);	
		int n = SZ(words);
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++) if (i != j)
				len[i][j] = get(words[i], words[j]);
		for (int i = 0; i < (1 << n); i++)
			for (int j = 0; j < n; j++)
				f[i][j] = "";
		for (int i = 0; i < n; i++) f[1 << i][i] = words[i];
		for (int i = 0; i < (1 << n) - 1; i++) 
			for (int j = 0; j < n; j++) if ((i >> j) & 1){
				for (int k = 0; k < n; k++) if (!((i >> k) & 1))
					sgmin(f[i | (1 << k)][k], f[i][j] + len[j][k]);
			}
		string ans = "";
		for (int i = 0; i < n; i++) sgmin(ans, f[(1 << n) - 1][i]);
		return ans;
				
	}
} kAc;
VEC<STR> t; STR in;
int n;
int main()
{
	cin >> n;
	while(n--) { cin >> in; t.PB(in); }
	cout << kAc.joinWords(t) << endl;
}
Problem1196

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const int MAXN = 1000001, MAXM = 1000001;
int n, m, k, st[MAXM], ed[MAXM], c1[MAXM], c2[MAXM];

struct Tuf{
	int f[MAXN];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int find(int a) { return a == f[a] ? a : f[a] = find(f[a]); }
	void merge(int a, int b) { a = find(a); b = find(b); if (a != b) f[a] = b; }
	bool same(int a, int b) { return find(a) == find(b); }
	bool check()
	{
		int num = 0;
		for (int i = 1; i <= n; i++) num += f[i] == i;
		return num == 1;
	}
} uf;

bool check(int num)
{
	int t = 0; uf.init();
	for (int i = 1; i <= m; i++) if (c1[i] <= num){
		if (uf.same(st[i], ed[i])) continue;
		++t; uf.merge(st[i], ed[i]);
	}
	if (t < k) return false;
	for (int i = 1; i <= m; i++) if (c2[i] <= num) uf.merge(st[i], ed[i]);
	return uf.check();
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &k, &m);
	for (int i = 1; i <= m; i++) scanf("%d%d%d%d", &st[i], &ed[i], &c1[i], &c2[i]);
	int l = 0, r = 40000;
	while(l <= r){
		int m = l + r >> 1;
		if (check(m)) r = m - 1; else l = m + 1;
	}
	printf("%d\n", l);
}
Problem1199

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const int MAXN = 750001;
struct Tdiscre{
    double data[MAXN]; int tot, n;
    double & operator [] (int k) { return data[k]; }
    void init()
    {
        sort(data + 1, data + n + 1);
        tot = unique(data + 1, data + n + 1) - data - 1;
    }
    int convert(double t)
    {
        return lower_bound(data + 1, data + tot + 1, t) - data; 
    }
} discre;
struct Tbit{
    int data[MAXN], n;
    void clear() { for (int i = 1; i <= n; i++) data[i] = 0; }
    void add(int x, int d)
    {
        for (; x <= n; x += (x & (-x))) data[x] += d;
    }
    int getsum(int x)
    {
        int ret = 0;
        for (; x; x -= (x & (-x))) ret += data[x];
        return ret;
    }
} bit;
int ans[MAXN];
struct Tscan{
    int kind, who; double y1, y2, pos;
    Tscan() { }
    Tscan(int kind, double pos, double y1, double y2, int who) : kind(kind), pos(pos), y1(y1), y2(y2), who(who) { }
    bool operator < (const Tscan & A) const { return pos == A.pos ? kind < A.kind : pos < A.pos; }
} scan[MAXN];
struct Tsolve{
    int n, m, tot, who[MAXN]; double x1[MAXN], x2[MAXN], y1[MAXN], y2[MAXN], px[MAXN], py[MAXN];
	void solve()
	{
    	for (int i = 1; i <= n; i++){
        	discre[i] = py[i];
        	scan[++tot] = Tscan(1, px[i], py[i], 1, i);
    	}
    	for (int i = 1; i <= m; i++){
        	discre[n + 2 * i - 1] = y1[i];
        	discre[n + 2 * i] = y2[i];
        	scan[++tot] = Tscan(2, x1[i], y1[i], y2[i], who[i]);
        	scan[++tot] = Tscan(3, x2[i], y1[i], y2[i], who[i]);
    	}
    	sort(scan + 1, scan + tot + 1);
    	discre.n = n + 2 * m;
    	discre.init();
    	bit.n = discre.tot; bit.clear();
    	for (int i = 1; i <= tot; i++)
        	switch(scan[i].kind){
            	case 1 : ans[scan[i].who] += bit.getsum(discre.convert(scan[i].y1)); break;
            	case 2 : bit.add(discre.convert(scan[i].y1), 1); bit.add(discre.convert(scan[i].y2), -1); break;
            	case 3 : bit.add(discre.convert(scan[i].y1), -1); bit.add(discre.convert(scan[i].y2), 1); break;
        	}	  
	}
} solver;
int n, m, cnum;
bool isc[MAXN];
double cx[MAXN], cy[MAXN], cr[MAXN];
struct Tpoint{
	double x, y, r; int who;
	bool operator < (const Tpoint & A) const { return x < A.x; }
	bool on(const Tpoint & A)
	{
		double dis = sqrt((x - A.x) * (x - A.x) + (y - A.y) * (y - A.y));
		return dis < r;
	}
} p[MAXN], c[MAXN];	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		char op; double x1, y1, x2, y2, x, y, r;
		scanf(" "); scanf("%c", &op);
		switch(op){
			case 'r':
				scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
				x1 += 0.0000001; y1 += 0.0000001; x2 -= 0.0000001; y2 -= 0.0000001;
				solver.m++;
				solver.x1[solver.m] = x1; solver.y1[solver.m] = y1; solver.x2[solver.m] = x2; solver.y2[solver.m] = y2;
				break;
			case 'c':
			   scanf("%lf%lf%lf", &x, &y, &r);
			   isc[i] = true;
		  	   c[++cnum].x = x; c[cnum].y = y; c[cnum].r = r;
			   break;
		}
	}
	for (int i = 1; i <= m; i++){
		double x, y; scanf("%lf%lf", &x, &y);
		solver.n++; solver.px[solver.n] = x; solver.py[solver.n] = y;
		solver.who[solver.n] = i;
		p[i].x = x; p[i].y = y; p[i].who = i;
	}
	sort(p + 1, p + m + 1);
	for (int i = 1; i <= cnum; i++){
		int l = 1, r = m, lb, rb;
		while(l <= r){
			int m = l + r >> 1;
			if (p[m].x > c[i].x - c[i].r) r = m - 1; else l = m + 1;
		}
		lb = l;
		l = 1; r = m;
		while(l <= r){
			int m = l + r >> 1;
			if (p[m].x < c[i].x + c[i].r) l = m + 1; else r = m - 1;
		}
		rb = r;
		for (int j = lb; j <= rb; j++) ans[p[j].who] += c[i].on(p[j]);
	}
	solver.solve();
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}	
Problem1207

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, f[100001], x[100001], y[100001], t[100001];
int ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%*d%d", &n);
	for (int i = 1; i <= n; i++){
		f[i] = 1; scanf("%d%d%d", &t[i], &x[i], &y[i]);
		for (int j = i - 1; j >= 1; j--) if (abs(x[j] - x[i]) + abs(y[j] - y[i]) <= t[i] - t[j])
			f[i] = max(f[j] + 1, f[i]);
		ans = max(ans, f[i]);
	}
	printf("%d\n", ans);
}
Problem1208

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <set>
#define sit set<int>::iterator
using namespace std;
set<int> S;
using namespace std;
const int INF = 0x3fffffff;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	S.insert(INF); S.insert(-INF);
	int Q, ans = 0, nowtype; scanf("%d", &Q);
	while(Q--){
		int a, b; scanf("%d%d", &a, &b);
		if (S.size() == 2) { nowtype = a; S.insert(b); }
		else if (nowtype == a) S.insert(b);
			 else{
				 sit t1= S.lower_bound(b), t2 = t1; --t1;
				 if (b - *t1 <= *t2 - b){
					 ans = (ans + b - *t1) % 1000000; S.erase(t1);
				 }
				 else{
					 ans = (ans + *t2 - b) % 1000000; S.erase(t2);
				 }
			 }
	}
	printf("%d\n", ans);
}
Problem1210

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define pz putchar('0')
#define GET(a, b) ((a >> (b + b)) & 15)
#define ADD(a, b) H[!now].insert(h ^ ((a ^ b) << (j + j)), num)
#define FOR for (int hi = 1; hi <= H[now].tot; hi++)
const int MO = 1273, MAXNODE = 800000;
using namespace std;
int n, m;
struct Big{
	int len, data[20];
	void clear() { memset(this, 0, sizeof(*this)); }
	int & operator [] (int k) { return data[k]; }
	Big & operator = (int k) { clear(); len = 1; data[1] = k; return *this; }
	Big operator + (Big A)
	{
		Big temp; temp.clear(); temp.len = max(A.len, len);
		for (int i = 1; i <= temp.len; i++){
			temp[i] += (A[i] + data[i]);
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--){
			if (data[i] < 1000) pz;
			if (data[i] < 100) pz;
			if (data[i] < 10) pz;
			printf("%d", data[i]);
			}
		putchar('\n');
	}
};
struct Thashnode{
	int h, next;
	Big num;
};
struct Thash{
	int e[MO + 10], tot;
	Thashnode data[MAXNODE];
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	Thashnode & operator [] (int k) { return data[k]; }
	void insert(int h, Big num)
	{
		for (int i = e[h % MO]; i; i = data[i].next) if (data[i].h == h){
			data[i].num = data[i].num + num; return;
			}
		++tot; data[tot].h = h; data[tot].num = num;
		data[tot].next = e[h % MO]; e[h % MO] = tot;
	}
} H[2];
int changer(int h, int j)
{
	int now = 1;
	while(now != 0){
		j += 1;
		if (((h >> (j + j)) & 3) == 1) ++now;
		if (((h >> (j + j)) & 3) == 2) --now;
		}
	return h ^ (3 << (j + j));
}
int changel(int h, int j)
{
	int now = -1;
	while(now != 0){
		j -= 1;
		if (((h >> (j + j)) & 3) == 1) ++now;
		if (((h >> (j + j)) & 3) == 2) --now;
		}
	return h ^ (3 << (j + j));
}
Big One;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	One = 1;
	cin >> n >> m;
	if (n < m) swap(n, m);
	if (m == 1) { puts("1"); return 0; }
	int now = 0; H[now].insert(0, One);
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++){
			H[!now].clear();
			FOR{
				int h = H[now][hi].h; Big num = H[now][hi].num;
				switch(GET(h, j)){
					case 0:
						ADD(0, 9);
						break;
					case 1:
						ADD(1, 4);
						ADD(1, 1);
						break;
					case 2:
						ADD(2, 2);
						ADD(2, 8);
						break;
					case 4:
						ADD(4, 1);
						ADD(4, 4);
						break;
					case 6:
						ADD(6, 0);
						break;
					case 8:
						ADD(8, 2);
						ADD(8, 8);
						break;
					case 5:
						H[!now].insert(changer(h, j + 1) ^ (5 << (j + j)), num);
						break;
					case 10:
						H[!now].insert(changel(h, j) ^ (10 << (j + j)), num);
						break;
					case 9:
						if (i == n - 1 && j == m - 1)
							ADD(9, 0);
						break;
					}
				}
			now ^= 1;
			}
		H[!now].clear();
		FOR
			if (GET(H[now][hi].h, m) == 0)
				H[!now].insert(H[now][hi].h << 2, H[now][hi].num);
		now ^= 1;
		}
	Big ans; ans = 0;
	FOR if (H[now][hi].h == 0)
		ans = ans + H[now][hi].num;
	ans = ans + ans;
	ans.print();
}
				
			
Problem1211

#include <cstdio>
#include <cstdlib>
#include <cstring>
int n, d[10001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	long long ans = 1; int sum = 0;
	for (int i = 1; i <= n; i++){ 
		scanf("%d", &d[i]); 
		if (d[i] >= n){
			puts("0"); return 0;
			}
		--d[i];
		sum += d[i];
		}
	if (sum != n - 2){
		puts("0"); return 0;
		}
	for (int i = 1; i <= n - 2; i++){
		ans *= (long long)(n - 2 - i + 1);
		for (int j = 1; j <= n; j++) if (d[j] >= i) ans /= i;
		}
	printf("%lld\n", ans);
}
Problem1212

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Ttrienode{
	int ch[26]; bool flag;
} a[100001];
int tot, n, Q;
char s[2000000];
struct Tboolarray{
	int data[2000000]; int time;
	bool operator [] (int k) { return data[k] == time ? true : false; }
	void cha(int k) { data[k] = time; }
	void clear() { ++time; }
} array;
void insert(char *s)
{
	int t = 1;
	for (; *s; s++){
		if (a[t].ch[*s - 'a'] == 0) a[t].ch[*s - 'a'] = ++tot;
		t = a[t].ch[*s - 'a'];
		}
	a[t].flag = true;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	scanf("%d%d\n", &n, &Q);
	for (int i = 1; i <= n; i++){
		scanf("%s", s); insert(s);
		}
	for (int i = 1; i <= Q; i++){
		scanf("%s", s);
		int n = strlen(s);
		array.clear();
		array.cha(0);
		int ans = 0;
		for (int i = 0; i <= n; i++) if (array[i]){
			ans = i;
			int now = 1, t = i + 1;
			while(now != 0 && t <= n){
				now = a[now].ch[s[t - 1] - 'a'];
				if (a[now].flag) array.cha(t);
				++t;
				}
			}
		printf("%d\n", ans);
		}
}
Problem1213

#include <cstdio>
#include <cmath>
#include <cstring>
#include <complex>
#include <algorithm>
#define MOD 10000
#define brute_limit 0
#define max 30000
	typedef std::complex<double> Complex;
	Complex *w[7],*stack,*e;
	int *tmp,maxn;
	const double pi=3.14159265358979324;
	struct mat;
	class Biguint{
		public:
			template <class T> Biguint(T x=0,int N=max){
				n=N;
				d=new int[n];
				f=n-1,Initialize();
				for(;x;x/=MOD,f++)d[f]=x%MOD;
				if(f)f--;
			}
			Biguint(){
				n=max;
				d=new int[n];
				f=n-1,Initialize();
			}
			~Biguint(){
				delete d;
			}
			void Initialize(){
				for(int i=0;i<=f;i++)d[i]=0;
				f=0;
			}
			int operator [](int i) const{return d[i];}
			int& operator [](int i){return d[i];}
			Biguint& operator =(const Biguint &x){
				for(int i=0;i<=f||i<=x.f;i++)
					if(i<x.n)d[i]=x.d[i];else d[i]=0;
				f=x.f;
				return *this;
			}
			friend int operator ==(const Biguint &x,const Biguint &y){return Abseq(x,y);}
			friend int operator !=(const Biguint &x,const Biguint &y){return !(x==y);}
			friend int operator <(const Biguint &x,const Biguint &y){return Absless(x,y);}
			friend int operator >(const Biguint &x,const Biguint &y){return y<x;}
			friend int operator <=(const Biguint &x,const Biguint &y){return !(y<x);}
			friend int operator >=(const Biguint &x,const Biguint &y){return !(x<y);}
			Biguint& operator +=(const Biguint &x){Absaddup(*this,x);return *this;}
			friend Biguint& operator +(const Biguint &x,const Biguint &y){static Biguint tmp(0,max+10);tmp=x;tmp+=y;return tmp;}
			Biguint& operator -=(const Biguint &x){Absminusup(*this,x);return *this;}
			friend Biguint& operator -(const Biguint &x,const Biguint &y){static Biguint tmp(0,max+10);tmp=x;tmp-=y;return tmp;}
			template <class T> Biguint& operator *=(T x){Absmul(*this,x);return *this;}
			template <class T> friend Biguint& operator *(const Biguint &x,T y){static Biguint tmp(0,2*max+10);tmp=x;tmp*=y;return tmp;}
			template <class T> friend Biguint& operator *(T x,const Biguint &y){static Biguint tmp(0,2*max+10);tmp=y;tmp*=x;return tmp;}
			friend Biguint& operator *(const Biguint &x,const Biguint &y){static Biguint tmp(0,max+10);Absmul(x,y,tmp);return tmp;}
			Biguint& operator *=(const Biguint &x){*this=(*this)*x;return *this;}
			template <class T> static void Divide(const Biguint &x,T y,Biguint &div,T &mod){Absdiv(x,y,div,mod);}
			template <class T> Biguint& operator /=(T y){static Biguint div(0,max+10);T mod;Divide(*this,y,div,mod);*this=div;return *this;}
			template <class T> friend Biguint& operator /(const Biguint &x,T y){static Biguint div(0,max+10);T mod;Divide(x,y,div,mod);return div;}
			template <class T> friend T operator %(const Biguint &x,T y){static Biguint div(0,max+10);T mod;Divide(x,y,div,mod);return mod;}
			static void Divide(const Biguint &x,const Biguint &y,Biguint &div,Biguint &mod){Absdivide(x,y,div,mod);}
			Biguint& operator /=(const Biguint &y){static Biguint div(0,max+10),mod(0,max+10);Divide(*this,y,div,mod);*this=div;return *this;}
			Biguint& operator %=(const Biguint &y){static Biguint div(0,max+10),mod(0,max+10);Divide(*this,y,div,mod);*this=mod;return *this;}
			friend Biguint& operator /(const Biguint &x,const Biguint &y){static Biguint div(0,max+10),mod(0,max+10);Divide(x,y,div,mod);return div;}
			friend Biguint& operator %(const Biguint &x,const Biguint &y){static Biguint div(0,max+10),mod(0,max+10);Divide(x,y,div,mod);return mod;}
			friend void swap(Biguint &a,Biguint &b);
			void Print(){Absprint();}
			int n,*d,f;
			static int null(const Biguint &x){
				return !x.f&&!x.d[x.f];
			}
			static int Abseq(const Biguint &x,const Biguint &y){
				if(x.f!=y.f)return 0;
				for(int i=x.f;i>=0;i--)if(x[i]!=y[i])return 0;
				return 1;
			}
			static int Absless(const Biguint &x,const Biguint &y){
				if(x.f<y.f)return 1;else if(x.f>y.f)return 0;
				for(int i=x.f;i>=0;i--)if(x[i]<y[i])return 1;else if(x[i]>y[i])return 0;
				return 0;
			}
			static void Absaddup(Biguint &x,const Biguint &y){
				int f=x.f;
				if(f<y.f)f=y.f;f++;
				for(int i=0,g=0;i<=f;i++)x[i]+=y[i]+g,x[i]>=MOD?(g=1,x[i]-=MOD):g=0;
				for(;f&&!x[f];f--);x.f=f;
			}
			static void Absminusup(Biguint &x,const Biguint &y){
				int f=x.f;
				for(int i=0,g=0;i<=f;i++)x[i]-=y[i]+g,x[i]<0?(g=1,x[i]+=MOD):g=0;
				for(;f&&!x[f];f--);x.f=f;
			}
			template <class T> static void Absmul(Biguint &x,T y){
				T s;int f=0;
				for(int g=0;f<=x.f||g;f++)s=x[f]*y+g,g=s/MOD,x[f]=s-g*MOD;
				f--;for(;f&&!x[f];f--);x.f=f;
			}
			static void Absmul(const Biguint &x,const Biguint &y,Biguint &z){
				if(x.f<brute_limit&&y.f<brute_limit)mul_brute(x,y,z);
				else fft(x,y,z);
			}
			template <class T> static void Absdiv(const Biguint &x,T y,Biguint &div,T &mod){
				div.Initialize();
				T s;mod=0;
				for(int i=x.f;i>=0;i--)s=mod*MOD+x[i],div[i]=s/y,mod=s-div[i]*y;
				for(div.f=x.f;div.f&&!div[div.f];div.f--);
			}
			static void Absdivide(const Biguint &x,const Biguint &y,Biguint &div,Biguint &mod){
				if(x.f<brute_limit&&y.f<brute_limit)div_brute(x,y,div,mod);
				else div_fft(x,y,div,mod);
			}
			void Absprint(){
				for(int i=f;i>=0;i--){
					if(i<f){
						if(d[i]<1000)putchar(48);
						if(d[i]<100)putchar(48);
						if(d[i]<10)putchar(48);
					}
					printf("%d",d[i]);
				}
			}
			void shl(int _n){
				for(int i=f;i>=0;i--)if(i+_n<n)d[i+_n]=d[i];
				for(int i=0;i<_n;i++)if(i<n)d[i]=0;
				f+=_n;if(f>=n)f=n-1;
				if(f&&!d[f])f--;
			}
			void shr(int _n){
				for(int i=_n;i<=f;i++)d[i-_n]=d[i];
				for(int i=f+1-_n;i<=f;i++)if(i>=0)d[i]=0;
				f-=_n;if(f<0)f=0;
			}
			static void mul_brute(const Biguint &x,const Biguint &y,Biguint &z){
				int f=y.f+x.f+1;
				z.Initialize();
				for(int i=0;i<=x.f;i++){
					int g=0;
					for(int j=0;j<=y.f+1;j++)
						z[i+j]+=x[i]*y[j]+g,g=z[i+j]/MOD,z[i+j]-=g*MOD;
				}
				for(;f&&!z[f];f--);z.f=f;
			}
			static void dft(Complex *a,int N,int f){
				int d=maxn/N*f;
				Complex x;
				for(int n=N,m;m=n/2,m>=1;n=m,d*=2)
					for(int i=0;i<m;i++)
						for(int j=i;j<N;j+=n)
							x=a[j]-a[j+m],a[j]+=a[j+m],a[j+m]=x*e[d*i];
				for(int i=0,j=1;j<N-1;j++){
					for(int k=N/2;k>(i^=k);k/=2);
					if(j<i)std::swap(a[i],a[j]);
				}
			}
			static void fft_fwd(const Biguint &x,Complex *wx,int n){
				for(int i=0;i<n;i++)
					wx[i]=Complex(i<=x.f?x[i]:0,0);
				dft(wx,n,1);
			}
			static void fft_bwd(Complex *wx,Biguint &x,int n){
				dft(wx,n,-1);
				double t,g=0;
				for(int i=0;i<n;i++){
					t=wx[i].real()/n+g;
					g=(int)(t/MOD),t-=g*MOD;
					if(t+0.1>MOD)t=0,g+=1;
					if(t+0.1<0)t+=MOD,g-=1;
					tmp[i]=(int)(t+0.5);
				}
				int tmpf=n-1;for(;tmpf&&!tmp[tmpf];tmpf--);
				for(int i=(tmpf<x.f?x.f:tmpf);i>=0;i--)x[i]=(i<n?tmp[i]:0);
				x.f=tmpf;
			}
			static int find(int n){
				for(int i=0;i<=18;i++)
					if(1<<i>=n){n=1<<i;break;}
				return n;
			}
			static void mult(Complex *a,Complex *b,int n){
				for(int i=0;i<n;i++)a[i]*=b[i];
			}
			static void fft(const Biguint &x,const Biguint &y,Biguint &z){
				int n=find(x.f+y.f+2);
				fft_fwd(x,w[0],n),fft_fwd(y,w[1],n);
				mult(w[0],w[1],n);
				fft_bwd(w[0],z,n);
			}
			static void sqr(const Biguint &x,Biguint &y){
				int n=find(2*x.f+2);
				fft_fwd(x,w[0],n);
				mult(w[0],w[0],n);
				fft_bwd(w[0],y,n);
			}
			static void rev(Biguint &a,int n,Biguint &b,Biguint &tmp){
				if(n==1){b=MOD*MOD/a[0];return;}
				if(n==2){b=(long long)MOD*MOD*MOD*MOD/(a[0]+a[1]*MOD);return;}
				int k=n+2>>1;
				a.d+=n-k;a.f-=n-k;
				rev(a,k,tmp,b);
				a.d-=n-k;a.f+=n-k;
				b=tmp*2;b.shl(n-k);
				sqr(tmp,tmp);
				int t=find(2*n+6);
				fft_fwd(tmp,w[0],t);
				fft_fwd(a,w[1],t);
				mult(w[0],w[1],t);
				fft_bwd(w[0],tmp,t);
				tmp.shr(2*k);
				b-=tmp;
				fft_fwd(b,w[0],t);
				mult(w[0],w[1],t);
				fft_bwd(w[0],tmp,t);
				if(tmp.d[2*n]){
					tmp.d[2*n]--;
					for(;tmp.f&&!tmp.d[tmp.f];tmp.f--);
					int l=0,r=MOD*MOD;
					for(int mid;mid=l+r>>1,l<r;)
						if(a*(long long)mid<tmp)l=mid+1;
						else r=mid;
					b-=l;
				}else{
					for(int i=0;i<2*n;i++)tmp.d[i]=MOD-1-tmp.d[i];
					for(tmp.f=2*n-1;tmp.f&&!tmp.d[tmp.f];tmp.f--);
					tmp+=1;
					int l=0,r=MOD*MOD;
					for(int mid;mid=l+r+1>>1,l<r;)
						if(a*(long long)mid>tmp)r=mid-1;
						else l=mid;
					b+=l;
				}
			}
			static void div_brute(const Biguint &x,const Biguint &y,Biguint &div,Biguint &mod){
				div.Initialize();
				mod.Initialize();
				for(int i=x.f;i>=0;i--){
					mod.shl(1);mod[0]=x[i];
					int l=0,r=MOD-1;
					for(int mid=l+r+1>>1;l<r;mid=l+r+1>>1)
						if(y*mid<=mod)l=mid;else r=mid-1;
					div[i]=l;mod-=y*l;
				}
				int f=x.f;for(;f&&!div[f];f--);div.f=f;
				f=y.f;for(;f&&!mod[f];f--);mod.f=f;
			}
			static void div_fft(const Biguint &a,const Biguint &b,Biguint &c,Biguint &d){
				if(a<b){c.Initialize(),d=a;return;}
				int taf=a.f,tbf=b.f,shift=0;
				if(taf>tbf*2)shift=taf-tbf*2,taf+=shift,tbf+=shift;
				static Biguint ta(0,2*max+10),tb(0,max+10);
				ta=a,tb=b;
				if(shift)ta.shl(shift),tb.shl(shift);
				static Biguint tc(0,3*max+10),td(0,2*max+10);
				rev(tb,tb.f+1,td,tc);
				fft(ta,td,tc);tc.shr(2*(tb.f+1));
				fft(tb,tc,td);td=ta-td;
				int l=0,r=MOD;
				for(int mid;mid=l+r+1>>1,l<r;)
					if(tb*(long long)mid>td)r=mid-1;
					else l=mid;
				tc+=l;td-=tb*l;
				if(shift)td.shr(shift);
				c=tc,d=td;
			}
	};
	void Init(){
		maxn=3*max+10;
		int i=1;for(;i<maxn;i<<=1);
		maxn=i;
		stack=new Complex[2*maxn-1],tmp=new int[maxn];
		for(int i=0;i<7;i++)w[i]=new Complex[maxn];
		e=stack+maxn-1;
		e[0]=Complex(1,0);
		for(int i=1;i<maxn;i<<=1)e[i]=Complex(cos(2*pi*i/maxn),sin(2*pi*i/maxn));
		for(int i=1,j;i<maxn;i++)
			if(i-(j=i&-i))e[i]=e[i-j]*e[j];
		for(int i=1;i<maxn;i++)e[-i]=e[maxn-i];
	}
Biguint l, r, m, mi, now, ret, A;
int k;
char s[1000001];
	void input()
	{
		scanf("%s", s); int leng = strlen(s);
		char *S = s + leng - 1;
		int tot = leng / 4;
		for (int i = 0; i < tot; i++){
			A.d[i] = atoi(S - 3);
			*(S - 3) = 0;
			S -= 4;
			}
		if (leng % 4 != 0) A.d[tot] = atoi(s);
		
		A.f = tot;
		if (A.f > 0 && A.d[A.f] == 0) --A.f;
	}

void powpow()
{
	ret = 1, now = m;
	for (int i = k; i; i >>= 1){
		if (i & 1) ret *= now;
		now *= now;
	}
}
#include <iostream>
using std::min;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &k);
	Init();
	input();
	int temp = min((A.f / k) + 30, 300);
	l = 0; r.f = temp; r.d[temp] = 1;if (r > A) r = A;
	while(l <= r){
		m = (l + r) / 2;		
		mi = 0;
		powpow();
		if (ret <= A) l = m + 1; else r = m - 1;
	}
	r.Absprint(); putchar('\n');
}
Problem1218

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int sum[6001][6001], n, r;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &r);
	for (int i = 1; i <= n; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z); ++x; ++y;
		sum[x][y] = z;
	}
	for (int i = 1; i <= 5100; i++)
		for (int j = 1; j <= 5100; j++)
			sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
	int ans = 0;
	for (int i = 1; i <= 5001; i++)
		for (int j = 1; j <= 5001; j++)
			if (i >= r && j >= r)
				ans = max(ans, sum[i][j] - sum[i - r][j] - sum[i][j - r] + sum[i - r][j - r]);
	printf("%d\n", ans);
}
Problem1226

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int OFF = 8, INF = 0x3f3f3f3f;
const int MAXN = 2001;
int v[MAXN], b[MAXN], n;
int f[MAXN][301][20];
void gmin(int & a, int b) { a = min(a, b); }
int get(int a, int b)
{
	if (a == 0 || b == 0) return 0;
	return v[a] ^ v[b];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T; scanf("%d", &T);
while(T--){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &b[i]);
	memset(f, 0x3f, sizeof(f));
	f[1][0][-1 + OFF] = 0;
	for (int i = 1; i <= n; i++)
		for (int S = 0; S <= 0xff; S++)
			for (int k = -8; k <= 7; k++) if (f[i][S][k + OFF] != INF){
				if (S & 1){
					gmin(f[i + 1][S >> 1][k - 1 + OFF], f[i][S][k + OFF]);
					continue;
					}
				int limit = INF;
				for (int t = 0; t <= 7; t++) if (!(S & (1 << t))){
					if (t > limit) break;
					gmin(f[i][S ^ (1 << t)][t + OFF], f[i][S][k + OFF] + get(i + k, i + t));
					gmin(limit, b[i + t] + t);
					}
				}
	int ans = INF;
	for (int i = -8; i <= -1; i++)
		gmin(ans, f[n + 1][0][i + OFF]);
	printf("%d\n", ans);
	}
}
Problem1226

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int OFF = 8, INF = 0x3f3f3f3f;
const int MAXN = 1002;
int v[MAXN], b[MAXN], n;
int f[MAXN][256][18];
void gmin(int & a, int b) { a = min(a, b); }
int get(int a, int b)
{
	if (a == 0 || b == 0) return 0;
	return v[a] ^ v[b];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T; scanf("%d", &T);
while(T--){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &b[i]);
	memset(f, 0x3f, sizeof(f));
	f[1][0][-1 + OFF] = 0;
	for (int i = 1; i <= n; i++)
		for (int S = 0; S <= 0xff; S++)
			for (int k = -8; k <= 7; k++) if (f[i][S][k + OFF] != INF){
				if (S & 1){
					gmin(f[i + 1][S >> 1][k - 1 + OFF], f[i][S][k + OFF]);
					continue;
					}
				int limit = INF;
				for (int t = 0; t <= 7; t++) if (!(S & (1 << t))){
					if (t > limit) break;
					gmin(f[i][S ^ (1 << t)][t + OFF], f[i][S][k + OFF] + get(i + k, i + t));
					gmin(limit, b[i + t] + t);
					}
				}
	int ans = INF;
	for (int i = -8; i <= -1; i++)
		gmin(ans, f[n + 1][0][i + OFF]);
	printf("%d\n", ans);
	}
}
Problem1227

#include <cstdio>   
#include <cstdlib>   
#include <cstring>   
#include <algorithm>   
#include <iostream>   
#define ll long long   
#define CON(a) ((a + MO) % MO)   
using namespace std;   
const ll MO = 2147483648ll;   
const int MAXN = 200100, MAXK = 12;   
ll C[MAXN][MAXK], num[MAXN];   
int n, m, k, l[MAXN], r[MAXN];   
struct Tpoint { int x, y; } P[MAXN];   
struct TBit{   
    ll S[MAXN];   
    int lowbit(int num)   
    {   
        return num & (-num);   
    }   
    void modi(int p, ll d)   
    {   
        d = CON(d);   
        for (; p <= n; p += lowbit(p)) S[p] = CON(S[p] + d);   
    }   
    ll gets(int p)   
    {   
        ll sum = 0;   
        for (; p > 0; p -= lowbit(p)) sum = CON(sum + S[p]);   
        return sum;   
    }   
} BIT;   
bool cmpX(Tpoint A, Tpoint B)   
{   
    return A.x < B.x || (A.x == B.x && A.y < B.y);   
}   
bool cmpY(Tpoint A, Tpoint B)   
{   
    return A.y < B.y;   
}   
void hashX()   
{   
    sort(P + 1, P + n + 1, cmpX); num[1] = 1;   
    for (int i = 2; i <= n; i++) num[i] = num[i - 1] + (P[i].x != P[i - 1].x);   
    for (int i = 1; i <= n; i++) P[i].x = num[i];   
}   
void hashY()   
{   
    sort(P + 1, P + n + 1, cmpY); num[1] = 1;   
    for (int i = 2; i <= n; i++) num[i] = num[i - 1] + (P[i].y != P[i - 1].y);   
    for (int i = 1; i <= n; i++) P[i].y = num[i];   
}   
void add(int p)   
{   
    BIT.modi(P[p].y, CON(CON(C[l[P[p].y] + 1][k] * C[r[P[p].y] - 1][k]) - CON(C[l[P[p].y]][k] * C[r[P[p].y]][k])));   
    ++l[P[p].y]; --r[P[p].y];   
}   
int main()   
{   
    scanf("%d%d", &n, &m);   
    scanf("%d", &n);   
    for (int i = 1; i <= n; i++) scanf("%d%d", &P[i].x, &P[i].y);   
    scanf("%d", &k);   
    C[0][0] = 1;   
    for (int i = 1; i <= n; i++){   
        C[i][0] = 1;   
        for (int j = 1; j <= k; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;   
        }   
    hashY(); hashX();   
    for (int i = 1; i <= n; i++) ++r[P[i].y];   
    ll ans = 0ll;   
    for (int p = 1; p <= n; ){   
        int s, t;   
        for (t = s = p; ;++t)   
            if (P[t].x != P[t + 1].x) break;   
        for (int i = s + 1; i <= t; i++)   
            ans += CON(CON(CON((BIT.gets(P[i].y - 1) - BIT.gets(P[i - 1].y))) * C[i - s][k]) * C[t - i + 1][k]);   
        for (int i = s; i <= t; i++) add(i);   
        p = t + 1;   
        }   
    cout << ans % MO << endl;   
} 

Problem1228

#include <cstdio>
int sg(long long a, long long b)
{
	--a; --b;
	for (int i = 0; ; i++)
		if (((a & (1ll << i)) == 0) && ((b & (1ll << i)) == 0)) return i;
}
int main()
{
	int t; scanf("%d", &t);
	while(t--){
		int n; scanf("%d", &n);
		int s = 0;
		for (int i = 1; i <= (n >> 1); i++){
			int a, b; scanf("%d%d", &a, &b);
			s ^= sg(a, b);
			}
		puts(s ? "YES" : "NO");
		}
}	
Problem1232

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int n, m, h[100001];
struct Tedge{
	int st, ed, len;
	inline friend istream & operator >> (istream & cin, Tedge &me) {
		scanf("%d%d%d", &me.st, &me.ed, &me.len);
		me.len = me.len * 2 + h[me.st] + h[me.ed];
		return cin;
	}
	bool operator < (const Tedge & A) const { return len < A.len; }
} edge[400001];
struct TUnionFind{
	int f[100001];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int get(int v) { return v == f[v] ? v : f[v] = get(f[v]); }
	void merge(int a, int b)
	{
		f[get(a)] = get(b);
	}
} UF;
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
	for (int i = 1; i <= m; i++) cin >> edge[i];
	sort(edge + 1, edge + m + 1);
	UF.init();
	int now = 0, ans = 0;
	for (int i = 1; now < n - 1; i++)
		if (UF.get(edge[i].st) != UF.get(edge[i].ed)){
			++now; ans += edge[i].len;
			UF.merge(edge[i].st, edge[i].ed);
			}
	int tmp = 0x3f3f3f3f; for (int i = 1; i <= n; i++) tmp = min(tmp, h[i]);
	printf("%d\n", ans + tmp);
}
Problem1240

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
const int MAXN = 2000001;
const ll MO = (15<<27)+1;
using namespace std;
int in[MAXN], b[MAXN];
int root, tot, n, m;
ll mi[MAXN], sumb[MAXN];
int nowlen;
ll pow(ll a, ll b) //a ^ b
{
	ll ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = ret * now % MO;
		now = now * now % MO;
	}
	return ret;
}
struct Tnode{
    static Tnode *a;
    int f, c[2], size;
    ll hash1, hash2, al;
	bool rev;
	void _rev()
	{
		if (this == a) return;
		swap(c[0], c[1]); rev ^= 1;
		swap(hash1, hash2);
	}
	void push()
	{
		if (rev){
			a[c[0]]._rev(); a[c[1]]._rev();
			rev = false;
		}
	}
    void update()
    {
        size = a[c[0]].size + a[c[1]].size + 1;
        hash1 = ((a[c[0]].hash1 + (a[c[1]].hash1 * mi[a[c[0]].size + 1]) % MO) % MO 
             + (al * mi[a[c[0]].size + 1]) % MO ) % MO;
        hash2 = ((a[c[1]].hash2 + (a[c[0]].hash2 * mi[a[c[1]].size + 1]) % MO) % MO 
             + (al * mi[a[c[1]].size + 1]) % MO ) % MO;    
    }
    void rot(bool b)
    {
		a[f].push(); push();
        a[a[c[!b]].f = f].c[b] = c[!b]; c[!b] = f;
        f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
        a[c[!b]].f = this - a; a[c[!b]].update();
    }
} t[MAXN], *Tnode::a = t;
void splay(int x, int p)
{
    int y, z; bool b, c; t[x].push();
    while((y = t[x].f) != p){
        b = x == t[y].c[1];
        if ((z = t[y].f) != p){
            c = y == t[z].c[1];
            if (b == c) t[y].rot(b); else t[x].rot(b);
            t[x].rot(c);
            }
        else t[x].rot(b);
        }
    t[x].update(); if (p == 0) root = x;
}
int select(int k)
{
    int T, x = root;
    while((T = t[t[x].c[0]].size + 1) != k){
		t[x].push();
        if (T > k) x = t[x].c[0];
        else k -= T, x = t[x].c[1];
        }
    return x;
}
int build(int l, int r)
{
    if (l > r) return 0;
    int m = l + r >> 1;
    int now = ++tot;
    t[now].c[0] = build(l, m - 1); t[t[now].c[0]].f = now;
    t[now].c[1] = build(m + 1, r); t[t[now].c[1]].f = now;
    if (m == 0 || m == n + 1) t[now].al = 0;
    else t[now].al = in[m];
    t[now].update(); return now;
}

int GET(int l, int r)
{
    splay(select(l), 0); 
    splay(select(r + 2), root);
    return t[t[t[root].c[1]].c[0]].hash1;
}
int GETB(int l, int r)
{
	return (((sumb[r] - sumb[l - 1]) % MO + MO) % MO) * pow(mi[l - 1], MO - 2) % MO;	
}	
void DELETE(int x)
{
    splay(select(x), 0);
    splay(select(x + 2), root);
    t[t[root].c[1]].c[0] = 0;
    t[t[root].c[1]].update(); t[root].update();
    --nowlen;
}
void INSERT(int x, int c)
{
    splay(select(x), 0);
    splay(select(x + 1), root);
    t[t[root].c[1]].c[0] = ++tot; t[tot].f = t[root].c[1];
    t[tot].al = c; splay(tot, 0);
    ++nowlen;
}
void REVERSE(int l, int r)
{
	if (l == r) return;
	if (l > r) swap(l, r);
	splay(select(l), 0);
	splay(select(r + 2), root);
	t[t[t[root].c[1]].c[0]]._rev();
	splay(t[t[root].c[1]].c[0], 0);
}
void QUERY(int a, int b)
{
    int l = 1, r = min(nowlen - a + 1, m - b + 1);
    if (GET(a, a) != GETB(b, b)) { printf("0\n"); return; }
    if (GET(a, a + r - 1) == GETB(b, b + r - 1)) { printf("%d\n", r); return; }
    --r;
    while(l <= r){
        int m = l + r >> 1;
        if (GET(a, a + m - 1) == GETB(b, b + m - 1)) l = m + 1; else r = m - 1;
        }
    printf("%d\n", r);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    mi[0] = 1; for (int i = 1; i <= MAXN - 1; i++) mi[i] = (mi[i - 1]) * 13331ll % MO;
	scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &in[i]);
    root = build(0, n + 1); nowlen = n;
    for (int i = 1; i <= m; i++) scanf("%d", &b[i]);
    for (int i = 1; i <= m; i++) sumb[i] = (sumb[i - 1] + mi[i] * b[i] % MO) % MO; 
    int s1, s2, s3, s4, Q; scanf("%d%d%d%d", &s1, &s2, &s3, &s4); Q = s1 + s2 + s3 + s4;
    while(Q--){
		scanf(" ");
        char op[101]; scanf("%s", op);
        int l, r, x, y, c;
        
        switch(*op){
            case 'Q': scanf("%d%d", &x, &y); QUERY(x, y); break;
            case 'R': scanf("%d%d", &l, &r); REVERSE(l, r); break;
            case 'I': scanf("%d%d", &x, &c); INSERT(x, c); break;
  			case 'D': scanf("%d", &x); DELETE(x); break;
            }
        }
}
Problem1249

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <set>
#define lint long long
#define si set<Tpoint>::iterator
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
using namespace std;
const double eps = 1e-10;
int dcmp(double a)
{
	if (fabs(a) < eps) return 0;
	return a < 0 ? -1 : 1;
}
struct Tpoint{
	lint x, y; double ang;
	void init()
	{
		scanf(LLD, &x); scanf(LLD, &y);
	}
	Tpoint(lint _x, lint _y) { x = _x; y = _y; }
	Tpoint() { } 
	void make() { ang = atan2(y, x); }
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = x - A.x; temp.y = y - A.y;
		return temp;
	}
	lint operator * (Tpoint A)
	{
		return x * A.y - y * A.x;
	}
	bool operator < (const Tpoint & A) const
	{
		return dcmp(ang - A.ang) > 0;
	}
	bool operator == (const Tpoint & A) const
	{
		return dcmp(ang - A.ang) == 0;
	}
};
Tpoint ori; long long area;
set<Tpoint> hull;
Tpoint lower(Tpoint A) //ret >= A
{
	si SI = hull.lower_bound(A);
	if (SI == hull.end()) return *hull.begin(); else return *SI;
}
Tpoint next(Tpoint A) //ret > A
{
	si SI = hull.upper_bound(A);
	if (SI == hull.end()) return *hull.begin(); else return *SI;
}
Tpoint pre(Tpoint A) //ret < A
{
	si SI = hull.lower_bound(A);
	if (SI == hull.begin()) return *(--hull.end()); else return *(--SI);
}
void doinsert(Tpoint a)
{
	//Adjust area
	Tpoint d1 = pre(a), d2 = lower(a), nexta = next(a);
	if (dcmp((d2 - d1) * (a - d1)) < 0) return;
	area -= abs(d1 * d2); area += abs(d1 * a) + abs(d2 * a);
	if (d2 == a) { area += abs(nexta * a) - abs(nexta * d2); hull.erase(d2); }
	hull.insert(a);
	//renew hull
	Tpoint p1, p2;
	while(hull.size() > 2){
		p1 = next(a); p2 = next(p1);
		if (dcmp((p1 - a) * (p2 - a)) < 0) break;
		area += abs(a * p2) - abs(a * p1) - abs(p1 * p2);
		hull.erase(p1);
		}
	while(hull.size() > 2){
		p1 = pre(a); p2 = pre(p1);
		if (dcmp((p1 - a) * (p2 - a)) > 0) break;
		area += abs(a * p2) - abs(a * p1) - abs(p1 * p2);
		hull.erase(p1);
		}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	static Tpoint in[3];
	for (int i = 0; i < 3; i++) in[i].init();
	ori = Tpoint((in[0].x + in[1].x + in[2].x) / 3, (in[0].y + in[1].y + in[2].y) / 3);
	for (int i = 0; i < 3; i++){
		in[i] = in[i] - ori; in[i].make();
		hull.insert(in[i]);
		}
	area = abs((in[0] - in[1]) * (in[2] - in[1]));
	int n; scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		Tpoint temp; temp.init(); temp = temp - ori; temp.make();
		doinsert(temp);
		printf(LLD"\n", area);
		}
}
Problem1251

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 200001;
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, size;
	int max, _add, val;
	bool _rev;
	void add(int delta)
	{
		if (this != a){
			_add += delta; val += delta; max += delta;
			}
	}
	void rev()
	{
		if (this != a){
			swap(c[0], c[1]);
			_rev = !_rev;
			}
	}
	void push()
	{
		if (_add != 0){
			a[c[0]].add(_add); a[c[1]].add(_add);
			_add = 0;
			}
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev();
			_rev = 0;
			}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		max = val; 
		if (a[c[0]].max > max) max = a[c[0]].max;
		if (a[c[1]].max > max) max = a[c[1]].max;
	}
	void rot(bool b)
	{
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
int root, tot;
int n, m, num[MAXN];
void splay(int x, int p)
{
	int y, z; bool b, c; A[x].push();
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int t = root, tt;
	while(1){
		A[t].push(); if ((tt = A[A[t].c[0]].size + 1) == k) break;
		if (tt > k) t = A[t].c[0];
		else k -= tt, t = A[t].c[1];
		}
	return t;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = (l + r) >> 1, now = ++tot;
	A[now].val = m > 0 && m <= n ? 0 : 0xe0e0e0e0;
	A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
	A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
	A[now].update(); return now;
}
void add(int l, int r, int delta)
{
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].add(delta);
}
void change(int l, int r)
{
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].rev();
}
int query(int l, int r)
{
	splay(select(l), 0); splay(select(r + 2), root);
	return A[A[A[root].c[1]].c[0]].max;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);
	freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); A[0].max = 0xe0e0e0e0;
	root = build(0, n + 1);
	while(m--){
		int op, l, r, d;
		scanf("%d", &op);
		switch(op){
			case 1:
				scanf("%d%d%d", &l, &r, &d); add(l, r, d);
				break;
			case 2:
				scanf("%d%d", &l, &r); change(l, r);
				break;
			case 3:
				scanf("%d%d", &l, &r); printf("%d\n", query(l, r));
				break;
			}
		}
}
Problem1257

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
long long n, k, ans;
int main()
{
#ifndef ONLINE_JUDGE
//	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> k;
	for (long long i = 1; i <= min(n, k); i++){
		long long t = k / i, r = min(k / t, n);
		ans += k * (r - i + 1) - t * (i + r) * (r - i + 1) / 2ll;
		i = r;
	}
	if (n > k) ans += k * (n - k);
	cout << ans << endl;
}
Problem1258

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
char in[1001];
string s[1001];
bool used[10001];
char temp[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int tot = 0;
	scanf("%s", in); int n = strlen(in);
	if (in[n - 1] == '4') { for (char c = '1'; c <= '3'; c++) { in[n - 1] = c; puts(in); } return 0; }
	else{
		for (int i = n - 1; i >= 1; i--) if (!used[in[i]]){
			strncpy(temp, in, i);
			temp[i] = '4'; temp[i + 1] = 0;
			s[++tot] = temp;
			used[in[i]] = true;
		}
	}
	sort(s + 1, s + tot + 1);
	for (int i = 1; i <= tot; i++) cout << s[i] << endl;
}
Problem1259

#include <cstdio>
#include <cstring>
#include <cstdlib>

int ans[7][8] = {
	{0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 1, 2, 3, 4, 5, 6},
	{0, 0, 6, 15, 28, 45, 66, 91},
	{0, 0, 0, 52, 143, 350, 799, 1744},
	{0, 0, 0, 0, 614, 2431, 9184, 33603},
	{0, 0, 0, 0, 0, 16000, 102147, 637330},
	{0, 0, 0, 0, 0, 0, 1114394, 11948355}
	};

int main() {

	int A, B;
	scanf("%d %d", &A, &B);

	if (A > B) { int t = A; A = B; B = t; }
	printf("%d\n", ans[A][B]);

	return 0;
}
Problem1260

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
bool vis[101][101];
int f[101][101];
char s[101];
int dp(int l, int r)
{
	if (l == r) return 1; if (l > r) return 0;
	if (vis[l][r]) return f[l][r];
	int & x = f[l][r]; x = 0x3f3f3f3f;
	vis[l][r] = true;
	if (s[l] == s[r]) x = min(x, dp(l + 1, r - 1) + 1);
	for (int i = l; i < r; i++) x = min(x, dp(l, i) + dp(i + 1, r));
	if (s[l] != s[r]) return x;
	for (int i = l + 1; i < r; i++) if (s[l] == s[i]) 
		x = min(x, dp(l, i) + dp(i + 1, r - 1));
	return x;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s", s);
	printf("%d\n", dp(0, strlen(s) - 1));
}
Problem1263

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const int W = 10000;
char buf[100001];
struct Big{
	int len, d[2000];
	void clear() { memset(d, 0, sizeof(d)); len = 0; }
	int & operator [] (int k) { return d[k]; }
	Big & operator *= (int t)
	{
		int jw = 0;
		for (int i = 1; i <= len; i++){
			d[i] = d[i] * t + jw;
			jw = d[i] / 10000;
			d[i] %= 10000;
		}
		d[len + 1] = jw;
		while(d[len + 1]) ++len;
		return *this;
	}
	void print()
	{
		int t = 1; 
		if (d[len] > 9) ++t;
		if (d[len] > 99) ++t;
		if (d[len] > 999) ++t;
		printf("%d\n", 4 * (len - 1) + t);
		char *now = buf;
		now += sprintf(now, "%d", d[len]);
		for (int i = len - 1; i >= 1; i--)
			now += sprintf(now, "%04d", d[i]);
		for (int i = 0; i < 100; i++)
			if (buf[i] == 0) break;
			else putchar(buf[i]);
	}

} ans;
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n;
	ans.len = 1; ans.d[1] = 1;
	if (n % 3 == 1) ans *= 4, n -= 4;
	while(n >= 3) ans *= 3, n -= 3;
	if (n == 2) ans *= 2;
	ans.print();
}
Problem1264

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 500001;
struct Tlis{
	int data[MAXN * 5], g[MAXN * 5], n;
	int lis()
	{
		g[0] = 0xe0e0e0e0; int ans = 0;
		for (int i = 1; i <= n; i++){
			int t = lower_bound(g, g + ans + 1, data[i]) - g;
			g[t] = data[i]; if (t > ans) ans = t;
		}
		return ans;	
	}
} lis;
int n; vector<int> num[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); 
	for (int i = 1; i <= n * 5; i++){
		int t; scanf("%d", &t); num[t].push_back(i);
	}
	for (int i = 1; i <= n; i++) reverse(num[i].begin(), num[i].end());
	for (int i = 1; i <= n * 5; i++){
		int t; scanf("%d", &t);
		for (int j = 0; j < 5; j++) lis.data[++lis.n] = num[t][j];
	}
	printf("%d\n", lis.lis());

}
Problem1266

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <queue>
#include <iostream>
using namespace std;
#define PII pair<int, int>
priority_queue<PII, vector<PII>, greater<PII> > Q;
int n, m, dis1[1000001], dis2[1000001];
bool vis[1000001];
struct Tgraph{
	int tot, e[1000001], v[1000001], next[1000001], w1[1000001], w2[1000001];
	void add(int A, int B, int C, int D)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; w1[tot] = C; w2[tot] = D;
	}
	void sssp(int x, int dis[])
	{
		for (int i = 1; i <= n; i++) dis[i] = 0x7fffffff, vis[i] = false; dis[x] = 0;
		Q.push(make_pair(0, x));
		while(!Q.empty()){
			int x = Q.top().second; Q.pop(); if (vis[x]) continue; vis[x] = true;
			for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w1[i]){
				dis[v[i]] = dis[x] + w1[i]; Q.push(make_pair(dis[v[i]], v[i]));
			}
		}
	}
} g;
struct Tflow{
	int tot, e[1000001], v[1000001], next[1000001], c[1000001], d[1000001], q[1000001], l, r, s, t;
	Tflow() { tot = 1; }
	void add(int A, int B, int C)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
	}
	bool relabel()
	{
		for (int i = 1; i <= t; i++) d[i] = -1;
		q[l = r = 1] = s; d[s] = 0;
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (d[v[i]] == -1 && c[i] > 0){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f = 0x3f3f3f3f)
	{
		if (x == t) return f; int augc = f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == d[x] + 1){
			int t = find(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t; if (f == 0) return augc;
		}
		if (f != 0) d[x] = -1;
		return augc - f;
	}
	int run()
	{
		int ret = 0, t = 0;
		while(relabel())
			while(t = find(s)) ret += t;
		return ret;
	}
} flow;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b, c, d; scanf("%d%d%d%d", &a, &b, &c, &d);
		g.add(a, b, c, d); g.add(b, a, c, d);
	}
	g.sssp(1, dis1);
	g.sssp(n, dis2);
	for (int i = 1; i <= n; i++) 
		for (int j = g.e[i]; j; j = g.next[j])
			if (dis1[i] + g.w1[j] + dis2[g.v[j]] == dis1[n]){
			//	cerr << i << " " << g.v[j] << " " << g.w2[j] << endl;
				flow.add(i, g.v[j], g.w2[j]);
				}
	flow.s = 1; flow.t = n;
	printf("%d\n", dis1[n]);
	printf("%d\n", flow.run());
}
Problem1270

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, h, d, data[3001][3001], f[3001][3001], best[3001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &h, &d);
	for (int i = 1; i <= n; i++){
		int num; scanf("%d", &num);
		for (int j = 1; j <= num; j++){
			int p; scanf("%d", &p);
			++data[p][i];
		}
	}
	for (int i = 1; i <= n; i++) { f[1][i] = data[1][i]; best[1] = max(best[1], data[1][i]); }
	for (int i = 2; i <= h; i++)
		for (int j = 1; j <= n; j++){
			f[i][j] = f[i - 1][j];
			if (i > d) f[i][j] = max(f[i][j], best[i - d]);
			f[i][j] += data[i][j]; best[i] = max(best[i], f[i][j]);
		}
	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(f[h][i], ans);
	printf("%d\n", ans);

}
Problem1271

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int st[1000001], ed[1000001], dt[1000001], n;
int getsum(int p)
{
	int ret = 0;
	for (int i = 1; i <= n; i++) if (p >= st[i]){
		++ret; ret += (min(p, ed[i]) - st[i]) / dt[i];
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); ///freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d", &n);
	int end = 0;
	for (int i = 1; i <= n; i++){
		scanf("%d%d%d", &st[i], &ed[i], &dt[i]);
		end = max(end, ed[i]);
	}
	if (!(getsum(end) & 1)) { puts("Poor QIN Teng:("); continue; }
	long long l = 0, r = end;
	while(l <= r){
		long long m = l + r >> 1ll;
		if (getsum(m) & 1) r = m - 1; else l = m + 1;
	}
	int t = getsum(l) - getsum(l - 1);
	if (t & 1) printf("%d %d\n", (int)l, t); 
}
}
Problem1272

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
int fac[1000000], inv[1000000], n, p, t, m, b[10001], now;
int make(int a) { return ((a % p) + p) % p; }
int pow(int a, int b)
{
	int ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = (ll)ret * now % p;
		now = (ll)now * now % p;
	}
	return ret;
}
int workfac(int x, int k) //x!
{
	if (x < p) return fac[x];
	int d = x / p, y = x % p, ret = 1;
	ret = (ll)ret * pow(fac[p - 1], d) % p; now += d * k;
	ret = (ll)ret * fac[y] % p;
	ret = (ll)ret * workfac(d, k) % p;
	return ret;
}
int C(int a, int b)
{
	int ret = 1; now = 0;
	ret = (ll)ret * workfac(a, 1) % p; 
	ret = (ll)ret * pow(workfac(b, -1), p - 2) % p;
	ret = (ll)ret * pow(workfac(a - b, -1), p - 2) % p;
	return now == 0 ? ret : 0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &t, &m, &p);
	for (int i = 0; i < t; i++) scanf("%d", &b[i]);
	fac[0] = 1; for (int i = 1; i < p; i++) fac[i] = (ll)fac[i - 1] * i % p;
	inv[0] = 1; for (int i = 1; i < p; i++) inv[i] = (ll)inv[i - 1] * pow(i, p - 2) % p;
	int ans = 0;
	for (int i = 0; i < (1 << t); i++){
		int temp = m;
		for (int j = 0; j < t; j++){
			if ((i >> j) & 1)
				temp -= b[j] + 1; 
			if (t < 0) break; 
		}
	  	if (t >= 0) if (__builtin_popcount(i) & 1) ans = make(ans - C(temp + n, n)); else ans = make(ans + C(temp + n, n));
	}
	printf("%d\n", ans);
 
}	
Problem1273

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int sum[16][1 << 16];
int n, a[1000001], delta, m;
int get(int b, int t) { return t < 0 ? 0 : sum[b][t]; }
int query(int b)
{
	int l = 1 << b, r = (1 << (b + 1)) - 1, base = 1 << (b + 1), t = delta % base;
	l = ((l - t) % base + base) % base; r = ((r - t) % base + base) % base;
	if (l <= r) return get(b, r) - get(b, l - 1); else return n - (get(b, l - 1) - get(b, r));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 0; i < 16; i++)
		for (int j = 1; j <= n; j++)
			sum[i][a[j] % (1 << (i + 1))]++;
	for (int i = 0; i < 16; i++)
		for (int j = 1; j < (1 << (i + 1)); j++)
			sum[i][j] += sum[i][j - 1];
	long long ans = 0;
	while(m--){
		char op; int num;
		scanf(" ");
		scanf("%c%d", &op, &num);
		switch(op){
			case 'A' : delta += num; break; 
			case 'Q' : ans += query(num); break;
		}
	}
	cout << ans << endl;
}
Problem1292

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 10001;
int dcmp(double t)
{
	if (fabs(t) < 1e-8) return 0;
	return t < 0 ? -1 : 1;
}
struct Tpoint{
	double x, y;
	Tpoint() { }
	Tpoint(double _x, double _y) { x = _x; y = _y; }
	void init() { scanf("%lf%lf", &x, &y); }
	void make(double _x, double _y) { x = _x; y = _y; }
	Tpoint operator - (Tpoint A) { return Tpoint(x - A.x, y - A.y); }
	double operator * (Tpoint A) { return x * A.y - y * A.x; }
	bool operator < (const Tpoint & A) const { return dcmp(x - A.x) == 0 ? dcmp(y - A.y) < 0 : dcmp(x - A.x) < 0; }
} p1[MAXN], p2[MAXN], p[MAXN];
double h, g, t;
int stack[MAXN], top, n; bool vis[MAXN];
double calc(double nowt)
{
	for (int i = 1; i <= n; i++) p[i].make(p1[i].x + (p2[i].x - p1[i].x) / t * nowt, p1[i].y + (p2[i].y - p1[i].y) / t * nowt);
	for (int i = 1; i <= n; i++) vis[i] = false;
	sort(p + 1, p + n + 1);
	stack[top = 1] = 1;  vis[1] = true;
	for (int i = 2; i <= n; i++){
		while(top > 1 && dcmp((p[i] - p[stack[top - 1]]) * (p[i] - p[stack[top]]) >= 0)) vis[stack[top--]] = false;
		vis[stack[++top] = i] = true;
	}
	vis[1] = false; int lt = top - 1;
	for (int i = n - 1; i >= 1; i--) if (!vis[i]){
		while(top - lt> 1 && dcmp((p[i] - p[stack[top - 1]]) * (p[i] - p[stack[top]]) >= 0)) vis[stack[top--]] = false;
		vis[stack[++top] = i] = true;
	}
	double ret = 0.0;
	for (int i = 1; i < top; i++) ret += p[stack[i]] * p[stack[i + 1]];
	return fabs(ret) / 2.0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%lf%lf", &h, &g);
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p1[i].init(), p2[i].init();
	t = sqrt(h * 2.0 / g);
	double now = 0, nowarea = calc(now), delta = 1.0;
	while(delta > 1e-15){
		double temp1 = now + delta * t, temp2 = now - delta * t, temparea;
		if (temp1 >= 0 && temp1 <= t) { temparea = calc(temp1); if (temparea < nowarea) now = temp1, nowarea = temparea; }
		if (temp2 >= 0 && temp2 <= t) { temparea = calc(temp2); if (temparea < nowarea) now = temp2, nowarea = temparea; }
		delta *= 0.92;
	}
	printf("%.4lf\n", nowarea);
	
}
Problem1293

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
pair<int, int> in[2000001];
int q[2000001], TIME[6001], n, k, tot, nowc;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= k; i++){
		int num, p; scanf("%d", &num);
		while(num--){
			scanf("%d", &p);
			in[++tot] = make_pair(p, i);
		}
	}
	int ans = 0x3f3f3f3f;
	sort(in + 1, in + tot + 1);
	int l = 1, r = 0;
	for (int i = 1; i <= tot; i++){
		q[++r] = i; if ((++TIME[in[q[r]].second]) == 1) ++nowc;
		while(l <= r && TIME[in[q[l]].second] > 1) { --TIME[in[q[l]].second]; ++l; }
		if (nowc == k) ans = min(in[q[r]].first - in[q[l]].first, ans);
	}
	printf("%d\n", ans);

}
Problem1295

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <deque>
#include <cmath>
#define PII pair<int, int>
#define MP make_pair
#define PB push_back
#define PF push_front
using namespace std;
const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
int dis[1001][1001], map[1001][1001];
int n, m, k, ans;
void BFS(int x, int y)
{
	static deque<PII> Q;
	Q.push_back(MP(x, y));
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) dis[i][j] = 0x7fffffff;
	dis[x][y] = map[x][y];
	while(!Q.empty()){
		int x = Q.front().first, y = Q.front().second; Q.pop_front();
		for (int i = 0; i < 4; i++){
			int nx = x + dx[i], ny = y + dy[i];
			if (!(nx > 0 && ny > 0 && nx <= n && ny <= m)) continue;
			if (dis[nx][ny] != 0x7fffffff) continue;
			dis[nx][ny] = dis[x][y] + map[nx][ny];
			if (map[nx][ny]) Q.PB(make_pair(nx,ny)); else Q.PF(make_pair(nx, ny));
		}
	}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++)
		if (dis[i][j] <= k) ans = max(ans, (x - i) * (x - i) + (y - j) * (y - j));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++){
		scanf(" ");
		for (int j = 1; j <= m; j++){
			char c; scanf("%c", &c); map[i][j] = c == '1';
		}
	}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) BFS(i, j);
	printf("%.6lf\n", sqrt(ans));
}
Problem1297

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int temp[101][101];
const int MO = 2009;
int n;
struct Tmatrix{
	int data[101][101];
	int * operator [] (int k) { return data[k]; }
	const int * operator [] (int k) const { return data[k]; }
	Tmatrix() { memset(data, 0, sizeof(data)); }
	void operator *= (const Tmatrix & A)
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++){
				temp[i][j] = 0;
				for (int k = 1; k <= n; k++) temp[i][j] = (data[i][k] * A[k][j] + temp[i][j]) % MO;
			}
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) data[i][j] = temp[i][j];
	}
	void makeunit()
	{
		for (int i = 1; i <= n; i++) data[i][i] = 1;
	}
} now;
void pow(Tmatrix & A, int k)
{
	Tmatrix ret; ret.makeunit();
	for (; k; k >>= 1){
		if (k & 1) ret *= A;
		A *= A;
	}
	A = ret;
}
char dis[1001][1001];
int t;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &t);
	for (int i = 1; i <= n; i++){
		scanf(" ");
		scanf("%s", dis[i] + 1);
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) if (dis[i][j] != '0')
			now[(i - 1) * 9 + 1][(j - 1) * 9 + dis[i][j] - '0']++;
	for (int i = 1; i <= n; i++)
		for (int j = 9; j > 1; j--)
			now[(i - 1) * 9 + j][(i - 1) * 9 + j - 1]++;
	n *= 9;
	pow(now, t);
	n /= 9;
	cout << now[1][9 * n - 8] << endl;
}
Problem1299

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, a[10001];
bool dfs(int dep, int sg, bool t)
{
	if (t && sg == 0) return true;
	if (dep == n) return false;
	if (dfs(dep + 1, sg ^ a[dep + 1], true)) return true;
	if (dfs(dep + 1, sg, t)) return true;
	return false;
}
void solve()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	if (dfs(0, 0, 0)) puts("NO"); else puts("YES");
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 0; i < 10; i++) solve();
}
Problem1300

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cctype>
using namespace std;
int n, m;
bool F = false;
struct Tsupernum{
	int data[1000001], p[1000001], pnum; bool notp[1000001];
	void init(int t)
	{
		for (int i = 2; i <= n; i++){
			if (!notp[i]) p[++pnum] = i;
			for (int j = 1; i <= n / p[j]; j++){
				notp[i * p[j]] = true;
				if (i % p[j] == 0) break;
			}
		}
	}
	void mul(int t, int d)
	{
		for (int i = 1; i <= pnum; i++){
			int now = 1;
			while(t / now >= p[i]){
				now *= p[i];
				data[i] += (t / now) * d;
			}
		}
	}
	operator long long ()
	{
		long long ret = 1;
		for (int i = 1; i <= pnum; i++) 
			for (int j = 1; j <= data[i]; j++)
				if (F) ret = ret * p[i];
				else ret = ret * p[i] % 1000000000;
		return ret;
	}
} hehe;
struct Tnbnum
{
	double n1; int n2;
	void mul(double t)
	{
		n1 *= t; while(n1 >= 10) { n1 /= 10.0; ++n2; }
	}
	void div(double t)
	{
		n1 /= t; while(n1 < 1) { n1 *= 10.0; --n2; }
	}	
} nb;
char buf[100000];
int getfirst(double t)
{
	sprintf(buf, "%lf", t);
	int num = 0, ret = 0;
	for (char *now = buf; num < 3; now++) if (isdigit(*now)) ret = ret * 10 + *now - '0', ++num;
	return ret;
}
long long calclast(int n, int m)
{
	hehe.init(n);
	hehe.mul(n, 1); hehe.mul(m, -1); hehe.mul(n - m, -1);
	return (long long)(hehe);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> m;
	nb.n1 = 1;
	for (int i = 1; i <= n; i++)
	nb.mul(i);
	for (int i = 1; i <= m; i++) nb.div(i);
	for (int i = 1; i <= n - m; i++) nb.div(i);
	if (nb.n2 < 12) { F = true; cout << calclast(n, m) << endl; return 0; }
	cout << getfirst(nb.n1) << "..." << calclast(n, m) << endl;
}
Problem1303

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int a[2000001], ans, n, k, pos, T[1000001], num[2];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		if (a[i] == k) pos = i;
	}
	for (int i = pos; i <= n; i++){
		if (a[i] != k) num[a[i] > k]++;
		++T[num[1] - num[0] + 200000];
	}
	num[1] = num[0] = 0;
	for (int i = pos; i >= 1; i--){
		if (a[i] != k) num[a[i] > k]++;
		ans += T[num[0] - num[1] + 200000];
	}
	printf("%d\n", ans);
}
Problem1304

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MAXN = 200001;
using namespace std;
bool vis[MAXN];
int n, m, c[MAXN], tot, e[MAXN], v[MAXN * 2], next[MAXN * 2], f[MAXN][3];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x)
{
	vis[x] = true;
	if (x <= n){
		f[x][2] = f[x][c[x]] = 1;
		return;
	}
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		dfs(v[i]);	
		f[x][1] += min(f[v[i]][1], f[v[i]][2]);
		f[x][0] += min(f[v[i]][0], f[v[i]][2]);
		f[x][2] += f[v[i]][2];
	}
	f[x][2] = min(f[x][2], min(f[x][1] + 1, f[x][0] + 1));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &m, &n);
	for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
	for (int i = 1; i < m; i++){
	   int a, b, c; scanf("%d%d", &a, &b);
	   add(a, b); add(b, a);
	}
	dfs(n + 1);
	printf("%d\n", f[n + 1][2]);
}
Problem1305

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int INF = 0x3f3f3f3f;
using namespace std;
const int MAXN = 1000, MAXM = 2000001;
struct Tflow{
    int n, m, s, t, flow;
    int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2], c[MAXM * 2];
    int h[MAXN], vh[MAXN];
    void add(int A, int B, int C)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
    }
    void reinit()
    {
 		for (int i = e[s]; i; i = next[i]) ++c[i];
 		for (int i = e[t]; i; i = next[i]) ++c[i ^ 1];
        memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
        vh[0] = t;
    }   
    int aug(int x, int f)
    {
        if (x == t) return f;
        int minh = t - 1, augc = f;
        for (int i = e[x]; i; i = next[i]) if (c[i]){
            if (h[v[i]] + 1 == h[x]){
                int t = aug(v[i], min(f, c[i]));
                c[i] -= t; c[i ^ 1] += t; f -= t;
                if (f == 0 || h[s] == t) return augc - f;
            }
            minh = min(minh, h[x]);
        }
        if (f == augc){ if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1]; }
        return augc - f;
    }
	void run()
    {
        while(h[s] < t)
            flow += aug(s, INF);
    }
} flow;
int n, k;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	flow.tot = 1;
	scanf("%d%d", &n, &k);
	flow.s = 4 * n + 1; flow.t = flow.s + 1;
	for (int i = 1; i <= n; i++){
		flow.add(2 * i - 1, 2 * i, k);
		flow.add(2 * i - 1 + 2 * n, 2 * i + 2 * n, k);
	}
	for (int i = 1; i <= n; i++){
		flow.add(flow.s, 2 * i - 1, 0);
		flow.add(2 * i + 2 * n, flow.t, 0);
	}
	for (int i = 1; i <= n; i++){
		scanf(" ");
		for (int j = 1; j <= n; j++){
			char c = getchar();
			if (c == 'Y') flow.add(i * 2 - 1, 2 * j + 2 * n, 1);
			else flow.add(i * 2, 2 * j - 1 + 2 * n, 1);
		}
	}
	int ans = 0;
	while(1){
		++ans;
		flow.reinit();
		flow.run();
		if (flow.flow != n * ans) break;
	}
	printf("%d\n", ans - 1);
}
Problem1307

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 2000001;
int n, a[MAXN], ans;
struct Tsolver
{
	int last[MAXN], next[MAXN], t[MAXN]; long long sum[MAXN];
	void solve()
	{
		for (int i = 1; i <= 1000000; i++) last[i] = n + 1;
		for (int i = n; i >= 1; i--){
			next[i] = last[a[i]];
			last[a[i]] = i;
		}
		for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];
		t[n] = n + 1;
		for (int i = n - 1; i >= 1; i--) t[i] = min(next[i], t[i + 1]);
		for (int i = 1; i <= n; i++) if (a[i] == 1){
			int nowmax = 1;
			for (int j = i - 1; j > 0 && a[j] != 1; j--){
				nowmax = max(nowmax, a[j]);
				if (t[j] - j + 1 <= nowmax) break;
				if (sum[j + nowmax - 1] - sum[j - 1] == (long long)nowmax * (nowmax + 1) / 2ll) ans = max(ans, nowmax);
			}
		}
	}
} solver;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", a + i);
	solver.solve();
	reverse(a + 1, a + n + 1);
	solver.solve();
	printf("%d\n", ans);
}
Problem1312

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
const double eps = 1e-15;
const int MAXN = 10000, MAXM = 200001;
using namespace std;
int n, m;
double M;
struct Tmincut{
    int s, t;
    int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2];
	double c[MAXM * 2];
    int h[MAXN], vh[MAXN];
    bool S[MAXN];
    Tmincut() { tot = 1; }
    void add(int A, int B, double C)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
    }
    void reinit(double t)
    {
		for (int i = 1; i <= tot; i++) if (!(i & 1)) c[i] += c[i ^ 1], c[i ^ 1] = 0;
		for (int i = tot - 2 * n + 1; i <= tot; i++) if (!(i & 1)) c[i] = t;
    }   
    double aug(int x, double f)
    {
        if (x == t) return f;
        int minh = t - 1; double augc = f;
        for (int i = e[x]; i; i = next[i]) if (fabs(c[i]) > eps){
            if (h[v[i]] + 1 == h[x]){
                double t = aug(v[i], min(f, c[i]));
                c[i] -= t; c[i ^ 1] += t; f -= t;
                if (fabs(f) < eps || h[s] == t) return augc - f;
            }
            minh = min(minh, h[x]);
        }
        if (fabs(f - augc) < eps){ if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1]; }
        return augc - f;
    }
    void dfs(int x)
    {
        S[x] = true;
        for (int i = e[x]; i; i = next[i]) if (fabs(c[i]) > eps && !S[v[i]]) dfs(v[i]);
    }
    double run()
    {
		for (int i = 0; i <= t; i++) h[i] = 0, vh[i] = 0;
		vh[0] = t;
		double flow = 0;
        while(h[s] < t) flow += aug(s, 1e8);
    	for (int i = 1; i <= t; i++) S[i] = false;
		return m - flow;
    }
} cut;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	if (m == 0) { printf("%d\n", 1); return 0; }
	cut.s = n + m + 1; cut.t = cut.s + 1;
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		cut.add(i, a + m, 1e8); cut.add(i, b + m, 1e8);
	}
	for (int i = 1; i <= m; i++) cut.add(cut.s, i, 1);
	for (int i = 1; i <= n; i++) cut.add(i + m, cut.t, 0);
	double l = 0, r = m;
	while(r - l > 1e-5){
		M = (l + r) / 2; cut.reinit(M);
		if (fabs(cut.run()) < eps) r = M; else l = M;
	}
	cut.reinit(l); cut.run(); cut.dfs(cut.s);
	int ans = 0;
	for (int i = m + 1; i <= n + m; i++) if (cut.S[i]) ++ans;
	printf("%d\n", ans);
}
Problem1313

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const int MAXN = 50001, MAXM = 500001;
int n;
    struct Tmaxflow{
        int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM];
        int h[MAXN], vh[MAXN];
        int s, t;
        void init()
        {
            for (int i = 1; i <= t; i++) e[i] = 0; tot = 1;  
        }
        void add(int A, int B, int C)
        {
            ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
            ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
        }
        int aug(int x, int f)
        {
            if (x == t) return f;
            int minh = t - 1, augc = f;
            for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
                if (h[x] == h[v[i]] + 1){
                    int t = aug(v[i], min(f, c[i]));
                    c[i] -= t; c[i ^ 1] += t; f -= t;
                    if (f == 0 || h[s] == t) return augc - f;
                }
                minh = min(minh, h[v[i]]);
            }
            if (f == augc){
                if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1];
            }
            return augc - f;    
        }
        int run()
        {
			int flow = 0;
            memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
            vh[0] = t; while(h[s] < t) flow += aug(s, 0x7fffffff);
            return flow;
        }
    } flow;

double line[1001], row[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); --n;
	flow.init();
	flow.s = n + n + 1; flow.t = flow.s + 1;
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			double x; scanf("%lf", &x);
			x += 10000.0;
			flow.add(i, j + n, floor(x));
			if (x - floor(x) > 1e-6)
				flow.add(i, j + n, 1);
			
		}
		double x; scanf("%lf", &x); x += 10000.0 * n;
		flow.add(flow.s, i, floor(x));
		if (x - floor(x) > 1e-6)
			flow.add(flow.s, i, 1);
		
	}
	for (int i = 1; i <= n; i++){
		double x; scanf("%lf", &x); x += 10000.0 * n;
		flow.add(i + n, flow.t, floor(x));
		if (x - floor(x) > 1e-6)
			flow.add(i + n, flow.t, 1);
		
	}
	int ans = flow.run();
	printf("%d\n", (ans - 10000 * n * n) * 3);
	
}
Problem1316

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 500001;
int tot, e[MAXN], v[MAXN * 2], w[MAXN * 2], next[MAXN * 2], l, r, n;
bool del[MAXN], ans[MAXN];
int Q, qu[MAXN]; 
int hash[2000001];
int q[MAXN], fa[MAXN], size[MAXN], ms[MAXN], dis[MAXN], num[MAXN];
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int find_heavy(int x)
{
	fa[x] = 0; l = 1, r = 1; q[1] = x;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != fa[x]){
			q[++r] = v[i]; fa[v[i]] = x;
		}
	}
	for (int i = r; i >= 1; i--){
		size[q[i]] = 1; ms[q[i]] = 0;
		for (int j = e[q[i]]; j; j = next[j]) if (!del[v[j]] && v[j] != fa[q[i]]){
			size[q[i]] += size[v[j]]; ms[q[i]] = max(ms[q[i]], size[v[j]]);
		}
		ms[q[i]] = max(ms[q[i]], r - size[q[i]]);
	}
	int w = q[1];
	for (int i = 2; i <= r; i++) if (ms[q[i]] < ms[w]) w = q[i];
	return w;
}
void doit(int x)
{
	x = find_heavy(x); if (r == 1) return; del[x] = true;
	hash[0] = x;
	for (int i = e[x]; i; i = next[i]) if (!del[v[i]]){
		int l = 1, r = 1; q[1] = v[i]; dis[v[i]] = w[i]; fa[v[i]] = 0;
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && fa[x] != v[i]){
				dis[v[i]] = dis[x] + w[i]; q[++r] = v[i]; fa[v[i]] = x;
			}
		}
		for (int i = 1; i <= r; i++){
			for (int j = 1; j <= Q; j++) if (dis[q[i]] <= qu[j])
				ans[j] |= (hash[qu[j] - dis[q[i]]] == x);
			
		}
		for (int i = 1; i <= r; i++) if (dis[q[i]] <= 1000000)
		hash[dis[q[i]]] = x;
	}
	for (int i = e[x]; i; i = next[i]) if (!del[v[i]]) doit(v[i]);			
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &Q);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	for (int i = 1; i <= Q; i++) scanf("%d", &qu[i]);
	doit(1);
	for (int i = 1; i <= Q; i++) puts(ans[i] || qu[i] == 0 ? "Yes" : "No");
}
Problem1318

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 2000001;
int n, a[MAXN], ans;
struct Tsolver
{
	int last[MAXN], next[MAXN], t[MAXN]; long long sum[MAXN];
	void solve()
	{
		for (int i = 1; i <= 1000000; i++) last[i] = n + 1;
		for (int i = n; i >= 1; i--){
			next[i] = last[a[i]];
			last[a[i]] = i;
		}
		for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];
		t[n] = n + 1;
		for (int i = n - 1; i >= 1; i--) t[i] = min(next[i], t[i + 1]);
		for (int i = 1; i <= n; i++) if (a[i] == 1){
			int nowmax = 1;
			for (int j = i - 1; j > 0 && a[j] != 1; j--){
				nowmax = max(nowmax, a[j]);
				if (t[j] - j + 1 <= nowmax) continue;
				if (sum[j + nowmax - 1] - sum[j - 1] == (long long)nowmax * (nowmax + 1) / 2ll) ans = max(ans, nowmax);
			}
		}
	}
} solver;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", a + i);
	solver.solve();
	reverse(a + 1, a + n + 1);
	solver.solve();
	printf("%d\n", ans);
}
Problem1319

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#include <map>
#define LL long long
using namespace std;
int a, k, p;
int pow(int a, int b, int c)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (LL) ret * a % c;
		a = (LL) a * a % c;
	}
	return ret;
}
int inv(int a)
{
	return pow(a, p - 2, p);
}
bool isroot(int t)
{
	for (int i = 1; i * i <= p - 1; i++) if ((p - 1) % i == 0){
		if (pow(t, i, p) == 1) return false;
		if (i != 1 && pow(t, (p - 1) / i, p) == 1) return false;
	}
	return true;
}
vector<int> ans, rans;
int exgcd(int a, int b, LL & x, LL & y)
{
	if (b == 0) { x = 1; y = 0; return a; }
	else { int ret = exgcd(b, a % b, y, x); y -= a / b * x; return ret; }
}
void solve_modular(int a, int b, int p)
{
	LL x, y; int d = exgcd(a, p, x, y);
	if (b % d != 0) return;
	x = x * b / d % (p / d);
	x = (x + p / d) % (p / d);
	while(x < p){
		ans.push_back(x);
		x += p / d;
	}
}
map<int, int> M;
int dis_log(int a, int b) //a ^ x == b
{
	int q = 1; while(q * q < p) ++q;
	int giant = 1;
	for (int i = 0; i <= q; i++){
		M[(LL)giant * b % p] = i;
		if (i != q) giant = (LL)giant * a % p;
	}
	int baby = giant;
	for (int i = 1; i <= q; i++){
		if (M.count(giant)) return ((LL)q * i - M[giant]) % (p - 1);
		giant = (LL)giant * baby % p;
	}		
}
int root;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> p >> a >> k;
	for (int i = 1; i <= p - 1; i++) if (isroot(i)) { root = i; break; }
	k = dis_log(root, k);
	solve_modular(a, k, p - 1);
	printf("%d\n", ans.size());
	for (int i = 0; i < ans.size(); i++) rans.push_back(pow(root, ans[i], p));
	sort(rans.begin(), rans.end());
	for (int i = 0; i < rans.size(); i++) printf("%d\n", rans[i]);
}
Problem1334

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <functional>
using namespace std;
int n, sum, ans, a[100001], f[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), sum += a[i];
	sort(a + 1, a + n + 1, greater<int>());
	for (int i = 1; i <= n; i++){
		ans = max(ans, a[i] + f[sum / 2]);
		for (int j = sum / 2; j >= a[i]; j--) f[j] = max(f[j], f[j - a[i]] + a[i]);
	}
	printf("%d\n", ans);
}
Problem1336

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
struct Tpoint{
	double x, y;
	void init() { scanf("%lf%lf", &x, &y); }
	void out() { printf("%.10lf %.10lf\n", x, y); }
	Tpoint(){}
	Tpoint (double x, double y) : x(x), y(y) {};
};
Tpoint mid(Tpoint A, Tpoint B)
{
	Tpoint x((A.x + B.x) / 2, (A.y + B.y) / 2);
	return x;
}
double dis(Tpoint A, Tpoint B)
{
	return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
}
Tpoint make(Tpoint A, Tpoint B, Tpoint C)
{
	double c1 = A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y,
	       c2 = A.x * A.x - C.x * C.x + A.y * A.y - C.y * C.y,
	       a1 = 2 * (B.x - A.x),
	       a2 = 2 * (C.x - A.x),
	       b1 = 2 * (B.y - A.y),
	       b2 = 2 * (C.y - A.y);
	Tpoint ret((c2 * b1 - c1 * b2) / (a1 * b2 - a2 * b1),
	           (c2 * a1 - c1 * a2) / (b1 * a2 - b2 * a1));
	//cerr << dis(A, ret) << " " << dis(B, ret) << " " << dis(C, ret) << endl;
	return ret;
}
int n;
Tpoint nowp, p[1000001]; 
double r;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	nowp = p[1]; r = 0.0;
	for (int i = 2; i <= n; i++)
		if (dis(nowp, p[i]) > r){
			nowp = mid(p[1], p[i]); r = dis(p[1], p[i]) / 2;
			for (int j = 2; j < i; j++) if (dis(nowp, p[j]) > r){
				nowp = mid(p[j], p[i]); r = dis(p[j], p[i]) / 2;
				for (int k = 1; k < j; k++)
					if (dis(p[k], nowp) > r){
						nowp = make(p[i], p[j], p[k]);
						r = dis(nowp, p[i]);
						}	
				}
			}
	printf("%.10lf\n", r);
	nowp.out();	
}
Problem1337

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
struct Tpoint{
	double x, y;
	void init() { scanf("%lf%lf", &x, &y); }
	void out() { printf("%.10lf %.10lf\n", x, y); }
	Tpoint(){}
	Tpoint (double x, double y) : x(x), y(y) {};
};
Tpoint mid(Tpoint A, Tpoint B)
{
	Tpoint x((A.x + B.x) / 2, (A.y + B.y) / 2);
	return x;
}
double dis(Tpoint A, Tpoint B)
{
	return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
}
Tpoint make(Tpoint A, Tpoint B, Tpoint C)
{
	double c1 = A.x * A.x - B.x * B.x + A.y * A.y - B.y * B.y,
	       c2 = A.x * A.x - C.x * C.x + A.y * A.y - C.y * C.y,
	       a1 = 2 * (B.x - A.x),
	       a2 = 2 * (C.x - A.x),
	       b1 = 2 * (B.y - A.y),
	       b2 = 2 * (C.y - A.y);
	Tpoint ret((c2 * b1 - c1 * b2) / (a1 * b2 - a2 * b1),
	           (c2 * a1 - c1 * a2) / (b1 * a2 - b2 * a1));
	//cerr << dis(A, ret) << " " << dis(B, ret) << " " << dis(C, ret) << endl;
	return ret;
}
int n;
Tpoint nowp, p[1000001]; 
double r;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	nowp = p[1]; r = 0.0;
	for (int i = 2; i <= n; i++)
		if (dis(nowp, p[i]) > r){
			nowp = mid(p[1], p[i]); r = dis(p[1], p[i]) / 2;
			for (int j = 2; j < i; j++) if (dis(nowp, p[j]) > r){
				nowp = mid(p[j], p[i]); r = dis(p[j], p[i]) / 2;
				for (int k = 1; k < j; k++)
					if (dis(p[k], nowp) > r){
						nowp = make(p[i], p[j], p[k]);
						r = dis(nowp, p[i]);
						}	
				}
			}
	printf("%.3lf\n", r);
}
Problem1338

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <complex>
#include <iostream>
using namespace std;
struct Tpoint{
	double x, y;
	Tpoint () { }
	Tpoint (double _x, double _y) { x = _x; y = _y; }
	Tpoint operator - (const Tpoint & A)
	{
		return Tpoint(x - A.x, y - A.y);
	}
	Tpoint operator + (const Tpoint & A)
	{
		return Tpoint(x + A.x, y + A.y);
	}
};
double abs(const Tpoint & A)
{
	return A.x * A.x + A.y * A.y;
}
double arg(const Tpoint & A)
{
	return atan2(A.y, A.x);
}
const double pi = acos(-1);
int n; Tpoint p[10001];
int getans(Tpoint A)
{
	int ret = 0;
	for (int i = 1; i <= n; i++) ret += (abs(A - p[i]) <= 1.0 + 1e-6);
	return ret;
}
Tpoint get(Tpoint A, Tpoint B)
{
	double del = arg(A - B) - pi / 2.0, len = sqrt(1.0 - abs(A - B) / 4.0); 
	Tpoint mid((A.x + B.x) / 2.0, (A.y + B.y) / 2.0);
	return Tpoint(mid.x + len * cos(del), mid.y + len * sin(del));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); //freopen("temp.out", "w", stdout);
#endif
while(1){
	scanf("%d", &n); if (n == 0) break;
	for (int i = 1; i <= n; i++) { double x, y; scanf("%lf%lf", &x, &y); p[i] = Tpoint(x, y); }
	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(getans(p[i]), ans);
	for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++)
		if (abs(p[i] - p[j]) <= 4.0 + 1e-6)
			ans = max(ans, getans(get(p[i], p[j])));
	printf("%d\n", ans);
}
}
Problem1342

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int l1, r1, l2, r2, q1[2000001], q2[2000001], data[2000001];
int n, m, c;
void push1(int t)
{
	while(l1 <= r1 && data[t] <= data[q1[r1]]) --r1; q1[++r1] = t;	
}
void push2(int t)
{
	while(l2 <= r2 && data[t] >= data[q2[r2]]) --r2; q2[++r2] = t;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &c); for (int i = 1; i <= n; i++) scanf("%d", &data[i]);
	l1 = 1; r1 = 0; l2 = 1; r2 = 0;
	for (int i = 1; i < m; i++) push1(i), push2(i);
	bool w = false;
	for (int i = 1; i + m - 1<= n; i++){
		push1(i + m - 1); push2(i + m - 1);
		while(q1[l1] < i) ++l1;
		while(q2[l2] < i) ++l2;
		if (data[q2[l2]] - data[q1[l1]] <= c) printf("%d\n", i), w = true;
	}
	if (!w) puts("NONE");
}
Problem1349

#include <iostream>
#include <cmath>
using namespace std;
long long n;
int main()
{
    cin >> n;
    cout << (long long)ceil(sqrt((double)n)) << endl;
}
Problem1362

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define PII pair<int, int>
using namespace std;
int delta(const PII & A)
{
	return min(A.first, A.second) + max(A.first, A.second);
}
bool cmp(const PII & A, const PII & B)
{
	return delta(A) < delta(B);
} 
PII d[1000001];
long long ans;
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d%d", &d[i].first, &d[i].second);
	sort(d + 1, d + n + 1, cmp);
	for (int i = 1; i <= n / 2; i++) ans += min(d[i].first, d[i].second);
	for (int i = n / 2 + 1; i <= n; i++) ans -= max(d[i].first, d[i].second);
	cout << ans << endl;
}
Problem1366

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define log(a) (31 - __builtin_clz(a))
using namespace std;
const int MAXN = 100001;
struct Tlcp{
	int n, sa[MAXN], ws[MAXN], wv[MAXN], rank[MAXN], t1[MAXN], t2[MAXN], h[MAXN], *x, *y;
	int f[MAXN][20];
	char s[1000001];
	void init(char *S)
	{
		x = t1; y = t2;
		for (; *S; S++) s[++n] = *S;
		for (int i = 1; i <= n; i++) x[i] = s[i] - 'a' + 1;
		for (int i = 1; i <= n; i++) ++ws[x[i]];
		for (int i = 1; i <= 2; i++) ws[i] += ws[i - 1];
		for (int i = n; i >= 1; i--) sa[ws[x[i]]--] = i;
		int m = 2;
		for (int j = 1; m < n; j <<= 1){
			int tot = 0;
			for (int i = n - j + 1; i <= n; i++) y[++tot] = i;
			for (int i = 1; i <= n; i++) if (sa[i] > j) y[++tot] = sa[i] - j;
		   	for (int i = 0; i <= m; i++) ws[i] = 0;
			for (int i = 1; i <= n; i++) ws[wv[i] = x[y[i]]]++;
			for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
			for (int i = n; i >= 1; i--) sa[ws[wv[i]]--] = y[i];
			swap(x, y); x[sa[1]] = 1;
			for (int i = 2; i <= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j]) ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
			m = x[sa[n]];
		}
		for (int i = 1; i <= n; i++) rank[i] = x[i];
		int k = 0;
		for (int i = 1; i <= n; i++){
			if (rank[i] == 1) { h[1] = k = 0; continue; }
			k = k > 0 ? k - 1: k; int j = sa[rank[i] - 1];
			while(s[i + k] == s[j + k]) ++k;
			h[rank[i]] = k;
		}
		int logn = log(n);
		for (int i = 1; i <= n; i++) f[i][0] = h[i];
		for (int j = 1; j <= logn; j++)
			for (int i = 1; i <= n - (1 << j) + 1; i++)
				f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);	
	}
	int ask(int a, int b)
	{
		a = rank[a], b = rank[b];
		if (a > b) swap(a, b); ++a;
		int x = log(b - a + 1);
		return min(f[a][x], f[b - (1 << x) + 1][x]);
	}
} lcp1, lcp2;
char buf[MAXN]; int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) { scanf(" "); scanf("%c", &buf[i - 1]); } 
	lcp1.init(buf);
	for (int i = 1; i + i <= n; i++) swap(buf[i - 1], buf[n - i]);
	lcp2.init(buf);
	int ans = 1;
	for (int i = 1; i <= n; i++)
		for (int j = i; j + i<= n; j += i){
			int a = j, b = j + i;
			int t = lcp1.ask(a, b) + lcp2.ask(n - a + 1, n - b + 1) - 1;
			ans = max(ans, t / i + 1);
		}
	printf("%d\n", ans);
}
Problem1372

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, T, a[2000001], na[2000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &T); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 0; i <= 31; i++) if ((T >> i) & 1){
		int p = 1 << i;
		for (int j = 1; j <= n; j++) na[j] = a[j];
		for (int j = 1; j <= n; j++)
			a[j] = na[j] ^ na[(j + p - 1) % n + 1];
	}
	for (int i = 1; i <= n; i++) printf("%d\n", a[i]);
}
Problem1382

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 150001;
struct Tline{
	int x, y1, y2, k;
	}L[MAXN];
bool cmp(Tline A, Tline B)
{
	return A.x < B.x;
}
int Y[MAXN], toty, numy;
int n, x1, y1, x2, y2, numl;
int cover[MAXN], m[MAXN];
void update(int idx, int l, int r)
{
	if (cover[idx]) m[idx] = Y[r] - Y[l];
	else m[idx] = m[idx * 2] + m[idx * 2 + 1];
}
void insert(int idx, int l, int r, int ll, int rr, int k)
{
	if (Y[l] >= ll && Y[r] <= rr) cover[idx] += k;
	else{
		int m = Y[(l + r) >> 1];
		if (ll < m) insert(idx * 2, l, (l + r) >> 1, ll, rr, k);
		if (rr > m) insert(idx * 2 + 1, (l + r) >> 1, r, ll, rr, k);
		}
	update(idx, l, r);
}	
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		Y[++numy] = y1; Y[++numy] = y2;
		++numl; L[numl].x = x1; L[numl].y1 = y1; L[numl].y2= y2; L[numl].k = 1;
		++numl; L[numl].x = x2; L[numl].y1 = y1; L[numl].y2= y2; L[numl].k = -1;
		}
	sort(Y + 1, Y + numy + 1);
	toty = 1; for (int i = 2; i <= numy; i++) if (Y[i] != Y[i - 1]) Y[++toty] = Y[i];
	sort(L + 1, L + numl + 1, cmp);
	int M = 0, ans = 0;
	for (int i = 1; i <= numl; i++){
		insert(1, 1, toty, L[i].y1, L[i].y2, L[i].k);
		if (i != 1) ans += M * (L[i].x - L[i - 1].x);
		M = m[1];
		}
	printf("%d\n", ans);
}
Problem1406

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;
set<int> S; int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n;
	for (int i = 1; (long long)i * i <= n; i++) if (n % i == 0){
		int a = i, b = n / i;
		for (int x = 1; x <= n; x += b) if ((x + 1) % a == 0) S.insert(x);
		for (int x = b - 1; x <= n; x += b) if ((x - 1) % a == 0) S.insert(x);
	}
	for (set<int>::iterator si = S.begin(); si != S.end(); si++) cout << *si << endl;
}
Problem1407

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define make(a) ((((a) % M) + M) % M)
int n, nownum;
long long s[1001], y[1001], p[1001];
long long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }
void exgcd(long long a, long long b, long long & x, long long & y)
{
	if (b == 0) { x = 1; y = 0; return; }
	else { exgcd(b, a % b, y, x); y -= x * (a / b); }
}
long long getans(long long a, long long b, long long M) //ax = b mod M
{
	long long x, y; long long t = gcd(a, M);
	if (b % t != 0) return 0x3f3f3f3f3f3f3f3fll;
	a /= t; b /= t; M /= t;
	exgcd(a, M, x, y); x = make(x * b);
	return x;
}
bool ok(long long M)
{
	nownum = M;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) if (i != j){
			long long t = getans(make(p[i] - p[j]), make(s[j] - s[i]), M);
			if (t <= y[i] && t <= y[j]) return false;
		}
	return true;
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &s[i], &p[i], &y[i]), --s[i];
	int MINNUM = 0;
	for (int i = 1; i <= n; i++) MINNUM = max(MINNUM, int(s[i] + 1));
	for (int i = MINNUM; i <= 1000000; i++) if (ok(i)) { printf("%d\n", i); return 0; }
}
Problem1411

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int a[62][100001], n, tot;
long long T;
long long make(long long a) { return (a % n + n) % n; }
int main()
{
	cin >> n >> T;
	for (int i = 0; i < n; i++) scanf("%d", &a[0][i]), --a[0][i];
	long long TT = T >> 1;
	for (int i = 0 ; i < 61; i++) if ((TT >> (long long)(i)) & 1ll) {
		long long OFF = 1ll << i; ++tot;
		for (int i = 0; i < n; i++) a[tot][i] = a[tot - 1][make((long long)i - OFF)] ^ a[tot - 1][make((long long)i + OFF)];
	}	
	if (T & 1) for (int i = 0; i < n; i++) printf("0 %d ", (a[tot][i] ^ a[tot][make(i + 1)]) + 1);
	else for (int i = 0; i < n; i++) printf("%d 0 ", a[tot][i] + 1);
	putchar('\n');
}
Problem1412

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define change(a, b) ((a) * m + (b) - m)
const int MAXN = 20001, MAXM = 1000001, inf = 0x3f3f3f3f;
using namespace std;
int n, m, s, t;
int h[MAXN], vh[MAXN];
int tot = 1, e[MAXN], v[MAXM], c[MAXM], next[MAXM];
bool vis[MAXN];
	int flow;
	void add(int a, int b, int d)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = d;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
	}	
	int dfs(int x, int f)
	{
		vis[x] = true; if (x == t)  { flow += f; return f; }
		for (int i = e[x]; i;i = next[i]) if (!vis[v[i]] && c[i] > 0){
			int t = dfs(v[i], min(c[i], f));
			if (t > 0){
				c[i] -= t; c[i ^ 1] += t; return t;
			}
		}
		return 0;
	}
	void run()
	{
		while(dfs(s, inf)) 
			memset(vis, 0, sizeof(vis));
	}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	s = n * m + 1; t = s + 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			int k; scanf("%d", &k);
			if (k == 1) add(s, change(i, j), inf);
			if (k == 2) add(change(i, j), t, inf);
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			if (i != 1) add(change(i, j), change(i - 1, j), 1);
			if (j != 1) add(change(i, j), change(i, j - 1), 1);
			if (i != n) add(change(i, j), change(i + 1, j), 1);
			if (j != m) add(change(i, j), change(i, j + 1), 1);
		}
	run();
	printf("%d\n", flow);
}
Problem1414

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 3001;
int n, m;
int ex1[MAXN][MAXN], ex2[MAXN][MAXN], ret[MAXN], P[MAXN], map[MAXN][MAXN], ans[MAXN][MAXN];
struct Tqueue{
	int who[MAXN], data[MAXN], l, r;
	void cl() { l = 1; r = 0; }
	void push(int _w, int _d) { while (l <= r && _d <= data[r]) --r; ++r; data[r] = _d; who[r] = _w; }
	void pop() { ++l; }
	int headw() { return who[l]; }
	int headd() { return data[l]; }
	bool emp() { return l > r; }
} Q;
void manacher(int len)
{
	int far = -1, who;
	for (int i = 0; i < len; i++){
		ret[i] = 1;
		if (far > i) ret[i] = min(ret[who * 2 - i], far - i);
		while(i - ret[i] >= 0 && i + ret[i] < len && P[i + ret[i]] == P[i - ret[i]]) ++ret[i];
		if (ret[i] + i > far) far = ret[i] + i, who = i;
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	//ex1 : L to R	ex2 : D to U
	memset(map, 0xff, sizeof(map));
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			scanf("%d", &map[i << 1][j << 1]);
	n = (n << 1) - 1; m = (m << 1) - 1;
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++) P[j] = map[i][j];
		manacher(m);
		for (int j = 0; j < m; j++) ex1[i][j] = ret[j];
	}
	for (int i = 0; i < m; i++){
		for (int j = 0; j < n; j++) P[j] = map[j][i];
		manacher(n);
		for (int j = 0; j < n; j++) ex2[j][i] = ret[j];
	}
	memset(ans, 0x3f, sizeof(ans));
	for (int i = 0; i < n; i++){
		Q.cl(); int now = 0;
		for (int j = 0; j < m; j++){
			ans[i][j] = min(ans[i][j], ex1[i][j]);
			Q.push(j, ex2[i][j]);
			while(1) { if (Q.headd() >= j - now + 1) break; ++now; if (Q.headw() < now) Q.pop(); }
			ans[i][j] = min(ans[i][j], j - now + 1);
		}
		Q.cl(); now = m - 1;
		for (int j = m - 1; j >= 0; j--){
			Q.push(j, ex2[i][j]);
			while(1) { if (Q.headd() >= now - j + 1) break; --now; if (Q.headw() > now) Q.pop(); }
			ans[i][j] = min(ans[i][j], now - j + 1);
		}
	}
	for (int i = 0; i < m; i++){
		Q.cl(); int now = 0;
		for (int j = 0; j < n; j++){
			ans[j][i] = min(ans[j][i], ex2[j][i]);
			Q.push(j, ex1[j][i]);
			while(1) { if (Q.headd() >= j - now + 1) break; ++now; if (Q.headw() < now) Q.pop(); }
			ans[j][i] = min(ans[j][i], j - now + 1);
		}
		Q.cl(); now = n - 1;
		for (int j = n - 1; j >= 0; j--){
			Q.push(j, ex1[j][i]);
			while(1) { if (Q.headd() >= now - j + 1) break; --now; if (Q.headw() > now) Q.pop(); }
			ans[j][i] = min(ans[j][i], now - j + 1);
		}
	}
	long long ANS = 0;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++){
			if (i & 1 && j & 1) ANS += ans[i][j] >>	1;
			if (!(i & 1) && !(j & 1)) ANS += ans[i][j] + 1 >> 1;
		}
	cout << ANS << endl;
}
Problem1415

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1001, INF = 0x3f3f3f3f;
int dis[MAXN][MAXN], p[MAXN][MAXN];
int tot, e[MAXN * 2], next[MAXN * 2], v[MAXN * 2];
int n, m, st, ed;
int l, r, q[MAXN * 4];
bool mark[MAXN][MAXN];
double f[MAXN][MAXN];
void add(int x, int y)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y;
}
void BFS(int S)
{
	for (int i = 1; i <= n; i++) dis[i][S] = INF; dis[S][S] = 0; p[S][S] = S;
	q[l = r = 1] = S;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]){
			if (dis[v[i]][S] == dis[x][S] + 1 && p[v[i]][S] > x) p[v[i]][S] = x;
			if (dis[v[i]][S] > dis[x][S] + 1){
				dis[v[i]][S] = dis[x][S] + 1, p[v[i]][S] = x;
				q[++r] = v[i];
				}
			}
		}
}
double dp(int x, int y)
{
	if (x == y) return 0;
	if (mark[x][y]) return f[x][y]; mark[x][y] = true;
	int s1 = p[x][y], s2 = p[s1][y];
	if (s1 == y || s2 == y){
		f[x][y] = 1.0; return 1.0;
		}
	double sum = dp(s2, y), t = 1.0;
	for (int i = e[y]; i; i = next[i]){
		sum += dp(s2, v[i]); t += 1.0;
		}
	f[x][y] = sum / t + 1;
	return f[x][y];
}
int main()
{
	scanf("%d%d", &n, &m);
	scanf("%d%d", &st, &ed);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); add(x, y); add(y, x);
		}
	for (int i = 1; i <= n; i++) BFS(i);
	printf("%.3lf\n", dp(st, ed));
}
		
Problem1416

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define NOANS { puts("0/1"); return 0; }
using namespace std;
int pnum, p[20001], t, n, d, num[20001], tot;
bool f[20001];
struct Tbig{
	int len, data[2001];
	void init() { memset(data, 0, sizeof(data)); len = 1; data[1] = 1; }
	Tbig & operator *= (int k)
	{
		int t = 0;
		for (int i = 1; i <= len; i++){
			data[i] = data[i] * k + t;
			t = data[i] / 10000;
			data[i] %= 10000;
			}
		data[len + 1] = t;
		while(data[len + 1]) ++len;
		return *this;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]);
	}
} temp1, temp2;
struct Tnum{
	int data[20001];
	void mul(int a, int d)
	{
		for (int i = 1; i <= pnum && p[i] <= a; i++){
			while(a % p[i] == 0) data[i] += d, a /= p[i];
			}
	}
	void print()
	{
		temp1.init(); temp2.init();
		for (int i = 1; i <= pnum; i++){
			while(data[i] > 0) temp1 *= p[i], --data[i];
			while(data[i] < 0) temp2 *= p[i], ++data[i];
			}
		temp1.print();
		putchar('/');
		temp2.print();
		putchar('\n');
	}		
} NUM;
void GETP(int MAXN)
{
	memset(f, 1, sizeof(f)); f[0] = f[1] = false;
	p[pnum = 1] = 2;
	for (int now = 2; now < MAXN;){
		for (int j = now + now; j <= MAXN; j += now) f[j] = false;
		for (++now; now < MAXN && !f[now]; ++now);
		if (f[now]) p[++pnum] = now;
		}
}
int main()
{
	GETP(20000);
	scanf("%d%d%d", &n, &t, &d);
	for (int i = 1; i <= n; i++) { scanf("%d", &num[i]); tot += num[i]; }
	for (int i = 1; i <= t; i++){
		int t; scanf("%*d%d", &t); if (num[t] == 0) NOANS;
		NUM.mul(num[t], 1); NUM.mul(tot, -1);
		num[t] += d; tot += d;
		}
	NUM.print();
}
	
Problem1417

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
using namespace std;
struct Tstate{
	int n, data[31];
	int & operator [] (int k) { return data[k]; }
	const int & operator [] (int k) const { return data[k]; }
	void renew()
	{
		sort(data + 1, data + n + 1);
	}
	Tstate merge(int i, int j)
	{
		Tstate temp = *this;
		temp[i] += temp[j]; swap(temp[j], temp[n]);
		--temp.n; temp.renew();
		return temp;
	}
	bool operator < (const Tstate & A) const
	{
		if (n != A.n) return n < A.n;
		for (int i = 1; i <= n; i++) if (data[i] != A[i]) return data[i] < A[i];
	}
} start;
int n, m, num[1001];
struct Tuf{
	int f[1001];
	int & operator [] (int k) { return f[k]; } 
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int getf(int a) { return f[a] == a ? a : f[a] = getf(f[a]); }
    void merge(int a, int b)
	{
		a = getf(a); b = getf(b);
		if (a != b) f[a] = b;
	}	
} uf;
map<Tstate, double> M;
double tot;
double dp(Tstate now)
{
	if (now.n == 1) return 0;
	double same = 0, zy = 0;
	if (M.count(now)) return M[now];
	for (int i = 1; i <= now.n; i++)
		for (int j = 1; j <= i; j++)
			if (i == j) same += double(now[i]) * (now[i] - 1) / tot / 2;
   			else zy += (double) now[i] * now[j] * dp(now.merge(i, j)) / tot;
	return M[now] = (zy + 1.0) / (1 - same);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	uf.init();
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		uf.merge(a, b);
	}
	for (int i = 1; i <= n; i++) ++num[uf.getf(i)];
	for (int i = 1; i <= n; i++) if (uf[i] == i) start[++start.n] = num[i];
	tot = n * (n - 1) / 2;
	printf("%.6lf\n", dp(start));
}
Problem1419

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
double now[5001], last[5001];
int r, b;
char buf[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &r, &b);
	for (int i = 1; i <= r; i++){
		for (int j = 0; j <= b; j++){
			now[j] = 0;
			if (j == 0) { now[j] = i; continue; }
			now[j] = max(0.0, (double)(i) / (double)(i + j) * (last[j] + 1.0) + (double)(j) / (double)(i + j) * (now[j - 1] - 1));
		}
		for (int j = 0; j <= b; j++) last[j] = now[j];
	}
	sprintf(buf, "%.8lf", now[b]);
	int len = strlen(buf);
	for (int i = 0; i < len - 2; i++) putchar(buf[i]);
	putchar('\n');
}
Problem1420

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#include <map>
#define LL long long
using namespace std;
int a, k, p;
int pow(int a, int b, int c)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (LL) ret * a % c;
		a = (LL) a * a % c;
	}
	return ret;
}
int inv(int a)
{
	return pow(a, p - 2, p);
}
bool isroot(int t)
{
	for (int i = 1; i * i <= p - 1; i++) if ((p - 1) % i == 0){
		if (pow(t, i, p) == 1) return false;
		if (i != 1 && pow(t, (p - 1) / i, p) == 1) return false;
	}
	return true;
}
vector<int> ans, rans;
int exgcd(int a, int b, LL & x, LL & y)
{
	if (b == 0) { x = 1; y = 0; return a; }
	else { int ret = exgcd(b, a % b, y, x); y -= a / b * x; return ret; }
}
void solve_modular(int a, int b, int p)
{
	LL x, y; int d = exgcd(a, p, x, y);
	if (b % d != 0) return;
	x = x * b / d % (p / d);
	x = (x + p / d) % (p / d);
	while(x < p){
		ans.push_back(x);
		x += p / d;
	}
}
map<int, int> M;
int dis_log(int a, int b) //a ^ x == b
{
	int q = 1; while(q * q < p) ++q;
	int giant = 1;
	for (int i = 0; i <= q; i++){
		M[(LL)giant * b % p] = i;
		if (i != q) giant = (LL)giant * a % p;
	}
	int baby = giant;
	for (int i = 1; i <= q; i++){
		if (M.count(giant)) return ((LL)q * i - M[giant]) % (p - 1);
		giant = (LL)giant * baby % p;
	}		
}
int root;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> p >> a >> k;
	for (int i = 1; i <= p - 1; i++) if (isroot(i)) { root = i; break; }
	k = dis_log(root, k);
	solve_modular(a, k, p - 1);
	printf("%d\n", ans.size());
	for (int i = 0; i < ans.size(); i++) rans.push_back(pow(root, ans[i], p));
	sort(rans.begin(), rans.end());
	for (int i = 0; i < rans.size(); i++) printf("%d\n", rans[i]);
}
Problem1429

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	long long n, i, ret = 0; cin >> n; n = n * 2 + 1;
	for (i = 1; i * i <= n; i++) if (n % i == 0){
		ret += i + n / i;
		if (i * i == n) ret -= i;
	}
	cout << ret << endl;
}
Problem1430

#include <iostream>
using namespace std;
const int MO = 9999991;
int n;
int main()
{
	cin >> n;
	int ans = 1;
	for (int i = 1; i <= n - 2; i++) ans = (long long) ans * n % MO;
	for (int i = 1; i <= n - 1; i++) ans = (long long) ans * i % MO;
	cout << ans << endl;
}
Problem1432

#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
	int n, k;
	cin >> n >> k;
	if (n == 1) cout << 1 << endl;
	else cout << 2 * min(k, n - k + 1) << endl;
}
Problem1433

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
bool map[101][101], rm[101][101], vis[101], a[101], b[101];
int n, link[101];
bool find(int x)
{
	for (int i = 1; i <= n; i++) if (map[x][i] && !vis[i]){
		vis[i] = true;
		if (link[i] == 0 || find(link[i])){
			link[i] = x; return true;
			}
		}
	return false;
}			
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &rm[i][j]);
	for (int i = 1; i <= n; i++) rm[i][i] = true;
	memset(map, 0, sizeof(map));
	memset(link, 0, sizeof(link));
	for (int i = 1; i <= n; i++) if (!a[i] || (a[i] && (!b[i])))
		for (int j = 1; j <= n; j++) if (a[j] && rm[i][j]) map[i][j] = true;
	bool f = true;
	for (int i = 1; i <= n; i++) if (!a[i] || (a[i] && (!b[i]))){
		memset(vis, 0, sizeof(vis));
		if (!find(i)) { puts("T_T"); f = false; break; }
		}
	if (f) puts("^_^");
}
}
Problem1434

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int r[100001], n, m;
int sg(int x, int y)
{
	if (x == 0 || y == 0) return __builtin_ctz(x + y + 1);
	return x + y;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d", &n, &m);
	memset(r, 0, sizeof(r));
	for (int i = 0; i < n; i++){
		scanf(" ");
		for (int j = 0; j < m; j++){
			char c; scanf("%c", &c);
			if (c == 'T') r[sg(i, j)] ^= 1;
		}
	}
	for (int i = 0; i <= n + m; i++) if (r[i]) { puts("-_-"); goto end; }
	puts("=_=");
end:;
}
}
Problem1435

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define GET(a, b) (((a) >> (b)) & 1)
#define CHA(a, b, c) (((a) & (~(1 << b))) | (c << b))
#define nexti (j != len - 1 ? i : i + 1)
#define nextj (j != len - 1 ? j + 1 : 0)
#define make(a) ((((a) % MO) + MO) % MO)
#define ll long long
const int MO = 19901013;
using namespace std;
int a[21][21][21][21], f[16][16][1 << 16];
int n, m, map[21][21], g[21];
int tot, l[21];
void add(int & a, int b) { a = (a + b + MO) % MO; }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); getchar();
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++) map[i][j] = getchar() == '.';
		getchar();
	}
	for (int u = 0; u < n; u++)
		for (int l = 0; l < m; l++)
			for (int r = l; r < m; r++){
				int len = r - l + 1;
				for (int i = 0; i <= n - u; i++) for (int j = 0; j < len; j++) for (int k = 0; k < (1 << len); k++) f[i][j][k] = 0;
				f[0][0][0] = 1;
				for (int i = 0; i <= n - u; i++){
					if (i != 0) a[u][u + i - 1][l][r] = (a[u][u + i][l][r] + f[i][0][0]) % MO;
					if (i == n - u) break;
					for (int j = 0; j < len; j++)
						for (int S = 0; S < (1 << len); S++) if (f[i][j][S]){
							add(f[nexti][nextj][CHA(S, j, 0)], f[i][j][S]); 
							if (GET(S, j) == 1) continue;
							if (j + 1 < len && map[u + i][j + l] && map[u + i][j + l + 1]  && (GET(S, j + 1) == 0))
								add(f[nexti][nextj][CHA(S, j + 1, 1)], f[i][j][S]);
							if (i < n - u && map[u + i][j + l] && map[u + i + 1][j + l])
								add(f[nexti][nextj][CHA(S, j, 1)], f[i][j][S]);
						}
				}
			}
	int ans = 0;
	for (int i = 0; i < (1 << (m - 1)); i++){
		tot = 0;
		for (int t = 0; t < m - 1; t++) if ((i >> t) & 1) l[++tot] = t; l[0] = -1; l[++tot] = m - 1;
		for (int j = 0; j < n; j++){
			g[j] = 1;
			for (int k = 1; k <= tot; k++) g[j] = make((long long)g[j] * a[0][j][l[k - 1] + 1][l[k]]);
			int tmp;
			if (j == 0) continue;
			for (int t = 1; t <= j; t++){
				tmp = 1;
				for (int k = 1; k <= tot; k++) tmp = make((ll)tmp * a[t][j][l[k - 1] + 1][l[k]]);
				g[j] = make((ll)g[j] - (ll)tmp * (ll)g[t - 1]);
			}
		}
		if (tot & 1) ans = make(ans + g[n - 1]); else ans = make(ans - g[n - 1]);
	}
	printf("%d\n", ans);

}
								
							
Problem1436

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int mi;
int pow(long long a)
{
	int ret = 1, temp = 2;
	for (; a; a >>= 1){
		if (a & 1) ret = ret * temp % 3;
		temp = temp * temp % 3;
	}
	return ret;
}
int calc(long long t, int d) //t! mod 3
{
	if (t < 3) return max(t, 1ll);
	long long part = t / 3; int rest = max(t % 3, 1ll), ret = 1;
	ret = rest * pow(part) % 3; mi += part * d;
	return ret * calc(part, d) % 3;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	long long a, b; cin >> a >> b;
	mi = 0;
	int ret = calc(2 * a, 1) * calc(b, -1) * calc(2 * a - b, -1);
	if (mi > 0) puts("0"); else printf("%d\n", pow(b) * ret % 3);
}
}
Problem1443

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXM = 200001, INF = 0x3f3f3f3f;
int n, m, s, t, tot = 1;
int next[MAXM], e[MAXM], v[MAXM], c[MAXM];
char map[1001][1001];
bool vis[MAXM], must[MAXM];
int getnum(int a, int b) { return (a - 1) * m + b; }
void add(int A, int B, int C)
{
	//cerr << A << " " << B << endl;
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
}
bool aug(int x, int f)
{
	if (vis[x]) return false; vis[x] = true; if (x == t) return f;
	for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
		int d = aug(v[i], min(f, c[i]));
		if (d == 0) continue;
		c[i] -= d; c[i ^ 1] += d;
		return true;
		}
	return false;
}
int kind(int t)
{
	int x = t % m == 0 ? t / m : t / m + 1;
	int y = t % m == 0 ? m : t % m;
	return (x + y) & 1;
}
void dfs(int x, int f)
{
	if (vis[x]) return; if (kind(x) == f) must[x] = true; vis[x] = true; 
	for (int i = e[x]; i; i = next[i]) if (c[i] == f) dfs(v[i], f);
}
int main()
{
#ifdef kAc
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d\n", &n, &m);
	for (int i = 1; i <= n; i++) gets(map[i] + 1);
	s = n * m + 1, t = s + 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) if (map[i][j] != '#'){
			if ((i + j) & 1){
				add(s, getnum(i, j), 1);
				if (i > 1 && map[i - 1][j] != '#') add(getnum(i, j), getnum(i - 1, j), 1);
				if (j > 1 && map[i][j - 1] != '#') add(getnum(i, j), getnum(i, j - 1), 1);
				if (i < n && map[i + 1][j] != '#') add(getnum(i, j), getnum(i + 1, j), 1);
				if (j < m && map[i][j + 1] != '#') add(getnum(i, j), getnum(i, j + 1), 1);
				}
			else add(getnum(i, j), t, 1);
			}
	while(aug(s, INF)) for (int i = 1; i <= t; i++) vis[i] = false;
	memset(vis, 0, sizeof(vis));
	dfs(s, 1); 
	memset(vis, 0, sizeof(vis));
	dfs(t, 0);
	bool ans = false;
	for (int i = 1; i <= n * m; i++) if (must[i]){
		if (!ans) puts("WIN");
		ans = true;
		printf("%d %d\n", i % m == 0 ? i / m : i / m + 1, i % m == 0 ? m : i % m);
		}
	if (!ans) puts("LOSE");
	
}
Problem1449

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 600001, MAXM = 600001, SIZE = 262144 - 1;
struct Tcostflow{
	int flow, cost, s, t;
	int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM], w[MAXM]; //graph
	int dis[MAXN], f[MAXN], q[SIZE + 100], l, r; bool vis[MAXN]; //spfa
	void init() { tot = 1; flow = cost = 0; memset(e, 0, sizeof(e)); }
	void add(int A, int B, int C, int D)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
	}
	bool spfa()
	{
		for (int i = 1; i <= t; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
		l = 0; r = 1; q[1] = s; vis[s] = true; dis[s] = 0;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i]; f[v[i]] = i;
				if (!vis[v[i]]) { r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true; }
			}
		}
		return dis[t] < 0x3f3f3f3f;
	}
	void aug()
	{
		int af = 0x3f3f3f3f;
		for (int i = t; i != s; i = v[f[i] ^ 1]) af = min(af, c[f[i]]);
		for (int i = t; i != s; i = v[f[i] ^ 1]) c[f[i]] -= af, c[f[i] ^ 1] += af;
		flow += af; cost += af * dis[t];
	}
	void run()
	{
		while(spfa()) aug();
	}
} costflow;
int w[MAXN], l[MAXN], c[MAXN], d[MAXN], num[MAXN], money[MAXN], n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	costflow.init();
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d%d%d%d", &w[i], &l[i], &c[i], &d[i]);
	for (int i = 1; i <= n; i++) num[i] = w[i] + l[i];
	costflow.s = n + m + 1; costflow.t = costflow.s + 1;
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		costflow.add(costflow.s, i, 1, 0);
		costflow.add(i, a + m, 1, 0); costflow.add(i, b + m, 1, 0);
		++num[a]; ++num[b];
	}
	int ans = 0;
	for (int i = 1; i <= n; i++){
		for (int j = 0; j <= num[i]; j++) money[j] = c[i] * j * j + d[i] * (num[i] - j) * (num[i] - j);
		ans += money[w[i]];
		for (int j = w[i] + 1; j <= num[i]; j++) costflow.add(i + m, costflow.t, 1, money[j] - money[j - 1]);
	}
	costflow.run();
	printf("%d\n", ans += costflow.cost);
}
Problem1452

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, a[301][301];
struct Tbit{
	int data[301][301];
	void add(int x, int y, int delta)
	{
		for (int xx = x; xx <= n; xx += (xx & (-xx)))
			for (int yy = y; yy <= m; yy += (yy & (-yy)))
				data[xx][yy] += delta;
	}
	int getsum(int x, int y)
	{
		int ret = 0;
		for (int xx = x; xx; xx -= (xx & (-xx)))
			for (int yy = y; yy; yy -= (yy & (-yy)))
				ret += data[xx][yy];
		return ret;
	}
	int getsum(int x1, int y1, int x2, int y2)
	{
		return getsum(x2, y2) - getsum(x1 - 1, y2) - getsum(x2, y1 - 1) + getsum(x1 - 1, y1 - 1);
	}
} bit[101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &a[i][j]);
			bit[a[i][j]].add(i, j, 1);
		}
	int Q; scanf("%d", &Q);
	while(Q--){
		int x1, y1, x2, y2, t, op;
		scanf("%d", &op);
		switch(op){
			case 1 : scanf("%d%d%d", &x1, &y1, &t); bit[a[x1][y1]].add(x1, y1, -1); a[x1][y1] = t; bit[a[x1][y1]].add(x1, y1, 1); break;
			case 2 : scanf("%d%d%d%d%d", &x1, &x2, &y1, &y2, &t); printf("%d\n", bit[t].getsum(x1, y1, x2, y2)); break;
		}
	}
}	
Problem1453

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXN = 1001;
int a[MAXN][MAXN], sum[MAXN][2], fu[MAXN][MAXN], fd[MAXN][MAXN];
int n;
int fnow[MAXN], nnum[MAXN];
int find(int v) { return v == fnow[v] ? v : fnow[v] = find(fnow[v]); }
void init(int idx, int x)
{	
	sum[idx][0] = sum[idx][1] = 0;
	fu[idx][1] = fd[idx][1] = 1; ++sum[idx][a[x][1]];
	for (int i = 2; i <= n; i++)
		if (a[x][i] == a[x][i - 1]) fu[idx][i] = fd[idx][i] = fu[idx][i - 1];
		else fu[idx][i] = fd[idx][i] = i, ++sum[idx][a[x][i]];
}
void update(int idx, int l, int r)
{
	int m = (l + r) >> 1;
	sum[idx][0] = sum[idx * 2][0] + sum[idx * 2 + 1][0];
	sum[idx][1] = sum[idx * 2][1] + sum[idx * 2 + 1][1];
	for (int i = 1; i <= n << 2; i++) fnow[i] = i, nnum[i] = 0;
	for (int i = 1; i <= n; i++) if (a[m][i] == a[m + 1][i]){
		int A = find(fd[idx * 2][i]), B = find(fu[idx * 2 + 1][i] + 2 * n);
		if (A != B) fnow[A] = B, --sum[idx][a[m][i]];
		}
	int p = 0;
	for (int i = 1; i <= n; i++){
		int t = find(fu[idx * 2][i]); if (!nnum[t]) nnum[t] = ++p; fu[idx][i] = nnum[t];
		t = find(fd[idx * 2 + 1][i] + 2 * n); if (!nnum[t]) nnum[t] = ++p; fd[idx][i] = nnum[t];
		}
}	
void build(int idx, int l, int r)
{
	if (l == r) init(idx, l);
	else{
		build(idx * 2, l, l + r >> 1);
		build(idx * 2 + 1, l + r + 2 >> 1, r);
		update(idx, l, r);
		}
}
void modify(int idx, int l, int r, int val)
{
	if (l == r){
		init(idx, l); return;
		}
	else if (val <= (l + r >> 1)) 
		modify(idx * 2, l, l + r >> 1, val);
	else modify(idx * 2 + 1, l + r + 2 >> 1, r, val);
	update(idx, l, r );
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &a[i][j]);
	build(1, 1, n);
	int m, x, y; scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%d%d", &x, &y);
		a[x][y] ^= 1;
		modify(1, 1, n, x);
		printf("%d %d\n", sum[1][1], sum[1][0]);
		}
}
Problem1453

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXN = 1001;
int a[MAXN][MAXN], sum[MAXN][2], fu[MAXN][MAXN], fd[MAXN][MAXN];
int n;
int fnow[MAXN], nnum[MAXN];
int find(int v) { return v == fnow[v] ? v : fnow[v] = find(fnow[v]); }
inline void init(int idx, int x)
{	
	sum[idx][0] = sum[idx][1] = 0;
	fu[idx][1] = fd[idx][1] = 1; ++sum[idx][a[x][1]];
	for (int i = 2; i <= n; i++)
		if (a[x][i] == a[x][i - 1]) fu[idx][i] = fd[idx][i] = fu[idx][i - 1];
		else fu[idx][i] = fd[idx][i] = i, ++sum[idx][a[x][i]];
}
inline void update(int idx, int l, int r)
{
	int m = (l + r) >> 1;
	sum[idx][0] = sum[idx * 2][0] + sum[idx * 2 + 1][0];
	sum[idx][1] = sum[idx * 2][1] + sum[idx * 2 + 1][1];
	for (int i = 1; i <= n << 2; i++) fnow[i] = i, nnum[i] = 0;
	for (int i = 1; i <= n; i++) if (a[m][i] == a[m + 1][i]){
		int A = find(fd[idx * 2][i]), B = find(fu[idx * 2 + 1][i] + 2 * n);
		if (A != B) fnow[A] = B, --sum[idx][a[m][i]];
		}
	int p = 0;
	for (int i = 1; i <= n; i++){
		int t = find(fu[idx * 2][i]); if (!nnum[t]) nnum[t] = ++p; fu[idx][i] = nnum[t];
		t = find(fd[idx * 2 + 1][i] + 2 * n); if (!nnum[t]) nnum[t] = ++p; fd[idx][i] = nnum[t];
		}
}	
void build(int idx, int l, int r)
{
	if (l == r) init(idx, l);
	else{
		build(idx * 2, l, l + r >> 1);
		build(idx * 2 + 1, l + r + 2 >> 1, r);
		update(idx, l, r);
		}
}
void modify(int idx, int l, int r, int val)
{
	if (l == r){
		init(idx, l); return;
		}
	else if (val <= (l + r >> 1)) 
		modify(idx * 2, l, l + r >> 1, val);
	else modify(idx * 2 + 1, l + r + 2 >> 1, r, val);
	update(idx, l, r );
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &a[i][j]);
	build(1, 1, n);
	int m, x, y; scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%d%d", &x, &y);
		a[x][y] ^= 1;
		modify(1, 1, n, x);
		printf("%d %d\n", sum[1][1], sum[1][0]);
		}
}
Problem1455

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 3000001;
struct Tnode{
	int c[2], val;
} node[MAXN];
int f[MAXN], n, Q;
bool killed[MAXN];
int find(int x) { while (x != f[x]) x = f[x]; return x; }
int merge(int a, int b)
{
	if (a == 0 || b == 0) return a + b;
	if (node[a].val > node[b].val) swap(a, b);
	node[a].c[1] = merge(node[a].c[1], b);
	f[node[a].c[1]] = a;
	swap(node[a].c[1], node[a].c[0]);
	return a;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= n; i++) scanf("%d", &node[i].val);
	scanf("%d", &Q);
	while(Q--){
		char op[101]; int x, y;
		scanf(" ");
		scanf("%s", op);
		switch(*op){
			case 'M' : scanf("%d%d", &x, &y);
					   if (killed[x] || killed[y]) break;
					   x = find(x); y = find(y);
					   if (x == y) break;
					   merge(x, y);
					   break;
			case 'K' : scanf("%d", &x);
					   if (killed[x]) { puts("0"); break; }
					   x = find(x); printf("%d\n", node[x].val); killed[x] = true;
					   x = merge(node[x].c[0], node[x].c[1]);
					   f[x] = x;
		}
	}
}
Problem1455

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 3000001;
struct Tnode{
	int c[2], val;
} node[MAXN];
int f[MAXN], n, Q;
bool killed[MAXN];
int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }
int merge(int a, int b)
{
	if (a == 0 || b == 0) return a + b;
	if (node[a].val > node[b].val) swap(a, b);
	node[a].c[1] = merge(node[a].c[1], b);
	swap(node[a].c[1], node[a].c[0]);
	return a;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= n; i++) scanf("%d", &node[i].val);
	scanf("%d", &Q);
	while(Q--){
		char op[101]; int x, y, t;
		scanf(" ");
		scanf("%s", op);
		switch(*op){
			case 'M' : scanf("%d%d", &x, &y);
					   if (killed[x] || killed[y]) break;
					   x = find(x); y = find(y);
					   if (x == y) break;
					   f[x] = f[y] = merge(x, y);
					   break;
			case 'K' : scanf("%d", &x);
					   if (killed[x]) { puts("0"); break; }
					   x = find(x); printf("%d\n", node[x].val); killed[x] = true;
					   t = merge(node[x].c[0], node[x].c[1]);
					   f[x] = f[t] = t;
		}
	}
}
Problem1457

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int s[310], dp[301][301];
void mark(int x, int y)
{
	if (x > 0 && y > 0 && x != y) s[dp[x][y]] = true;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 1; i <= 100; i++)
		for (int j = 1; j <= 100; j++) if (i != j){
			memset(s, 0, sizeof(s));
			for (int k = 1; k <= 100; k++){
				mark(i - k, j);
				mark(i, j - k);
				mark(i - k, j - k);
			}
			int t = 0; while(s[t]) ++t;
			dp[i][j] = t;
		}
int TEST; scanf("%d", &TEST);
while(TEST--){
	int n, sg = 0, win = 0; scanf("%d", &n);
	while(n--){
		int x, y; scanf("%d%d", &x, &y);
		if (x == 0 || y == 0 || x == y) win = true; else sg ^= dp[x][y];
	}
		puts(win || sg ? "^o^" : "T_T");
}
}
Problem1458

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, MAXM = 2000001;
struct Tflow{
	int tot, e[MAXN], v[MAXM], c[MAXM], next[MAXM], s, t;
	int d[MAXN], q[MAXN], l, r;
	Tflow() { tot = 1; }
	void add(int a, int b, int w)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = w;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
	}
	bool relable()
	{
		for (int i = 1; i <= t; i++) d[i] = -1; d[s] = 0; l = r = 1; q[1] = s;
		while(l <= r){
			int x = q[l++]; 
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == -1){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f = 0x3f3f3f3f)
	{
		if (x == t) return f;
		int augc = f;
		for (int i = e[x]; i; i = next[i]) if (d[v[i]] == d[x] + 1 && c[i] > 0){
			int t = find(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0) break;
		}
		if (f != 0) d[x] = -1;
		return augc - f;
	}
	int run()
	{
		int t, ret = 0;
		while(relable()) while(t = find(s)) ret += t;
		return ret;
	}
} flow;
bool map[1001][1001];
int tnum1[1001], tnum2[1001], num1[1001], num2[1001];
int n, m, k, ans;
void check()
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) if (!map[i][j]){
			++tnum1[i]; ++tnum2[j]; ++ans;
		}
	for (int i = 1; i <= n; i++) if (num1[i] > tnum1[i]) { puts("JIONG!"); exit(0); }
	for (int i = 1; i <= m; i++) if (num2[i] > tnum2[i]) { puts("JIONG!"); exit(0); }
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &num1[i]);
	for (int i = 1; i <= m; i++) scanf("%d", &num2[i]);
	for (int i = 1; i <= k; i++){
		int a, b; scanf("%d%d", &a, &b); map[a][b] = true;
	}
	check();
	flow.s = n + m + 1; flow.t = n + m + 2;
	for (int i = 1; i <= n; i++) flow.add(flow.s, i, tnum1[i] - num1[i]);
	for (int i = 1; i <= m; i++) flow.add(i + n, flow.t, tnum2[i] - num2[i]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) if (!map[i][j])
			flow.add(i, j + n, 1);
	printf("%d\n", ans - flow.run());
}
Problem1465

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
long long n, s[1200001];
int a[1200001];
inline void scan(int&t)
{
    char c;while(c=getchar(),c<'0'||c>'9');t=c-'0';
    while(c=getchar(),c>='0'&&c<='9')t=t*10+c-'0';
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scan(a[i]);
    long long sum = 0; for (int i = 1; i <= n; i++) sum += a[i];
    long long ave = sum / n;
    for (int i = 1; i <= n; i++) a[i] -= ave;
    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
    sort(s + 1, s + n + 1);
    long long ans = 0;
    long long t = (n & 1) ? s[n + 1 >> 1] : ((s[n >> 1] + s[(n >> 1) + 1]) >> 1 );
    for (int i = 1; i <= n; i++) ans += abs(s[i] - t);
    printf("%lld\n", ans);
}
Problem1468

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 400001;
int e[MAXN], next[MAXN], v[MAXN], w[MAXN]; //Adjust
int q[MAXN], l, r; //Queue
int size[MAXN], ms[MAXN]; //find heaviest point
int D[MAXN], d[MAXN], cnt; //depth
int f[MAXN];
bool vis[MAXN];
int ans, n, K, tot;
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
}
void clear()
{
	memset(vis, 0, sizeof(vis));
	memset(e, 0, sizeof(e)); tot = 0; ans = 0;
}
void solve(int num)
{
	//Every time I go into this function, I should clear the array F NO
	//I should only clear F[num]
	//Part I : Find the heaviest point
	q[l = r = 1] = num; f[num] = 0;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]] && f[x] != v[i]){
			f[v[i]] = x; q[++r] = v[i];
			}
		}
	int MIN = 0x3f3f3f3f;
	for (int i = r; i >= 1; i--){
		int x = q[i]; size[x] = 1; ms[x] = 0; 
		for (int j = e[x]; j; j = next[j]) if (!vis[v[j]] && v[j] != f[x]){
			size[x] += size[v[j]]; ms[x] = max(ms[x], size[v[j]]);
			}
		ms[x] = max(ms[x], r - size[x]);
		if (ms[x] < MIN) MIN = ms[x], num = x;
		}	
	//Part II : BFS each son of num, get dis[] and calc
	D[cnt = 1] = d[num] = 0; vis[num] = true;
	for (int i = e[num]; i; i = next[i]) if (!vis[v[i]]){
		int x = v[i], start; D[start = (++cnt)] = d[x] = w[i]; f[x] = num;
		q[l = r = 1] = x;
		while(l <= r){
			int x =q[l++];
			for (int i = e[x]; i; i = next[i]) if (!vis[v[i]] && v[i] != f[x]){
				f[v[i]] = x; d[v[i]] = d[x] + w[i]; D[++cnt] = d[v[i]]; q[++r] = v[i];
				}
			}
		sort(D + start, D + cnt + 1);
		for (int i = start, j = cnt; ; i++){
			while(j > i && D[i] + D[j] >K) --j;
			if (j <= i) break;
			ans -= j - i;
			}
		}
	sort(D + 1, D + cnt + 1);
	for (int i = 1, j = cnt; ; i++){
		while(j > i && D[i] + D[j] >K) --j;
		if (j <= i) break;
		ans += j - i;
		}
	for (int i = e[num]; i; i = next[i]) if (!vis[v[i]]) solve(v[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	clear(); 
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(x, y, z); add(y, x, z);
		}
	scanf("%d", &K);
	solve(1);
	printf("%d\n", ans);
}
Problem1475

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 100001, INF = 0x3f3f3f3f;
int s, t, n, h[MAXN], vh[MAXN];
int tot = 1, e[MAXN], v[MAXN], c[MAXN], next[MAXN];
int change(int x, int y) { return (x - 1) * n + y; }
void add(int A, int B, int C)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
} 
int aug(int x, int f)
{
	if (x == t) return f;
	int augc = f, minh = t - 1;
	for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
		if (h[x] == h[v[i]] + 1){
			int t = aug(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0 || h[s] == t) return augc - f;
		}
		minh = min(minh, h[v[i]]);
	}
	if (f == augc){ if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1]; }
	return augc - f;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); s = n * n + 1; t = s + 1;
	int flow = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++){
			int num; scanf("%d", &num); flow += num;
			if ((i + j) & 1) add(s, change(i, j), num); else add(change(i, j), t, num);
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if ((i + j) & 1){
				if (i != 1) add(change(i, j), change(i - 1, j), INF);
				if (j != 1) add(change(i, j), change(i, j - 1), INF);
				if (i != n) add(change(i, j), change(i + 1, j), INF);
				if (j != n) add(change(i, j), change(i, j + 1), INF);
			}
	vh[0] = t;
	while(h[s] < t)
		flow -= aug(s, INF);
	printf("%d\n", flow);
}
Problem1477

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
ll x, y, n, m, P;
ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }
ll make(ll a) { return ((a % P) + P) % P; } 
void exgcd(ll a, ll b, ll & x, ll & y)
{
	if (b == 0) { x = 1; y = 0; return ; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
void solve(ll a, ll b) //ax == b mod P
{
	ll t = gcd(a, P);
	if (b % t) { puts("Impossible"); return; }
	a /= t; P /= t; b /= t;
	long long x, y;
	exgcd(a, P, x, y);
	cout << make(x * b) << endl;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> x >> y >> n >> m >> P;
	solve(make(m - n), make(x - y));
}
Problem1483

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <list>
#include <algorithm>
#include <iostream>
using namespace std;
#define Tli list<int>::iterator
list<int> l[1000001];
int color[1000001], num[1000001], real[1000001], n, m, ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	ans = 1;
	for (int i = 1; i <= n; i++){
		scanf("%d", &color[i]);
		if (i > 1 && color[i] != color[i - 1]) ++ans;
		l[color[i]].push_back(i); ++num[color[i]];
	}
	for (int i = 1; i <= 1000000; i++) real[i] = i;
	for (int i = 1; i <= m; i++){
		int op; scanf("%d", &op);
		if (op == 2) printf("%d\n", ans);
		else{
			int c1, c2; scanf("%d%d", &c1, &c2); if (c1 == c2) continue;
			if (num[real[c1]] > num[real[c2]]) swap(real[c1], real[c2]);
			c1 = real[c1]; c2 = real[c2];
			if (num[c1] == 0) continue;
			for (Tli li = l[c1].begin(); li != l[c1].end(); li++){
				int t = *li;
				if (t != 1 && color[t] != color[t - 1]) --ans;
				if (t != n && color[t] != color[t + 1]) --ans;
			}
			for (Tli li = l[c1].begin(); li != l[c1].end(); li++) color[*li] = c2;
			for (Tli li = l[c1].begin(); li != l[c1].end(); li++){
				int t = *li;
				if (t != 1 && color[t] != color[t - 1]) ++ans;
				if (t != n && color[t] != color[t + 1]) ++ans;
			}
			num[c2] += num[c1]; num[c1] = 0;
			l[c2].splice(l[c2].end(), l[c1]);
		}
	}
}
Problem1485

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
bool f[2000001];
int pnum, p[1000001], q[1000001], n, P, ans;
int pow(int a, int b)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1)  ret = (long long) ret * a % P;
		a = (long long)a * a % P;
	}
	return ret;
}
void work(int t, int d)
{
	for (int i = 1; i <= pnum; i++){
		int now = 1;
		while(t / now >= p[i]){
			now *= p[i];
			q[i] += (t / now) * d;
		}
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 2; i <= 2000000; i++){
		if (!f[i]) p[++pnum] = i;
		for (int j = 1; j <= pnum && 2000000 / i >= p[j]; j++){
		   f[i * p[j]] = true;
	   	   if (i % p[j] == 0) break;
		}
	}
	scanf("%d%d", &n, &P);
	work(2 * n, 1); work(n, -1); work(n + 1, -1);
	ans = 1;
	for (int i = 1; i <= pnum; i++) ans = (long long)ans * pow(p[i], q[i]) % P;
	printf("%d\n", ans);
}
Problem1486

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 100001, MAXM = 600001;
int n, m;
bool vis[MAXN];
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM];
	double w[MAXM], dis[MAXN];
	void add(int a, int b, double c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	bool spfa(int x, double k)
	{
		if (vis[x]) return true; vis[x] = true;
		for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i] - k){
			dis[v[i]] = dis[x] + w[i] - k; if (spfa(v[i], k)) { vis[x] = false; return true; }
		}
		vis[x] = false;
		return false;
	}
	bool check(double k)
	{
		for (int i = 1; i <= n; i++) dis[i] = 0.0;
		for (int i = 1; i <= n; i++) if (spfa(i, k)) return true;
		return false;
	}
} graph;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; double c; scanf("%d%d%lf", &a, &b, &c);
		graph.add(a, b, c);
	}
	double l = -10000.0, r = 10000.0;
	while(r - l > 1e-9){
		double m = (l + r) / 2.0;
		if (graph.check(m)) r = m; else l = m;
	}
	printf("%.8lf\n", l);
}
Problem1486

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 100001, MAXM = 600001;
int n, m;
bool vis[MAXN];
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM];
	double w[MAXM], dis[MAXN];
	void add(int a, int b, double c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	bool spfa(int x, double k)
	{
		if (vis[x]) return true; vis[x] = true;
		for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i] - k){
			dis[v[i]] = dis[x] + w[i] - k; if (spfa(v[i], k)) { vis[x] = false; return true; }
		}
		vis[x] = false;
		return false;
	}
	bool check(double k)
	{
		for (int i = 1; i <= n; i++) dis[i] = 0.0;
		for (int i = 1; i <= n; i++) if (spfa(i, k)) return true;
		return false;
	}
} graph;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; double c; scanf("%d%d%lf", &a, &b, &c);
		graph.add(a, b, c);
	}
	double l = 0.0, r = 10000.0;
	while(r - l > 1e-9){
		double m = (l + r) / 2.0;
		if (graph.check(m)) r = m; else l = m;
	}
	printf("%.8lf\n", l);
}
Problem1487

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001;
int f[MAXN][2], g[MAXN][2], cir[MAXN], l;
int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2];
int anc[MAXN], deep[MAXN], fa[MAXN];
int temp; bool vis[MAXN];
int num[MAXN], n, m;
void add(int a, int b) 
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void circle()
{
	int temp[2];
	temp[0] = temp[1] = 0xe0e0e0e0;
	for (int t = 0; t < 2; t++){
		g[1][t] = f[cir[1]][t]; g[1][!t] = 0xe0e0e0e0;
		for (int i = 2; i <= l; i++){
			g[i][0] = max(g[i - 1][0], g[i - 1][1]) + f[cir[i]][0];
			g[i][1] = g[i - 1][0] + max(f[cir[i]][1], f[cir[i]][0]);
		}
		if (t == 0) temp[0] = max(temp[0], max(g[l][0], g[l][1]));
		if (t == 1) temp[1] = max(temp[1], g[l][0]);
	}
	f[cir[1]][0] = temp[0]; f[cir[1]][1] = temp[1];
}
void dfs(int x)
{
	vis[x] = true; anc[x] = deep[x];
	for (int i = e[x]; i; i = next[i]) 
		if (!vis[v[i]]){
			fa[v[i]] = x; deep[v[i]] = deep[x] + 1;
			dfs(v[i]);
			anc[x] = min(anc[x], anc[v[i]]);
		}
		else if (fa[x] != v[i]) anc[x] = min(anc[x], deep[v[i]]);
	f[x][0] = 0; f[x][1] = num[x];
	for (int i = e[x]; i; i = next[i]) if (fa[v[i]] == x && anc[v[i]] > deep[x]){
		f[x][0] += max(f[v[i]][0], f[v[i]][1]); f[x][1] += f[v[i]][0];
	}
	for (int i = e[x]; i; i = next[i]) if (fa[v[i]] != x && deep[v[i]] > deep[x]){
		l = 2; for (int temp = fa[v[i]]; temp != x; temp = fa[temp]) cir[++l] = temp; cir[1] = x; cir[2] = v[i];
		circle();
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); add(a, b); add(b, a);
	}
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]);
	dfs(1);
	printf("%d\n", max(f[1][0], f[1][1]));
}
Problem1487

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001;
int f[MAXN][2], g[MAXN][2], cir[MAXN], l;
int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2];
int anc[MAXN], deep[MAXN], fa[MAXN];
int temp; bool vis[MAXN];
int num[MAXN], n, m;
void add(int a, int b) 
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void circle()
{
	int temp[2];
	temp[0] = temp[1] = 0xe0e0e0e0;
	for (int t = 0; t < 2; t++){
		g[1][t] = f[cir[1]][t]; g[1][!t] = 0xe0e0e0e0;
		for (int i = 2; i <= l; i++){
			g[i][0] = max(g[i - 1][0], g[i - 1][1]) + f[cir[i]][0];
			g[i][1] = g[i - 1][0] + max(f[cir[i]][1], f[cir[i]][0]);
		}
		if (t == 0) temp[0] = max(temp[0], max(g[l][0], g[l][1]));
		if (t == 1) temp[1] = max(temp[1], g[l][0]);
	}
	f[cir[1]][0] = temp[0]; f[cir[1]][1] = temp[1];
}
void dfs(int x)
{
	vis[x] = true; anc[x] = deep[x];
	for (int i = e[x]; i; i = next[i]) 
		if (!vis[v[i]]){
			fa[v[i]] = x; deep[v[i]] = deep[x] + 1;
			dfs(v[i]);
			anc[x] = min(anc[x], anc[v[i]]);
		}
		else if (fa[x] != v[i]) anc[x] = min(anc[x], deep[v[i]]);
	f[x][0] = 0; f[x][1] = num[x];
	for (int i = e[x]; i; i = next[i]) if (fa[v[i]] != x && deep[v[i]] > deep[x]){
		l = 2; for (int temp = fa[v[i]]; temp != x; temp = fa[temp]) cir[++l] = temp; cir[1] = x; cir[2] = v[i];
		circle();
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); add(a, b); add(b, a);
	}
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]);
	dfs(1);
	printf("%d\n", max(f[1][0], f[1][1]));
}
Problem1488

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MO = 997;
using namespace std;
int ans, mi[1001], ni[1001], g[101][101], a[101], n;
void dfs(int dep, int num, int nowans, int q, int last, int l)
{
	if (num == 0) { ans = (ans + nowans * mi[q]) % MO; return; }
	for (int i = last; i <= num; i++){
		a[dep + 1] = i;
		int temp = 0; for (int j = 1; j <= dep; j++) temp += g[a[j]][i];
		temp += (i >> 1);
		int templ = (dep == 0 || a[dep] != a[dep + 1]) ? 1 : l + 1;
		dfs(dep + 1, num - i, (nowans * ni[i]) % MO * ni[templ] % MO, (q + temp) % (MO - 1), i, templ);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	mi[0] = 1; for (int i = 1; i <= MO - 1; i++) mi[i] = mi[i - 1] * 2 % MO;
	ni[1] = 1; for (int i = 2; i <= MO - 1; i++) ni[i] = ni[MO % i] * (MO - MO / i) % MO;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) g[i][j] = __gcd(i, j);
	int jc = 1;
	for (int i = 1; i <= n; i++) jc = jc * i % MO;
	dfs(0, n, jc, 0, 1, 0);
	printf("%d\n", ans * ni[jc] % MO);
}
Problem1489

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, a[5001], f[3001][3001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	f[1][1] = a[1]; f[1][0] = -1;
	for (int i = 2; i <= n; i++)
		for (int j = 0; j <= n / 2; j++){
			f[i][j] = 0x3f3f3f3f;
			if (a[i] > a[i - 1]) f[i][j] = min(f[i][j], f[i - 1][j]);
			if (i > j && a[i] > f[i - 1][i - j - 1]) f[i][j] = min(a[i - 1], f[i][j]);
		}
	puts(f[n][n >> 1] == 0x3f3f3f3f ? "No!" : "Yes!");
}
}
Problem1491

#include <cstdio>
#include <cstdlib>
#include <cstring>
#define ll long long
const int MAXN = 200, INF = 0x3f3f3f3f;
int map[MAXN][MAXN];
ll path[MAXN][MAXN];
int n, m;
int main()
{
	scanf("%d%d", &n, &m);
	memset(map, 0x3f, sizeof(map));
	for (int i = 1; i <= n; i++) map[i][i] = 0, path[i][i] = 1;
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		if (map[x][y] == z) ++path[x][y], ++path[y][x];
		if (map[x][y] > z) map[x][y] = map[y][x] = z, path[x][y] = path[y][x] = 1;
		}
	for (int k = 1; k <= n; k++)
		for (int i = 1; i <= n; i++) if (k != i && map[i][k] != INF)
			for (int j = 1; j <= n; j++) if (k != j && i != j && map[k][j] != INF){
				if (map[i][k] + map[k][j] == map[i][j]) path[i][j] += path[i][k] * path[k][j];
				if (map[i][k] + map[k][j] < map[i][j]){
					path[i][j] = path[i][k] * path[k][j];
					map[i][j] = map[i][k] + map[k][j];
					}
				}
	for (int i = 1; i <= n; i++){
		double ans = 0.0;
		for (int s = 1; s <= n; s++) if (i != s)
			for (int t = 1; t <= n; t++) if (i != t && s != t)
				if (map[s][i] + map[i][t] == map[s][t])
					ans += (double)(path[s][i]) * path[i][t] / path[s][t];
		printf("%.3lf\n", ans);
		} 
}	
Problem1492

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
const int MAXN = 600001;
const double eps = 1e-7;
using namespace std;
int root, tot, n;
double s, A[MAXN], B[MAXN], R[MAXN], f[MAXN];
struct Tnode{
	static Tnode *A;
	int c[2], f;
	double k1, k2, x, y;
	void rot(bool b)
	{
		A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = A[f].f; A[f].c[c[!b] == A[f].c[1]] = this - A;
		A[c[!b]].f = this - A;
	}
	void print()
	{
		printf("father = %d c[0] = %d c[1] = %d\n", f, c[0], c[1]);
		printf("x = %.3lf y = %.3lf\n", x, y);
		printf("k1 = %.3lf k2 = %.3lf\n", k1, k2);
	}
} a[MAXN], *Tnode::A = a;
void splay(int x, int p)
{
	int y, z; bool b, c;
	if (p == 0) root = x;
	if (x == p) return;
	while((y = a[x].f) != p){
		b = x == a[y].c[1];
		if ((z = a[y].f) != p){
			c = y == a[z].c[1];
			if (b == c) a[y].rot(b); else a[x].rot(b);
			a[x].rot(c);
			}
		else a[x].rot(b);
		}
}
int nodemin(int t)
{
	while(a[t].c[0] != 0) t = a[t].c[0]; return t;
}
int nodemax(int t)
{
	while(a[t].c[1] != 0) t = a[t].c[1]; return t;
}
int getsmaller(int t)
{
	splay(t, 0); return nodemax(a[t].c[0]);
}
int getbigger(int t)
{
	splay(t, 0); return nodemin(a[t].c[1]);
}	
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	return 1;
}
bool shun(int A, int B, int C)
{
	return ((a[A].x - a[C].x) * (a[B].y - a[C].y) - (a[A].y - a[C].y) * (a[B].x - a[C].x)) >= 0;
}
double getmax(double A, double B)
{
	int t = root; double k = - A / B;
	while(1){
		if (dcmp(a[t].k1 - k) >= 0 && dcmp(a[t].k2 - k) <= 0) return A * a[t].x + B * a[t].y;
		if (a[t].k1 > k) t = a[t].c[1]; else t = a[t].c[0];
		}
}
int insert(double x, double y) //±£÷§≤Â»Îµƒ ±∫Ú“—æ≠»•≥˝¡Àxœ‡µ±µƒ«Èøˆ≤¢«““—æ≠splayÕÍ±œ 
{
	int p = root;
	while(1)
		if(dcmp(a[p].x - x) == 0)
			if (y > a[p].y){
				a[p].y = y; splay(p, 0); return p;
				}
			else return 0;
		else if (a[p].c[x > a[p].x] == 0){
			++tot; a[tot].f = p; a[tot].x = x; a[tot].y = y;
			a[p].c[x > a[p].x] = tot;
			splay(tot, 0); return tot;
			}
		else p = a[p].c[x > a[p].x];
}
void del(int x)
{
	splay(x, 0);
	if (a[x].c[0] == 0)
		root = a[x].c[1];
	else if (a[x].c[1] == 0)
		root = a[x].c[0];
	else{
		splay(nodemax(a[x].c[0]), x);
		root = a[x].c[0];
		a[a[x].c[1]].f = root; a[root].c[1] = a[x].c[1];
		}
	a[root].f = 0;
}
void fix()
{
	if (a[root].c[0] == 0 && a[root].c[1] == 0){
		a[root].k1 = 1e99; a[root].k2 = -1e99;
		return;
		}
	//–¬µ„“™±ª…æ≥˝£¨”–¡Ω÷÷«Èøˆ 
	if (a[root].c[0] == 0){ //◊Ó◊Û∂Àµ„«Èøˆ≈–∂œ 
		a[root].k1 = 1e99;
		splay(nodemin(a[root].c[1]), root);
		if (a[root].y < a[a[root].c[1]].y){
			root= a[root].c[1]; a[root].k1 = 1e99;
			return;
			}
		}
	int now = root, l = a[root].c[0], r = a[root].c[1], ll, rr;
	if (l != 0) splay(nodemax(a[root].c[0]), root);
	if (r != 0) splay(nodemin(a[root].c[1]), root);
	l = a[root].c[0]; r = a[root].c[1];
	if (l != 0 && r != 0)
		if (shun(now, r, l)){
			del(now); //÷ª“™≤ª≤Â»Î–¬µƒ£¨‘≠¿¥µƒ–≈œ¢æÕ «∂‘µƒ£¨»Áπ˚’‚∏ˆµ„µƒ–≈œ¢ «“‘«∞µƒµ„∏ƒµƒ£¨ƒ«√¥“ª∂®“™≤Â»Î
			return;
			}
	//≤Â»ÎÀ˚£¨…æ±µƒµ„
	while(1){
		if (l == 0) break;
		ll = getsmaller(l);
		if (a[l].y < a[now].y){
			del(l); l = ll; continue;
			}
		if (ll == 0) break;
		if (shun(l, now, ll)){
			del(l); l = ll; continue;
			}
		else break;
		}
	while(1){
		if (r == 0) break;
		rr = getbigger(r);
		if (rr == 0) break;
		if (!shun(r, now, rr)){
			del(r); r = rr; continue;
			}
		else break;
		}
	if (l == 0) a[now].k1 = 1e99; else{
		a[now].k1 = (a[now].y - a[l].y) / (a[now].x - a[l].x);
		a[l].k2 = (a[now].y - a[l].y) / (a[now].x - a[l].x);
		}
	if (r == 0) a[now].k2 = -1e99; else{
		a[now].k2 = (a[r].y - a[now].y) / (a[r].x - a[now].x);
		a[r].k1 = (a[r].y - a[now].y) / (a[r].x - a[now].x);
		}
}
void DEBUG(int t)
{
	if (t == 0) return;
	printf("INF of %d\n", t); a[t].print();
	DEBUG(a[t].c[0]); DEBUG(a[t].c[1]);
}
void readf(double&a) {
    int t; bool p=false; double l=1;
    while ((t=getchar())==' '||t=='\n'); a=t-'0';
    while ((t=getchar())!=' '&&t!='\n') {
        if (t=='.') {p=true;continue;}
        if (!p) a*=10,a+=t-'0';else l*=0.1,a+=(t-'0')*l;
    }
}
int main()
{
	scanf("%d%lf", &n, &s);
	for (int i = 1; i <= n; i++) readf(A[i]), readf(B[i]), readf(R[i]);
	f[1] = s;
	a[1].y = s / (A[1] * R[1] + B[1]); a[1].x = a[1].y * R[1];
	a[1].k1 = 1e99; a[1].k2 = -1e99; tot = root = 1;
	for (int i = 2; i <= n; i++){
		if (i == 287){
			int a;
			++a;
			}
		double tt = getmax(A[i], B[i]);
		//printf("%.7lf\n", tt);
		f[i] = f[i - 1]; f[i] = max(f[i], tt);
		double y = f[i] / (A[i] * R[i] + B[i]), x = y * R[i];
		int t = insert(x, y);
		if (t == 0) continue; else fix();
		//printf("-----------------STAGE%d\n", i); DEBUG(root);
		}
	double ans = -1e99;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
	printf("%.3lf\n", ans);
}
Problem1492

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
const int MAXN = 600001;
const double eps = 1e-7;
using namespace std;
int root, tot, n;
double s, A[MAXN], B[MAXN], R[MAXN], f[MAXN];
struct Tnode{
	static Tnode *A;
	int c[2], f;
	double k1, k2, x, y;
	void rot(bool b)
	{
		A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = A[f].f; A[f].c[c[!b] == A[f].c[1]] = this - A;
		A[c[!b]].f = this - A;
	}
} a[MAXN], *Tnode::A = a;
void splay(int x, int p)
{
	int y, z; bool b, c;
	if (p == 0) root = x;
	if (x == p) return;
	while((y = a[x].f) != p){
		b = x == a[y].c[1];
		if ((z = a[y].f) != p){
			c = y == a[z].c[1];
			if (b == c) a[y].rot(b); else a[x].rot(b);
			a[x].rot(c);
			}
		else a[x].rot(b);
		}
}
int nodemin(int t)
{
	while(a[t].c[0] != 0) t = a[t].c[0]; return t;
}
int nodemax(int t)
{
	while(a[t].c[1] != 0) t = a[t].c[1]; return t;
}
int getsmaller(int t)
{
	splay(t, 0); return nodemax(a[t].c[0]);
}
int getbigger(int t)
{
	splay(t, 0); return nodemin(a[t].c[1]);
}	
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	return 1;
}
bool shun(int A, int B, int C)
{
	return ((a[A].x - a[C].x) * (a[B].y - a[C].y) - (a[A].y - a[C].y) * (a[B].x - a[C].x)) >= 0;
}
double getmax(double A, double B)
{
	int t = root; double k = - A / B;
	while(1){
		if (dcmp(a[t].k1 - k) >= 0 && dcmp(a[t].k2 - k) <= 0) return A * a[t].x + B * a[t].y;
		if (a[t].k1 > k) t = a[t].c[1]; else t = a[t].c[0];
		}
}
int insert(double x, double y) //±£÷§≤Â»Îµƒ ±∫Ú“—æ≠»•≥˝¡Àxœ‡µ±µƒ«Èøˆ≤¢«““—æ≠splayÕÍ±œ 
{
	int p = root;
	while(1)
		if(dcmp(a[p].x - x) == 0)
			if (y > a[p].y){
				a[p].y = y; splay(p, 0); return p;
				}
			else return 0;
		else if (a[p].c[x > a[p].x] == 0){
			++tot; a[tot].f = p; a[tot].x = x; a[tot].y = y;
			a[p].c[x > a[p].x] = tot;
			splay(tot, 0); return tot;
			}
		else p = a[p].c[x > a[p].x];
}
void del(int x)
{
	splay(x, 0);
	if (a[x].c[0] == 0)
		root = a[x].c[1];
	else if (a[x].c[1] == 0)
		root = a[x].c[0];
	else{
		splay(nodemax(a[x].c[0]), x);
		root = a[x].c[0];
		a[a[x].c[1]].f = root; a[root].c[1] = a[x].c[1];
		}
	a[root].f = 0;
}
void fix()
{
	if (a[root].c[0] == 0 && a[root].c[1] == 0){
		a[root].k1 = 1e99; a[root].k2 = -1e99;
		return;
		}
	//–¬µ„“™±ª…æ≥˝£¨”–¡Ω÷÷«Èøˆ 
	if (a[root].c[0] == 0){ //◊Ó◊Û∂Àµ„«Èøˆ≈–∂œ 
		a[root].k1 = 1e99;
		splay(nodemin(a[root].c[1]), root);
		if (a[root].y < a[a[root].c[1]].y){
			root= a[root].c[1]; a[root].k1 = 1e99;
			return;
			}
		}
	int now = root, l = a[root].c[0], r = a[root].c[1], ll, rr;
	if (l != 0) splay(nodemax(a[root].c[0]), root);
	if (r != 0) splay(nodemin(a[root].c[1]), root);
	l = a[root].c[0]; r = a[root].c[1];
	if (l != 0 && r != 0)
		if (shun(now, r, l)){
			del(now); //÷ª“™≤ª≤Â»Î–¬µƒ£¨‘≠¿¥µƒ–≈œ¢æÕ «∂‘µƒ£¨»Áπ˚’‚∏ˆµ„µƒ–≈œ¢ «“‘«∞µƒµ„∏ƒµƒ£¨ƒ«√¥“ª∂®“™≤Â»Î
			return;
			}
	//≤Â»ÎÀ˚£¨…æ±µƒµ„
	while(1){
		if (l == 0) break;
		ll = getsmaller(l);
		if (a[l].y < a[now].y){
			del(l); l = ll; continue;
			}
		if (ll == 0) break;
		if (shun(l, now, ll)){
			del(l); l = ll; continue;
			}
		else break;
		}
	while(1){
		if (r == 0) break;
		rr = getbigger(r);
		if (rr == 0) break;
		if (!shun(r, now, rr)){
			del(r); r = rr; continue;
			}
		else break;
		}
	if (l == 0) a[now].k1 = 1e99; else{
		a[now].k1 = (a[now].y - a[l].y) / (a[now].x - a[l].x);
		a[l].k2 = (a[now].y - a[l].y) / (a[now].x - a[l].x);
		}
	if (r == 0) a[now].k2 = -1e99; else{
		a[now].k2 = (a[r].y - a[now].y) / (a[r].x - a[now].x);
		a[r].k1 = (a[r].y - a[now].y) / (a[r].x - a[now].x);
		}
}
void readf(double&a) {
    int t; bool p=false; double l=1;
    while ((t=getchar())==' '||t=='\n'); a=t-'0';
    while ((t=getchar())!=' '&&t!='\n') {
        if (t=='.') {p=true;continue;}
        if (!p) a*=10,a+=t-'0';else l*=0.1,a+=(t-'0')*l;
    }
}
int main()
{
	scanf("%d%lf", &n, &s);
	for (int i = 1; i <= n; i++) readf(A[i]), readf(B[i]), readf(R[i]);
	f[1] = s;
	a[1].y = s / (A[1] * R[1] + B[1]); a[1].x = a[1].y * R[1];
	a[1].k1 = 1e99; a[1].k2 = -1e99; tot = root = 1;
	for (int i = 2; i <= n; i++){
		if (i == 287){
			int a;
			++a;
			}
		double tt = getmax(A[i], B[i]);
		f[i] = f[i - 1]; f[i] = max(f[i], tt);
		double y = f[i] / (A[i] * R[i] + B[i]), x = y * R[i];
		int t = insert(x, y);
		if (t == 0) continue; else fix();
		}
	double ans = -1e99;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
	printf("%.3lf\n", ans);
}
Problem1493

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
int n, p, dir;
struct Tinf{
	int lc, rc, num;
	void set(int c)
	{
		lc = rc = c; num = 1;
	}
	Tinf operator + (Tinf B)
	{
		Tinf temp; 
		temp.lc = lc; temp.rc = B.rc; 
		temp.num = num + B.num - (rc == B.lc);
		return temp;
	}
};	
struct Tsegtree{
	Tinf inf[MAXN << 2]; int same[MAXN << 2];
	void color(int idx, int c)
	{
		inf[idx].set(c); same[idx] = c;
	}
	void update(int idx)
	{
		inf[idx] = inf[idx * 2] + inf[idx * 2 + 1];
	}
	void push(int idx)
	{
		if (same[idx] != 0){
			color(idx * 2, same[idx]);
			color(idx * 2 + 1, same[idx]);
			}
		same[idx] = 0;
	}
	void build(int idx, int l, int r)
	{
		if (l == r){
			int t; scanf("%d", &t); inf[idx].set(t);
			return;
			}
		int m = l + r >> 1;
		build(idx * 2, l, m); build(idx * 2 + 1, m + 1, r);
		update(idx);
	}
	Tinf getinf(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return inf[idx];
		int m = l + r >> 1; push(idx);
		if (ll > m) return getinf(idx * 2 + 1, m + 1, r, ll, rr);
		if (rr <= m) return getinf(idx * 2, l, m, ll, rr);
		return getinf(idx * 2, l, m, ll, rr) + getinf(idx * 2 + 1, m + 1, r, ll, rr);
	}
	void paint(int idx, int l, int r, int ll, int rr, int c)
	{
		if (ll <= l && rr >= r) { color(idx, c); return; }
		int m = l + r >> 1; push(idx);
		if (ll <= m) paint(idx * 2, l, m, ll, rr, c);
		if (rr > m) paint(idx * 2 + 1, m + 1, r, ll, rr, c);
		update(idx);
	}
	void paint(int l, int r, int c)
	{
		paint(1, 1, n, l, r, c);
	}
	Tinf getinf(int l, int r)
	{
		return getinf(1, 1, n, l, r);
	}
}T;
void rotate(int k)
{
	p = (p + k - 1) % n + 1;
}
void flip()
{
	dir *= -1;
	if (p != 1) p = n + 2 - p;
}
int get(int a)
{
	int t;
	if (dir == 1) t = (a - p + n) % n + 1; else t = (p - a + n) % n + 1;
	//printf("%d -> %d\n", a, t);
	return t;
}
void swap(int a, int b)
{
	a = get(a); b = get(b);
	int ca = T.getinf(a, a).lc, cb = T.getinf(b, b).lc;
	T.paint(a, a, cb); T.paint(b, b, ca);
}
void count()
{
	Tinf temp = T.getinf(1, n);
	printf("%d\n", max(1, temp.num - (temp.lc == temp.rc)));
}
void paint(int l, int r, int c)
{
	l = get(l); r = get(r);
	if (dir == -1) std::swap(l, r);
	if (l <= r) T.paint(l, r, c);
	else { T.paint(1, r, c); T.paint(l, n, c); }
}
void cs(int l, int r)
{
	l = get(l); r = get(r);
	if (dir == -1) std::swap(l, r);
	if (l <= r) printf("%d\n", T.getinf(l, r).num);
	else{
		Tinf infl = T.getinf(1, r), infr = T.getinf(l, n);
		printf("%d\n", infl.num + infr.num - (infl.lc == infr.rc));
		}
}
int main()
{
	scanf("%d%*d", &n); p = 1; dir = 1;
	T.build(1, 1, n);
	int m;
	scanf("%d", &m); getchar();
	char op[20];
	while(m--){
		scanf("%s", op);
		int k, a, b, l, r, c;
		switch(*op){
			case 'R' : scanf("%d", &k); rotate(k); break;
			case 'F' : flip(); break;
			case 'S' : scanf("%d%d", &a, &b); swap(a, b); break;
			case 'P' : scanf("%d%d%d", &l, &r, &c); paint(l, r, c); break;
			case 'C' :
				if (*(op + 1) == 'S'){
					scanf("%d%d", &a, &b); 
					cs(a, b);
					} 
				else count(); 
				break;
			}
		}
}
Problem1494

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
#define GET(S, i) ((S >> (i + i + i)) & 7)
#define CHA(S, i, t) (S ^ ((GET(S, i) ^ t) << (i + i + i)))
#define DEBUG
using namespace std;
const int MO = 65521;
long long n;
int k;
int calcS, nowS, nownum;
struct Thash{
	map<int, int> M; int tot;
	int find(int t)
	{
		if (M.count(t) > 0) return M[t];
		else return M[t] = ++tot;
	}
} H;
inline int mul(int a,int b) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n"
            :"=d"(ret):"a"(a),"b"(b),"c"(MO));
    return ret;
}
struct Tmatrix{
    int data[71][71];
    int r, c;
    void clear() { memset(data, 0, sizeof(data)); }
}TM, temp, start, G;
inline Tmatrix operator * (Tmatrix A, Tmatrix B)
{
    temp.r = A.r; temp.c = B.c;
    for (int i = 1; i <= temp.r; i++)
        for (int j = 1; j <= temp.c; j++){
            temp.data[i][j] = 0;
            for (int k = 1; k <= A.c; k++)
                temp.data[i][j] = (temp.data[i][j] + mul(A.data[i][k], B.data[k][j]) ) % MO;
            }
    return temp;
}
int app[10];
int findnew(int S)
{
	for (int i = 0; i <= 7; i++) app[i] = false;
	for (int i = 0; i <= k; i++) app[GET(S, i)] = true;
	for (int i = 0; i <= 7; i++) if (!app[i]) return i;
	return 0;
}
int newnum[101];
int rebuild(int S, int flag = false)
{
	int tot = -1;
	for (int i = 0; i <= 7; i++) newnum[i] = -1;
	for (int i = 0; i <= k - flag; i++){
		int t = GET(S, i);
		if (newnum[t] == -1) newnum[t] = ++tot;
		}
	for (int i = 0; i <= k - flag; i++) S = CHA(S, i, newnum[GET(S, i)]);
	return S;
}
int merge(int S, int a, int b)
{
	a = GET(S, a); b = GET(S, b);
	for (int i = 0; i <= k; i++) if (GET(S, i) == a) S = CHA(S, i, b);
	return rebuild(S);
}
bool check(int S)
{
	return rebuild(S) == S;
}
void checkDFS()
{
	int S = rebuild(nowS);
	bool bad = true;
	for (int i = 1; i <= k; i++) if (GET(S, i) == GET(S, 0)) bad = false;
	if (bad) return;
	int nS = rebuild(S >> 3, true);
	TM.data[nownum][H.find(nS)]++;
}
void DFS(int dep)
{
	if (dep == k) { checkDFS(); return; }
	DFS(dep + 1);
	if (GET(nowS, k) == GET(nowS, dep)) return;
	int tempS = nowS;
	nowS = merge(nowS, dep, k);
	DFS(dep + 1);
	nowS = tempS;
}
int calcstart(int S)
{
	for (int i = 0; i <= 7; i++) app[i] = 0;
	for (int i = 0; i < k; i++) ++app[GET(S, i)];
	int t = 1;
	for (int i = 0; i <= 7; i++) if (app[i] > 2)
		for (int j = 1; j <= app[i] - 2; j++)
			t = t * app[i];
	return t;
}
void prepare()
{
	for (int i = 0; i <= ((1 << (k * 3)) - 1); i++) if (check(i)){
		nownum = H.find(i); calcS = nowS = i;
		int t = findnew(nowS); nowS = CHA(nowS, k, t);
		t = nownum;
		start.data[1][t] = calcstart(i);
		DFS(0);
		}
}
int main()
{
	cin >> k >> n;
	prepare();
	TM.r = TM.c = H.tot;
	start.r = 1; start.c = H.tot;
	G = TM;
	for (long long i = n - k - 1; i; i >>= 1){
		if (i & 1) G = G * TM;
		TM = TM * TM;
		}
	start = start * G;
	printf("%d\n", start.data[1][1]);
}
Problem1495

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int SIZE = 173456, INF = 0x1f1f1f1f;
int n, how[1025], cost[1025], map[1024][1024];
struct Thashnode{
	int i, j, k, f, next;
};
struct Thash1{
	int e[SIZE + 100], tot; Thashnode data[910000];
	void insert(int i, int j, int k, int f)
	{
		int h = (i * 1132896 + j * 112997 + k * 13931) % SIZE;
		for (int hashi = e[h]; hashi; hashi = data[hashi].next)
			if (data[hashi].i == i && data[hashi].j == j && data[hashi].k == k)
				data[hashi].f = min(data[hashi].f, f);
		++tot; data[tot].i = i; data[tot].j = j; data[tot].k = k; data[tot].f = f;
		data[tot].next = e[h]; e[h] = tot;
	}
	int find(int i, int j, int k)
	{
		int h = (i * 1132896 + j * 112997 + k * 13931) % SIZE;
		for (int hashi = e[h]; hashi; hashi = data[hashi].next)
			if (data[hashi].i == i && data[hashi].j == j && data[hashi].k == k)
				return data[hashi].f;
		return INF;
	}
} hash;
struct Thash2{
	int e[SIZE + 100], tot; Thashnode data[2100000];
	void insert(int i, int j, int k, int f)
	{
		int h = (i * 1132896 + j * 112997 + k * 13931) % SIZE;
		for (int hashi = e[h]; hashi; hashi = data[hashi].next)
			if (data[hashi].i == i && data[hashi].j == j && data[hashi].k == k)
				data[hashi].f = min(data[hashi].f, f);
		++tot; data[tot].i = i; data[tot].j = j; data[tot].k = k; data[tot].f = f;
		data[tot].next = e[h]; e[h] = tot;
	}
	int find(int i, int j, int k)
	{
		int h = (i * 1132896 + j * 112997 + k * 13931) % SIZE;
		for (int hashi = e[h]; hashi; hashi = data[hashi].next)
			if (data[hashi].i == i && data[hashi].j == j && data[hashi].k == k)
				return data[hashi].f;
		return INF;
	}
} HASH;
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= (1 << n); i++) scanf("%d", &how[i]);
	for (int i = 1; i <= (1 << n); i++) scanf("%d", &cost[i]);
	for (int i = 1; i <= (1 << n); i++)
		for (int j = i + 1; j <= (1 << n); j++){
			int t; scanf("%d", &t);
			int a = i - 1 + (1 << n), b = j - 1 + (1 << n), lca = 0;
			for (int k = n; k >= 0; k--)
				if ((a >> k) != (b >> k)) break;
				else lca = (a >> k);
			map[i][lca] += t; map[j][lca] += t;
			}
	for (int i = 1; i <= (1 << n); i++){
		int real = i + (1 << n) - 1;
		for (int color = 0; color <= 1; color++)
			for (int j = 0; j < (1 << n); j++){
				int nowcost = color == how[i] ? 0 : cost[i];
				for (int f = 0; f < n; f++)
					if (color != ((j >> f) & 1)) nowcost += map[i][real >> (f + 1)];
				HASH.insert(real, !color, j, nowcost);
				}
		}
	for (int dep = n; dep >= 1; dep--)
		for (int i = 1; i <= (1 << (dep - 1)); i++){
			int real = (1 << (dep - 1)) + i - 1;
			for (int j = 0; j <= (1 << (n - dep + 1)); j++)
				for (int k = 0; k < (1 << (dep - 1)); k++){
					int best = INF; int color = (j < (1 << (n - dep)));
					if (dep == n){
					for (int lj = 0; lj <= j; lj++)
						best = min(HASH.find(real << 1, lj, (k << 1) + color)+
								   HASH.find((real << 1) + 1, j - lj, (k << 1) + color),
								   best);
					}
					else{
					for (int lj = 0; lj <= j; lj++)
						best = min(hash.find(real << 1, lj, (k << 1) + color)+
								   hash.find((real << 1) + 1, j - lj, (k << 1) + color),
								   best);
					}	
					if (best < INF) hash.insert(real, j, k, best);
					}
			}
	int ans = INF;
	for (int j = 0; j <= (1 << n); j++) ans = min(ans, hash.find(1, j, 0));
	printf("%d\n", ans);
}
		
Problem1497

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using std::min;
const int INF = 0x3f3f3f3f;
int n, m, tot = 1, S, T;
int e[100001], next[1000001], v[1000001], c[1000001], h[1000001], vh[1000001];
void add(int A, int B, int C)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
}
int aug(int x, int f)
{
	if (x == T) return f;
	int augc = f, minh = T - 1;
	for (int i = e[x]; i ; i = next[i]) if (c[i] > 0){
		if (h[x] == h[v[i]] + 1){
			int t = aug(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0 || h[S] == T) return augc - f;
			}
		if (h[v[i]] < minh) minh = h[v[i]];
		}
	if (f == augc){
		--vh[h[x]]; if (vh[h[x]] == 0) h[S] = T;
		h[x] = minh + 1; ++vh[h[x]];
		}
	return augc - f;
}
int main()
{
	scanf("%d%d", &n, &m);
	S = n + m + 1; T = S + 1;
	for (int i = 1; i <= n; i++) { int t; scanf("%d", &t); add(m + i, T, t); }
	int sum = 0;
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c); sum += c;
		add(S, i, c); add(i, a + m, INF); add(i, b + m, INF);
		}
	vh[0] = T;
	while(h[S] < T) sum -= aug(S, INF);
	printf("%d\n", sum);
}
Problem1498

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define NOANS { puts("0/1"); return 0; }
using namespace std;
int pnum, p[20001], t, n, d, num[20001], tot;
bool f[20001];
struct Tbig{
	int len, data[2001];
	void init() { memset(data, 0, sizeof(data)); len = 1; data[1] = 1; }
	Tbig & operator *= (int k)
	{
		int t = 0;
		for (int i = 1; i <= len; i++){
			data[i] = data[i] * k + t;
			t = data[i] / 10000;
			data[i] %= 10000;
			}
		data[len + 1] = t;
		while(data[len + 1]) ++len;
		return *this;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]);
	}
} temp1, temp2;
struct Tnum{
	int data[20001];
	void mul(int a, int d)
	{
		for (int i = 1; i <= pnum && p[i] <= a; i++){
			while(a % p[i] == 0) data[i] += d, a /= p[i];
			}
	}
	void print()
	{
		temp1.init(); temp2.init();
		for (int i = 1; i <= pnum; i++){
			while(data[i] > 0) temp1 *= p[i], --data[i];
			while(data[i] < 0) temp2 *= p[i], ++data[i];
			}
		temp1.print();
		putchar('/');
		temp2.print();
		putchar('\n');
	}		
} NUM;
void GETP(int MAXN)
{
	memset(f, 1, sizeof(f)); f[0] = f[1] = false;
	p[pnum = 1] = 2;
	for (int now = 2; now < MAXN;){
		for (int j = now + now; j <= MAXN; j += now) f[j] = false;
		for (++now; now < MAXN && !f[now]; ++now);
		if (f[now]) p[++pnum] = now;
		}
}
int main()
{
	GETP(20000);
	scanf("%d%d%d", &n, &t, &d);
	for (int i = 1; i <= n; i++) { scanf("%d", &num[i]); tot += num[i]; }
	for (int i = 1; i <= t; i++){
		int t; scanf("%*d%d", &t); if (num[t] == 0) NOANS;
		NUM.mul(num[t], 1); NUM.mul(tot, -1);
		num[t] += d; tot += d;
		}
	NUM.print();
}
	
Problem1499

//f[i][j][k] after we have passes the kth we are at (i,j),the maxstep wo have gone
//f[x0][y0][0] = 0
//f[i][j][k] = max (f[i'][j'][k - 1] + dis(i, j, i', j'))
//For example type[k] = 4
//f[i][j][k] = max f[i][j'][k - 1] + j - j' (j' < j && j - j'<=maxstep[k]) 
//mono_queue
//O(M*N*K)
#include <cstdio>
#include <cstdlib>

const int MAXN = 210, MAXM = 210, MAXK = 210, INF = 100000000;

struct Tnode{
       int f,w;
       } q[MAXN];
int f[MAXN][MAXM];
bool ok[MAXN][MAXM];
int st[MAXK], ed[MAXK], type[MAXK];
int N, M, K, x0, y0;
int l, r;
int ans;
int main()
{
    scanf("%d%d%d%d%d\n", &N , &M, &x0, &y0, &K);
    for (int i = 1; i <= N; i++){
        for (int j = 1; j <= M; j++){
            char c = getchar();
            if (c == 'x')
               ok[i][j] = false;
            else
                ok[i][j] = true;
            f[i][j] = -INF;
            }
        getchar();
        
        }
    f[x0][y0] = 0;
    for (int i = 1; i <= K; i++)
        scanf("%d%d%d", &st[i], &ed[i], &type[i]);
    for (int i = 1; i <= K; i++)
        switch (type[i]){
           case 1:
                for (int x = 1; x <= M; x++){
                    l = 1; r = 0;
                    for (int y = N; y >= 1; y--){
                        if (!ok[y][x]) {
                           l = 1; r = 0;
                           continue;
                           }
                        int t = f[y][x] + y;
                        while (l <= r && q[r].f <= t)
                              r--;
                        ++r;
                        q[r].f = t;
                        q[r].w = y;
                        if  (q[l].w - y > ed[i] - st[i] + 1) l++;
                        f[y][x] = q[l].f - y;
                        }        
                    }
                break;
           case 2:
                for (int x = 1; x <= M; x++){
                    l = 1; r = 0;
                    for (int y = 1; y <= N; y++){
                        if (!ok[y][x]) {
                           l = 1; r = 0;
                           continue;
                           }
                        int t = f[y][x] - y;
                        while (l <= r && q[r].f <= t)
                              r--;
                        ++r;
                        q[r].f = t;
                        q[r].w = y;
                        if  (y -q[l].w > ed[i] - st[i] + 1) l++;
                        f[y][x] = q[l].f + y;
                        } 
                    }
                break;
           case 3:
                for (int x = 1; x <= N; x++){
                    l = 1; r = 0;
                    for (int y = M; y >= 1; y--){
                        if (!ok[x][y]) {
                           l = 1; r = 0;
                           continue;
                           }
                        int t = f[x][y] + y;
                        while (l <= r && q[r].f <= t)
                              r--;
                        ++r;
                        q[r].f = t;
                        q[r].w = y;
                        if  (q[l].w - y > ed[i] - st[i] + 1) l++;
                        f[x][y] = q[l].f - y;
                        }        
                    }
                break;
           case 4:
                for (int x = 1; x <= N; x++){
                    l = 1; r = 0;
                    for (int y = 1; y <= M; y++){
                        if (!ok[x][y]){
                           l = 1; r = 0;
                           continue;
                           }
                        int t = f[x][y] - y;
                        while (l <= r && q[r].f <= t)
                              r--;
                        ++r;
                        q[r].f = t;
                        q[r].w = y;
                        if  (y -q[l].w > ed[i] - st[i] + 1) l++;
                        f[x][y] = q[l].f + y;
                        } 
                    }
                break;
           }
    ans = 0;
    for (int i = 1; i <=N; i++)
        for (int j = 1; j <= M; j++)
            if (f[i][j] > ans)
               ans = f[i][j];
    printf("%d\n", ans);
}
Problem1500

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;	
struct Tnode{
	static Tnode *a;
	int f, c[2], size, val;
	int _same; bool _rev;
	int sum, maxl, maxr, maxs;
	void same(int k)
	{
		if(this != a){
			_same = val = k;
			sum = k * size;
			maxl = maxr = (sum > 0 ? sum : 0);
			maxs = (k > 0 ? sum : k);
			}
	}
	void rev()
	{
		if (this != a){
			swap(c[0], c[1]);
			swap(maxl, maxr);
			_rev ^= 1;
			}
	}
	void push()
	{
		if (_same != 0xe0e0e0e0){
			a[c[0]].same(_same); a[c[1]].same(_same); _same = 0xe0e0e0e0;
			}
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = 0;
			}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		sum = a[c[0]].sum + a[c[1]].sum + val;
		maxl = max(a[c[0]].maxl, a[c[0]].sum + val + a[c[1]].maxl);
		maxr = max(a[c[1]].maxr, a[c[1]].sum + val + a[c[0]].maxr);
		maxs = a[c[0]].maxr + val + a[c[1]].maxl;
		maxs = max(maxs, max(a[c[0]].maxs, a[c[1]].maxs));
	}
	void rot(bool b)
	{
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
int n, m, tot, root, num[MAXN];
struct Tmemory{
	int stack[MAXN], top;
	void clear()
	{
		top = 0;
	}
	void push(int t)
	{
		if (top > 600000) return;
		stack[++top] = t;
		A[t].f = A[t].c[1] = A[t].c[2] = A[t].val = A[t]._rev = 0;
		A[t]._same = 0xe0e0e0e0;
	}
	int pop()
	{
		if (top) return stack[top--]; else return ++tot;
	}
}mem;

void splay(int x, int p)
{
	int y, z; bool b, c; A[x].push();
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int t = root, tt;
	while((tt = A[A[t].c[0]].size + 1) != k){
		A[t].push();
		if (k < tt) t = A[t].c[0]; else k -= tt, t = A[t].c[1];
		}
	return t;
}
void recycle(int t)
{
	if (t == 0) return;
	recycle(A[t].c[0]); recycle(A[t].c[1]);
	mem.push(t); 
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = (l + r) >> 1, now = mem.pop(); A[now].val = num[m]; A[now]._same = 0xe0e0e0e0;
	A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
	A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
	A[now].update(); return now;
}
void REVERSE(int l, int len)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].rev(); A[A[root].c[1]].update(); A[root].update();
}
void GETSUM(int l, int len)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root);
	printf("%d\n", A[A[A[root].c[1]].c[0]].sum);
}
void MAKESAME(int l, int len, int d)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].same(d); A[A[root].c[1]].update(); A[root].update();
}
void DELETE(int l, int len)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root); recycle(A[A[root].c[1]].c[0]);
	A[A[root].c[1]].c[0] = 0; A[A[root].c[1]].update(); A[root].update();
} 
void INSERT()
{
	int l, nt, tt; 
	scanf("%d%d", &l, &nt); for (int i = 1; i <= nt; i++) scanf("%d", &num[i]);
	tt = build(1, nt); 
	splay(select(l + 1), 0); splay(select(l + 2), root);
	A[A[root].c[1]].c[0] = tt; A[tt].f = A[root].c[1];
	A[A[root].c[1]].update(); A[root].update();
}
void MAXSUM()
{
	splay(select(1), 0); splay(select(A[root].size), root);
	printf("%d\n", A[A[A[root].c[1]].c[0]].maxs);
} 
char op[1001];
int main()
{
	mem.clear();
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]); num[0] = num[n + 1] = -100000000;
	A[0].maxs = -100000000;
	root = build(0, n + 1);
	int l, len, d;
	while(m--){
		scanf("%s", op);
		switch(*(op + 2)){
			case 'X': MAXSUM(); break;
			case 'V': scanf("%d%d", &l, &len); REVERSE(l, len); break;
			case 'T': scanf("%d%d", &l, &len); GETSUM(l, len); break;
			case 'K': scanf("%d%d%d", &l, &len, &d); MAKESAME(l, len, d); break;
			case 'L': scanf("%d%d", &l, &len); DELETE(l, len); break;
			case 'S': INSERT(); break;
			}
		}
}
Problem1500

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;	
struct Tnode{
	static Tnode *a;
	int f, c[2], size, val;
	int _same; bool _rev;
	int sum, maxl, maxr, maxs;
	void same(int k)
	{
		if(this != a){
			_same = val = k;
			sum = k * size;
			maxl = maxr = (sum > 0 ? sum : 0);
			maxs = (k > 0 ? sum : k);
			}
	}
	void rev()
	{
		if (this != a){
			swap(c[0], c[1]);
			swap(maxl, maxr);
			_rev ^= 1;
			}
	}
	void push()
	{
		if (_same != 0xe0e0e0e0){
			a[c[0]].same(_same); a[c[1]].same(_same); _same = 0xe0e0e0e0;
			}
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = 0;
			}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		sum = a[c[0]].sum + a[c[1]].sum + val;
		maxl = max(a[c[0]].maxl, a[c[0]].sum + val + a[c[1]].maxl);
		maxr = max(a[c[1]].maxr, a[c[1]].sum + val + a[c[0]].maxr);
		maxs = a[c[0]].maxr + val + a[c[1]].maxl;
		maxs = max(maxs, max(a[c[0]].maxs, a[c[1]].maxs));
	}
	void rot(bool b)
	{
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
int n, m, tot, root, num[MAXN];
struct Tmemory{
	int stack[MAXN], top;
	void clear()
	{
		top = 0;
	}
	void push(int t)
	{
		if (top > 600000) return;
		stack[++top] = t;
		A[t].f = A[t].c[1] = A[t].c[2] = A[t].val = A[t]._rev = 0;
		A[t]._same = 0xe0e0e0e0;
	}
	int pop()
	{
		if (top) return stack[top--]; else return ++tot;
	}
}mem;

void splay(int x, int p)
{
	int y, z; bool b, c; A[x].push();
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int t = root, tt;
	while((tt = A[A[t].c[0]].size + 1) != k){
		A[t].push();
		if (k < tt) t = A[t].c[0]; else k -= tt, t = A[t].c[1];
		}
	return t;
}
void recycle(int t)
{
	if (t == 0) return;
	recycle(A[t].c[0]); recycle(A[t].c[1]);
	mem.push(t); 
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = (l + r) >> 1, now = mem.pop(); A[now].val = num[m]; A[now]._same = 0xe0e0e0e0;
	A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
	A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
	A[now].update(); return now;
}
void REVERSE(int l, int len)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].rev(); splay(A[A[root].c[1]].c[0], 0);
}
void GETSUM(int l, int len)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root);
	printf("%d\n", A[A[A[root].c[1]].c[0]].sum);
}
void MAKESAME(int l, int len, int d)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].same(d); splay(A[A[root].c[1]].c[0], 0);
}
void DELETE(int l, int len)
{
	int r = l + len - 1;
	splay(select(l), 0); splay(select(r + 2), root); recycle(A[A[root].c[1]].c[0]);
	A[A[root].c[1]].c[0] = 0; splay(A[root].c[1], 0);
} 
void INSERT()
{
	int l, nt, tt; 
	scanf("%d%d", &l, &nt); for (int i = 1; i <= nt; i++) scanf("%d", &num[i]);
	tt = build(1, nt); 
	splay(select(l + 1), 0); splay(select(l + 2), root);
	A[A[root].c[1]].c[0] = tt; A[tt].f = A[root].c[1];
	splay(A[A[root].c[1]].c[0], 0);
}
void MAXSUM()
{
	splay(select(1), 0); splay(select(A[root].size), root);
	printf("%d\n", A[A[A[root].c[1]].c[0]].maxs);
} 
char op[1001];
int main()
{
	mem.clear();
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]); num[0] = num[n + 1] = -100000000;
	A[0].maxs = -100000000;
	root = build(0, n + 1);
	int l, len, d;
	while(m--){
		scanf("%s", op);
		switch(*(op + 2)){
			case 'X': MAXSUM(); break;
			case 'V': scanf("%d%d", &l, &len); REVERSE(l, len); break;
			case 'T': scanf("%d%d", &l, &len); GETSUM(l, len); break;
			case 'K': scanf("%d%d%d", &l, &len, &d); MAKESAME(l, len, d); break;
			case 'L': scanf("%d%d", &l, &len); DELETE(l, len); break;
			case 'S': INSERT(); break;
			}
		}
}
Problem1501

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <iostream>
#include <algorithm>
using namespace std;
struct Thow{
	int x, y, rot, who;
	bool ifRX, ifRY;
} how[100001];
struct Tnode{
	int l, r, u, d, x, y;
	void set(int _l, int _r, int _u, int _d, int _x, int _y)
	{
		l = _l; r = _r; u = _u; d = _d; x = _x; y = _y;
	}
} a[1000001];
int tot, top, row, totnum, canblock;
int s[10001], newnum[101][101], ansrec[100001];
char S[101][101];
int blocknum[101];
bool can[1001];
typedef int block[5][2];
int zb[13][5][2] ={{},
				  {{0, 0}, {1, 0}, {0, 1}},
				  {{0, 0}, {0, 1}, {0, 2}, {0, 3}},
				  {{0, 0}, {0, 1}, {0, 2}, {1, 0}},
		 		  {{0, 0}, {0, 1}, {1, 0}, {1, 1}},
				  {{0, 0}, {1, 0}, {2, 0}, {2, 1}, {2, 2}},
			      {{0, 0}, {0, 1}, {0, 2}, {0, 3}, {1, 1}},
				  {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 2}},
			      {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 1}},
				  {{0, 0}, {0, 1}, {0, 2}, {1, 2}, {1, 3}},
				  {{0, 0}, {1, -1}, {1, 0}, {1, 1}, {2, 0}},
				  {{0, 0}, {1, 0}, {1, 1}, {2, 1}, {2, 2}},
				  {{0, 0}, {0, 1}, {0, 2}, {0, 3}, {1, 0}}
				  };
int size(int num)
{
	if (num <= 1) return 3;
	if (num <= 4) return 4;
	return 5;
}
void RT(int a)
{
	int t = size(a);
	for (int i = 0; i < t; i++){
		swap(zb[a][i][0], zb[a][i][1]);
		zb[a][i][0] *= -1;
		}
}
void RX(int a)
{
	int t = size(a);
	for (int i = 0; i < t; i++) zb[a][i][0] *= -1;
}
void RY(int a)
{
	int t = size(a);
	for (int i = 0; i < t; i++) zb[a][i][1] *= -1;
}

void add(int left, int x, int y)
{
	++tot; ++s[y];
	a[tot].x = x; a[tot].y = y;
	a[a[tot].l = left].r = tot;
	a[a[tot].u = a[y].u].d = tot;
	a[a[tot].d = y].u = tot;
}
int who[1001];
void adddlx(int num, bool ifRX, bool ifRY, int rot)
{
	int s = size(num);
	for (int i = 1; i <= 10; i++)
		for (int j = 1; j <= i; j++){
			bool can = true;
			for (int k = 0; k < s; k++){
				int x = i + zb[num][k][0], y = j + zb[num][k][1];
				if (x < 1 || x > 10 && y < 1 || y > x || S[x][y] != '.') can = false;
				}
			if (!can) continue;
			++row;
			how[row].who = num; how[row].ifRX = ifRX; how[row].ifRY = ifRY; how[row].rot = rot;
			how[row].x = i; how[row].y = j; 
			//cerr << i << " " << j << " " << num << " " << ifRX << ifRY << rot << endl;
			for (int k = 0; k < s; k++){
				int x = i + zb[num][k][0], y = j + zb[num][k][1];
				who[k] = newnum[x][y];
				}
				
			sort(who, who + s);
			add(tot + s + 1, row, who[0]);
			for (int i = 1; i < s; i++)
				add(tot, row, who[i]); 
			add(tot, row, totnum + blocknum[num]);
			}
}							
void addblock(int num)
{
	RT(num); adddlx(num, 0, 0, 1); 
	RT(num); adddlx(num, 0, 0, 2); 
	RT(num); adddlx(num, 0, 0, 3); 
	RT(num); adddlx(num, 0, 0, 0);

	RX(num); 
	RT(num); adddlx(num, 1, 0, 1); 
	RT(num); adddlx(num, 1, 0, 2); 
	RT(num); adddlx(num, 1, 0, 3); 
	RT(num); adddlx(num, 1, 0, 0);
	RX(num);

/*
	RY(num);
	RT(num); adddlx(num, 0, 1, 1); 
	RT(num); adddlx(num, 0, 1, 2); 
	RT(num); adddlx(num, 0, 1, 3); 
	RT(num); adddlx(num, 0, 1, 0);
	RY(num);
	RX(num); RY(num);
	RT(num); adddlx(num, 1, 1, 1); 
	RT(num); adddlx(num, 1, 1, 2); 
	RT(num); adddlx(num, 1, 1, 3); 
	RT(num); adddlx(num, 1, 1, 0);
	RX(num); RY(num);
*/
}
void prepare()
{
	for (int i = 1; i <= 10; i++)
		for (int j = 1; j <= i; j++)
			if (!isalpha(S[i][j]))
				newnum[i][j] = ++totnum;
	for (int i = 1; i <= 12; i++) if (can[i]) blocknum[i] = ++canblock;
	int m = totnum + canblock;
	a[0].set(m, 1, 0, 0, 0, 0);
	for (int i = 1; i < m; i++) a[i].set(i - 1, i + 1, i, i, 0, i);
	a[m].set(m - 1, 0, m, m, 0, m);
	tot = m;
	for (int i = 1; i <= 12; i++)
		if (can[i])
			addblock(i);
}
void remove(int c)
{
	a[a[c].l].r = a[c].r; a[a[c].r].l = a[c].l;
	for (int i = a[c].d; i != c; i = a[i].d)
		for (int j = a[i].r; j != i; j = a[j].r){
			a[a[j].u].d = a[j].d; a[a[j].d].u = a[j].u;
			--s[a[j].y];
			}
}
void resume(int c)
{
	a[a[c].l].r = a[a[c].r].l = c;
	for (int i = a[c].u; i != c; i = a[i].u)
		for (int j = a[i].l; j != i; j = a[j].l){
			a[a[j].d].u = a[a[j].u].d = j;
			++s[a[j].y];
			}
}
bool dfs()
{
	if (a[0].r == 0) return true;
	int c = a[0].r;
	for (int i = a[0].r; i != 0; i = a[i].r) if (s[i] < s[c]) c = i;
	remove(c);
	for (int i = a[c].d; i != c; i = a[i].d){
		for (int j = a[i].r; i != j; j = a[j].r) remove(a[j].y);
		ansrec[++top] = a[i].x; if (dfs()) return true; --top;
		for (int j = a[i].l; i != j; j = a[j].l) resume(a[j].y);
		}
	resume(c);
	return false;
}
int main()
{	
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 1; i <= 10; i++) gets(S[i] + 1);
	for (int i = 1; i <= 12; i++) can[i] = true;
	for (int i = 1; i <= 10; i++)
		for (int j = 1; j <= 10; j++)
			if (isalpha(S[i][j]))
				can[S[i][j] - 'A' + 1] = false;	
	prepare();
	dfs();
	for (int i = 1; i <= top; i++){
		//cerr << i << endl;
		if (how[ansrec[i]].ifRX) RX(how[ansrec[i]].who);
		if (how[ansrec[i]].ifRY) RY(how[ansrec[i]].who);
		for (int j = 1; j <= how[ansrec[i]].rot; j++)
			RT(how[ansrec[i]].who);
		int s = size(how[ansrec[i]].who);
		//cerr << how[ansrec[i]].who << endl;
		for (int k = 0; k < s; k++){
				int x = how[ansrec[i]].x + zb[how[ansrec[i]].who][k][0], 
				    y = how[ansrec[i]].y + zb[how[ansrec[i]].who][k][1];
				//cerr << x << " " << y << endl;
				S[x][y] = 'A' - 1 + how[ansrec[i]].who;
				}
		}
	if (top == 0) { puts("No solution"); return 0; }
	for (int i = 1; i <= 10; i++) puts(S[i] + 1);
}
Problem1501

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <iostream>
#include <algorithm>
using namespace std;
struct Thow{
	int x, y, rot, who;
	bool ifRX, ifRY;
} how[100001];
struct Tnode{
	int l, r, u, d, x, y;
	void set(int _l, int _r, int _u, int _d, int _x, int _y)
	{
		l = _l; r = _r; u = _u; d = _d; x = _x; y = _y;
	}
} a[1000001];
int tot, top, row, totnum, canblock;
int s[10001], newnum[101][101], ansrec[100001];
char S[101][101];
int blocknum[101];
bool can[1001];
typedef int block[5][2];
int zb[13][5][2] ={{},
				  {{0, 0}, {1, 0}, {0, 1}},
				  {{0, 0}, {0, 1}, {0, 2}, {0, 3}},
				  {{0, 0}, {0, 1}, {0, 2}, {1, 0}},
		 		  {{0, 0}, {0, 1}, {1, 0}, {1, 1}},
				  {{0, 0}, {1, 0}, {2, 0}, {2, 1}, {2, 2}},
			      {{0, 0}, {0, 1}, {0, 2}, {0, 3}, {1, 1}},
				  {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 2}},
			      {{0, 0}, {0, 1}, {0, 2}, {1, 0}, {1, 1}},
				  {{0, 0}, {0, 1}, {0, 2}, {1, 2}, {1, 3}},
				  {{0, 0}, {1, -1}, {1, 0}, {1, 1}, {2, 0}},
				  {{0, 0}, {1, 0}, {1, 1}, {2, 1}, {2, 2}},
				  {{0, 0}, {0, 1}, {0, 2}, {0, 3}, {1, 0}}
				  };
int size(int num)
{
	if (num <= 1) return 3;
	if (num <= 4) return 4;
	return 5;
}
void RT(int a)
{
	int t = size(a);
	for (int i = 0; i < t; i++){
		swap(zb[a][i][0], zb[a][i][1]);
		zb[a][i][0] *= -1;
		}
}
void RX(int a)
{
	int t = size(a);
	for (int i = 0; i < t; i++) zb[a][i][0] *= -1;
}
void add(int left, int x, int y)
{
	++tot; ++s[y];
	a[tot].x = x; a[tot].y = y;
	a[a[tot].l = left].r = tot;
	a[a[tot].u = a[y].u].d = tot;
	a[a[tot].d = y].u = tot;
}
int who[1001];
void adddlx(int num, bool ifRX, bool ifRY, int rot)
{
	int s = size(num);
	for (int i = 1; i <= 10; i++)
		for (int j = 1; j <= i; j++){
			bool can = true;
			for (int k = 0; k < s; k++){
				int x = i + zb[num][k][0], y = j + zb[num][k][1];
				if (x < 1 || x > 10 && y < 1 || y > x || S[x][y] != '.') can = false;
				}
			if (!can) continue;
			++row;
			how[row].who = num; how[row].ifRX = ifRX; how[row].rot = rot;
			how[row].x = i; how[row].y = j; 
			//cerr << i << " " << j << " " << num << " " << ifRX << ifRY << rot << endl;
			for (int k = 0; k < s; k++){
				int x = i + zb[num][k][0], y = j + zb[num][k][1];
				who[k] = newnum[x][y];
				}
				
			sort(who, who + s);
			add(tot + s + 1, row, who[0]);
			for (int i = 1; i < s; i++)
				add(tot, row, who[i]); 
			add(tot, row, totnum + blocknum[num]);
			}
}
				
void addblock(int num)
{
	if (num == 4 || num == 10) { adddlx(num, 0, 0, 0); return; }
	if (num == 2){
		adddlx(num, 0, 0, 0); 
		RT(num); 
		adddlx(num, 0, 0, 1); 
		RT(num); RT(num); RT(num); 
		return; 
		}
	RT(num); adddlx(num, 0, 0, 1); 
	RT(num); adddlx(num, 0, 0, 2); 
	
	RT(num); adddlx(num, 0, 0, 3); 
	RT(num); adddlx(num, 0, 0, 0);
	if (num == 7 || num == 11) return;
	RX(num); 
	RT(num); adddlx(num, 1, 0, 1); 
	RT(num); adddlx(num, 1, 0, 2); 
	RT(num); adddlx(num, 1, 0, 3); 
	RT(num); adddlx(num, 1, 0, 0);
	RX(num);
}
void prepare()
{
	for (int i = 1; i <= 10; i++)
		for (int j = 1; j <= i; j++)
			if (!isalpha(S[i][j]))
				newnum[i][j] = ++totnum;
	for (int i = 1; i <= 12; i++) if (can[i]) blocknum[i] = ++canblock;
	int m = totnum + canblock;
	a[0].set(m, 1, 0, 0, 0, 0);
	for (int i = 1; i < m; i++) a[i].set(i - 1, i + 1, i, i, 0, i);
	a[m].set(m - 1, 0, m, m, 0, m);
	tot = m;
	for (int i = 1; i <= 12; i++)
		if (can[i])
			addblock(i);
}
void remove(int c)
{
	a[a[c].l].r = a[c].r; a[a[c].r].l = a[c].l;
	for (int i = a[c].d; i != c; i = a[i].d)
		for (int j = a[i].r; j != i; j = a[j].r){
			a[a[j].u].d = a[j].d; a[a[j].d].u = a[j].u;
			--s[a[j].y];
			}
}
void resume(int c)
{
	a[a[c].l].r = a[a[c].r].l = c;
	for (int i = a[c].u; i != c; i = a[i].u)
		for (int j = a[i].l; j != i; j = a[j].l){
			a[a[j].d].u = a[a[j].u].d = j;
			++s[a[j].y];
			}
}
bool dfs()
{
	if (a[0].r == 0) return true;
	int c = a[0].r;
	for (int i = a[0].r; i != 0; i = a[i].r) if (s[i] < s[c]) c = i;
	remove(c);
	for (int i = a[c].d; i != c; i = a[i].d){
		for (int j = a[i].r; i != j; j = a[j].r) remove(a[j].y);
		ansrec[++top] = a[i].x; if (dfs()) return true; --top;
		for (int j = a[i].l; i != j; j = a[j].l) resume(a[j].y);
		}
	resume(c);
	return false;
}
int main()
{	
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 1; i <= 10; i++) gets(S[i] + 1);
	for (int i = 1; i <= 12; i++) can[i] = true;
	for (int i = 1; i <= 10; i++)
		for (int j = 1; j <= 10; j++)
			if (isalpha(S[i][j]))
				can[S[i][j] - 'A' + 1] = false;	
	prepare();
	dfs();
	for (int i = 1; i <= top; i++){
		if (how[ansrec[i]].ifRX) RX(how[ansrec[i]].who);
		for (int j = 1; j <= how[ansrec[i]].rot; j++)
			RT(how[ansrec[i]].who);
		int s = size(how[ansrec[i]].who);
		for (int k = 0; k < s; k++){
				int x = how[ansrec[i]].x + zb[how[ansrec[i]].who][k][0], 
				    y = how[ansrec[i]].y + zb[how[ansrec[i]].who][k][1];
				S[x][y] = 'A' - 1 + how[ansrec[i]].who;
				}
		}
	if (top == 0) { puts("No solution"); return 0; }
	for (int i = 1; i <= 10; i++) puts(S[i] + 1);
}
Problem1502

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const double eps = 2.0 * 1e-6;
double a, x[1001], x1[1001], x2[1001], y1[1001], y2[1001], k[1001], r[1001];
int n;
inline double sqrt(double __x) { return __builtin_sqrtl(__x); }
inline double tan(double __x) { return __builtin_tanl(__x); }
inline double fabs(double __x) { return __builtin_fabsl(__x); }
double f(double X)
{
	double ret = 0.0;
	for (int i = 1; i <= n; i++) if (fabs(X - x[i]) < r[i])
		ret = max(ret, sqrt(r[i] * r[i] - (X - x[i]) * (X - x[i])));
	for (int i = 1; i <= n; i++) if (x[i + 1] - x[i] > fabs(r[i + 1] - r[i]))
		if (X > x1[i] && X < x2[i]) ret = max(ret, y1[i] + k[i] * (X - x1[i]));
	return ret;
}
double simpson(double l, double r)
{
	return (r - l) * (f(l) + f(r) + 4.0 * f((l + r) / 2)) / 6.0;
}
double rsimpson(double l, double r)
{
	double m = (l + r) / 2;
	double a = simpson(l, r), b = simpson(l, m), c = simpson(m, r);
	if (fabs(a - b - c) < eps) return a;
	else return rsimpson(l, m) + rsimpson(m, r);
} 
int main()
{
	scanf("%d%lf", &n, &a); a = 1 / tan(a);
	double h = 0.0;
	for (int i = 1; i <= n + 1; i++){ 
		double t; scanf("%lf", &t); h += t;
		x[i] = h * a;
		}
	for (int i = 1; i <= n; i++) scanf("%lf", &r[i]);
	double MIN = x[n + 1], MAX = x[n + 1];
	for (int i = 1; i <= n; i++){
		MIN = min(x[i] - r[i], MIN);
		MAX = max(x[i] + r[i], MAX);
		}
	for (int i = 1; i <= n; i++) if (x[i + 1] - x[i] > fabs(r[i + 1] - r[i])){
		x1[i] = x[i] + r[i] * (r[i] - r[i + 1]) / (x[i + 1] - x[i]);
		y1[i] = sqrt(r[i] * r[i] - (x1[i] - x[i]) * (x1[i] - x[i]));
		x2[i] = x[i + 1] + r[i + 1] * (r[i] - r[i + 1]) / (x[i + 1] - x[i]);
		y2[i] = sqrt(r[i + 1] * r[i + 1] - (x2[i] - x[i + 1]) * (x2[i] - x[i + 1]));
		k[i] = (y2[i] - y1[i]) / (x2[i] - x1[i]);
		}
	printf("%.2lf\n", rsimpson(MIN, MAX) * 2);
}
		
Problem1503

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int size[2000001], minm, delta, tot;
bool same[2000001];
void _same(int idx)
{
	same[idx] = 1; size[idx] = 0;
}
void push(int idx)
{
	if (same[idx]){
		_same(idx * 2); _same(idx * 2 + 1);
		same[idx] = 0;
	}
}
void update(int idx)
{
	size[idx] = size[idx * 2] + size[idx * 2 + 1];
}	
void insert(int idx, int l, int r, int x)
{
	if (l == r)  { ++size[idx]; return; }
	push(idx); int m = l + r >> 1;
	if (x <= m) insert(idx * 2, l, m, x); else insert(idx * 2 + 1, m + 1, r, x);
	update(idx);
}
void makesame(int idx, int l, int r, int ll, int rr)
{
	if (ll > rr) return;
	if (ll <= l && rr >= r) { _same(idx); return; }
	push(idx);
	int m = l + r >> 1;
	if (ll <= m) makesame(idx * 2, l, m, ll, rr);
	if (rr > m) makesame(idx * 2 + 1, m + 1, r, ll, rr);
	update(idx);
}
int getsum(int idx, int l, int r, int ll, int rr)
{
	if (ll > rr) return 0;
	if (ll <= l && rr >= r) return size[idx];
	push(idx);	
	int m = l + r >> 1, ret = 0;
	if (ll <= m) ret += getsum(idx * 2, l, m, ll, rr);
	if (rr > m) ret += getsum(idx * 2 + 1, m + 1, r, ll, rr);
	return ret;
}
void doi(int num)
{
	if (num < minm) return; ++tot;
	insert(1, 1, 1000000, num - delta + 100000);
}
void dos()
{
	makesame(1, 1, 1000000, 1, minm - delta + 100000 - 1);
}
void dof(int num)
{
	if (num > size[1]) { puts("-1"); return; }
	num = size[1] + 1 - num;
	int l = 0, r = 1000000;
	while(l <= r){
		int m = l + r >> 1;
		int t = getsum(1, 1, 1000000, 1, m);
		if (t >= num) r = m - 1; else l = m + 1;
	}
	printf("%d\n", l + delta - 100000);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q; scanf("%d%d", &Q, &minm);
	while(Q--){
		char op; int num;
		getchar(); scanf("%c %d", &op, &num);
		switch(op){
			case 'I' : doi(num); break;
			case 'A' : delta += num; break;
			case 'S' : delta -= num; dos(); break;
			case 'F' : dof(num); break;
		}
	}
	printf("%d\n", tot - size[1]);
}
Problem1504

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#define PDD pair<double, double>
#define PDI pair<double, int>
const int MAXN = 101;
using namespace std;
int n, w, t, v;
struct Tblock{
	int l, x, v;
	void init() { scanf("%d%d%d", &x, &l, &v); }
	double get(double t)
	{
		if (v == 0) return x;
		if (w == l) return 0;
		double zq = (double)(w - l) / (double(fabs(v))) * 2.0;
		t -= floor(t / zq) * zq;
		double xx = x + t * v; int ll = w - l;
		if (v < 0){
			if (xx >= 0) return xx;
			xx += ll;
			if (xx >= 0) return (double(ll) - xx);
			return xx + ll;
		}
		if (v > 0){
			if (xx <= ll) return xx;
			xx -= ll;
			if (xx <= ll) return (double(ll) - xx);
			return xx - ll;
		}
	}
} block[MAXN];
double f(double time)
{
	int sc = 0; static PDI sp[MAXN * 2]; static PDD t[MAXN];
	for (int i = 1; i <= n; i++)  { t[i].first = block[i].get(time); t[i].second = t[i].first + block[i].l; }
	for (int i = 1; i <= n; i++){
		sp[++sc] = make_pair(t[i].first, 1);
		sp[++sc] = make_pair(t[i].second, -1);
	}
	double ret = 0; int now = 0;
	sort(sp + 1, sp + 2 * n + 1);
	for (int i = 1; i <= 2 * n; i++){
		if (now > 0) ret += sp[i].first - sp[i - 1].first;
		now += sp[i].second;
	}
	return ret;
}	
double simpson(double l, double r)
{
	return (r - l) * (f(l) + f(r)) / 2.0;
}
double rsimpson(double l, double r)
{
	double m = (l + r) / 2.0, t = simpson(l, r);
	if (r - l > 1e-2) return rsimpson(l, m) + rsimpson(m, r);
	if (fabs(t - simpson(l, m) - simpson(m, r)) < 1e-17) return t;
	return rsimpson(l, m) + rsimpson(m, r);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &w, &t, &v); 
	for (int i = 1; i <= n; i++) block[i].init();
	printf("%.2lf\n", double(w * t * v) - rsimpson(0, t) * v);
}
Problem1505

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
double k1, k2; int n, m;
double area[101][101], f[101][101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%lf%lf%d%d", &k1, &k2, &n, &m);
	for (int i = 1; i <= 100; i++) area[i][0] = 1e99;
	for (int i = 1; i <= 100; i++)
		for (int j = 1; j <= m; j++){
			area[i][j] = 1e99;
			for (int k = 0; k <= i; k++)
				area[i][j] = min(area[i - k][j - 1] + k2 * k * k, area[i][j]);
		}
	for (int i = 1; i <= 100; i++)
		for (int j = 1; j <= m; j++)
			area[i][j] += k1 * i * i;
	for (int i = 0; i <= 100; i++)
		for (int j = 0; j <= n; j++)
			for (int k = 0; k <= m; k++)
				f[i][j][k] = 1e99;
	f[0][0][0] = 0;
	for (int i = 1; i <= 100; i++)
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= m; k++){
				int last = 0;
				for (int l = 1; l <= i; l++){
					int t;
					for (t = last; t < k; t++) if (f[i - l][j - 1][k - t] + area[l][t] < f[i - l][j - 1][k - t - 1] + area[l][t + 1]) break;
					last = t;
					f[i][j][k] = min(f[i][j][k], f[i - l][j - 1][k - t]  + area[l][t]);
				}
			}
	printf("%.1lf\n", f[100][n][m]);
						

}
Problem1506

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1001;
int n, m, q, ans = 0x3f3f3f3f, req[MAXN][4], dir[MAXN], cost[MAXN][2];
int startdir[MAXN][2];
char startdirchar[MAXN][2];
struct Task {
	int l, r;
	Task() { }
	Task(int _l, int _r) { l = _l; r = _r; }
	bool operator < (const Task & A) const
	{
		return r == A.r ? l > A.l : r < A.r;
	}
};
struct Tdymanic{
	Task inask[2][MAXN], ask[2][MAXN]; int intot[2], tot[2], where[2][MAXN];
	int f[101][101][101];
	void init() { intot[0] = 0; intot[1] = 0; }
	void renew(int & a, int b) { if (a > b) a = b; }
	void addask(int kind, int l, int r) 
	{
		inask[kind][++intot[kind]] = Task(l, r);
	}
	void doit(int t)
	{
		if (intot[t] == 0) { tot[t] = 0; return; }
		sort(inask[t] + 1, inask[t] + intot[t] + 1);
		ask[t][1] = inask[t][1]; tot[t] = 1;
		for (int i = 2; i <= intot[t]; i++)
			if (inask[t][i].l > ask[t][tot[t]].l)
				ask[t][++tot[t]] = inask[t][i];
		for (int i = 1; i <= n; i++){
			where[t][i] = tot[t];
			for (int j = 1; j <= tot[t]; j++) if (i < ask[t][j].l){
				where[t][i] = j - 1;  break;
			}
		}
		for (int i = 1; i <= n; i++) if (i > ask[t][where[t][i]].r) where[t][i] = 0;
	}
	int solve()
	{
		doit(0); doit(1);
		memset(f, 0x3f, sizeof(f));
		f[0][0][0] = 0;
		for (int i = 0; i < n; i++)
			for (int j = 0; j <= tot[0]; j++)
				for (int k = 0; k <= tot[1]; k++) if (f[i][j][k] < 0x3f3f3f3f){
					if (i + 1 <= ask[0][j + 1].r) renew(f[i + 1][max(j, where[0][i + 1])][k], f[i][j][k] + cost[i + 1][1] * (startdir[i + 1][1] != 0));
					if (i + 1 <= ask[1][k + 1].r) renew(f[i + 1][j][max(k, where[1][i + 1])], f[i][j][k] + cost[i + 1][1] * (startdir[i + 1][1] != 1));
					renew(f[i + 1][j][k], f[i][j][k]);
				}
		return f[n][tot[0]][tot[1]];
	}
} dp;
void work(int now)
{
	dp.init();
	for (int i = 1; i <= q; i++){
		int *op = req[i];
		if (op[0] == op[2] && op[1] == op[3]) continue;
		if (op[0] == op[2]) if (dir[op[0]] == op[1] < op[3]) return; else continue;	   
		if (op[1] == op[3]) { dp.addask(op[0] > op[2], op[1], op[1]); continue; }
		if (dir[op[0]] == op[1] > op[3] && dir[op[2]] == op[1] > op[3])
			dp.addask(op[0] > op[2], min(op[1], op[3]), max(op[1], op[3]));
		if (dir[op[0]] == op[1] > op[3] && dir[op[2]] == op[1] < op[3])
			dp.addask(op[0] > op[2], op[3], op[3]);
		if (dir[op[0]] == op[1] < op[3] && dir[op[2]] == op[1] > op[3])
			dp.addask(op[0] > op[2], op[1], op[1]);
		if (dir[op[0]] == op[1] < op[3] && dir[op[2]] == op[1] < op[3]){
			bool ok = false;
			for (int temp = min(op[0], op[2]); temp <= max(op[0], op[2]); temp++) if (dir[temp] == op[1] > op[3]){
				ok = true; dp.addask(op[0] > op[2], op[3], op[3]); dp.addask(op[0] > op[2], op[1], op[1]); break;
			}
			if (!ok) return;
		}
	}
	ans = min(ans, dp.solve() + now);
}
void dfs(int dep, int num)
{
	if (dep == m + 1) { work(num); return; }
	dir[dep] = 0; dfs(dep + 1, num + cost[dep][0] * (dir[dep] != startdir[dep][0]));
	dir[dep] = 1; dfs(dep + 1, num + cost[dep][0] * (dir[dep] != startdir[dep][0]));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &m, &n); scanf(" ");
	for (int i = 1; i <= m; i++) scanf("%c", &startdirchar[i][0]); scanf(" "); // 0 : E 1 : W
	for (int i = 1; i <= n; i++) scanf("%c", &startdirchar[i][1]); //0 : S 1 : N
	for (int i = 1; i <= m; i++) startdir[i][0] = startdirchar[i][0] != 'E';
	for (int i = 1; i <= n; i++) startdir[i][1] = startdirchar[i][1] != 'S';
	for (int i = 1; i <= m; i++) scanf("%d", &cost[i][0]);
	for (int i = 1; i <= n; i++) scanf("%d", &cost[i][1]);
	scanf("%d", &q);
	for (int i = 1; i <= q; i++) scanf("%d%d%d%d", &req[i][0], &req[i][1], &req[i][2], &req[i][3]);
	dfs(1, 0);
	if (ans == 0x3f3f3f3f) printf("impossible\n"); else printf("possible\n%d\n", ans);
}
Problem1507

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXNODE = 2000001;
struct Tnode{
	static Tnode *a;
	int c[2], f, size;
	char ch; bool rev;
	void print()
	{
		if (this == a) return;
		a[c[0]].print();
		putchar(ch);
		a[c[1]].print();
	} 
	void _rev()
	{
		if (this != a){
			swap(c[0], c[1]);
			rev ^= 1;
		}
	}
	void push()
	{
		if (rev){
			a[c[0]]._rev();
			a[c[1]]._rev();
			rev = false;
		}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
	}
	void rot(bool b)
	{
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXNODE], *Tnode::a = A;
int now; char s[2000001];
int root, tot; 
void splay(int x, int p)
{
	int y, z; bool b, c; A[x].push();
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int t = root, tt;
	while((tt = A[A[t].c[0]].size + 1) != k){
		A[t].push();
		if (k < tt) t = A[t].c[0]; else t = A[t].c[1], k -= tt; 
	}
	return t;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = l + r >> 1; int now = ++tot; A[tot].ch = s[m];
	A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
	A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
	A[now].update(); return now;
}
void INSERT()
{
	splay(select(now + 1), 0); splay(select(now + 2), root);
	int nowlen = 0;
	int len; scanf("%d", &len); getchar(); 
	while(nowlen < len){
		gets(s + nowlen + 1);
		nowlen += strlen(s + nowlen + 1);
	}
	int tt = build(1, len);
	A[A[root].c[1]].c[0] = tt; A[tt].f = A[root].c[1];
	splay(tt, 0);
}
void DELETE()
{
	int len; scanf("%d", &len);
	splay(select(now + 1), 0); splay(select(now + len + 2), root);
	A[A[root].c[1]].c[0] = 0; A[A[root].c[1]].update();
	splay(A[root].c[1], 0);
}
void ROTATE()
{
	int len; scanf("%d", &len);
	splay(select(now + 1), 0); splay(select(now + len + 2), root);
	A[A[A[root].c[1]].c[0]]._rev();
}
void GET()
{
	int len; scanf("%d", &len);
	splay(select(now + 1), 0); splay(select(now + len + 2), root);
	A[A[A[root].c[1]].c[0]].print(); putchar('\n');
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q;
	scanf("%d", &Q);
	//root = 1; A[1].c[1] = 2; A[1].size = 2; A[2].f = 1; A[2].size = 1;
	//tot = 2; 
	root = build(1, 5);
	while(Q--){
		char op[1001]; scanf("%s", op);
		switch(*op){
			case 'M' : scanf("%d", &now); break;
			case 'I' : INSERT(); break;
			case 'D' : DELETE(); break;
			case 'G' : GET(); break;
			case 'P' : --now; break;
			case 'N' : ++now; break;
			case 'R' : ROTATE(); break;
		}
	}
}
Problem1513

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
int ret, n, m;
struct Tsgt1d{
	int val[3001][2];
	void query(int idx, int ll, int rr, int l, int r)
	{
		if (ll <= l && rr >= r){
			gmax(ret, val[idx][1]);
			return;
		}
		gmax(ret, val[idx][0]);
		int m = l + r >> 1;
		if (ll <= m) query(idx * 2, ll, rr, l, m);
		if (rr > m) query(idx * 2 + 1, ll, rr, m + 1, r);
	}
	void cover(int idx, int ll, int rr, int l, int r, int d)
	{
		gmax(val[idx][1], d)
		if (ll <= l && rr >= r){
			gmax(val[idx][0], d);
			return;
		}
		int m = l + r >> 1;
		if (ll <= m) cover(idx * 2, ll, rr, l, m, d);
		if (rr > m) cover(idx * 2 + 1, ll, rr, m + 1, r, d);
	}
};
struct Tsgt2d{
	Tsgt1d val[3001][2];
	void query(int idx, int ll, int rr, int lll, int rrr, int l, int r)
	{
		if (ll <= l && rr >= r){
			val[idx][1].query(1, lll, rrr, 0, m);
			return;
		}
		val[idx][0].query(1, lll, rrr, 0, m);
		int m = l + r >> 1;
		if (ll <= m) query(idx * 2, ll, rr, lll, rrr, l, m);
		if (rr > m) query(idx * 2 + 1, ll, rr, lll, rrr, m + 1, r);
	}
	void cover(int idx, int ll, int rr, int lll, int rrr, int l, int r, int d)
	{
		val[idx][1].cover(1, lll, rrr, 0, m, d);
		if (ll <= l && rr >= r){
			val[idx][0].cover(1, lll, rrr, 0, m, d);
			return;
		}
		int m = l + r >> 1;
		if (ll <= m) cover(idx * 2, ll, rr, lll, rrr, l, m, d);
		if (rr > m) cover(idx * 2 + 1, ll, rr, lll, rrr, m + 1, r, d);
	}
} sgt;
int Q, x1, y1, x2, y2, d;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &Q);
	int ans = 0;
	while(Q--){
		scanf("%d%d%d%d%d", &x2, &y2, &d, &x1, &y1);
		x2 += x1; y2 += y1; ++x1; ++y1;
		ret = 0;
		sgt.query(1, x1, x2, y1, y2, 0, n);
		sgt.cover(1, x1, x2, y1, y2, 0, n, ret + d);
		gmax(ans, ret + d);
	}
	printf("%d\n", ans);	
}
Problem1537

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tdata{
	int first, second, third;
	bool operator < (const Tdata & A) const
	{
		return first == A.first ? second < A.second : first < A.first;
	}
};
Tdata a[1000001];
int hash[1000001], tot, n, f[1000001], bit[1000001], ans;
int get(int t)
{
	int ret = 0;
	for (; t; t -= (t & (-t))) ret = max(ret, bit[t]);
	return ret;
}
void insert(int t, int d)
{
	for (; t <= tot; t += (t & (-t))) bit[t] = max(bit[t], d);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%*d%*d%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d%d%d", &a[i].first, &a[i].second, &a[i].third);
		hash[i] = a[i].second;
	}
	sort(a + 1, a + n + 1);
	sort(hash + 1, hash + n + 1);
	tot = unique(hash + 1, hash + n + 1) - hash - 1;
	for (int i = 1; i <= n; i++){
		int t = lower_bound(hash + 1, hash + tot + 1, a[i].second) - hash;
		f[i] = get(t) + a[i].third; insert(t, f[i]);
		ans = max(ans, f[i]);
	}
	cout << ans << endl;
}
Problem1543

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 200001, MO = 1000003;
int n, m, t;
long long ans1, ans2;
struct Tedge{
    int st, ed, len;
    void init() { scanf("%d%d%d", &st, &ed, &len); }
    bool operator < (const Tedge & A) const { return len < A.len; }
} edge[MAXN];
struct Tuf{
    int f[MAXN];
    void init() { for (int i = 1; i <= n; i++) f[i] = i; }
    int getf(int v) { return v == f[v] ? v : f[v] = getf(f[v]); }
    int GETF(int v) { return v == f[v] ? v  : GETF(f[v]); }
    bool same(int a, int b) { return getf(a) == getf(b); }
    void merge(int a, int b) { f[getf(a)] = getf(b); }
} uf1, uf2;
void dfs(int dep, int st, int ed, int num)
{
    if (num == 0) { ++t; return; }
    if (dep > ed) return;
    dfs(dep + 1, st, ed, num);
    int A = uf2.GETF(edge[dep].st), B = uf2.GETF(edge[dep].ed);
    if (A == B) return;
    uf2.f[A] = B;
    dfs(dep + 1, st, ed, num - 1);
    uf2.f[A] = A;
}
int main()
{
    scanf("%d%d", &n, &m);
    uf1.init(); uf2.init();
    for (int i = 1; i <= m; i++) edge[i].init();
    sort(edge + 1, edge + m + 1);
    int now = 0, pt = 0; ans2 = 1;
    while(now < n - 1){
        ++pt;
        int st = pt;
        while(pt < m && edge[pt + 1].len == edge[st].len) ++pt;
        int num = 0;
        for (int i = st; i <= pt; i++)
            if (!uf1.same(edge[i].st, edge[i].ed)){
                ans1 += edge[i].len; ++num;
                uf1.merge(edge[i].st, edge[i].ed);
                ++now;
            }
        t = 0;
        dfs(st, st, pt, num);
        ans2 = ans2 * t % MO;
        for (int i = st; i <= pt; i++)
            if (!uf2.same(edge[i].st, edge[i].ed)) uf2.merge(edge[i].st, edge[i].ed);
 
    }
    cout << ans2 << endl;
}
Problem1549

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXn = 201, MAXm = 201, MAXN = 200001, MAXM = 600001;
const int SIZE = 262144 - 1, inf = 0x3f3f3f3f;
int e[MAXN], next[MAXM], v[MAXM], c[MAXM], w[MAXM], tot = 1;
int a[MAXn][MAXm], S, SS, T, n, m;
int q[SIZE + 100], l, r, dis[MAXN], pre[MAXN];
bool vis[MAXN];
int cost;
int con(int x, int y)
{
	return (m + m + x - 2) * (x - 1) / 2 + y;
}
void add(int A, int B, int C, int D)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
}
bool spfa()
{
	memset(vis, 0, sizeof(vis)); vis[S] = true;
	memset(dis, 0x3f, sizeof(dis)); dis[S] = 0;
	l = 0; r = 1; q[1] = S;
	while (l != r){
		l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
			dis[v[i]] = dis[x] + w[i]; pre[v[i]] = i;
			if (!vis[v[i]]){
				vis[v[i]] = true; r = (r + 1) & SIZE; q[r] = v[i];
				}
			}
		}
	return dis[T] < 0x3f3f3f3f;
}
void aug()
{
	int min = 0x3f3f3f3f;
	for (int i = T; i != S; i = v[pre[i] ^ 1]) if (c[pre[i]] < min) min = c[pre[i]];
	for (int i = T; i != S; i = v[pre[i] ^ 1]){
		c[pre[i]] -= min; c[pre[i] ^ 1] += min;
		}
	cost += min * dis[T];
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m + i - 1; j++)
			scanf("%d", &a[i][j]);
	int TOT = (m + n + m - 1) * n / 2;
	S = TOT << 1 + 1; SS = S + 1; T = SS + 1;
	add(S, SS, m, 0);
	for (int i = 1; i <= m + n - 1; i++) add(SS, con(n, i) * 2 - 1, inf, 0);
	for (int i = n; i > 1; i--)
		for (int j = 1; j <= m + i - 1; j++){
			if (j > 1) add(con(i, j) * 2, con(i - 1, j - 1) * 2 - 1, 1, 0);
			if (j < m + i - 1) add(con(i, j) * 2, con(i - 1, j) * 2 - 1, 1, 0);
			}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m + i - 1; j++)
			add(con(i, j) * 2 - 1, con(i, j) * 2, 1, a[i][j]);
	for (int i = 1; i <= m; i++) add(con(1, i) * 2, T, inf, 0);
	while (spfa()) aug();
	printf("%d\n", cost);
	
	tot = 1; memset(e, 0, sizeof(e));
	TOT = (m + n + m - 1) * n / 2; cost = 0;
	S = TOT + 1; SS = S + 1; T = SS + 1;
	add(S, SS, m, 0);
	for (int i = 1; i <= m + n - 1; i++) add(SS, con(n, i), inf, 0);
	for (int i = n; i > 1; i--)
		for (int j = 1; j <= m + i - 1; j++){
			if (j > 1) add(con(i, j), con(i - 1, j - 1), 1, a[i][j]);
			if (j < m + i - 1) add(con(i, j), con(i - 1, j), 1, a[i][j]);
			}
	for (int i = 1; i <= m; i++) add(con(1, i), T, 0x3f3f3f3f, a[1][i]);
	while (spfa()) aug();
	printf("%d\n", cost);
}
Problem1559

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
char s[1001];
struct Tnode{
	int ch[26], flag, fail;
} a[100001];
char temp[101];
struct Trec{
	vector<string> V;
	long long num;
	void clear() { num = 0; V.clear(); }
	void add(Trec A, int ch)
	{
		num += A.num;
		temp[0] = ch + 'a';
		if (num <= 42){
			for (vector<string>::iterator vsi = A.V.begin(); vsi != A.V.end(); vsi++)
				V.push_back((*vsi) + temp);
		}
	}
};
Trec f[2][101][1024];
int l, n, tot;
void insert(char *s, int flag)
{
	int now = 1;
	for (char *S = s; *S; S++){
		if (a[now].ch[*S - 'a'] == 0) a[now].ch[*S - 'a'] = ++tot;
		now = a[now].ch[*S - 'a'];
	}
	a[now].flag |= flag;
}
int q[100001];
void build()
{
	int l = 1, r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = 0; i < 26; i++){
			a[a[x].ch[i]].fail = x == 1 ? 1 : a[a[x].fail].ch[i];
			if (a[x].ch[i] == 0) a[x].ch[i] = a[0].fail;
			else { a[a[x].ch[i]].flag |= a[a[a[x].ch[i]].fail].flag; q[++r] = a[x].ch[i]; }
		}
	}
}
vector<string> ansrec;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	scanf("%d%d", &l, &n);
	for (int i = 0; i < n; i++) { scanf("%s", s); insert(s, 1 << i); }
	build();
	f[0][1][0].num = 1; f[0][1][0].V.push_back(""); int now = 0;
	for (int i = 0; i < l; i++){
		for (int j = 1; j <= tot; j++)
			for (int S = 0; S < (1 << n); S++) f[!now][j][S].clear();
		for (int j = 1; j <= tot; j++)
			for (int S = 0; S < (1 << n); S++) if (f[now][j][S].num)
				for (int ch = 0; ch < 26; ch++)
					f[!now][a[j].ch[ch]][S | a[a[j].ch[ch]].flag].add(f[now][j][S], ch);
		now = !now;
	}
	long long ans = 0;
	for (int i = 1; i <= tot; i++) ans = ans + f[now][i][(1 << n) - 1].num;
	cout << ans << endl;
	if (ans <= 42){
		for (int i = 1; i <= tot; i++)
			for (vector<string>::iterator vsi = f[now][i][(1 << n) - 1].V.begin(); vsi != f[now][i][(1 << n) - 1].V.end(); vsi++)
				ansrec.push_back(*vsi);
	}
	sort(ansrec.begin(), ansrec.end());
	for (int i = 0; i < ansrec.size(); i++) cout << ansrec[i] << endl;
}
Problem1560

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define dis(x1, y1, x2, y2) ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))
using namespace std;
struct Tdata{
	int x, y, v;
	bool operator < (const Tdata & A) const
	{
		return y == A.y ? x < A.x : y < A.y;
	}
} d[1000001];
int n, m, f[1000001], nowy[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &d[i].x, &d[i].y, &d[i].v);
	sort(d + 1, d + n + 1);
	memset(f, 0xe0, sizeof(f)); f[1] = d[1].v; nowy[1] = 1;
	for (int i = 2; i <= n; i++){
		int temp = 0xe0e0e0e0;
		for (int j = 1; j <= d[i].x; j++) if (f[j] != 0xe0e0e0e0)
			temp = max(f[j] - dis(d[i].x, d[i].y, j, nowy[j]) + d[i].v, temp);
		nowy[d[i].x] = d[i].y; f[d[i].x] = temp;
	}	 
	printf("%d\n", f[m]);
}
Problem1562

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int n, a[100001], c[100001][2], ans[100001], link[100001];
bool vis[100001];
bool find(int x)
{
	for (int i = 0; i < 2; i++) if (!vis[c[x][i]]){
		vis[c[x][i]] = true;
		if (link[c[x][i]] == 0 || find(link[c[x][i]])){
			link[c[x][i]] = x; return true;
			}
		}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);
	for (int i = 0; i < n; i++){
		int mi = (i - a[i] + n) % n, ma = (i + a[i]) % n;
		if (mi > ma) swap(mi, ma);
		c[i][0] = mi; c[i][1] = ma;
		}
	for (int i = n - 1; i >= 0; i--){
		memset(vis, 0, sizeof(vis));
		if (!find(i)) { puts("No Answer"); return 0; }
		}
	for (int i = 0; i < n; i++) ans[link[i]] = i;
	for (int i = 0; i < n - 1; i++) printf("%d ", ans[i]);
	printf("%d\n", ans[n- 1]);
}	
Problem1563

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <algorithm>
#define st first.first
#define ed first.second
#define who second
#define ll long long
const ll LIM = 1000000000000000001ll;
const int MAXN = 300001;
using namespace std;
ll f[MAXN], sum[MAXN], L, P;
int n, l, r, which[MAXN];
pair<pair<int, int>, int> q[110000];
char data[110000][41];
double dpow(ll a, ll b)
{
	double ret = 1.0, now = double(a);
	for (; b; b >>= 1ll){ if (b & 1) ret = ret * now; now = now * now; }
	return ret;
}
ll ipow(ll a, ll b)
{
	long long ret = 1, now = a;
	for (; b; b >>= 1ll){ if (b & 1) ret = ret * now; now = now * now; }
	return ret;
}
double dcalc(int a, int b) //use b to calc a
{
	//fprintf(stderr, "%.0lf\n", double(f[b]) + dpow(abs(sum[a] - sum[b] + (a - b - 1) - L), P));
	return double(f[b]) + dpow(abs(sum[a] - sum[b] + (a - b - 1) - L), P);
} 
long long icalc(int a, int b) //use b to calc a
{
	return f[b] + ipow(abs(sum[a] - sum[b] + (a - b - 1) - L), P);
}
int find(int w)
{
	int L = q[r].st, R = q[r].ed;
	while(L <= R){
		int m = L + R >> 1;
		if (dcalc(m, w) < dcalc(m, q[r].who)) R = m - 1; else L = m + 1;
		}
	return L;
}	
void printans(int t)
{
	if (t == 0) return;
	printans(which[t]);
	for (int i = which[t] + 1; i <= t; i++)
		printf("%s%c", data[i], i == t ? '\n' : ' ');
}
int main()
{
int T; scanf("%d", &T);
while(T--){
	cin >> n >> L >> P; getchar();
	for (int i = 1; i <= n; i++) { gets(data[i]); sum[i] = sum[i - 1] + strlen(data[i]); }
	q[1].who = 0; q[1].st = 1; q[1].ed = n; l = 1; r = 1;
	for (int i = 1; i <= n; i++){
		if (dcalc(i, q[l].who) > 1e18) f[i] = LIM; 
		else f[i] = icalc(i, q[l].who), which[i] = q[l].who;
		q[l].st++; if (q[l].st > q[l].ed) ++l;
		while(r >= l && dcalc(q[r].st, i) < dcalc(q[r].st, q[r].who)) --r;
		if (l > r) { l = 1; r = 1; q[1].st = i + 1; q[1].ed = n; q[1].who = i; }
		else { 
			int t = find(i);
			q[r].ed = t - 1; ++r; q[r].st = t; q[r].ed = n; q[r].who = i;
			if (q[r].ed < q[r].st) --r;
			}
		}
	if (f[n] >= LIM) puts("Too hard to arrange");
	else{
		cout << f[n] << endl;
		//printans(n);
		}
	puts("--------------------");
}
}
Problem1564

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tdata{
	int a, b, c;
	bool operator < (const Tdata & A) const { return a < A.a; }
} d[1001];
int n, kk;
int hashb[1001], sum[1001];
long long f[101][101][101];
long long dp(int l, int r, int mn)
{
	if (f[l][r][mn] > 0) return f[l][r][mn]; 
	if (l > r) return 0;
	if (l == r) return d[l].c + (d[l].b <= mn) * kk;
	long long & x = f[l][r][mn]; x = 0x1fffffffffffffffll;
	for (int k = l; k <= r; k++){
		if (d[k].b > mn) x = min(x, dp(l, k - 1, d[k].b) + dp(k + 1, r, d[k].b));
		x = min(x, dp(l, k - 1, mn) + dp(k + 1, r, mn) + kk);
	}
	x = x + sum[r] - sum[l - 1];
	return x;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &kk);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i].a);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i].b);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i].c);
	sort(d + 1, d + n + 1);
	for (int i = 1; i <= n; i++) hashb[i] = d[i].b; sort(hashb + 1, hashb + n + 1);
	for (int i = 1; i <= n; i++) d[i].b = lower_bound(hashb + 1, hashb + n + 1, d[i].b) - hashb;
	for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + d[i].c;
	memset(f, 0xff, sizeof(f));
	cout << dp(1, n, 0) << endl;
}
Problem1565

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 500001, MAXM = 900001, INF = 0x3f3f3f3f;
int n, m, s, t, ans, vh[MAXM], h[MAXN], sco[MAXN];
bool vis[MAXN];
int a[MAXN], p, num, nowc, col[MAXN];
struct Tgraph{
	int tot, e[MAXN], next[MAXM], v[MAXM], c[MAXM];
	void add(int A, int B, int C)
	{
		//cerr << A << " " << B << " " << C << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
	}
	void add(int A, int B)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B;
	}
	void dfs1(int x)
	{
		vis[x] = true;
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) dfs1(v[i]);
		a[++p] = x;
	}
	void dfs2(int x)
	{
		++num; col[x] = nowc;
		for (int i = e[x]; i; i = next[i]) if (col[v[i]] == 0) dfs2(v[i]);
	}
	int aug(int x, int f)
	{
		int minh = t - 1, augc = f;
		if (x == t) return f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
			if (h[v[i]] + 1 == h[x]){
				int t = aug(v[i], min(f, c[i]));
				c[i] -= t; c[i ^ 1] += t; f -= t;
				if (f == 0 || h[s] == t) return augc - f;
				}
			minh = min(minh, h[v[i]]);
			}
		if (f == augc){
			--vh[h[x]]; if (vh[h[x]] == 0) h[s] = t;
			h[x] = minh + 1; ++vh[h[x]];
			}
		return augc - f;
	} 	
	void maxflow()
	{
		vh[0] = t;
		while(h[s] < t) ans -= aug(s, INF);
		printf("%d\n", ans);
	}	
} g, gt, G;
int cha(int a, int b) { return a * m + b + 1; }
void scc()
{
	for (int i = 1; i <= n * m; i++) if (!vis[i]) g.dfs1(i);
	for (int i = n * m; i >= 1; i--) if (col[a[i]] == 0){
		num = 0;
		nowc = a[i]; gt.dfs2(a[i]);
		if (num > 1) sco[a[i]] = -INF;
		}
	for (int i = 1; i <= n * m; i++)
		for (int j = g.e[i]; j; j = g.next[j]) if (col[i] != col[g.v[j]])
			G.add(col[i], col[g.v[j]], INF);
	for (int i = 1; i <= n * m; i++) if (col[i] == i)
		if (sco[i] > 0) G.add(s, i, sco[i]), ans += sco[i];
		else G.add(i, t, -sco[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++){
			int num, x, y;
			scanf("%d", &sco[cha(i, j)]);
			scanf("%d", &num);
			for (int t = 0; t < num; t++){
				scanf("%d%d", &x, &y);
				g.add(cha(x, y), cha(i, j));
				gt.add(cha(i, j), cha(x, y));
				}
			if (j != m - 1){
				g.add(cha(i, j), cha(i, j + 1));
				gt.add(cha(i, j + 1), cha(i, j));
				}
			}
	s = n * m + 1, t = n * m + 2; G.tot = 1;
	scc();
	G.maxflow();
}	
	
Problem1566

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 1024523;
int f[2][501][501] = {}, n, m;
char a[1001], b[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); scanf(" ");
	scanf("%s", a + 1); scanf(" "); scanf("%s", b + 1);
	f[0][0][0] = 1; int now = 1;
	for (int L = 1; L <= n + m; L++){
		now ^= 1; for (int i = 0; i <= n; i++) for (int k = 0; k <= n; k++) f[!now][i][k] = 0;
		for (int i = 0; i <= n; i++) if (L - i >= 0 && L - i <= m)
			for (int k = 0; k <= n; k++) if (L - k >= 0 && L - k <= m){
				int j = L - i, l = L - k; //((i, j), (k, l))
				if (i > 0 && k > 0 && a[i] == a[k]) f[!now][i][k] = (f[!now][i][k] + f[now][i - 1][k - 1]) % MO;
				if (i > 0 && a[i] == b[l]) f[!now][i][k] = (f[!now][i][k] + f[now][i - 1][k]) % MO;
				if (k > 0 && b[j] == a[k]) f[!now][i][k] = (f[!now][i][k] + f[now][i][k - 1]) % MO;
				if (b[j] == b[l]) f[!now][i][k] = (f[!now][i][k] + f[now][i][k]) % MO;
			}
	}
	printf("%d\n", f[now ^ 1][n][n]);

}
Problem1567

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int a[501][501], b[501][501], n, l, r;
bool check(int x1, int y1, int x2, int y2, int l)
{
	for (int i = 1; i <= l; i++)
		for (int j = 1; j <= l; j++)
			if (a[x1 + i - 1][y1 + j - 1] != b[x2 + i - 1][y2 + j - 1]) return false;
	return true;
}
bool ok(int t)
{
	for (int x1 = 1; x1 <= n - t + 1; x1++)
		for (int y1 = 1; y1 <= n - t + 1; y1++)
			for (int x2 = 1; x2 <= n - t + 1; x2++)
				for (int y2 = 1; y2 <= n - t + 1; y2++)
					if (check(x1, y1, x2, y2, t)) return true;
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &a[i][j]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &b[i][j]);
	l = 1; r = n;
	while(l <= r){
		int m = l + r >> 1;
		if (ok(m)) l = m + 1; else r = m - 1;
	}
	printf("%d\n", r);
}
Problem1568

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <set>
#include <cmath>
#include <algorithm>
#include <iostream>
#define si set<Tpoint>::iterator
#define PII pair<int, int>
using namespace std;
const int MAXN = 200001;
const double eps = 1e-7;
int n = 50000;
int dcmp(double a)
{
	if (fabs(a) < eps) return 0;
	return a < 0 ? -1 : 1;
}
struct Tsgt{
	double A[MAXN << 2], B[MAXN << 2];
	void same(int idx, double _A, double _B)
	{
		A[idx] = _A; B[idx] = _B;
	}
	void push(int l, int r, int idx)
	{
		int m = l + r >> 1;
		if (B[idx] > 0){
			same(idx * 2, A[idx], B[idx]);
			same(idx * 2 + 1,  A[idx] + B[idx] * (m - l + 1), B[idx]);
			A[idx] = 0; B[idx] = 0;
		}
	}
	void makesame(int idx, int l, int r, int ll, int rr, double _A, double _B)
	{
		if (ll <= l && rr >= r) { same(idx, _A + _B * (l - 1), _B); return; }
		int m = l + r >> 1;
		push(l, r, idx);
		if (ll <= m) makesame(idx * 2, l, m, ll, rr, _A, _B);
		if (rr > m) makesame(idx * 2 + 1, m + 1, r, ll, rr, _A, _B);
	}
	double get(int idx, int l, int r, int x)
	{
		if (l == r) return A[idx];
		int m = l + r >> 1;
		push(l, r, idx);
		if (x <= m) return get(idx * 2, l, m, x); else return get(idx * 2 + 1, m + 1, r, x);
	}
} sgt;
struct Tpoint{
	double x, y;
	Tpoint() { }
	Tpoint(double _x, double _y) { x = _x; y = _y; }
	bool error() { return x > 1e50; }
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = x - A.x; temp.y = y - A.y;
		return temp;
	}
	double operator * (Tpoint A)
	{
		return x * A.y - y * A.x;
	}
	bool operator < (const Tpoint & A) const
	{
		return dcmp(x - A.x) < 0;
	}
	bool operator == (const Tpoint & A) const
	{
		return (dcmp(x - A.x) == 0);
	}
} error;
struct Thull{
	set<Tpoint> hull;
	double calc_k(Tpoint A, Tpoint B)
	{
		return (A.y - B.y) / (A.x - B.x);
	}
	Tpoint lower(Tpoint A) //ret >= A
	{
		si SI = hull.lower_bound(A);
		if (SI == hull.end()) return error; else return *SI;
	}
	Tpoint next(Tpoint A) //ret > A
	{
		si SI = hull.upper_bound(A);
		if (SI == hull.end()) return error; else return *SI;
	}
	Tpoint pre(Tpoint A) //ret < A
	{	
		si SI = hull.lower_bound(A);
		if (SI == hull.begin()) return error; else return *(--SI);
	}
	PII insert(Tpoint a)
	{
		if (hull.size() == 0) { hull.insert(a); return make_pair(1, n); }
		Tpoint d1 = pre(a), d2 = lower(a);
		if (d1.error() && d2.y > a.y) return make_pair(0, -1); 
		if ((!d1.error()) && (!d2.error()) && (dcmp((d2 - d1) * (a - d1)) < 0)) return make_pair(0, -1);
		if (d2 == a) hull.erase(d2);
		Tpoint p1 = a, p2 = next(a);
		while(1){
			p1 = p2; p2 = next(p2);
			if (p1.error() || p2.error()) break;
			if (dcmp((p1 - a) * (p2 - a)) < 0) break;
			hull.erase(p1);
		}
		p1 = a; p2 = pre(a);
		while(1){
			p1 = p2; p2 = pre(p2);
			if (p1.error() || p2.error()) break;
			if (dcmp((p1 - a) * (p2 - a)) > 0) break;
			hull.erase(p1);
		}
		hull.insert(a);
		d1 = pre(a); d2 = next(a);
		PII temp(1, n);
		if (!d1.error()) temp.first = max(temp.first, (int)ceil(-calc_k(d1, a)) + 1);
		if (!d2.error()) temp.second = min(temp.second, (int)floor(-calc_k(a, d2)) + 1);
		return temp; 
	}
} hull;
	int Q;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	error.x = 1e99;
	hull.insert(Tpoint(0, 0));
	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		scanf(" "); char op[101]; double A, B; int x; 
		scanf("%s", op);
		switch(*op){
			case 'Q' : scanf("%d", &x); printf("%d\n", int(floor(sgt.get(1, 1, n, x) / 100.0))); break;
			case 'P' : scanf("%lf%lf", &A, &B); PII temp = hull.insert(Tpoint(B, A)); 
					   if (temp.first > temp.second) break;
					   sgt.makesame(1, 1, n, temp.first, temp.second, A, B);
					   break;
		}
	}
}
Problem1569

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[50][200][200], n, x, y, z, a, b;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d%d%d", &n, &x, &y, &z, &a, &b);
	memset(f, 0xe0, sizeof(f));
	f[0][n][0] = 0; //i time j people k money
	for (int i = 0; ;i++){
		bool ok = false;
		for (int j = 0; j <= 100; j++)
			for (int k = 0; k <= 100; k++) if (f[i][j][k] >= 0){
				if (f[i][j][k] >= b && k >= a) { ok = true; goto find; }
				for (int t = 0; t <= j; t++) if (k + t * x <= 100) f[i + 1][j][k + t * x] = max(f[i][j][k] + (j - t) * y, f[i + 1][j][k + t * x]);
				if (k >= z) for (int t = 0; t <= 3 * j; t++) 
				if (k + t * x - z <= 100 && j < 100)
					f[i + 3][j + 1][k + t * x - z] = max(f[i][j][k] + (3 * j - t) * y, f[i + 3][j + 1][k + t * x - z]);
			}
		continue;
		find: { printf("%d\n", i); break;  } 
	}
}
Problem1570

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 5010, MAXM = 1000001, INF = 0x3f3f3f3f, MAXDAY = 100;
int n, m, T, st[100001], ed[100001], num[100001];
struct Tflow{
	int s, t, e[MAXN], v[MAXM], next[MAXM], c[MAXM], h[MAXN], vh[MAXN], tot;
	Tflow() { tot = 1; }
	void add(int a, int b, int w) 
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = w;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
	}
	int aug(int x, int f)
	{
		if (x == t) return f;
		int augc = f, minh = t - 1;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
			if (h[x] == h[v[i]] + 1){
				int t = aug(v[i], min(f, c[i]));
				c[i] -= t; c[i ^ 1] += t; f -= t;
				if (f == 0 || h[s] == t) return augc - f;
			}
			if (minh > h[v[i]]) minh = h[v[i]];
		}
		if (f == augc) { if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1]; }
		return augc - f;
	}
	int run()
	{
		for (int i = 1; i <= tot; i++) c[i * 2] += c[i * 2 + 1], c[i * 2 + 1] = 0;
		int flow = 0;
		memset(h, 0, sizeof(h)); 
		memset(vh, 0, sizeof(vh));
		vh[0] = t;
		while(h[s] != t) flow += aug(s, INF);
		return flow;
	}
	void addnew(int x)
	{
		for (int i = 1; i <= m; i++) add((x - 1) * n + st[i], x * n + ed[i], num[i]);
		add(s, x * n + 1, T);
		add((x + 1) * n, t, T);
	}
} flow;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &T);
	for (int i = 1; i <= m; i++) scanf("%d%d%d", &st[i], &ed[i], &num[i]);
	flow.s = n * MAXDAY + 1; flow.t = flow.s + 1;
	flow.add(flow.s, 1, T);
	flow.add(n, flow.t, T);
	for (int i = 1; i <= MAXDAY; i++){
		flow.addnew(i);
		if (flow.run() >= T) { printf("%d\n", i); break; }
	}
}
Problem1576

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <algorithm>
#include <iostream>
#include <functional>
#define mp make_pair
#define PII pair<int, int>
#define log(a) (31 - __builtin_clz(a))
const int MAXN = 300001, MAXM = 600001;
using namespace std;
priority_queue<PII, vector<PII>, greater<PII> > Q;
int dis[MAXN]; bool vis[MAXN];
int DFSX[MAXN * 2], DFSNOW, in[MAXN], deep[MAXN], fa[MAXN];
int n, m;
struct Tgraph{
	int tot, e[MAXN], v[MAXM], w[MAXM], next[MAXM];
	void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void dijkstra()
	{
		memset(dis, 0x3f, sizeof(dis)); Q.push(mp(0, 1)); dis[1] = 0;
		while(!Q.empty()){
			PII now = Q.top(); Q.pop();
			if (!vis[now.second])
				for (int i = e[now.second]; i; i = next[i]) if (dis[v[i]] > now.first + w[i]){
					Q.push(make_pair(now.first + w[i], v[i]));
					dis[v[i]] = now.first + w[i];
				}
			vis[now.second] = true;
		}
	}
	void dfs(int x)
	{
		DFSX[++DFSNOW] = x; in[x] = DFSNOW;
		for (int i = e[x]; i; i = next[i]){
			deep[v[i]] = deep[x] + 1; dfs(v[i]); DFSX[++DFSNOW] = x;
		}
	}
} graph, tree;
struct Tlca{
	int f[MAXN][20];
	int getmin(int a, int b) { return deep[a] < deep[b] ? a : b; }
	void build()
	{
		tree.dfs(1);
		int lg = log(DFSNOW);
		for (int i = 1; i <= DFSNOW; i++) f[i][0] = DFSX[i];
	  	for (int i = 1; i <= lg; i++)
			for (int j = 1; j + (1 << i) - 1 <= DFSNOW; j++)
				f[j][i] = getmin(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);	
	}
	int ask(int a, int b)
	{
		a = in[a]; b = in[b]; if (a > b) swap(a, b);
		int x = log(b - a + 1);
		return getmin(f[a][x], f[b - (1 << x) + 1][x]);
	}
} lca;
struct Tskewnode{
	static Tskewnode *a;
	int c[2], _add, data, who;
	void add(int delta)
	{
		if (this == a) return;
		_add += delta; data += delta;
	}
	void push()
	{
		if (_add != 0){
			a[c[0]].add(_add); a[c[1]].add(_add);
			_add = 0;
		}
	}
} skewnode[MAXN], *Tskewnode::a = skewnode; int tot;
int make(int data, int who)
{
	++tot; skewnode[tot].data = data; skewnode[tot].who = who;
	return tot;
}
int root[MAXN];
int merge(int a, int b)
{
	if (a == 0 || b == 0) return a + b;
	if (skewnode[a].data > skewnode[b].data) swap(a, b);
	skewnode[a].push();
	skewnode[a].c[1] = merge(skewnode[a].c[1], b);
	swap(skewnode[a].c[0], skewnode[a].c[1]);
	return a;
}
void remove(int t)
{
	skewnode[root[t]].push();
	root[t] = merge(skewnode[root[t]].c[0], skewnode[root[t]].c[1]);
}
int ans[MAXN];
void doit(int x)
{
	for (int i = tree.e[x]; i; i = tree.next[i]) { fa[tree.v[i]] = x; doit(tree.v[i]); }
	for (int i = graph.e[x]; i; i = graph.next[i]) if (lca.ask(x, graph.v[i]) != x && graph.v[i] != fa[x])
		root[x] = merge(root[x], make(dis[graph.v[i]] + graph.w[i], graph.v[i]));
	for (int i = tree.e[x]; i; i = tree.next[i]){
		skewnode[root[tree.v[i]]].add(tree.w[i]);
		root[x] = merge(root[x], root[tree.v[i]]);
	}
	while(lca.ask(skewnode[root[x]].who, x) == x) remove(x);
	ans[x] = root[x] == 0 ? -1 : skewnode[root[x]].data;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		graph.add(a, b, c); graph.add(b, a, c);
	}
	graph.dijkstra();
	for (int i = 1; i <= n; i++)
		for (int ei = graph.e[i]; ei; ei = graph.next[ei])
			if (dis[i] == dis[graph.v[ei]] - graph.w[ei]){
				tree.add(i, graph.v[ei], graph.w[ei]);
			}
	lca.build();
	doit(1);
	for (int i = 2; i <= n; i++) printf("%d\n", ans[i]);
}
Problem1593

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001;
struct Tsgt{
	int cover[MAXN << 2], maxl[MAXN << 2], maxr[MAXN << 2], maxs[MAXN << 2];
	void push(int idx, int l, int r)
	{
		int m = l + r >> 1;
		if (cover[idx]){
			if (cover[idx] == 1) { cover1(idx * 2, m - l + 1); cover1(idx * 2 + 1, r - m); }
			if (cover[idx] == 2) { cover2(idx * 2, m - l + 1); cover2(idx * 2 + 1, r - m); }
		}
		cover[idx] = 0;
	}
	void cover1(int idx, int len)
	{
		maxl[idx] = maxr[idx] = maxs[idx] = len;
		cover[idx] = 1;
	}
	void cover2(int idx, int len)
	{
		maxl[idx] = maxr[idx] = maxs[idx] = 0;
		cover[idx] = 2;
	}
	void update(int idx, int l, int r)
	{
		int m = l + r >> 1;
		maxl[idx] = maxl[idx * 2] == m - l + 1 ? maxl[idx * 2] + maxl[idx * 2 + 1] : maxl[idx * 2];
		maxr[idx] = maxr[idx * 2 + 1] == r - m ? maxr[idx * 2 + 1] + maxr[idx * 2] : maxr[idx * 2 + 1];
		maxs[idx] = max(max(maxs[idx * 2], maxs[idx * 2 + 1]), maxr[idx * 2] + maxl[idx * 2 + 1]); 
	}
	void build(int idx, int l, int r)
	{
		if (l == r) { maxl[idx] = maxr[idx] = maxs[idx] = 1; return; }
		build(idx * 2, l, l + r >> 1); build(idx * 2 + 1, l + r + 2 >> 1, r);
		maxl[idx] = maxr[idx] = maxs[idx] = r - l + 1;
	}
	void makecover(int idx, int l, int r, int ll, int rr, int c)
	{
		if (maxr[idx] > r - l + 1){
			fputs("BUG\n", stderr);
		}
		if (ll <= l && rr >= r) { if (c == 1) cover1(idx, r - l + 1); else cover2(idx, r - l + 1); return; }
		int m = l + r >> 1;
		push(idx, l, r);
		if (ll <= m) makecover(idx * 2, l, m, ll, rr, c);
		if (rr > m) makecover(idx * 2 + 1, m + 1, r, ll, rr, c);
		update(idx, l, r);
	}	
	int query(int idx, int l, int r, int len) //find an interval [ret, ret + len - 1] empty
	{
		if (maxr[idx] > r - l + 1){
			fputs("BUG\n", stderr);
		}
		if (maxs[idx] < len) return 0; int m = l + r >> 1;
		if (l == r) return len == 1 ? l : 0;
		push(idx, l, r);
		if (maxs[idx * 2] >= len) return query(idx * 2, l, m, len);
		if (maxr[idx * 2] + maxl[idx * 2 + 1] >= len) return m - maxr[idx * 2] + 1;
		return query(idx * 2 + 1, m + 1, r, len);
	}
} sgt;
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	sgt.build(1, 1, n);
	while(m--){
		int op, l, r, num, t;
		scanf("%d", &op);
		switch(op){
			case 1 : scanf("%d", &num); t = sgt.query(1, 1, n, num); printf("%d\n", t); if (t != 0) sgt.makecover(1, 1, n, t, t + num - 1, 2); break;
			case 2 : scanf("%d%d", &l, &r); sgt.makecover(1, 1, n, l, l + r - 1, 1); break;
		}
	}
}
Problem1628

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tstack{
    int top, data[1000001];
    void cl() { top = 0; }
    bool find(int num)
    {
        int l = 1, r = top;
        while(l <= r){
            int m = l + r >> 1;
            if (data[m] == num) return true;
            if (data[m] < num) l = m + 1; else r = m - 1;
            }
        return false;
    }
    void push(int num)
    {
        while(top > 0 && data[top] > num) --top;
        data[++top] = num;
    }   
} S;
int n, ans, h[1000001];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("pla.in", "r", stdin); freopen("pla.out", "w", stdout);
#endif
    scanf("%d%*d", &n);
    for (int i = 1; i <= n; i++) scanf("%*d%d", &h[i]);
    S.cl();
    for (int i = 1; i <= n; i++){
        ans += !S.find(h[i]) && h[i] > 0;
        S.push(h[i]);
        }
    printf("%d\n", ans);
}
Problem1652

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define uint unsigned
uint n, f[2001][2001], a[2001];
using namespace std;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%u", &n);
	for (uint i = 1; i <= n; i++){
		uint t; scanf("%u", &t); a[i] = t; f[i][i] = n * t;
		}
	for (uint l = 2; l <= n; l++)
		for (uint i = 1; i <= n; i++){
			uint j = i + l - 1; if (j > n) continue;
			f[i][j] = max(f[i + 1][j] + a[i] * (n - l + 1), f[i][j - 1] + a[j] * (n - l + 1));
			}
	printf("%u\n", f[1][n]);
}
Problem1653

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Tdata{
	int data[11];
	int & operator [] (int k) { return data[k]; }
	Tdata operator + (Tdata A)
	{
		Tdata temp;
		for (int i = 1; i <= 10; i++) temp[i] = data[i] + A[i];
		return temp;
	}
	}f[21][21];
int n, num, t[21];
bool vis[31];
void check()
{
	int ttt = 0;
	for (int i = 1; i <= n; i++) ttt += f[n][1][i] * t[i];
	if (ttt == num){
		for (int i = 1; i <= n - 1; i++) printf("%d ", t[i]); printf("%d\n", t[n]);
		exit(0);
		}
}
void DFS(int depth)
{
	if (depth == n){
		check(); return;
		}
	for (int i = 1; i <= n; i++) if (!vis[i]){
		vis[i] = true; t[depth + 1] = i; DFS(depth + 1); vis[i] = false;
		}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	memset(f, 0, sizeof(f));
	scanf("%d%d", &n, &num);
	for (int i = 1; i <= n; i++) f[1][i][i] = 1;
	for (int i = 2; i <= n; i++)
		for (int j = 1; j <= n - i + 1; j++)
			f[i][j] = f[i - 1][j] + f[i - 1][j + 1];
	DFS(0);
}
Problem1657

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
int ans[MAXN];
struct Tstack{
	int top, data[MAXN], cc[MAXN];
	int & operator [] (int k) {return data[k];}
	void clear()
	{
		top = 0;
	}
	bool empty()
	{
		return top == 0;
	}
	void push(int h, int c, int w)
	{
		while(!empty() && h > data[top]){
			ans[w] += cc[top]; --top;
			}
		++top; data[top] = h; cc[top] = c;
	}
} stack;
int n, a[MAXN], b[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i], &b[i]);
	for (int i = 1; i <= n; i++) stack.push(a[i], b[i], i);
	stack.clear();
	for (int i = n; i >= 1; i--) stack.push(a[i], b[i], i);
	int tans = 0;
	for (int i = 1; i <= n; i++) tans = max(ans[i], tans);
	printf("%d\n", tans);
}
Problem1663

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 1001;
using namespace std;
int ans;
int n, t[MAXN], num[MAXN], map[MAXN][MAXN], best[MAXN];
bool cmp(int a, int b)
{
	return t[a] < t[b];
} 
int main()
{
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &t[i]);
	for (int i = 1; i <= n; i++) num[i] = i;
	sort(num + 1, num + n + 1, cmp);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &map[i][j]);
	memset(best, 0xe0, sizeof(best));
	for (int i = 1; i <= n; i++) if (map[1][i] <= t[i]) best[i] = 1;
	for (int i = 1; i <= n; i++)
#define i num[i]
		if (best[i] != 0){
		ans = max(ans, best[i]);
		for (int j = 1; j <= n; j++) if (i != j)
			 if (t[j] - t[i] >= map[i][j] && best[j] <= best[i])
			best[j] = best[i] + 1;
		}
#undef i
	printf("%d\n", ans);
}
Problem1666

#include <cstdio>
#include <iostream>
using namespace std;
int get(int k)
{
    if (k == 1) return 0;
    if (k & 1) return get(3 * k + 1) + 1; else return get(k >> 1) + 1;
}
int main()
{
    int a; cin >> a; cout << get(a) << endl;
}
Problem1677

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, tot;
int num[1001], f[1000001], g[1000001];
int main()
{
	scanf("%d", &n);
	num[tot = 1] = 1;
	while(num[tot] * 2 < n) num[tot + 1] = num[tot] * 2, ++tot;
	g[0] = 1;
	for (int i = 1; i <= tot; i++){
		f[0] = 1;
		for (int j = 1; j <= n; j++){
			if (j >= num[i]) f[j] = (g[j] + f[j - num[i]]) % 1000000000;
			else f[j] = g[j];
			}
		memcpy(g, f, sizeof(f));
		}
	printf("%d\n", f[n]);
}
Problem1679

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int a[100001], n;
long long ans;
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	for (int i = 1; i < n; i++)
		ans = ans + (long long)i * (long long)(n - i) * (long long)(a[i + 1] - a[i]);
	printf("%lld\n", ans * 2);
}
Problem1692

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 500001;
int sa[MAXN], t1[MAXN], t2[MAXN], rank[MAXN], ws[MAXN], wv[MAXN];
int n, *x = t1, *y = t2;
char s[MAXN], ans[MAXN];
bool cmp(int a, int b) { return s[a] < s[b]; }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) { scanf(" "); scanf("%c", s + i); }
	for (int i = 1; i <= n; i++) s[n + i] = s[n - i + 1]; n <<= 1;
	for (int i = 1; i <= n; i++) sa[i] = i;
	sort(sa + 1, sa + n + 1, cmp);
	x[sa[1]] = 1; for (int i = 2; i <= n; i++) x[sa[i]] = s[sa[i]] == s[sa[i - 1]] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
	int m = x[sa[n]];
	for (int j = 1; m < n; j <<= 1){
		int tot = 0;
		for (int i = n - j + 1; i <= n; i++) y[++tot] = i;
		for (int i = 1; i <= n; i++) if (sa[i] > j) y[++tot] = sa[i] - j;
		for (int i = 0; i <= m; i++) ws[i] = 0;
		for (int i = 1; i <= n; i++) ws[wv[i] = x[y[i]]]++;
		for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
		for (int i = n; i >= 1; i--) sa[ws[wv[i]]--] = y[i];
		swap(x, y); x[sa[1]] = 1;
		for (int i = 2; i <= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j]) ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
		m = x[sa[n]];
	}
	for (int i = 1; i <= n; i++) rank[i] = x[i];
	n >>= 1; int l = 1, r = n;
	for (int i = 1; i <= n; i++)
		if (x[l] < x[n + n - r + 1]) { ans[i] = s[l]; l++; }
		else { ans[i] = s[r]; r--; }
	int temp = 0;
	for (int i = 1; i <= n; i++){
		putchar(ans[i]); ++temp;
		if (temp % 80 == 0) putchar('\n');
	}
}
Problem1715

#include <cstdio>
#include <cstdlib>
#include <cstring>
int tot, e[100001], next[100001], w[100001], v[100001];
int dis[100001];
bool vis[100001], VIS[100001];
int n, m, t;
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
}
bool spfa(int x)
{
	VIS[x] = true;
	if (vis[x]) return true;
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]){
		if (dis[x] + w[i] < dis[v[i]]){
			dis[v[i]] = dis[x] + w[i];
			if (spfa(v[i])) return true;
			}
		}
	vis[x] = false;
	return false;
} 
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
for (int test = 1; test <= TEST; test++){
	memset(dis, 0x3f, sizeof(dis));
	memset(VIS, 0, sizeof(VIS));
	memset(vis, 0, sizeof(vis));
	scanf("%d%d%d", &n, &m, &t);
	tot = 0; memset(e, 0 ,sizeof(e));
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z); add(x, y, z); add(y, x, z);
		}
	for (int i = 1; i <= t; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z); add(x, y, -z);
		}
	
	bool ans = false;
	for (int i = 1; i <= n; i++) if (!VIS[i]){
		dis[i] = 0;
		ans |= spfa(i);
		}
	puts(ans ? "YES" : "NO");
	}
}
Problem1716

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;
const int W = 30000;
const int MAXN = 100001;
int n, T, V[MAXN], v[100001], p[100001], tot;
int f1[W + 1000], f2[W + 1000];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &T);
	for (int i = 1; i <= n; i++) scanf("%d", &V[i]);
	for (int i = 1; i <= n; i++){
		int num; scanf("%d", &num);
		int now = 1;
		while(num >= now){
			v[++tot] = V[i] * now; p[tot] = now;
			num -= now;
			now <<= 1;
			}
		if (num) {v[++tot] = V[i] * num; p[tot] = num;}
		}
	memset(f1, 0x3f, sizeof(f1)); f1[0] = 0; 
	for (int i = 1; i <= tot; i++)
		for (int j = W; j >= v[i]; j--)
			f1[j] = min(f1[j - v[i]] + p[i], f1[j]);	
	memset(f2, 0x3f, sizeof(f2)); f2[0] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = V[i]; j <= W; j++)
			f2[j] = min(f2[j - V[i]] + 1, f2[j]);
	int ans = 0x3f3f3f3f;
	for (int i = T; i <= W; i++) ans = min(ans, f1[i] + f2[i - T]);
	printf("%d\n", ans > 1000000 ? -1 : ans);
}
Problem1717

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXN = 300001, MAXW = 1000001;
int wa[MAXN], wb[MAXN], *x = wa, *y = wb;
int a[MAXN], ws[MAXW], wv[MAXN], n, k;
int sa[MAXN], rank[MAXN], h[MAXN];
int m, p;
bool ok(int len)
{
	int num = 1;
	for (int i = 1; i < n; i++){
		if (h[i] < len) num = 1;
		else if (++num == k) return true;
		}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);
	for (int i = 0; i < n; i++) ws[x[i] = (++a[i])]++;
	for (int i = 1; i <= MAXW; i++) ws[i] += ws[i - 1];
	for (int i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;
	for (int j = 1, m = MAXW; p < n; j <<= 1, m = p){
		p = 0;
		for (int i = n - j; i < n; i++) y[p++] = i;
		for (int i = 0; i < n; i++) if (sa[i] >= j) y[p++] = sa[i] - j;
		memset(ws, 0, sizeof(ws));
		for (int i = 0; i < n; i++) ws[wv[i] = x[y[i]]]++;
		for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
		for (int i = n - 1; i >= 0; i--) sa[--ws[wv[i]]] = y[i];
		int *t = x; x = y; y = t; p = 1; x[sa[0]] = 1;
		for (int i = 1; i < n; i++) 
			x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] +j]) ? p : ++p;
		}
	for (int i = 0; i < n; i++) rank[sa[i]] = i;
	int k = 0;
	for (int i = 0; i < n; i++)
		if (rank[i] == 0) h[0] = k = 0;
		else{
			int j = sa[rank[i] - 1];
			k = (k > 0) ? k - 1 : k;
			while(a[i + k] == a[j + k]) ++k;
			h[rank[i]] = k;
			}			
	int l = 1, r = n;
	while(l <= r){
		int m = l + r >> 1;
		if (ok(m)) l = m + 1; else r = m - 1;
		}
	printf("%d\n", r);
}
Problem1718

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 100001, MAXM = 600001;
int tot, e[MAXN], v[MAXM], next[MAXM];
bool br[MAXM], vis[MAXN];
int deep[MAXN], father[MAXN], anc[MAXN];
int n, m, now;
int c[MAXN], d[MAXN];
void add(int x, int y)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y;
}
void DFS(int x)
{
	anc[x] = deep[x]; vis[x] = true;
	for (int i = e[x]; i; i = next[i])
		if (vis[v[i]]){
			if (i != (father[x] ^ 1))
				anc[x] = min(deep[v[i]], anc[x]);
			}
		else{
			deep[v[i]] = deep[x] + 1; father[v[i]] = i;
			DFS(v[i]);
			if (anc[v[i]] > deep[x]) br[i] = br[i ^ 1] = true;
			anc[x] = min(anc[x], anc[v[i]]);
			}
}
void color(int x)
{
	c[x] = now; 
	for (int i = e[x]; i; i = next[i]) if (!br[i] && c[v[i]] == 0) color(v[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	tot = 1;
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y);
		add(x, y); add(y, x);
		}
	DFS(1);
	for (int i = 1; i <= n; i++) if (c[i] == 0) now = i, color(i);
	for (int i = 1; i <= n; i++)
		for (int j = e[i]; j; j = next[j]) if (br[j] && c[i] != c[v[j]])
			++d[c[v[j]]];
	int ans = 0;
	for (int i = 1; i <= n; i++) if (d[i] == 1) ++ans;
	printf("%d\n", ans + 1 >> 1);
}
Problem1719

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define abs(a) (((a) > 0) ? (a) : (-(a)))
using namespace std;
const double eps = 1e-6;
double r;
int n, g;
bool map[1001][1001];
struct Tpoint{
	double x, y;
	double dis(Tpoint A)
	{
		return (A.x - x) * (A.x - x) + (A.y - y) * (A.y - y);
	}
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = A.x - x; temp.y = A.y - y; return temp;
	}
	double operator * (Tpoint A)
	{
		return (A.x * x + A.y * y);
	}
};
int make(int t)
{
	return ((t - 1) % n) + 1;
}
int dblcmp(double a)
{
	if (abs(a) < eps) return 0;
	if (a < 0) return -1;
	if (a > 0) return 1;
}
bool dis2(Tpoint A, Tpoint B, Tpoint C)
{
	double a = B.y - C.y, b = C.x- B.x, c = B.x * C.y - C.x * B.y;
	return dblcmp((a * A.x + b * A.y + c) * (a * A.x + b * A.y + c) - r * r * (a * a + b * b)) <= 0;
}
bool ok(Tpoint A, Tpoint B, Tpoint C)
{
	if ((dblcmp(A.dis(C) - r * r) <= 0) ||  (dblcmp(B.dis(C) - r * r) <= 0)) return true;
	if ((dblcmp(((A - C)*(A - B)) * ((B - C) * (B - A)))) >= 0 && dis2(C, A, B)) return true;
	return false;
}	
Tpoint c[1001], p[1001];
bool judge(Tpoint A, Tpoint B)
{
	for (int i = 1; i <= g; i++) if (ok(A, B, c[i])) return false;
	return true;
}
int f[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%lf", &n, &g, &r);
	for (int i = 1; i <= n; i++) scanf("%lf%lf", &p[i].x, &p[i].y);
	for (int i = 1; i <= g; i++) scanf("%lf%lf", &c[i].x, &c[i].y);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (i != j && (abs(i - j) != 1)) map[i][j] = judge(p[i], p[j]);
	map[1][n] = map[n][1] = false;
	for (int l = 2; l <= n - 1; l++)
		for (int i = 1; i <= n; i++){
			int j = l + i;
			for (int k = i + 1; k <= j - 1; k++)
				f[i][make(j)] = max(f[i][make(j)], f[i][make(k)] + f[make(k)][make(j)] + map[i][make(j)]);
			}
	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i][make(i + n - 1)]);
	printf("%d\n", ans);
}
Problem1720

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 2001;
int totx, toty, hx[MAXN], hy[MAXN];
int n, k;
int map[MAXN][MAXN], MAP[MAXN][MAXN];
struct Tpoint{
	int x, y;
	bool operator < (const Tpoint & A) const{
		return x == A.x ? y < A.y : x < A.x;
		}
	} p[MAXN];
int get(int x1, int y1, int x2, int y2)
{
	return MAP[x2][y2] - MAP[x1 - 1][y2] - MAP[x2][y1 - 1] + MAP[x1 - 1][y1 - 1];
} 
int getans(int x, int y)
{
	int l = 0, r = 10000;
	while(l <= r){
		int m = l + r >> 1, xx = hx[x] + m - 1, yy = hy[y] + m - 1;
		int nx = lower_bound(hx + 1, hx + totx + 1, xx) - hx; if (hx[nx] > xx) --nx;
		int ny = lower_bound(hy + 1, hy + toty + 1, yy) - hy; if (hy[ny] > yy) --ny;
		if (get(x, y, nx, ny) >= k) r = m - 1; else l = m + 1;
		}
	return l;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &k, &n);
	for (int i = 1; i <= n; i++){
		int x, y; scanf("%d%d", &x, &y);
		p[i].x = x; p[i].y = y; hx[i] = x; hy[i] = y;
		}
	sort(hx + 1, hx + n + 1); sort(hy + 1, hy + n + 1);
	totx = 1; for (int i = 2; i <= n; i++) if (hx[i] != hx[i - 1]) hx[++totx] = hx[i];
	toty = 1; for (int i = 2; i <= n; i++) if (hy[i] != hy[i - 1]) hy[++toty] = hy[i];
	for (int i = 1; i <= n; i++){
		p[i].x = lower_bound(hx + 1, hx + totx + 1, p[i].x) - hx;
		p[i].y = lower_bound(hy + 1, hy + toty + 1, p[i].y) - hy;
		}
	hx[totx + 1] = 1000000; hy[toty + 1] = 1000000;
	for (int i = 1; i <= n; i++) map[p[i].x][p[i].y]++;
	for (int i = 1; i <= totx; i++)
		for (int j = 1; j <= toty; j++)
			MAP[i][j] = MAP[i - 1][j] + MAP[i][j - 1] - MAP[i - 1][j - 1] + map[i][j];
	int ans = 0x3f3f3f3f;
	for (int i = 1; i <= totx; i++)
		for (int j = 1; j <= toty; j++)
			ans = min(getans(i, j), ans);
	printf("%d\n", ans);
}
Problem1721

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int f[10001], a[10001];
int n, k;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	f[1] = 1;
	for (int i = 2; i <= n; i++){
		double M = 1e99; f[i] = 0x3f3f3f3f;
		for (int j = i - 1; j >= i - k && j >= 1; j--){
			if ((double)(a[i] - a[j]) / (double)(i - j) <= M){
				f[i] = min(f[i], f[j] + 1);
				}
			M = min(M, (double)(a[i] - a[j]) / (double)(i - j));
			}
		}
	printf("%d\n", f[n]);
}
Problem1722

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, x, tot, e[100001], next[100001], v[100001];
int t[100001], f;
int dp[1001][1001][2];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void DP(int x)
{
	for (int i = e[x]; i; i = next[i]) 
		DP(v[i]);
	dp[x][0][0] = 0; dp[x][0][1] = 0;
	for (int i = e[x]; i; i = next[i])
		for (int j = n; j >= 0; j--)
			for (int k = 0; k <= j; k++)
				dp[x][j][0] = max(dp[x][j][0], max(dp[v[i]][k][0], dp[v[i]][k][1]) + dp[x][j - k][0]);
	for (int i = e[x]; i; i = next[i])
		for (int j = n; j >= 0; j--)
			for (int k = 0; k <= j; k++){
				dp[x][j][1] = max(dp[x][j][1], 
				max(dp[v[i]][k][0], dp[v[i]][k - 1][1]) + dp[x][j - k][1]);
				}
	for (int i = 0; i <= n; i++) dp[x][i][1] += t[x];
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);
	freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &x);
	for (int i = 1; i <= n; i++){
		int f; scanf("%d%d", &t[i], &f);
		add(f, i);
		}
	memset(dp, 0xe0, sizeof(dp));
	DP(0);
	for (int i = n; i >= 0; i--) if (dp[0][i][0] >= x){
		printf("%d\n", i); return 0;
		}
	puts("-1");
}
Problem1723

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
int ans[MAXN];
struct Tstack{
	int top, data[MAXN], cc[MAXN];
	int & operator [] (int k) {return data[k];}
	void clear()
	{
		top = 0;
	}
	bool empty()
	{
		return top == 0;
	}
	void push(int h, int c, int w)
	{
		while(!empty() && h > data[top]){
			ans[w] += cc[top]; --top;
			}
		++top; data[top] = h; cc[top] = c;
	}
} stack;
int n, a[MAXN], b[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i], &b[i]);
	for (int i = 1; i <= n; i++) stack.push(a[i], b[i], i);
	stack.clear();
	for (int i = n; i >= 1; i--) stack.push(a[i], b[i], i);
	int tans = 0;
	for (int i = 1; i <= n; i++) tans = max(ans[i], tans);
	printf("%d\n", tans);
}
Problem1724

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
struct Tnode{
	long long data;
	bool operator < (const Tnode & A) const
	{
		return data > A.data;
	}
};
priority_queue<Tnode> H;
int n;
long long a[100001];
long long ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); 
	for (int i = 1; i <= n; i++){
		Tnode temp; scanf("%d", &temp.data); H.push(temp);
		}
	for (int i = 1; i < n; i++){
		long long A = H.top().data; H.pop();
		long long B = H.top().data; H.pop();
		ans += A + B;
		Tnode temp; temp.data = A + B; H.push(temp);
		}
	printf("%lld\n", ans);
}
Problem1725

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
const int MO = 100000000;
map<int, int> last, now;
int n, m, s, num, h;
int a[1001][1001];
using namespace std;
void DFS(int depth, int NOW)
{
	if (depth == m){
		now[NOW] = (now[NOW] + num) % MO;
		return;
		} 
	DFS(depth + 1, NOW);
	if ((depth != 0 && ((NOW & (1 << (depth - 1))) > 0)) || ((s & (1 << depth)) > 0))
		return;
	if (a[h][depth + 1] == 0) return;
	DFS(depth + 1, NOW ^ (1 << depth));
}
	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	last.insert(make_pair(0, 1));
	for (h = 1; h <= n; h++){
		for (map<int,int>::iterator i = last.begin(); i != last.end(); i++){
			s = i->first; num = i->second;
			DFS(0, 0);
			}
		last = now; now.clear();
		}
	int ans = 0;
	for (map<int,int>::iterator i = last.begin(); i != last.end(); i++)
		ans = (ans + i->second) % MO;
	printf("%d\n", ans);
}
Problem1726

#include <cstdio>
#include <cstdlib>
#include <cstring>
int n, m, tot, e[1000001], v[1000001], w[1000001], next[1000001];
int dis[100001][2];
bool vis[100001][2];
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(x, y, z); add(y, x, z);
		}
	memset(dis, 0x3f, sizeof(dis));
	dis[1][0] = 0;
	for (int i = 1; i <= 2 * n; i++){
		int MIN = 0x3f3f3f3f, who, t;
		for (int i = 1; i <= n; i++)
			for (int j = 0; j <= 1; j++)
				if (!vis[i][j] && dis[i][j] < MIN){
					MIN = dis[i][j]; who = i; t = j;
					}
		vis[who][t] = true;
		for (int i = e[who]; i; i = next[i]){
			int len = dis[who][t] + w[i];
			if (len < dis[v[i]][0]){
				dis[v[i]][1] = dis[v[i]][0];
				dis[v[i]][0] = len;
				continue;
				}
			if (len == dis[v[i]][0]) continue;
			if (len < dis[v[i]][1]) dis[v[i]][1] = len;
			}
		}
	printf("%d\n", dis[n][1]);
} 
Problem1729

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXN = 100001, MAXS = 31;
int n, k, s, next[100001], ans[100001], tot;
struct string{
	int data[MAXN]; int len;
	int suml[MAXN][MAXS], sume[MAXN][MAXS];
	int & operator [] (int k) { return data[k]; }
	int gete(int l, int r, int num)
	{
		return sume[r][num] - sume[l - 1][num];
	}
	int getl(int l, int r, int num)
	{
		return suml[r][num] - suml[l - 1][num];
	}
	void init()
	{
		for (int i = 1; i <= len; i++){
			scanf("%d", &data[i]);
			for (int j = 1; j <= s; j++)
				sume[i][j] = sume[i - 1][j] + (data[i] == j);
			for (int j = 1; j <= s; j++) suml[i][j] = suml[i - 1][j] + (data[i] < j);
			}
	}
} A, B;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &k, &s);
	A.len = k; B.len = n; B.init(); A.init();
	next[1] = 0;
	int j = 0;
	for (int i = 2; i <= A.len; i++){
		while(j != 0 && ((A.gete(i - j, i, A[i]) != A.gete(1, 1 + j, A[j + 1])
					  || (A.getl(i - j, i, A[i]) != A.getl(1, 1 + j, A[j + 1]))))) j = next[j];
		if ((A.gete(i - j, i, A[i]) == A.gete(1, 1 + j, A[j + 1])
		 && (A.getl(i - j, i, A[i]) == A.getl(1, 1 + j, A[j + 1])))) ++j;
		next[i] = j;
		}
	j = 0;
	for (int i = 1; i <= B.len; i++){
		while(j != 0 && ((B.gete(i - j, i, B[i]) != A.gete(1, 1 + j, A[j + 1])
					  || (B.getl(i - j, i, B[i]) != A.getl(1, 1 + j, A[j + 1]))))) j = next[j];		
		if ((B.gete(i - j, i, B[i]) == A.gete(1, 1 + j, A[j + 1])
		 && (B.getl(i - j, i, B[i]) == A.getl(1, 1 + j, A[j + 1])))) ++j;
		if (j == A.len){
			++tot; ans[tot] = i - j + 1;
			j = next[j];
			}
		}
	printf("%d\n", tot);
	for (int i = 1; i <= tot; i++) printf("%d\n", ans[i]);
}
	
Problem1730

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using std::sort;
const int MAXN = 30000;
bool can[MAXN];
int who[MAXN * 4];
struct Tpoint{
	int x, y, ord;
	bool operator < (const Tpoint & A) const{
		return x == A.x ? y < A.y : x < A.x;
	}
	bool operator == (const Tpoint & A) const{
		return x == A.x && y == A.y;
	}	
};
struct Tpointsolve{
	Tpoint p[MAXN * 4]; int tot;
	Tpoint & operator [] (int k) {return p[k];}
	void solve()
	{
		sort(p + 1, p + tot + 1);
		for (int i = 2; i <= tot; i++)
			if (p[i] == p[i - 1]) 
				can[p[i].ord] = can[p[i - 1].ord] = false;
	}
} ps;
struct Tedge{
	int x, y1, y2, ord;
	bool operator < (const Tedge & A) const{
		return x == A.x ? y1 < A.y1 : x < A.x;
	}
};
struct Tedgesolve{
	int tot; Tedge edge[MAXN * 4];
	Tedge & operator [] (int k) {return edge[k];}
	void solve()
	{
		sort(edge + 1, edge + tot + 1);
		int i = 1;
		while(i < tot){
			int end = edge[i].y2, first = i, cnt = 0, xx = edge[i].x; ++i;
			while(i <= tot && edge[i].x == xx && edge[i].y1 <= end){
				if (edge[i].y2 > end) end = edge[i].y2;
				can[edge[i].ord] = false;
				++cnt; ++i;
				}
			if (cnt) can[edge[first].ord] = false;
			}
	}
} es1, es2;
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	memset(can, 1, sizeof(can));
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x1, y1, x2, y2; scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		ps.tot += 4; 
		ps[i * 4 - 3].x = x1; ps[i * 4 - 3].y = y1; ps[i * 4 - 3].ord = i;
		ps[i * 4 - 2].x = x2; ps[i * 4 - 2].y = y1; ps[i * 4 - 2].ord = i; 
		ps[i * 4 - 1].x = x1; ps[i * 4 - 1].y = y2; ps[i * 4 - 1].ord = i;
		ps[i * 4 - 0].x = x2; ps[i * 4 - 0].y = y2; ps[i * 4 - 0].ord = i;
		es1.tot += 2;
		es1[i * 2 - 1].x = x1; es1[i * 2 - 1].y1 = y1; es1[i * 2 - 1].y2 = y2; es1[i * 2 - 1].ord = i;
		es1[i * 2 - 0].x = x2; es1[i * 2 - 0].y1 = y1; es1[i * 2 - 0].y2 = y2; es1[i * 2 - 0].ord = i;
		es2.tot += 2;
		es2[i * 2 - 1].x = y1; es2[i * 2 - 1].y1 = x1; es2[i * 2 - 1].y2 = x2; es2[i * 2 - 1].ord = i;
		es2[i * 2 - 0].x = y2; es2[i * 2 - 0].y1 = x1; es2[i * 2 - 0].y2 = x2; es2[i * 2 - 0].ord = i;
		}
	ps.solve();
	es1.solve(); 
	es2.solve();
	int ans = 0;
	for (int i = 1; i <= n; i++) if (can[i]) ++ans;
	printf("%d\n", ans);
}
		
Problem1731

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int SIZE = 1023, MAXN = 100001, MAXM = 500001;
int tot, e[MAXN], next[MAXM], v[MAXM], w[MAXM];
int n, A, B, dis[MAXN], time[MAXN];
int q[MAXN];
bool vis[MAXN];
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &A, &B);
	for (int i = 1; i <= A; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(x, y, z);
		}
	for (int i = 1; i <= B; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(y, x, -z);
		}
	memset(dis, 0x3f, sizeof(dis));
	int l = 0, r = 1; q[1] = 1; dis[1] = 0; vis[1] = true; time[1] = 1;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
		for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i]){
			dis[v[i]] = dis[x] + w[i];
			if (!vis[v[i]]){ 
				vis[v[i]] = true; r = (r + 1) & SIZE; q[r] = v[i];
				if (++time[v[i]] > n) { puts("-1"); return 0; }
				} 
			}
		}
	if (dis[n] == 0x3f3f3f3f) puts("-2"); else printf("%d\n", dis[n]);
}
Problem1733

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1001, MAXM = 100001, INF = 0x3f3f3f3f;
struct Tedge{
	int st, ed, len;
	bool operator < (const Tedge & A) const{
		return len < A.len;
		}
	} edge[MAXM];
int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM], h[MAXN], vh[MAXN];
int n, m, S, T, TT;
int flow = 0;
void add(int a, int b, int C)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = C;
}
int aug(int x, int f)
{
	int augc = f, minh = T - 1;
	if (x == T) return f;
	for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
		if (h[x] == h[v[i]] + 1){
			int t = aug(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0 || h[S] == T) return augc - f;
			}
		minh = min(h[v[i]], minh);
		}
	if (f == augc){
		--vh[h[x]]; if (vh[h[x]] == 0) h[S] = T;
		h[x] = minh + 1; ++vh[h[x]];
		}
	return augc - f;
}
int maxflow()
{
	memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
	vh[0] = T;
	while(h[S] < T) flow += aug(S, INF);
	return flow;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &TT);
	for (int i = 1; i <= m; i++) scanf("%d%d%d", &edge[i].st, &edge[i].ed, &edge[i].len);
	sort(edge + 1, edge + m + 1);
	S = 1; T = n; tot = 1;
	for (int now = 1; now <= m; now++){
		int k = now;
		while(edge[k].len == edge[now].len){
			add(edge[k].st, edge[k].ed, 1);
			add(edge[k].ed, edge[k].st, 1);
			++k;
			}
		if (maxflow() >= TT){
			printf("%d\n", edge[now].len); return 0;
			}
		now = k - 1;
		}
	puts("ERROR WHILE F**KING");
}
Problem1734

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, r, a[1000001];
bool ok(int t)
{
	int now = 2, last = 1, s = 2;
	while(now <= n){
		if (a[now] - a[last] >= t){
			++s; last = now; now = now + 1;
			if (s > r)
				return true;
			}
		else ++now;
		}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &r); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	int l = 0, r = 2100000000;
	while (l <= r){
		int m = l + r >> 1;
		if (ok(m)) l = m + 1; else r = m - 1;
		}
	printf("%d\n", r);
}
Problem1735

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 101, MAXINF = 5001;
struct Tinf{
	int h, st, ed;
	bool operator == (Tinf t)
	{
		return t.st <= h && t.ed >= h && st <= t.h && ed >= t.h;
	} 
	}infx[MAXINF], infy[MAXINF];
char in[MAXN][MAXN];
int n, m;
int totx, toty, link[MAXINF];
bool map[MAXINF][MAXINF], vis[MAXINF];;
void makex(int h, int now)
{
	if (now > m) return;
	if (in[h][now] == '.'){
		makex(h, now + 1); return;
		}
	int t = now; while(in[h][t + 1] == '*') ++t;
	++totx; infx[totx].h = h; infx[totx].st = now; infx[totx].ed = t;
	makex(h, t + 1);
} 
void makey(int h, int now)
{
	if (now > n) return;
	if (in[now][h] == '.'){
		makey(h, now + 1); return;
		}	
	int t = now; while(in[t + 1][h] == '*') ++t;
	++toty; infy[toty].h = h; infy[toty].st = now; infy[toty].ed = t;
	makey(h, t + 1);
} 
bool find(int v)
{
	for (int i = 1; i <= toty; i++) if (map[v][i] && !vis[i]){
		vis[i] = true;
		if (link[i] == 0 || find(link[i])){
			link[i] = v; return true;
			}
		}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%s", in[i] + 1);
	for (int i = 1; i <= n; i++) makex(i, 1);
	for (int i = 1; i <= m; i++) makey(i, 1);
	for (int i = 1; i <= totx; i++)
		for (int j = 1; j <= toty; j++)
			map[i][j] = (infx[i] == infy[j]);
	int ans = 0;
	for (int i = 1; i <= totx; i++){
		memset(vis, 0, toty << 2);
		if (find(i)) ++ans;
		}
	printf("%d\n", ans);
}
Problem1736

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 501;
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, -1, 1};
long long ans;
bool vis[MAXN][MAXN];
int n, m, a[MAXN][MAXN], h[MAXN][MAXN]; 
struct Theapnode{
	int x, y, h;
	bool operator < (const Theapnode & A) const
	{
		return h < A.h;
	}
};
struct Theap{
	int size;
	Theapnode data[MAXN * MAXN];
	Theapnode & operator [] (int k) { return data[k]; }
	bool empty() { return size == 0; }
	void push(int x, int y, int h)
	{
		++size; data[size].x = x; data[size].y = y; data[size].h = h;
		int i = size;
		while(i != 1){
			if (data[i] < data[i >> 1]) swap(data[i >> 1], data[i]); else break;
			i >>= 1;
			}
	}
	Theapnode pop()
	{
		Theapnode temp = data[1];
		swap(data[1], data[size]); --size;
		int i = 2;
		while(i <= size){
			if (i < size && data[i + 1] < data[i]) ++i;
			if (data[i] < data[i >> 1]) swap(data[i >> 1], data[i]); else break;
			i <<= 1;
			}
		return temp;
	} 
}H;
void floodfill(int x, int y, int hh) 
{
	vis[x][y] = true;
	if (a[x][y] > hh){
		h[x][y] = a[x][y];
		H.push(x, y, h[x][y]);
		}
	if (a[x][y] <= hh){
		ans += hh - a[x][y];
		for (int i = 0; i < 4; i++) if (!vis[x + dx[i]][y + dy[i]])
			floodfill(x + dx[i], y + dy[i], hh);
		}
}
int main()
{
	scanf("%d%d", &m, &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	for (int i = 0; i <= n + 1; i++) vis[i][0] = vis[i][m + 1] = true;
	for (int i = 0; i <= m + 1; i++) vis[0][i] = vis[n + 1][i] = true;
	for (int i = 1; i <= n; i++){
		h[i][1] = a[i][1]; H.push(i, 1, h[i][1]);
		h[i][m] = a[i][m]; H.push(i, m, h[i][m]);
		vis[i][1] = vis[i][m] = true;
		}
	for (int i = 2; i <= m - 1; i++){
		h[1][i] = a[1][i]; H.push(1, i, h[1][i]);
		h[n][i] = a[n][i]; H.push(n, i, h[n][i]);
		vis[1][i] = vis[n][i] = true;
		}
	while(!H.empty()){
		Theapnode now = H.pop();
		floodfill(now.x, now.y, now.h);
		}
	printf("%lld\n", ans);	
}
Problem1737

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, b, a[5001], f[4001][2], g[4001][2];
int ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &b);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	memset(g, 0xe0, sizeof(g));
	g[0][0] = 0; g[1][1] = 0;
	for (int i = 2; i <= n; i++){
		memset(f, 0xe0, sizeof(f));
		f[0][0] = 0;
		for (int j = 1; j <= min(b, i); j++){
			f[j][0] = max(g[j][0], g[j][1]);
			f[j][1] = max(g[j - 1][0], g[j - 1][1] + a[i]);
			}
		memcpy(g, f, sizeof(g));
		}
	ans = max(f[b][0], f[b][1]);
	memset(g, 0xe0, sizeof(g));
	g[1][1] = a[1]; g[0][0] = 0;
	for (int i = 2; i <= n; i++){
		memset(f, 0xe0, sizeof(f));
		f[0][0] = 0;
		for (int j = 1; j <= min(b, i); j++){
			f[j][0] = max(g[j][0], g[j][1]);
			f[j][1] = max(g[j - 1][0], g[j - 1][1] + a[i]);
			}
		memcpy(g, f, sizeof(g));
		}
	ans = max(ans, f[b][1]);
	printf("%d\n", ans);
}
	
Problem1738

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
const int MAXN = 1001, MAXM = 500001, INF = 0x3f3f3f3f;
const ll INFL = 0x3f3f3f3f3f3f3f3fll;
using namespace std;
struct Tedge{
	int st, ed;
	ll len;
	bool operator < (const Tedge & A) const{
		return len < A.len;
		}
} edge[MAXM];
int edget;
int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM];
int S, T, n, m, flow = 0;
int h[MAXN], vh[MAXN];
ll map[MAXN][MAXN];
void add(int x, int y, int z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; c[tot] = z;
}
int aug(int x, int f)
{
	if (x == T) return f;
	int augc = f, minh = T - 1;
	for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
		if (h[x] == h[v[i]] + 1){
			int t = aug(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (h[S] == T || f == 0) return augc - f;
			}
		minh = min(minh, h[v[i]]);
		}
	if (f == augc){
		--vh[h[x]]; if (vh[h[x]] == 0) h[S] = T;
		h[x] = minh + 1; ++vh[h[x]];
		}
	return augc - f;
} 
int maxflow()
{
	memset(vh, 0, sizeof(vh));
	memset(h, 0, sizeof(h));
	vh[0] = T;
	while(h[S] < T)
		flow += aug(S, INF);
	return flow;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	S = n * 2 + 1; T = S + 1; tot = 1;
	int sum = 0, Tsum = 0, num;
	for (int i = 1; i <= n; i++){
		scanf("%d", &num); add(S, i, num); add(i, S, 0);
		sum += num; Tsum += num;
		scanf("%d", &num); add(i + n, T, num); add(T, i + n, 0);
		sum -= num;
		}
	for (int i = 1; i <= n; i++){
		add(i, i + n, INF); add(i + n, i, 0);
		}
	memset(map, 0x3f, sizeof(map));
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		map[x][y] = min(map[x][y], (ll)(z)); map[y][x] = map[x][y];
		}
	for (int k = 1; k <= n; k++)
		for (int i = 1; i <= n; i++) if (k != i && map[i][k] != INFL)
			for (int j = 1; j <= n; j++) if (i != j && k != j && map[k][j] != INFL)
				if (map[i][k] + map[k][j] < map[i][j])
					map[i][j] = map[j][i] = map[i][k] + map[k][j];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) if (i != j && map[i][j] != INFL){
			++edget; edge[edget].st = i; edge[edget].ed = j;
			edge[edget].len = map[i][j];
			}
	if (maxflow() == Tsum){
			printf("%d\n", 0);
			return 0;
			}
	sort(edge + 1, edge + edget + 1);
	for (int i = 1; i <= edget; i++){
		if (i == edget - 1){
			int a;
			++a;
			}
		int now = i;
		while(edge[i].len == edge[now].len){
			add(edge[now].st, edge[now].ed + n, INF);
			add(edge[now].ed + n, edge[now].st, 0);
			++now;
			}
		if (maxflow() == Tsum){
			printf("%lld\n", edge[i].len);
			return 0;
			}
		i = now - 1;
		}
	puts("-1");
}
Problem1739

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Tinf{
	int h, num, mh;
	bool operator < (const Tinf & A) const{
		if (mh == A.mh) return h * num > A.h * A.num; else return mh < A.mh;
		}
} inf[1001];
int n;
bool f[401][40001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d%d", &inf[i].h, &inf[i].mh, &inf[i].num);
	sort(inf + 1, inf + n + 1);
	f[0][0] = true;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= inf[i].mh; j++)
			for (int k = 0; k <= inf[i].num; k++) if (k * inf[i].h <= j)
				f[i][j] |= f[i - 1][j - k * inf[i].h];
	for (int i = 40000; i; i--) if (f[n][i]){
		printf("%d\n", i); return 0;
		}
	puts("0");
}
Problem1740

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, s, c[100001], y[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &s);
	int MIN = 0x3f3f3f3f; long long ans = 0;
	for (int i = 1; i <= n; i++) scanf("%d%d", &c[i], &y[i]);
	for (int i = 1; i <= n; i++){
		MIN = min(c[i] - s * i, MIN);
		ans += (long long)y[i] * (long long)(s * i + MIN);
		}
	printf("%lld\n", ans);
}
Problem1741

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int tot, e[1001], next[200001], v[200001];
int n, m, mx[1001], my[1001], dx[1001], dy[1001];
int q[200001];
void add(int x, int y)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y;
}
bool BFS()
{
	int l = 1, r = 0; bool ok = false;
	memset(dx, 0, sizeof(dx)); memset(dy, 0, sizeof(dy));
	for (int i = 1; i <= n; i++) if (mx[i] == 0) q[++r] = i;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (dy[v[i]] == 0){
			dy[v[i]] = dx[x] + 1;
			if (my[v[i]] == 0) ok = true; else dx[q[++r] = my[v[i]]] = dx[x] + 2;
			}
		}
	return ok;
}
bool DFS(int x)
{
	for (int i = e[x]; i; i = next[i]) if (dx[x] + 1== dy[v[i]]){
		dy[v[i]] = 0;
		if (my[v[i]] == 0 || DFS(my[v[i]])){
			my[v[i]] = x; mx[x] = v[i]; return true;
			}
		}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); add(x, y);
		}
	int ans = 0;
	while(BFS())
		for (int i = 1; i <= n; i++) if (mx[i] == 0 && DFS(i)) ++ans;
	printf("%d\n", ans);
}
Problem1742

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, start, a[10001], f[1002][1002][2];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &start);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]); a[++n] = start;
	sort(a + 1, a + n + 1);
	int t = lower_bound(a + 1, a + n + 1, start) - a;
	memset(f, 0x3f, sizeof(f));	f[t][t][0] = f[t][t][1] = 0;
	for (int l = 2; l <= n; l++)
		for (int i = 1; i <= n; i++) if (i + l - 1 <= n){
			int j = i + l - 1;
			f[i][j][0] = min(f[i + 1][j][0] + (n - (j - i + 1) + 1) * (a[i + 1] - a[i]), 
							 f[i + 1][j][1] + (n - (j - i + 1) + 1) * (a[j] - a[i]));
			f[i][j][1] = min(f[i][j - 1][0] + (n - (j - i + 1) + 1) * (a[j] - a[i]),
							 f[i][j - 1][1] + (n - (j - i + 1) + 1) * (a[j] - a[j - 1]));
			}
	printf("%d\n", min(f[1][n][0], f[1][n][1]));
}
Problem1744

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};
const int SIZE = 262144 - 1;
int a[201][201], n, m, v, l, r;
bool vis[201][201];
double dis[201][201], time[10001];
struct Tqueue{
	int x, y;
	} q[SIZE + 1000];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &v, &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	time[100] = 1.0; for (int i = 1; i <= 100; i++) time[i + 100] = time[i + 99] * 2.0;
	for (int i = -1; i >= -100; i--) time[i + 100] = time[i + 101] * 0.5;
	memset(dis, 0x7f, sizeof(dis)); dis[1][1] = 0;
	l = 0; r = 1;
	vis[1][1] = true; q[1].x = 1; q[1].y = 1; dis[1][1] = 0;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l].x, y = q[l].y; vis[x][y] = false;
		for (int i = 0; i < 4; i++){
			int nx = x + dx[i], ny = y + dy[i];
			if (nx > 0 && nx <= n && ny > 0 && ny <= m && dis[nx][ny] > dis[x][y] + time[a[x][y] - a[1][1] + 100]){
				dis[nx][ny] = dis[x][y] + time[a[x][y] - a[1][1] + 100];
				if (!vis[nx][ny]){
					r = (r + 1) & SIZE; q[r].x = nx; q[r].y = ny; vis[nx][ny] = true;
					}
				}
			}
		}
	printf("%.2lf\n", double(dis[n][m]) / (double(v)));
}
Problem1744

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};
const int SIZE = 262144 - 1;
int a[201][201], n, m, v, l, r;
bool vis[201][201];
double dis[201][201], time[10001];
struct Tqueue{
	int x, y;
	} q[SIZE + 1000];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &v, &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	time[100] = 1.0; for (int i = 1; i <= 100; i++) time[i + 100] = time[i + 99] * 2.0;
	for (int i = -1; i >= -100; i--) time[i + 100] = time[i + 101] * 0.5;
	memset(dis, 0x7f, sizeof(dis)); dis[1][1] = 0;
	l = 0; r = 1;
	vis[1][1] = true; q[1].x = 1; q[1].y = 1; dis[1][1] = 0;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l].x, y = q[l].y; vis[x][y] = false;
		for (int i = 0; i < 4; i++){
			int nx = x + dx[i], ny = y + dy[i];
			if (nx > 0 && nx <= n && ny > 0 && ny <= m && dis[nx][ny] > dis[x][y] + time[a[x][y] - a[1][1] + 100]){
				dis[nx][ny] = dis[x][y] + time[a[x][y] - a[1][1] + 100];
				if (!vis[nx][ny]){
					r = (r + 1) & SIZE; q[r].x = nx; q[r].y = ny; vis[nx][ny] = true;
					}
				}
			}
		}
	printf("%.2f\n", double(dis[n][m]) / (double(v)));
}
Problem1744

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};
const int SIZE = 262144 - 1;
int a[201][201], n, m, v, l, r;
bool vis[201][201];
double dis[201][201], time[10001];
struct Tqueue{
	int x, y;
	} q[SIZE + 1000];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &v, &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	time[100] = 1.0; for (int i = 1; i <= 100; i++) time[i + 100] = time[i + 99] * 2.0;
	for (int i = -1; i >= -100; i--) time[i + 100] = time[i + 101] * 0.5;
	memset(dis, 0x7f, sizeof(dis)); dis[1][1] = 0;
	l = 0; r = 1;
	vis[1][1] = true; q[1].x = 1; q[1].y = 1; dis[1][1] = 0;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l].x, y = q[l].y; vis[x][y] = false;
		for (int i = 0; i < 4; i++){
			int nx = x + dx[i], ny = y + dy[i];
			if (nx > 0 && nx <= n && ny > 0 && ny <= m && dis[nx][ny] > dis[x][y] + time[a[x][y] - a[1][1] + 100]){
				dis[nx][ny] = dis[x][y] + time[a[x][y] - a[1][1] + 100];
				if (!vis[nx][ny]){
					r = (r + 1) & SIZE; q[r].x = nx; q[r].y = ny; vis[nx][ny] = true;
					}
				}
			}
		}
	printf("%.2lf", double(dis[n][m]) / (double(v)));
}
Problem1745

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using std::sort;
const int MAXN = 1000001;
struct Tdata{
	int st, ed, num;
	bool operator < (const Tdata & A) const{
		return ed < A.ed;
		}
	} data1[MAXN], data2[MAXN];
int max[MAXN], _add[MAXN];
int n, k, c, tot1, tot2;
void add(int idx, int delta)
{
	_add[idx] += delta; max[idx] += delta;
}
void push(int idx)
{
	if (_add[idx] != 0){
		add(idx * 2, _add[idx]); add(idx * 2 + 1, _add[idx]);
		_add[idx] = 0;
		} 
}
void update(int idx)
{
	max[idx] = max[idx * 2] > max[idx * 2 + 1] ? max[idx * 2] : max[idx *  2 + 1];
}
void insert(int idx, int l, int r, int ll, int rr, int delta)
{
	if (ll <= l && rr >= r){
		add(idx, delta); return;
		}
	push(idx);
	int m = l + r >> 1;
	if (ll < m) insert(idx * 2, l, m, ll, rr, delta);
	if (rr > m) insert(idx * 2 + 1, m, r, ll, rr, delta);
	update(idx);
}
int getmax(int idx, int l, int r, int ll, int rr)
{
	if (ll <= l && rr >= r)
		return max[idx];
	int m = l + r >> 1, ret = 0;
	push(idx);
#define gmax(a, b) a = a > b ? a : b;
	if (ll < m){
		int t = getmax(idx * 2, l, m, ll, rr);
		gmax(ret, t);
		}
	if (rr > m){
		int t = getmax(idx * 2 + 1, m, r, ll, rr);
		gmax(ret, t);
		}
	return ret;
#undef gmax
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &k, &n, &c);
	for (int i = 1; i <= k; i++){
		int st, ed, num;
		scanf("%d%d%d", &st, &ed, &num);
		if (st < ed){
			++tot1; data1[tot1].st = st; data1[tot1].ed = ed; data1[tot1].num = num;
			}
		else{
			++tot2; data2[tot2].st = ed; data2[tot2].ed = st; data2[tot2].num = num;
			}
		}
	sort(data1 + 1, data1 + tot1 + 1); sort(data2 + 1, data2 + tot2 + 1);
	int ans = 0;
	for (int i = 1; i <= tot1; i++){
		int t = getmax(1, 1, n, data1[i].st, data1[i].ed);
		int tt = c - t < data1[i].num ? c - t : data1[i].num;
		ans += tt; if (tt != 0) insert(1, 1, n, data1[i].st, data1[i].ed, tt);
		}
	memset(max, 0, sizeof(max)); memset(_add, 0, sizeof(_add));
	for (int i = 1; i <= tot2; i++){
		int t = getmax(1, 1, n, data2[i].st, data2[i].ed);
		int tt = c - t < data2[i].num ? c - t : data2[i].num;
		ans += tt; if (tt != 0) insert(1, 1, n, data2[i].st, data2[i].ed, tt);
		}
	printf("%d\n", ans);	
}			
Problem1746

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define all (min(f[i - 1][j - 1][0], min(f[i - 1][j - 1][1], f[i - 1][j - 1][2])))
#define all2 (min(f[i - 1][j - 2][0], min(f[i - 1][j - 2][1], f[i - 1][j - 2][2])))
#define onlyt (min(f[i - 1][j][0], f[i - 1][j][2]))
using namespace std;
const int MAXN = 10001;
struct Tcow{
	int x, y;
	bool operator < (const Tcow & A) const{
		return y < A.y;
		}
	} cow[MAXN];
int n, k, b;
int f[1001][1001][3];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	memset(f, 0x3f, sizeof(f));
	scanf("%d%d%d", &n, &k, &b);
	for (int i = 1; i <= n; i++) scanf("%d%d", &cow[i].x, &cow[i].y);
	sort(cow + 1, cow + n + 1);
	f[0][0][0] = 0;
	for (int i = 1; i <= n; i++) 
	for (int j = 1; j <= k; j++) 
	for (int l = 0; l < 3; l++){
	switch(l){
		case 0:
			if (cow[i].y == cow[i - 1].y){
				f[i][j][l] = 0x3f3f3f3f; break;
				}
			f[i][j][l] = all + 1;
			if (cow[i].x == cow[i - 1].x) f[i][j][l] = min(f[i][j][l], onlyt + cow[i].y - cow[i - 1].y);
			else f[i][j][l] = min(f[i][j][l], f[i - 1][j][2] + cow[i].y - cow[i - 1].y);
			break;
		case 1:
			f[i][j][l] = all + 2;
			f[i][j][l] = min(f[i][j][l], f[i - 1][j][l] + 2 * (cow[i].y - cow[i - 1].y));
			break;
		case 2:
			f[i][j][l] = 0x3f3f3f3f;
			if (j > 2) f[i][j][l] = min(f[i][j][l], all2 + 2);
			f[i][j][l] = min(f[i][j][l], f[i - 1][j][l] + 2 * (cow[i].y - cow[i - 1].y));
			if (i > 1) f[i][j][l] = min(f[i][j][l], f[i - 1][j - 1][0]+ cow[i].y - cow[i - 1].y + 1);
			}
	}
	printf("%d\n", min(f[n][k][0], min(f[n][k][1], f[n][k][2])));
}
Problem1747

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int dis, nowo, n, h[100001], size;
struct Tdata{
	int d, o;
	bool operator < (const Tdata & A) const{
		return d > A.d;
		}
	} data[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &data[i].d, &data[i].o);
	sort(data + 1, data + n + 1);
	scanf("%d%d", &dis, &nowo);
	int ans = 0;
	data[n + 1].d = 0;
	for (int i = 1; i <= n + 1; i++){
		if (nowo >= dis - data[i].d){
			h[++size] = data[i].o; push_heap(h + 1, h + size + 1);
			continue;
			}
		while(nowo < dis - data[i].d){
			if (size == 0){
				puts("-1"); return 0;
				}
			nowo += h[1]; pop_heap(h + 1, h + size + 1); --size; ++ans;
			}
		h[++size] = data[i].o; push_heap(h + 1, h + size + 1);
		}
	printf("%d\n", ans);
}
		
Problem1748

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 100001, MAXM = 500001;
struct Tqueue{
	int w, q;
	} Q[MAXN];
int tot, e[MAXN], next[MAXM], v[MAXM];
int dis[MAXN][10];
bool vis[MAXN][10];
int pos[MAXN], n, m, l, r, fst, rfst;
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
int dir (int a)
{
    if (a >= rfst) a -= 360;
    if (a < fst) return 0;
    else return 1;
}
int reverse (int a, int b)
{
    if (a > b) b += 360;
    if (b - a > 180) return 1;
    else return 0;
}
int cround (int a, int b)
{
	a = pos[a]; b = pos[b];
    int r = reverse(a, b);
    if (r == 0)
    {
        if (dir(a) == 0 && dir(b) == 1) return 1;
        else return 0;
    }
    else
    {
        if (dir(a) == 1 && dir(b) == 0) return -1;
        else return 0;
    }
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &pos[i]);
	fst = pos[1]; rfst = (fst + 180) % 360;
	for (int i = 1; i <= m; i++){
		int x, y;
		scanf("%d%d", &x, &y);
		add(x, y); add(y, x);
		}
	l = 1; r = 1; vis[1][3] = true; Q[1].w = 1; Q[1].q = 0;
	memset(dis, 0x3f, sizeof(dis)); dis[1][3] = 0;
	while(l <= r){
		Tqueue x = Q[l++]; int w = x.w, q = x.q, t = q;
		if (t > 3) t = 3; if (t < -3) t = -3;
		for (int i = e[w]; i; i = next[i]){
			int delta = cround(w, v[i]);
			int newt = q + delta, neww = v[i], newq = newt;
			if (newq > 3) newq = 3;
			if (newq < -3) newq = -3;
			if (!vis[neww][newq + 3]){
				vis[neww][newq + 3] = true;
				++r; Q[r].q = newt; Q[r].w = neww;
				dis[neww][newq + 3] = dis[w][t + 3] + 1;
				}
			}
		}
	if (!vis[1][0] && !vis[1][1] && !vis[1][2] && !vis[1][4] && !vis[1][5] && !vis[1][6]) puts("-1");
	else printf("%d\n", min(dis[1][0], min(dis[1][1], min(dis[1][2], min(dis[1][4], min(dis[1][5], dis[1][6]))))));
}
Problem1753

#include <iostream>
#include <algorithm>
using namespace std;
int n, a[1000001];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	cout << a[1 + n >> 1] << endl;
}
Problem1756

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXN = 2000000;
struct Tnode{
    int l, r, m, s;
    } tr[MAXN];
int n, m, a[MAXN];
char c;
inline int getint()
{
    static int t;
    static bool tt;
    tt = false;
    t = 0;
    c = getchar();
    while (c != '\n' && c != ' '){
        if (c == '-'){
            tt = true;
            c = getchar();
            continue;
            }
        t = t * 10 + c - '0';
        c = getchar();
        }
    if (tt) t = -t;
    return t;
}
inline void putint(int t)
{
    static char ch[10], *P;
    P = ch;
    if (t < 0) {
        putchar('-');
        t = -t;
        }
    ch[0] = 0;
    while (t > 0){
        *(P++) = t % 10 + '0';
        t /= 10;
        }
    do {
        putchar(*(--P));
        } while (P != ch);
    putchar('\n');
}
inline int max(int a, int b)
{
    return a > b ? a : b;
}
void update(int v)
{
    tr[v].l = max(tr[v << 1].s + tr[(v << 1) + 1].l, tr[v << 1].l);
    tr[v].r = max(tr[(v << 1) + 1].s + tr[v << 1].r, tr[(v << 1) + 1].r);
    tr[v].m = max(tr[v << 1].m, tr[(v << 1) + 1].m);
    tr[v].m = max(tr[v].m, tr[v << 1].r + tr[(v << 1) + 1].l);
    tr[v].s = tr[v << 1].s + tr[(v << 1) + 1].s;
}
void build(int v, int l, int r){
    if (l == r){
        tr[v].s = a[l];
        tr[v].m = a[l];
        tr[v].l = a[l];
        tr[v].r = a[l];
        return;
        }
    build(v << 1, l, (l + r) >> 1);
    build((v << 1) + 1, ((l + r) >> 1) + 1, r);
    update(v);
    }
void cha(int v, int l, int r, int w, int num)
{
    if (l == r){
        tr[v].s = num;
        tr[v].m = num;
        tr[v].l = num;
        tr[v].r = num;
        return;
        }
    if (((l + r) >> 1) >= w)
        cha(v << 1, l, (l + r) >> 1, w, num);
    else
        cha((v << 1) + 1, ((l + r) >> 1) +1, r, w, num);
    update(v);
}
Tnode/**/ que(int v, int l, int r, int ll, int rr)
{
    if (ll <= l && rr >= r)
        return tr[v];
    if (rr <= ((l + r) >> 1))
        return que(v << 1, l, (l + r) >> 1, ll, rr);
    else if (ll > ((l + r) >> 1)) return que((v << 1) + 1, (((l + r) >> 1)+ 1), r, ll, rr);
            else {
                Tnode t1, t2, t;
                t1 = que(v << 1, l, (l + r) >> 1, ll, rr);
                t2 = que((v << 1) + 1, (((l + r) >> 1) + 1), r, ll, rr);
                t.l = max(t1.l, t1.s + t2.l);
                t.r = max(t2.r, t2.s + t1.r);
                t.s = t1.s + t2.s;
                t.m = max(t1.m, t2.m);
                t.m = max(t.m, t1.r + t2.l);
                return t;
                }
}
int main()
{
    n = getint(); m = getint();
    for (int i = 1; i <= n; i++) a[i] = getint();
    build(1, 1, n);
    for (int i = 1; i <= m; i++){
        int x, l, r, t, nn;
        x = getint();
        if (x == 1){
            l = getint(); r = getint();
            if (l > r){
                int t = l; l = r; r = t;
                }
            putint(que(1, 1, n, l, r).m);
            }
        else {
            t = getint(); nn = getint();
            cha(1, 1, n, t, nn);
            }
        }
}
Problem1758

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 200001, INF = 0x3f3f3f3f;
const double inf = 1e99, eps = 1e-4;
double ans;
int tot, next[MAXN * 2], e[MAXN], v[MAXN * 2], w[MAXN * 2];
int f[MAXN], l, r, q[MAXN], size[MAXN], ms[MAXN];
double buf[MAXN * 4], *sp[MAXN];
bool del[MAXN];
double sum[MAXN], nmsum[MAXN];
int len[MAXN], list[MAXN], deep[MAXN];
int n, I, A, maxc, num;
bool cmp(int a, int b) { return len[a] < len[b]; }
struct Tqueue{
	int who[MAXN];
	int l, r;
	void cl() { l = 1; r = 0; }
	bool emp() { return l > r; }
	void push(int w) { while(l <= r && nmsum[w] >= nmsum[who[r]]) --r; ++r; who[r] = w;}
  	void pop() { ++l; }
	int head() { return who[l]; }
} mQ;
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int find_heavy(int x)
{
	f[x] = 0; l = 1; r = 1; q[1] = x;
	while(l <= r){
		int nx = q[l++];
		for (int i = e[nx]; i; i = next[i]) if (v[i] != f[nx] && !del[v[i]]) q[++r] = v[i], f[v[i]] = nx;
		}
	for (int i = r; i >= 1; i--){
		size[q[i]] = 1;
		ms[q[i]] = 0;
		for (int j = e[q[i]]; j; j = next[j]) if (f[q[i]] != v[j] && !del[v[j]])  { size[q[i]] += size[v[j]]; ms[q[i]] = max(ms[q[i]], size[v[j]]); }
		ms[q[i]] = max(ms[q[i]], r - 1 - size[q[i]]);
		}
	int w = q[1];
	for (int i = 2; i <= r; i++) if (ms[q[i]] < ms[w]) w = q[i];
	return w;
}
bool check(double k) //a chain sum > 0
{
	int nl = 0; double ret = -inf;
	for (int i = 1; i <= num; i++){
		int x = list[i];
		if (nl + len[x] >= I){
			mQ.cl(); int now = -1;
			for (int i = len[x]; i >= 1; i--){
				while(now < nl && now + 1 + i <= A)  { mQ.push(now + 1); ++now; }
				while(mQ.head() + i < I) mQ.pop();
				if (!mQ.emp()) ret = max(ret, nmsum[mQ.head()] + sp[x][i] - k * i);
				}
			}
		for (int i = 1; i <= len[x]; i++) nmsum[i] = i > nl ? sp[x][i] - k * i : max(nmsum[i], sp[x][i] - k * i);
		nl = len[x];
		}
	//cerr << k << " " << ret << endl;
	return ret >= 0;
}
void doit(int x)
{
	x = find_heavy(x); if (r == 1) return;
	num = 0; int tot = 0; del[x] = true; f[x] = 0;
	for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]){
		sp[v[i]] = buf +(++tot); ++tot;
		++num; list[num] = v[i]; f[v[i]] = 0; deep[v[i]] = 1; sum[v[i]] = sp[v[i]][1] = w[i]; len[v[i]] = 1;
		l = 1; r = 1; q[1] = v[i];
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]){
				q[++r] = v[i]; f[v[i]] = x; deep[v[i]] = deep[x] + 1; sum[v[i]] = sum[x] + w[i];
				if (deep[v[i]] > len[list[num]])  { len[list[num]] = deep[v[i]]; ++tot; buf[tot] = -inf; }
				sp[list[num]][deep[v[i]]] = max(sp[list[num]][deep[v[i]]], sum[v[i]]);
				}
			}
		}
	sort(list + 1, list + num + 1, cmp);
	double l = 0, r = maxc;
	while(r - l > eps){
		double m = (l + r) / 2;
		if (check(m)) l = m; else r = m;
		}
	ans = max(ans, l);
	for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]) doit(v[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("rebuild.in", "r", stdin); freopen("rebuild.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &I, &A);
	ans = -inf;
	for (int i = 1; i < n; i++) {
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
		maxc = max(maxc, c);
		}
	doit(1);
	printf("%.3lf\n", ans);
}
Problem1764

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 200;
using namespace std;
int ans;
struct Tsolve1{
	int h[MAXN], n, top, stack[MAXN], l[MAXN], r[MAXN];
	int solve()
	{
		top = 0;
		for (int i = 1; i <= n; i++) r[i] = n;
		for (int i = 1; i <= n; i++) { 
			while(top > 0 && h[i] < h[stack[top]]) { r[stack[top]] = i - 1; --top; }
			stack[++top] = i;
		}
		top = 0;
		for (int i = 1; i <= n; i++) l[i] = 1;
		for (int i = n; i >= 1; i--) { 
			while(top > 0 && h[i] < h[stack[top]]) { l[stack[top]] = i + 1; --top; }
			stack[++top] = i;
		}
		int ans = 0;
		for (int i = 1; i <= n; i++) ans = max(ans, (r[i] - l[i] + 1) * h[i]);
		return ans;
	}
} solve1; // poj 2559 
struct Tsolve2{
	int map[MAXN][MAXN], n, m, ret[MAXN][MAXN];
	void solve()
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (map[i][j]){
					ret[i][j] = min(ret[i - 1][j], min(ret[i][j - 1], ret[i - 1][j - 1])) + 1;
				}
				else ret[i][j] = 0;
	}
} solve2; //USACO SX
struct Tsolve3{
	bool map[MAXN][MAXN][MAXN]; int n1, n2, n3;
	int num1[MAXN][MAXN][MAXN];
	void solve()
	{
		solve2.n = n2; solve2.m = n3;
		for (int k = 1; k <= n1; k++){
			for (int i = 1; i <= n2; i++)
				for (int j = 1; j <= n3; j++)
					solve2.map[i][j] = map[k][i][j];
			solve2.solve();
			for (int i = 1; i <= n2; i++)
				for (int j = 1; j <= n3; j++)
					num1[k][i][j] = solve2.ret[i][j];
		}
		for (int i = 1; i <= n2; i++)
			for (int j = 1; j <= n3; j++){
				solve1.n = n1;
				for (int k = 1; k <= n1; k++) solve1.h[k] = num1[k][i][j];
				ans = max(ans, solve1.solve());
			}
	}
} solve3;
int n1, n2, n3; bool map[MAXN][MAXN][MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n2, &n1, &n3);
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++){
			getchar();
			for (int k = 1; k <= n3; k++) map[i][j][k] = getchar() == 'N';
		}
	solve3.n1 = n1; solve3.n2 = n2; solve3.n3 = n3;
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++)
			for (int k = 1; k <= n3; k++)
				solve3.map[i][j][k] = map[i][j][k];
	solve3.solve();
	
	solve3.n1 = n3; solve3.n2 = n2; solve3.n3 = n1;
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++)
			for (int k = 1; k <= n3; k++)
				solve3.map[k][j][i] = map[i][j][k];
	solve3.solve();
	
	solve3.n1 = n2; solve3.n2 = n3; solve3.n3 = n1;
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++)
			for (int k = 1; k <= n3; k++)
				solve3.map[j][k][i] = map[i][j][k];
	solve3.solve();

	printf("%d\n", ans * 4);
}
Problem1765

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
#include <cmath>
#define PII pair<int, int>
#define PIII pair<pair<int, int>, long long>
#define PV pair<PIII, PII>
#define double long double
using namespace std;
int x[10001], y[10001], n, tot; long long ans;
PV buf[2500000];
double getdis(int a, int b)
{
	return sqrt((double)(x[a] - x[b]) * (double)(x[a] - x[b]) + (double)(y[a] - y[b]) * (double)(y[a] - y[b]));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++)
			buf[++tot] = make_pair(make_pair(make_pair(x[i] + x[j], y[i] + y[j]), (long long)(x[i] - x[j]) * (long long)(x[i] - x[j]) + (long long)(y[i] - y[j]) * (long long)(y[i] - y[j])), make_pair(i, j));
	sort(buf + 1, buf + tot + 1);
	for (int i = 1; i <= tot; i++)
		for (int j = i - 1; j >= 1; j--)
			if (buf[i].first != buf[j].first) break;
			else ans = max(ans, (long long)round(getdis(buf[i].second.first, buf[j].second.first) * getdis(buf[i].second.first, buf[j].second.second)));
	cout << ans << endl;				
}
Problem1766

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[110][110][110], n, maxS, hashx[110], hashy[110], x[110], y[110], totx, toty;
int tempx[110], tempy[110];
int dp(int l, int r, int h)
{
	int & now = f[l][r][h]; if (now != 0x3f3f3f3f) return now;
	if (l < r) for (int i = l; i < r; i++)
		now = min(dp(l, i, h) + dp(i + 1, r, h), now);
	int tot = 0;
	for (int i = 1; i <= n; i++) if (x[i] >= l && x[i] <= r && y[i] >= h) { tempx[++tot] = x[i];  tempy[tot] = y[i]; }
	if (tot == 0) return now = 0;
	int minx = totx + 1, maxx = 0, miny = totx + 1;
	for (int i = 1; i <= tot; i++) minx = min(minx, tempx[i]), maxx = max(maxx, tempx[i]), miny = min(miny, tempy[i]);
	int deltah = maxS / max(1, hashx[maxx] - hashx[minx]);
	int downy = n + 1;
	for (int i = 1; i <= tot; i++) if (hashy[tempy[i]] > deltah) downy = min(downy, tempy[i]);
	if (downy == n + 1) return now = 1;
	now = min(dp(l, r, downy) + 1, now);
	return now;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &maxS);
	for (int i = 1; i <= n; i++){
		scanf("%d%d", x + i, y + i);
		hashx[i] = x[i]; hashy[i] = y[i];
	}
	memset(f, 0x3f, sizeof(f));
	sort(hashx + 1, hashx + n + 1); totx = unique(hashx + 1, hashx + n + 1) - hashx - 1;
	sort(hashy + 1, hashy + n + 1); toty = unique(hashy + 1, hashy + n + 1) - hashy - 1;
	hashx[0] = -1; hashy[0] = -1;
	hashx[totx + 1] = 0x3f3f3f3f; hashy[toty + 1] = 0x3f3f3f3f;
	for (int i = 1; i <= n; i++) x[i] = lower_bound(hashx + 1, hashx + totx + 1, x[i]) - hashx;
	for (int i = 1; i <= n; i++) y[i] = lower_bound(hashy + 1, hashy + toty + 1, y[i]) - hashy;
	printf("%d\n", dp(1, totx, 1));
}
Problem1767

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
#define ll long long
using namespace std;
const int MAXN = 300001;
int tot, e[MAXN], v[MAXN], next[MAXN];
long long w[MAXN], f[MAXN], d[MAXN];
struct Tpoint{
	ll x, y;
	Tpoint() { }
	Tpoint(ll x, ll y) : x(x), y(y) { }
	Tpoint operator - (const Tpoint & A)
	{
		return Tpoint(x - A.x, y - A.y);
	}
	long double operator * (const Tpoint & A)
	{
		return (long double)x * A.y - (long double)y * A.x;
	}
} stack[MAXN];
int top;
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
ll find1(ll k) //find min kx+y 
{
	if (top == 0) return 0;
	stack[0] = Tpoint(stack[1].x, stack[1].y + 1);
	int l = 1, r = top;
	while(l <= r){
		int m = l + r >> 1; 
		if (stack[m - 1].x * k - stack[m - 1].y <= stack[m].x * k - stack[m].y) l = m + 1; else r = m - 1;
	}
	return stack[r].y - k * stack[r].x;
}
int find2(Tpoint p)
{
	if (top <= 1) return top;
	int l = 2, r = top;
	while(l <= r){
		int m = l + r >> 1;
		if ((p - stack[m - 1]) * (stack[m] - stack[m - 1]) < 0) l = m + 1; else r = m - 1;
	}
	return r;
}
bool vis[MAXN];
int t, pos[MAXN], n;
ll V[MAXN], W[MAXN];
Tpoint back[MAXN];
void dfs(int x)
{
	vis[x] = true;
	f[x] = find1(V[x]) + d[x] * V[x] + W[x];
	t = find2(Tpoint(d[x], f[x]));
	pos[x] = t + 1; back[x] = stack[pos[x]]; stack[top = pos[x]] = Tpoint(d[x], f[x]);
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		d[v[i]] = d[x] + w[i];
		dfs(v[i]);
		top = pos[x];
	}
	stack[pos[x]] = back[x];
}
const int N_MAX = 1000000;
static int stack2[N_MAX * 5], bak;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	for (int i = 2; i <= n; i++) scanf(LLD""LLD, &W[i], &V[i]);
	asm __volatile__
	(
		"movl %%esp, %0\n\t"
		"movl %1, %%esp\n\t": 
		"=g"(bak):
		"g"(stack2 + N_MAX * 5 - 1):
	);
	static int x;
	dfs(1);
	for (int i = 2; i < n; i++) printf(LLD" ", f[i]);
	printf(LLD"\n", f[n]);
}
Problem1768

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m, ans, h[100001], ws[100001], id[100001];
void Sort()
{
	for (int i = 0; i <= n; i++) ws[i] = 0;
	for (int i = 1; i <= m; i++) ws[h[i]]++;
	for (int i = 1; i <= n; i++) ws[i] += ws[i - 1];
	for (int i = m; i >= 1; i--) id[ws[h[i]]--] = i;
	reverse(id + 1, id + m + 1);
}
char s[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		scanf("%s", s + 1);
		for (int j = 1; j <= m; j++) h[j] += s[j] == '0' ? -h[j] : 1;
		Sort();
		for (int j = 1; j <= m; j++) ans = max(j * h[id[j]], ans);
	}
	printf("%d\n", ans);
}
Problem1778

#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
int n, m, p, q, deg[1001], map[1001][1001], where[1001];
double M[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &p, &q);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); ++deg[a]; ++deg[b];
		map[a][b]++; map[b][a]++;
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) if (deg[j] != 0)
			M[i][j] = (1 - double(p) / double(q)) / double(deg[j]) * map[j][i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			M[i][j] = (i == j) - M[i][j];
	M[1][0] = double(p) / double(q);
	for (int i = 1; i <= n; i++){
		int p = 1;
		for (int j = 2; j <= n; j++) if (fabs(M[i][p]) < fabs(M[i][j])) p = j;
		double t = M[i][p]; where[p] = i;
		for (int j = 0; j <= n; j++) M[i][j] /= t;
		for (int j = 1; j <= n; j++) if (i != j){
			double t = M[j][p];
			for (int k = 0; k <= n; k++) M[j][k] -= t * M[i][k];
			}
		}
	for (int i = 1; i <= n; i++) printf("%.9lf\n", M[where[i]][0]);
}
			
Problem1787

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 500001;
int tot, n, e[MAXN], v[MAXN * 2], next[MAXN * 2];
int f[MAXN][21], dis[MAXN], q[MAXN];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void BFS()
{
	int l = 1, r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (v[i] != f[x][0]){
			f[v[i]][0] = x; dis[v[i]] = dis[x] + 1; q[++r] = v[i]; 
		}
	}
}
int go(int x, int k)
{
	for (int i = 20; i >= 0; i--) if ((k >> i) & 1) x = f[x][i];
	return x;
}
int lca(int x, int y)
{
	if (dis[x] > dis[y]) swap(x, y);
	y = go(y, dis[y] - dis[x]);
	if (x == y) return x;
	for (int i = 20; i >= 0; i--) if (f[x][i] != f[y][i]){
		x = f[x][i]; y = f[y][i];
	}
	return f[x][0];
}
int ans, who;
void check(int a, int b, int c, int d)
{
	int t = dis[a] + dis[b] + dis[c] + 3 * dis[d] - dis[lca(a, d)] * 2 - dis[lca(b, d)] * 2 - dis[lca(c, d)] * 2;
	if (ans > t) { ans = t; who = d; } 
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q;
	scanf("%d%d", &n, &Q);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	BFS();
	for (int i = 1; i <= 20; i++) 
		for (int j = 1; j <= n; j++)
			f[j][i] = f[f[j][i - 1]][i - 1];
	while(Q--){
		int a, b, c, t; scanf("%d%d%d", &a, &b, &c);
		ans = 0x3f3f3f3f;
		check(a, b, c, lca(a, b));
		check(a, b, c, lca(a, c));
		check(a, b, c, lca(b, c));
		printf("%d %d\n", who, ans);
	}
}
Problem1791

#include <cstdio>
#include <cstdlib>
#include <cstring>

const int MAXN = 1001010;
struct Tnode{
       int w;
       long long v;
       } qq[MAXN + MAXN];
long long l, r, q[MAXN], len[MAXN], n ,vv, ww, all;
long long g[MAXN], who[MAXN + MAXN], dis[MAXN + MAXN];
bool vis[MAXN], bfs_vis[MAXN], core[MAXN];
long long e[MAXN], w[MAXN + MAXN], v[MAXN + MAXN], next[MAXN + MAXN], p[MAXN][3];
long long a, maxn, ans;
void tree(int root)
{
     core[root] = false;
     l = r = 1;
     q[1] = root;
     len[1] = 0;
     bfs_vis[root] = true;
     while (l <= r){
           for (int i = e[q[l]]; i; i = next[i])
               if (!core[v[i]] && !bfs_vis[v[i]]){
                  r++;
                  bfs_vis[v[i]] = true;
                  vis[v[i]] = true;
                  q[r] = v[i];
                  len[r] = len[l] + w[i];
                  if (len[r] > g[root]){
                     g[root] = len[r]; 
                     a = v[i];
                     }
               }
           l++;
           }     
     
     if (r == 1){
           core[root] = true;
           return;
           }
     for (int i = 1; i <= r; i++)
         bfs_vis[q[i]]  = false;
     l = r = 1;
     q[1] = a;
     len[1] = 0;
     
     bfs_vis[a] = true;
     while (l <= r){
           for (int i = e[q[l]]; i; i = next[i])
               if (!core[v[i]] && !bfs_vis[v[i]]){
                  r++;
                  bfs_vis[v[i]] = true;
                  q[r] = v[i];
                  len[r] = len[l] + w[i];
                  if (len[r] > maxn)
                     maxn = len[r];
                  }  
           l++;  
           }
     core[root] = true;
}                
void doit(int vv)
{
     int i, st;
     maxn = 0;
     i = vv;
     while (!vis[i]){
           vis[i] = true;
           i = p[i][1];
           }
     st = i;
     do {
         core[i] = true;
         i = p[i][1];
         } while (i != st);
     do {
         tree(i);
         i = p[i][1];
         } while (i != st);
     dis[1] = 0;
     who[1] = st;
     all = 1;
     int tt;
     do {
         tt = p[i][2];
         i = p[i][1];
         if (i != st){
            all++;
            dis[all] = dis[all - 1] + tt;
            who[all] = i;
            }  
         } while (i != st);
     who[all + 1] = who[1];
     dis[all + 1] = dis[all] + tt;
     for (int i = 2; i < all; i++){
         dis[i + all] = dis[i + all - 1] + dis[i] - dis[i - 1];
         who[i + all] = who[i];
         }
     l = 1; r= 0;
     for (int i = 1; i < all; i++){
         long long tmp = g[who[i]] - dis[i];
         while (l <= r && tmp > qq[r].v)
               r--;
         r++;
         qq[r].w = i;
         qq[r].v = tmp;
         }
     for (int i = all; i < all + all; i++){
         while (i - qq[l].w >= all)
               l++;
         if (g[who[i]] + dis[i] + qq[l].v > maxn)
            maxn = g[who[i]] + dis[i] + qq[l].v;
         long long tmp = g[who[i]] - dis[i];
         while (l <= r && tmp > qq[r].v)
               r--;
         r++;
         qq[r].w = i;
         qq[r].v = tmp;
         }
     ans += maxn;
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++){
        scanf("%d%d", &vv, &ww);
        p[i][1] = vv; p[i][2] = ww;
        next[i * 2 - 1] = e[i];
        v[i * 2 - 1] = vv;
        w[i * 2 - 1] = ww;
        e[i] = i * 2 - 1;
        next[i * 2] = e[vv];
        v[i * 2] = i;
        w[i * 2] = ww;
        e[vv] = i * 2;
        }
    for (int i = 1; i <= n; i++)
        if (!vis[i])
           doit(i);
    printf("%lld\n", ans);
}
Problem1797

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, MAXM = 200001, INF = 0x3f3f3f3f;
int n, m, col[MAXN], p, a[MAXN], nowc; bool vis[MAXN];
struct Tscc{
	struct Tgraph{
		int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2];
		void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }	
		void dfs(int x) { vis[x] = true; for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) dfs(v[i]); a[++p] = x; }
		void DFS(int x) { col[x] = nowc; for (int i = e[x]; i; i = next[i]) if (!col[v[i]]) DFS(v[i]); }
	} g, G;
	void add(int a, int b) { g.add(a, b); G.add(b, a); }
	void solve()
	{
		for (int i = 1; i <= n; i++) if (!vis[i]) g.dfs(i);
		for (int i = n; i >= 1; i--) if (!col[a[i]]){ nowc = a[i]; G.DFS(a[i]); }
	}
} scc;
int belong[MAXN], pos[MAXN], st[MAXM], ed[MAXM];
struct Tflow{
    int s, t, flow;
    int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2], c[MAXM * 2];
    int h[MAXN], vh[MAXN];
    Tflow() { tot = 1; }
    void add(int A, int B, int C)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
    }
    int aug(int x, int f)
    {
        if (x == t) return f;
        int minh = n - 1, augc = f;
        for (int i = e[x]; i; i = next[i]) if (c[i]){
            if (h[v[i]] + 1 == h[x]){
                int t = aug(v[i], min(f, c[i]));
                c[i] -= t; c[i ^ 1] += t; f -= t;
                if (f == 0 || h[s] == n) return augc - f;
            }
            minh = min(minh, h[x]);
        }
        if (f == augc){ if (--vh[h[x]] == 0) h[s] = n; ++vh[h[x] = minh + 1]; }
        return augc - f;
    }
	void dfs(int x, bool t)
	{
		belong[x] = t + 1;
		for (int i = e[x]; i; i = next[i]) {
			if (belong[v[i]] == 0 && c[i ^ t] > 0) dfs(v[i], t);
		}
	}
    void run()
    {
		vh[0] = n;
        while(h[s] < n) flow += aug(s, INF);
		dfs(s, 0); 
		dfs(t, 1);
		for (int x = 1; x <= n; x++)
			for (int i = e[x]; i; i = next[i]) if (c[i]) scc.add(x, v[i]);
		scc.solve();
    }
} flow;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &flow.s, &flow.t);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c); st[i] = a; ed[i] = b;
		flow.add(a, b, c); pos[i] = flow.tot - 1;
	}
	flow.run();	
	for (int i = 1; i <= m; i++){
		if (flow.c[pos[i]] == 0 && col[st[i]] != col[ed[i]]) putchar('1'); else putchar('0');
		putchar(' ');
		putchar(belong[st[i]] == 1 && belong[ed[i]] == 2 ? '1' : '0');
		putchar('\n');
	}

}
Problem1798

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define lint long long
using namespace std;
const int MAXN = 600001;
int n, p, m;
lint a[MAXN];
struct Tsegmenttree{
	lint sum[MAXN], _mul[MAXN], _add[MAXN];
	void add(int idx, lint delta, lint len)
	{
		sum[idx] = (sum[idx] + len * delta) % p;
		_add[idx] = (_add[idx] + delta) % p;
	}
	void mul(int idx, lint delta, lint len)
	{
		sum[idx] = (sum[idx] * delta) % p;
		_add[idx] = (_add[idx] * delta) % p;
		_mul[idx] = (_mul[idx] * delta) % p;
	}
	void push(int idx, lint len1, lint len2)
	{
		if (_mul[idx] != 1){
			mul(idx * 2, _mul[idx], len1);
			mul(idx * 2 + 1, _mul[idx], len2);
			_mul[idx] = 1;
			}
		if (_add[idx] != 0){
			add(idx * 2, _add[idx], len1);
			add(idx * 2 + 1, _add[idx], len2);
			_add[idx] = 0;
			}
	}
	void update(int idx)
	{
		sum[idx] = (sum[idx * 2] + sum[idx * 2 + 1]) % p;
	}
	void build(int idx, int l, int r)
	{
		_mul[idx] = 1;
		if (l == r){
			sum[idx] = a[l]; return;
			}
		else{
			build(idx * 2, l, l + r >> 1);
			build(idx * 2 + 1, l + r + 2 >> 1, r);
			}
		update(idx);
	}	
	void make_add(int idx, int l, int r, int ll, int rr, int delta)
	{
		if (ll <= l && rr >= r){
			add(idx, delta, r - l + 1); return;
			}
		else{
			int m = l + r >> 1;
			push(idx, m - l + 1, r - m);
			if (ll <= m) make_add(idx * 2, l, m, ll, rr, delta);
			if (rr > m) make_add(idx * 2 + 1, m + 1, r, ll, rr, delta);
			}
		update(idx);
	}
	void make_mul(int idx, int l, int r, int ll, int rr, int delta)
	{
		if (ll <= l && rr >= r){
			mul(idx, delta, r - l + 1); return;
			}
		else{
			int m = l + r >> 1;
			push(idx, m - l + 1, r - m);
			if (ll <= m) make_mul(idx * 2, l, m, ll, rr, delta);
			if (rr > m) make_mul(idx * 2 + 1, m + 1, r, ll, rr, delta);
			}
		update(idx);
	}
	lint getsum(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return sum[idx];
		int m = l + r >> 1; lint ret = 0;
		push(idx, m - l + 1, r - m);
			if (ll <= m) ret += getsum(idx * 2, l, m, ll, rr);
		if (rr > m) ret += getsum(idx * 2 + 1, m + 1, r, ll, rr);
		return ret % p;
	}
} T;
int main()
{
	scanf("%d%d", &n, &p);
	for (int i = 1; i <= n; i++) scanf("%I64d", &a[i]);
	T.build(1, 1, n);
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		int op, l, r, delta;
		scanf("%d%d%d", &op, &l, &r);
		switch(op){
			case 2: scanf("%d", &delta); T.make_add(1, 1, n, l, r, delta); break;
			case 1: scanf("%d", &delta); T.make_mul(1, 1, n, l, r, delta); break;
			case 3: printf("%lld\n", T.getsum(1, 1, n, l, r)); break;
			}
		}

}	
Problem1800

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int sum[1001], h[1001], n, ans;
void check()
{
	if (h[2] != h[4]) return;
	if (h[3] != sum[n] - h[2] - h[3] - h[4]) return;
	++ans;
}
void dfs(int dep, int last)
{
	if (dep == 4) { check(); return; }
	for (int i = last + 1; i <= n; i++){
		if (dep != 0) h[dep + 1] = sum[i - 1] - sum[last - 1];
		dfs(dep + 1, i);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &sum[i]);
	for (int i = 1; i <= n; i++) sum[i] += sum[i - 1];
	dfs(0, 0);
	cout << ans << endl;
}
Problem1803

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
using namespace std;
const int MAXN = 200001;
int tot, next[MAXN], e[MAXN], v[MAXN];
int X[MAXN], DFSX, in[MAXN], out[MAXN];
bool vis[MAXN];
int tl[21][MAXN], val[21][MAXN];
int a[MAXN], n, m;
bool cmp(int A, int B)
{
	return a[A] < a[B];
}
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void DFS(int x)
{
	vis[x] = true; X[++DFSX] = x; in[x] = DFSX;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) DFS(v[i]);
	out[x] = DFSX;
}
void build(int idx, int l, int r)
{
	if (l == r) return;
	int m = (l + r) >> 1, ls = m - l + 1, lp = l - 1, rp = m, same = 0;
	for (int i = l; i <= r; i++) if (a[X[i]] < a[X[m]]) --ls;
	for (int i = l; i <= r; i++){
		tl[idx][i] = i == l ? 0 : tl[idx][i - 1];
		if (a[val[idx][i]] < a[X[m]]) val[idx + 1][++lp] = val[idx][i], ++tl[idx][i];
		else if (a[val[idx][i]] > a[X[m]]) val[idx + 1][++rp] = val[idx][i];
		else if (same < ls) val[idx + 1][++lp] = val[idx][i], ++tl[idx][i], ++same;
		else val[idx + 1][++rp] = val[idx][i];
		}
	build(idx + 1, l, m); build(idx + 1, m + 1, r);
}		
int query(int idx, int ll, int rr, int l, int r, int k)
{
	if (ll == rr) return val[idx][ll];
	int m = (ll + rr) >> 1, A, B, C, D;
	if (l == ll) A = 0, B = tl[idx][r]; else A = tl[idx][l - 1], B = tl[idx][r] - A;
	C = l - ll - A, D = r - l + 1 - B;
	if (B >= k) return query(idx + 1, ll, m, ll + A, ll + A + B - 1, k);
	else return query(idx + 1, m + 1, rr, m + 1 + C, m + C + D, k - B);
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i < n; i++){
		int x, y; scanf("%d%d", &x, &y); add(x, y); add(y, x);
		}
	DFS(1);
	for (int i = 1; i <= DFSX; i++) val[0][i] = X[i];
	sort(X + 1, X + DFSX + 1, cmp);
	build(0, 1, DFSX);
	scanf("%d", &m);
	while(m--){
		int x, k; scanf("%d%d", &x, &k);
		printf("%d\n", query(0, 1, DFSX, in[x], out[x], k));
		}
}
Problem1807

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
const int MAXN = 200001;
int b, n, d, m;
int BIT1[200011];
int BIT2[226][226][226];
struct Tdata1{
	int x, k;
	} data1[MAXN];
struct Tdata2{
	int x, y, k;
	} data2[MAXN];
struct Tdata3{
	int x, y, z, w, k;
	} data3[MAXN];
bool cmp1(Tdata1 A, Tdata1 B)
{
	return A.x == B.x ? A.k > B.k : A.x < B.x;
}
bool cmp2(Tdata2 A, Tdata2 B)
{
	return A.x == B.x ? A.k > B.k : A.x < B.x;
}
bool cmp3(Tdata3 A, Tdata3 B)
{
	return A.x == B.x ? A.k > B.k : A.x < B.x;
}
void work1()
{
	for (int i = 1; i <= n; i++){
		int x; scanf("%d", &x);
		data1[i * 2 - 1].x = x; data1[i * 2 - 1].k = 1;
		data1[i * 2].x = x + d; data1[i * 2].k = -1;
		}
		
	sort(data1 + 1, data1 + 2 * n + 1, cmp1);
	ll count = 0, ans = 0;
	for (int i = 1; i <= 2 * n; i++){
		if (data1[i].k > 0) ++count;
		if (data1[i].k < 0){
			--count; ans += count;
			}
		}
	printf("%lld\n", ans);
}
void insert(int k, int delta)
{
	for (int i = k; i <= 200000; i += (i & (-i))) BIT1[i] += delta;
}
ll query(int l, int r)
{
	if (l <= 0) l = 1; if (r > 200000) r = 200000;
	ll ret = 0;
	for (int i = l - 1; i; i -= (i & (-i))) ret -= BIT1[i];
	for (int i = r; i; i -= (i & (-i))) ret += BIT1[i];
	return ret;
}
void work2()
{
	for (int i = 1; i <= n; i++){
		int x, y; scanf("%d%d", &x, &y);
		int xx = x + y, yy = x - y + m;
		x = xx; y = yy;
		data2[i * 2 - 1].x = x; data2[i * 2 - 1].y = y; data2[i * 2 - 1].k = 1;
		data2[i * 2].x = x + d; data2[i * 2].y = y; data2[i * 2].k = -1;
		}
	sort(data2 + 1, data2 + 2 * n + 1, cmp2);
	ll ans = 0;
	for (int i = 1; i <= 2 * n; i++){
		if (data2[i].k > 0) insert(data2[i].y, 1);
		if (data2[i].k < 0){
			insert(data2[i].y, -1);
			ans += query(data2[i].y - d, data2[i].y + d);
			}
		}
	printf("%lld\n", ans);
}
void insert(int x, int y, int z, int delta)
{
	for (int i = x; i <= 225; i += (i & (-i)))
		for (int j = y; j <= 225; j += (j & (-j)))
			for (int k = z; k <= 225; k += (k & (-k)))
				BIT2[i][j][k] += delta;
}
ll Query(int x, int y, int z)
{
	ll ret = 0;
	for (int i = x; i >= 1; i -= (i & (-i)))
		for (int j = y; j >= 1; j -= (j & (-j)))
			for (int k = z; k >= 1; k -= (k & (-k)))	
				ret += BIT2[i][j][k];
	return ret;
}
ll Query(int x1, int y1, int z1, int x2, int y2, int z2)
{
	if (x1 < 1) x1 = 1; if (y1 < 1) y1 = 1; if (z1 < 1) z1 = 1;
	if (x2 > 225) x2 = 225; if (y2 > 225) y2 = 225; if (z2 > 225) z2 = 225;
	return Query(x2, y2, z2) 
	- Query(x1 - 1, y2, z2) - Query(x2, y1 - 1, z2) - Query(x2, y2, z1 - 1)
	+ Query(x1 - 1, y1 - 1, z2)  + Query(x1 - 1, y2, z1 - 1) + Query(x2, y1 - 1, z1 - 1)
	- Query(x1 - 1, y1 - 1, z1 - 1);
}
void work3()
{
	for (int i = 1; i <= n; i++){
		int x, y, z, w; scanf("%d%d%d", &x, &y, &z);
		int xx = x + y + z, yy = x - y + z + m, zz = x + y - z + m, ww= x - y - z + m * 2;
		x = xx; y = yy; z = zz; w = ww;
		data3[i * 2 - 1].x = x; data3[i * 2 - 1].y = y; 
		data3[i * 2 - 1].z = z; data3[i * 2 - 1].w = w;
		data3[i * 2 - 1].k = 1;
		data3[i * 2].x = x + d; data3[i * 2].y = y;
		data3[i * 2].z = z; data3[i * 2].w = w;
		data3[i * 2].k = -1;
		}
	sort(data3 + 1, data3 + 2 * n + 1, cmp3);
	ll ans = 0;
	for (int i = 1; i <= 2 * n; i++){
		if (data3[i].k > 0) insert(data3[i].y, data3[i].z, data3[i].w, 1);
		if (data3[i].k < 0){
			insert(data3[i].y, data3[i].z, data3[i].w, -1);
			ans += Query(data3[i].y - d, data3[i].z - d, data3[i].w - d, data3[i].y + d, data3[i].z + d, data3[i].w + d);
			}
		}
	printf("%lld\n", ans);
}
int main()
{
	scanf("%d%d%d%d", &b, &n, &d, &m);
	if (b == 1) work1();
	if (b == 2) work2();
	if (b == 3) work3();
}
Problem1809

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int INF = 0x3f3f3f3f;
struct Tnode{
	int l, r, ls, rs, k, delta, maxdelta;
	void init(int _l, int _r, int _k)
	{
		l = _l; r = _r; ls = -1; rs = -1; k = _k; delta = k * (r - l + 1); maxdelta = max(delta, 0);
	}
} node[6000001];
int tot, n;
void makek(int idx, int k)
{
	node[idx].k = k; node[idx].delta = k * (node[idx].r - node[idx].l + 1); node[idx].maxdelta = max(node[idx].delta, 0);
}
void push(int idx)
{
	if (node[idx].k != INF){
		makek(node[idx].ls, node[idx].k);
		makek(node[idx].rs, node[idx].k);
		node[idx].k = INF;
	}
}
void update(int idx)
{
	node[idx].delta = node[node[idx].ls].delta + node[node[idx].rs].delta;
	node[idx].maxdelta = max(node[node[idx].ls].maxdelta, node[node[idx].ls].delta + node[node[idx].rs].maxdelta);
}
void addson(int idx)
{
	if (node[idx].ls > 0) return;
	++tot; node[tot].init(node[idx].l, node[idx].l + node[idx].r >> 1, node[idx].k); node[idx].ls = tot;
	++tot; node[tot].init(node[idx].l + node[idx].r + 2 >> 1, node[idx].r, node[idx].k); node[idx].rs = tot;
}
int query(int idx, int h)
{
	if (node[idx].k != INF)
		if (node[idx].k <= 0) return node[idx].r + 1; else return min(node[idx].r + 1, node[idx].l + h / node[idx].k);
	if (h >= node[node[idx].ls].maxdelta) return query(node[idx].rs, h - node[node[idx].ls].delta); else return query(node[idx].ls, h);
}
void insert(int idx, int l, int r, int d)
{
	if (l <= node[idx].l && r >= node[idx].r) { makek(idx, d); return; }
	addson(idx);
	push(idx);
	int m = node[idx].l + node[idx].r >> 1;
	if (l <= m) insert(node[idx].ls, l, r, d);
	if (r > m) insert(node[idx].rs, l, r, d);
	update(idx);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	tot = 1; node[1].l = 1; node[1].r = n; node[1].ls = -1; node[1].rs = -1;
	while(1){
		int h, l, r, k, d;
		scanf(" ");
		char op[101]; scanf("%s", op);
		switch(*op){
			case 'Q' : scanf("%d", &h); printf("%d\n", query(1, h) - 1); break;
			case 'I' : scanf("%d%d%d", &l, &r, &d); insert(1, l, r, d); break;
			case 'E' : goto end;
		}
	}
end:;
}
Problem1814

#include <cstdio>
#include <cstdlib>
#include <cstring>
#define LL long long
#define ADD(a, b) insert(!cur, H ^ (a ^ b) << j + j, V)
const int MAXHASH = 1509, MAXNODE = 1510000;
int n, m;
char s[20][20];
struct Tnode{
    int h, next; LL num;
    };
struct Thash{
    int P; Tnode buf[MAXNODE];
    int head[MAXHASH + 100];
    } f[2];
void insert(int w, int h, LL num)
{
    int hh = h % MAXHASH, t = f[w].head[hh];
    while (t != 0 && f[w].buf[t].h != h) t = f[w].buf[t].next;
    if (t != 0)
        f[w].buf[t].num += num;
    else {
        ++f[w].P;
        f[w].buf[f[w].P].h = h;
        f[w].buf[f[w].P].num = num;
        f[w].buf[f[w].P].next = f[w].head[hh]; f[w].head[hh] = f[w].P;
        }
}
LL get(int w, int h)
{
    int hh = h % MAXHASH, t =f[w].head[hh];
    while (t !=0 && f[w].buf[t].h != h) t = f[w].buf[t].next;
    return t == 0 ? 0 : f[w].buf[t].num;
}
void clear(int w)
{
    f[w].P= 0; memset(f[w].head, 0, sizeof(f[w].head));
}
int chanl(int h, int p)
{
    int i = p, cnt = -1;
    while (cnt != 0){
        i -= 2;
        if ((h >> i & 3) == 1) ++cnt;
        if ((h >> i & 3) == 2) -- cnt;
        }
    return h ^ 3 << i;
}
int chanr(int h, int p)
{
    int i = p, cnt = 1;
    while (cnt != 0){
        i += 2;
        if ((h >> i & 3) == 1) ++cnt;
        if ((h >> i & 3) == 2) -- cnt;
        }
    return h ^ 3 << i;
}
int main()
{
    scanf("%d%d", &n, &m);
    int ex, ey;
    for (int i = 0; i < n; i++)
        scanf("%s", s[i]);
    for (ex = n - 1; ~ex; ex--){
        for (ey = m - 1; ~ey; ey--)
            if (s[ex][ey] == '.') break;
        if (~ey) break;
        }
    insert(0, 0, 1);
    int cur = 1;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            cur = !cur;
            clear(!cur);
            if (s[i][j] == '*'){
                for (int p = f[cur].P; p; p--)
                    if (((f[cur].buf[p].h >> (j + j)) & 15) == 0)
                        insert(!cur, f[cur].buf[p].h, f[cur].buf[p].num);
                }
            else{
                for (int p = f[cur].P; p; p--){
                    int H = f[cur].buf[p].h; LL V = f[cur].buf[p].num;
                    switch (H >> (j + j) & 15){
                        case 0:
                            ADD(0, 9);
                            break;
                        case 1:
                            ADD(1, 4);
                            ADD(1, 1);
                            break;
                        case 2:
                            ADD(2, 8);
                            ADD(2, 2);
                            break;
                        case 4:
                            ADD(4, 1);
                            ADD(4, 4);
                            break;
                        case 8:
                            ADD(8, 8);
                            ADD(8, 2);
                            break;
                        case 9:
                            if (i == ex && j == ey)
                                ADD(9 ,0);
                            break;
                        case 6:
                            ADD(6, 0);
                            break;
                        case 5:
                            insert(!cur, chanr(H, j + j + 2) ^ 5 << (j + j), V);
                            break;
                        case 10:
                            insert(!cur, chanl(H, j + j) ^ 10 << (j + j), V);
                            break;
                        }
                    }
                }
            }
            cur = !cur;
            clear(!cur);
            for (int p = f[cur].P; p; p--)
                if ((f[cur].buf[p].h >> (m + m)) == 0) insert(!cur, f[cur].buf[p].h << 2, f[cur].buf[p].num);
        }
    printf("%lld\n", get(cur, 0));
}
Problem1816

#include <algorithm>
#include <cstdio>
#include <cctype>
const int MAXN = 1000001;
using namespace std;
typedef long long ll;
const ll inf = 0x7ffffffffll;
int n;
ll A[2000001];
int main()
{
	scanf("%d", &n); ++n;
    for (int i = 1; i <= n; i++) scanf("%lld", &A[i]);
	ll l = 0,r = 1000000000000ll;
    while(l + 1 < r)
    {
        ll m= l + r >> 1,s = 0;
        for (int i = 1; i <= n; i++) s += max(m - A[i], 0ll);
        if(s <= m) l = m; else r = m;
    }
    printf("%lld\n", l);
}
Problem1818

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 400001;
struct Tpoint{
	int x, y;
} in[MAXN], row[MAXN], line[MAXN];
int n, start[MAXN];
struct Tbit{
	int data[MAXN * 2];
	void add(int x, int d) { for (; x <= 2 * n; x += (x & (-x))) data[x] += d; }
	int sum(int x) { int ret = 0; for (; x; x -= (x & (-x))) ret += data[x]; return ret; }
	int sum(int l, int r) { return sum(r) - sum(l - 1); }
} bit;
struct Tscan{
	int kind, x1, x2, y;
	void init(int _k, int _x1, int _x2, int _y) { kind = _k; x1 = _x1; x2 = _x2; y = _y; }
	bool operator < (const Tscan & A) const
	{
		return y == A.y ? kind < A.kind : y < A.y;
	}
} scan[MAXN * 3];
bool cmprow(Tpoint A, Tpoint B)
{
	return A.y == B.y ? A.x < B.x : A.y < B.y;
}
bool cmpline(Tpoint A, Tpoint B)
{
	return A.x == B.x ? A.y < B.y : A.x < B.x;
}
void lsh()
{
	static int hashx[MAXN];
	for (int i = 1; i <= n; i++) hashx[i] = in[i].x;
	sort(hashx + 1, hashx + n + 1);
	int tot = unique(hashx + 1, hashx + n + 1) - hashx;
	for (int i = 1; i <= n; i++) in[i].x = lower_bound(hashx + 1, hashx + tot + 1, in[i].x) - hashx;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &in[i].x, &in[i].y);
	lsh();
	for (int i = 1; i <= n; i++) row[i] = in[i];
	for (int i = 1; i <= n; i++) line[i] = in[i];
	sort(row + 1, row + n + 1, cmprow);
	sort(line + 1, line + n + 1, cmpline);
	int tot = 0;
	for (int i = 1; i <= n; i++){
		int t = i; while(t < n && row[t + 1].y == row[t].y) ++t;
		for (int j = i; j < t; j++) scan[++tot].init(1, row[j].x + 1, row[j + 1].x - 1, row[j].y);
		i = t;
	}
	for (int i = 1; i <= n; i++){
		int t = i; while(t < n && line[t + 1].x == line[t].x) ++t;
		for (int j = i; j < t; j++){
			scan[++tot].init(0, line[j].x, -1, line[j].y + 1);
			scan[++tot].init(2, line[j].x, -1, line[j + 1].y - 1);
		}
		i = t;
	}
	
	long long ans = n;
	sort(scan + 1, scan + tot + 1);
	for (int i = 1; i <= tot; i++)
		switch(scan[i].kind){
			case 1 : ans += bit.sum(scan[i].x1, scan[i].x2); break;
			case 0 : bit.add(scan[i].x1, 1); break;
			case 2 : bit.add(scan[i].x1, -1); break;
		}
	cout << ans << endl;
}
Problem1819

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tnode{
	int ch[26]; bool f;
} a[500001];
int tot, vis[500001];
char in[200001], now[2000001];
void insert(char *S)
{
	int now = 1;
	for (; *S; S++){
		if (a[now].ch[*S - 'a'] == 0) a[now].ch[*S - 'a'] = ++tot;
		now = a[now].ch[*S - 'a'];
	}
	a[now].f = true;
}
int find(char *S)
{
	int now = 1;
	for (; *S; S++){
		if (a[now].ch[*S - 'a'] == 0) return 0;
		now = a[now].ch[*S - 'a'];
	}
	return now;
}
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		scanf(" ");
		scanf("%s", in); insert(in);
	}
	for (int i = 1; i <= m; i++){
		int ans = 0;
		scanf(" ");
		scanf("%s", in); if (a[find(in)].f) { puts("-1"); continue; }
		int l = strlen(in);
		for (int t = 0; t < l; t++){
			int tot = 0;
			for (int j = 0; j < t; j++) now[tot++] = in[j];
			for (int j = t + 1; j < l; j++) now[tot++] = in[j];
			now[tot] = 0;
			int p = find(now); if (a[p].f && vis[p] != i) ++ans; vis[p] = i;
		}
		for (int t = 0; t < l; t++)
			for (char c = 'a'; c <= 'z'; c++) if (c != in[t]){
				char backc = in[t];
				in[t] = c;
				int p = find(in); 
				if (a[p].f && vis[p] != i) ++ans; 
				vis[p] = i;
				in[t] = backc;
			}
		for (int t = 0; t <= l; t++)
			for (char c = 'a'; c <= 'z'; c++){
				int tot = 0;
				for (int j = 0; j < t; j++) now[tot++] = in[j];
				now[tot++] = c;
				for (int j = t; j < l; j++) now[tot++] = in[j];
				now[tot] = 0;
				int p = find(now); if (a[p].f && vis[p] != i) ++ans; vis[p] = i;
			}
		printf("%d\n", ans);
	}


}
Problem1820

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[2][201][201], n, cost[1001][1001], a[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &cost[i][j]);
	a[0] = 1; int tot = 0;
	memset(f, 0x7f, sizeof(f)); f[0][2][3] = 0; f[0][3][2] = 0; int now = 1; tot = 1;
	while(~scanf("%d", &a[tot])){
		now ^= 1; memset(f[now ^ 1], 0x7f, sizeof(f[now ^ 1]));
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				if (f[now][i][j] != 0x7f7f7f7f){
					f[now ^ 1][i][j] = min(f[now ^ 1][i][j], f[now][i][j] + cost[a[tot - 1]][a[tot]]);
					f[now ^ 1][a[tot - 1]][j] = min(f[now ^ 1][a[tot - 1]][j], f[now][i][j] + cost[i][a[tot]]);
					f[now ^ 1][a[tot - 1]][i] = min(f[now ^ 1][a[tot - 1]][i], f[now][i][j] + cost[j][a[tot]]);
					}
		++tot;

	}
	int ans = 0x7f7f7f7f;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) ans = min(ans, f[now ^ 1][i][j]);
	printf("%d\n", ans);
}
Problem1821

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tdata{
	int a, b, dis;
	bool operator < (const Tdata & A) const { return dis < A.dis; }
} data[1000001];
int x[10001], y[1001], f[100001], n, k, tot;
int find(int v) { return v == f[v] ? v : f[v] = find(f[v]); }
int dis(int x1, int y1, int x2, int y2)
{
	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) f[i] = i;
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++){
			++tot; data[tot].a = i; data[tot].b = j; data[tot].dis= dis(x[i], y[i], x[j], y[j]);
		}
	sort(data + 1, data + tot + 1);
	int now = n;
	for (int i = 1; i <= tot; i++){
		int a = find(data[i].a), b = find(data[i].b);
		if (a != b){
			if (now == k) { printf("%.2lf\n", sqrt(data[i].dis)); return 0; }
			f[a] = b; --now;
		}
	}
	printf("%.2lf\n", sqrt(data[tot].dis));
}
Problem1822

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const int MAXN = 200001, MAXM = 800001, INF = 0x3f3f3f3f; 
int n, m, k, tt[MAXN];
struct Tflow{
    int s, t, flow;
    int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2], c[MAXM * 2], copyc[MAXM * 2];
    int h[MAXN], vh[MAXN];
	Tflow() { tot = 1; }
	void add(int A, int B, int C)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
    }
    void init()
    {
		memcpy(copyc, c, sizeof(c));
	}
    void reinit(int time)
    {
		memcpy(c, copyc, sizeof(c));
		for (int i = e[s]; i; i = next[i]) c[i] = time / tt[v[i]] + 1;
        memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
        vh[0] = t;
    }   
    int aug(int x, int f)
    {
        if (x == t) return f;
        int minh = t - 1, augc = f;
        for (int i = e[x]; i; i = next[i]) if (c[i]){
            if (h[v[i]] + 1 == h[x]){
                int t = aug(v[i], min(f, c[i]));
                c[i] -= t; c[i ^ 1] += t; f -= t;
                if (f == 0 || h[s] == t) return augc - f;
            }
            minh = min(minh, h[x]);
        }
        if (f == augc){ if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1]; }
        return augc - f;
    }
	int run()
    {
		int flow = 0;
        while(h[s] < t)
            flow += aug(s, INF);
		return flow;
    }
} flow;
struct Tpoint{
	double x, y;
	void init() { scanf("%lf%lf", &x, &y); }
} wizard[MAXN];
struct Tcircle{
	Tpoint mid; double r;
	void init() { scanf("%lf%lf%lf", &mid.x, &mid.y, &r); }
} lich[MAXN], tree[MAXN];
struct Tline{
	double A, B, C;
	Tline() { }
	Tline(Tpoint a, Tpoint b)
	{
		A = b.y - a.y; B = a.x - b.x; C = -(a.x * b.y - a.y * b.x);
	}
	double dis(Tpoint a)
	{
		return fabs(a.x * A + a.y * B + C) / sqrt(A * A + B * B);
	}
};
double dis(Tpoint a, Tpoint b)
{
	return ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++) lich[i].init(), scanf("%d", &tt[i]);
	for (int i = 1; i <= m; i++) wizard[i].init();
	for (int i = 1; i <= m; i++) tree[i].init();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			bool ok = true;
			if(dis(lich[i].mid, wizard[j]) > lich[i].r * lich[i].r) continue;
			Tline line(lich[i].mid, wizard[j]);
			for (int t = 1; t <= k; t++) if (line.dis(tree[t].mid) < tree[t].r ) ok = false;
			if (ok){
				flow.add(i, j + n, 1);
			}
		}
	flow.s = n + m + 1; flow.t = flow.s + 1;
	for (int i = 1; i <= m; i++) flow.add(i + n, flow.t, 1);
	for (int i = 1; i <= n; i++) flow.add(flow.s, i, 0);
	flow.init();
	int l = 0, r = 0x3f3f3f3f;
	while(l <= r){
		int mid = l + r >> 1;
		flow.reinit(mid); int t = flow.run();
		if (t == m) r = mid - 1; else l = mid + 1;
	}
	printf("%d\n", l == 0x3f3f3f3f + 1 ? -1 : l);
}
Problem1823

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1001, MAXM = 10001;
int n, m;
static bool vis[MAXN]; static int p, a[MAXN], nowc, col[MAXN];
struct Tscc{
	struct Tgraph{
		int e[MAXN], v[MAXM], next[MAXM], tot;
		void clr() { tot = 0; memset(e, 0, sizeof(e)); }
		void add(int a, int b)
		{
			++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
		}
		void dfs1(int x)
		{
			vis[x] = true;
			for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) dfs1(v[i]);
			a[++p] = x;
		}
		void dfs2(int x)
		{
			col[x] = nowc;
			for (int i = e[x]; i; i = next[i]) if (col[v[i]] == 0) dfs2(v[i]);
		}
	} g1, g2;
	void clr() { g1.clr(); g2.clr(); memset(vis, 0, sizeof(vis)); memset(col, 0, sizeof(col)); p = 0; }
	void add(int a, int b) { g1.add(a, b); g2.add(b, a); }
	void scc()
	{
		for (int i = 1; i <= 2 * n; i++) if (!vis[i]) g1.dfs1(i);
		for (int i = 2 * n; i >= 1; i--) if (col[a[i]] == 0){
			nowc = a[i]; g2.dfs2(a[i]);
		}
	}
}scc;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T;scanf("%d", &T);
while(T--){
	scc.clr();
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		scanf(" "); int i1, i2; char c1, c2;
		scanf("%c%d %c%d", &c1, &i1, &c2, &i2);
		int ti1 = i1 * 2 - (c1 == 'm');
		int ti2 = i2 * 2 - (c2 == 'm');
		scc.add(4 * i1 - 1 - ti1, ti2); scc.add(4 * i2 - 1 - ti2, ti1);
	}
	scc.scc();
	for (int i = 1; i <= n; i++) if (col[i * 2] == col[i * 2 - 1]) { puts("BAD"); goto bad; }
	puts("GOOD");
bad:;
}
}
Problem1826

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
#include <map>
using namespace std;
struct Tdata{
	int num, next;
	bool operator < (const Tdata & A) const 
	{ 
		return next == A.next ? num < A.num : next > A.next; 
	}
};
Tdata makedata(int _num, int _next) { Tdata temp; temp.num = _num; temp.next = _next; return temp; }
map<int, int> last;
set<Tdata> heap;
map<int, int> hash;
int next[1000001], a[1000001], n, m;

int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	memset(next, 0x3f, sizeof(next));
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		if (last.count(a[i])){
			next[last[a[i]]] = i;
		}
		last[a[i]] = i;
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
		if (hash.count(a[i])){
			set<Tdata>::iterator si = heap.find(makedata(a[i], hash[a[i]]));
			heap.erase(si); heap.insert(makedata(si->num, next[i])); hash[a[i]] = next[i];
		}
		else {
			++ans;
			if (heap.size() < m){
				Tdata temp; temp.num = a[i]; temp.next = next[i];
				heap.insert(temp);
				hash[a[i]] = next[i];
			}
			else{
				hash.erase(heap.begin()->num);
				heap.erase(heap.begin());
				Tdata temp; temp.num = a[i]; temp.next = next[i];
				heap.insert(temp);
				hash[a[i]] = next[i];
			}
		}
	printf("%d\n", ans);
}
Problem1832

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 500001;
int tot, n, e[MAXN], v[MAXN * 2], next[MAXN * 2];
int f[MAXN][21], dis[MAXN], q[MAXN];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void BFS()
{
	int l = 1, r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (v[i] != f[x][0]){
			f[v[i]][0] = x; dis[v[i]] = dis[x] + 1; q[++r] = v[i]; 
		}
	}
}
s
s
int ans, who;
void check(int a, int b, int c, int d)
{
	int t = dis[a] + dis[b] + dis[c] + 3 * dis[d] - dis[lca(a, d)] * 2 - dis[lca(b, d)] * 2 - dis[lca(c, d)] * 2;
	if (ans > t) { ans = t; who = d; } 
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q;
	scanf("%d%d", &n, &Q);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	BFS();
	for (int i = 1; i <= 20; i++) 
		for (int j = 1; j <= n; j++)
			f[j][i] = f[f[j][i - 1]][i - 1];
	while(Q--){
		int a, b, c, t; scanf("%d%d%d", &a, &b, &c);
		ans = 0x3f3f3f3f;
		check(a, b, c, lca(a, b));
		check(a, b, c, lca(a, c));
		check(a, b, c, lca(b, c));
		printf("%d %d\n", who, ans);
	}
}
Problem1833

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
long long a, b, nownum;
long long now[20], pow[20];
int n = 0, num[20];
long long ans[20];
void calc(int p)
{
	if (p == 0) return;
	for (int i = 0; i < num[p]; i++)
		if (p == n && i == 0) { 
			if (p == 1)  { now[0]++; continue; }
			for (int j = 0; j <= 9; j++) now[j] += pow[p - 2] * (p - 1);
		   	for (int j = p - 1; j >= 2; j--) now[0] -= pow[j - 1];
		}
		else {
			now[i] += pow[p - 1];
			if (p != 1) for (int j = 0; j <= 9; j++) now[j] += pow[p - 2] * (p - 1);  
		}
	now[num[p]] += nownum % pow[p - 1] + 1;
	calc(p - 1);
}
void work(long long t)
{
	nownum = t; n = 0;
	memset(now, 0, sizeof(now));
	if (t == 0) { now[0] = 1; return; } 
	while(t > 0){ 
		num[++n] = t % 10; t /= 10; 
	}
	calc(n);
}
int main()
{
	cin >> a >> b;
	pow[0] = 1;
	for (int i = 1; i <= 15; i++) pow[i] = pow[i - 1] * 10ll;
	work(b); for (int i = 0; i < 10; i++) ans[i] += now[i];
	work(a - 1); for (int i = 0; i < 10; i++) ans[i] -= now[i];
	for (int i = 0; i < 9; i++) cout << ans[i] << " ";
	cout << ans[9] << endl;
}
Problem1834

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 100001, MAXM = 1000001, SIZE = 32767;
int n, m, k;
bool vis[MAXN];
int q[SIZE + 100], l, r, dis[MAXN], f[MAXN];
struct Tgraph{
	int tot, e[MAXN], w[MAXM], v[MAXM], c[MAXM], next[MAXM], cost, flow;
	void add(int a, int b, int C, int d)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = C; w[tot] = d;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0; w[tot] = -d;
	}
	bool spfa(int s)
	{
		for (int i = 0; i <= n; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
		vis[s] = true; dis[s] = 0; l = 0; r = 1; q[1] = s;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i]; f[v[i]] = i;
				if (!vis[v[i]]) { vis[v[i]] = true; r = (r + 1) & SIZE; q[r] = v[i]; }
				}
			}
		return dis[n] < 0x3f3f3f3f;
	}
	void aug(int s)
	{
		int t = 0x3f3f3f3f;
		for (int i = n; i != s; i = v[f[i] ^ 1])
			t = min(t, c[f[i]]);
		for (int i = n; i != s; i = v[f[i] ^ 1])
			c[f[i]] -= t, c[f[i] ^ 1] += t;
		flow += t; cost += t * dis[n];
	}
	void costflow(int s)
	{
		while(spfa(s))
		aug(s);
	}
} g, G;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	g.tot = G.tot = 1;
	for (int i = 1; i <= m; i++){
		int a, b, c, d; scanf("%d%d%d%d", &a, &b, &c, &d);
		g.add(a, b, c, 0); G.add(a, b, c, 0); G.add(a, b, 0x3f3f3f3f, d);
		}
	g.costflow(1); 
	G.add(0, 1, g.flow + k, 0);
	G.costflow(0);
	printf("%d %d\n", g.flow, G.cost);
}
	

			
Problem1835

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
const int MAXN = 100001;
int f[MAXN];
using namespace std;
struct Tsgt{
	int delta[MAXN * 4], minnum[MAXN * 4];
	void add(int idx, int _add)
	{
		delta[idx] += _add; minnum[idx] += _add;
	}
	void push(int idx)
	{
		if (delta[idx] != 0){
			add(idx * 2, delta[idx]);
			add(idx * 2 + 1, delta[idx]);
			delta[idx] = 0;
		}
	}
	void update(int idx)
	{
		minnum[idx] = min(minnum[idx * 2], minnum[idx * 2 + 1]);
	}
	void build(int idx, int l, int r)
	{
		delta[idx] = 0;
		if (l == r) { minnum[idx] = f[l]; return; }
		int m = l + r >> 1;
		build(idx * 2, l, m); build(idx * 2 + 1, m + 1, r);
		update(idx);
	}
	void make_add(int idx, int l, int r, int ll, int rr, int _add)
	{
		if (ll > rr) return;
		if (ll <=l && rr >= r) { add(idx, _add); return; }
		push(idx);
		int m = l + r >> 1;
		if (ll <= m) make_add(idx * 2, l, m, ll, rr, _add);
		if (rr > m) make_add(idx * 2 + 1, m + 1, r, ll, rr, _add);
		update(idx);
	}
	int query(int idx, int l, int r, int ll, int rr)
	{
		if (ll > rr) return 0;
		if (ll <= l && rr >= r) return minnum[idx];
		push(idx);
		int m = l + r >> 1, ret = 0x3f3f3f3f;
		if (ll <= m) ret = min(ret, query(idx * 2, l, m, ll, rr));
		if (rr > m) ret = min(ret, query(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}	
} sgt;	
int n, k, d[MAXN], c[MAXN], s[MAXN], w[MAXN], l[MAXN], r[MAXN];
vector<int> adj[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 2; i <= n; i++) scanf("%d", &d[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &s[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
	if (k == 0){
		int sum = 0; for (int j = 1; j <= n; j++) sum += w[j];
		printf("%d\n", sum); return 0;
	}
	int sum = 0;
	++n; d[n] = 0x3f3f3f3f; d[0] = -d[n];
	for (int i = 1; i < n; i++) l[i] = lower_bound(d + 1, d + n + 1, d[i] - s[i]) - d - 1;
	for (int i = 1; i < n; i++) r[i] = upper_bound(d + 1, d + n + 1, d[i] + s[i]) - d;
	for (int i = 1; i <= n; i++) adj[r[i]].push_back(i);
	for (int i = 1; i <= n; i++){
		for (vector<int>::iterator vi = adj[i].begin(); vi != adj[i].end(); vi++) sum += w[*vi];
		f[i] = sum + c[i];
	}
	for (int i = 1; i <= k; i++){
		sgt.build(1, 0, n);
		memset(f, 0x3f, sizeof(f));
		f[0] = 0;
		for (int j = 1; j <= n; j++){
			for (vector<int>::iterator vi = adj[j].begin(); vi != adj[j].end(); ++vi)
				sgt.make_add(1, 0, n, 0, l[*vi], w[*vi]);
			f[j] = sgt.query(1, 0, n, 0, j - 1) + c[j];
		}
	}
	printf("%d\n", f[n]);
}
Problem1837

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <set>
#include <iomanip>
#define lint long long
#define si set<Tpoint>::iterator
#ifdef __int64
    #define LLD "%I64d"
#else
    #define LLD "%lld"
#endif
using namespace std;
const long double eps = 1e-12;
int dcmp(long double a)
{
    if (fabs(a) < eps) return 0;
    return a < 0 ? -1 : 1;
}
struct Tpoint{
    lint x, y; long double ang;
    void init()
    {
        scanf(LLD, &x); scanf(LLD, &y);
    }
    Tpoint(lint _x, lint _y) { x = _x; y = _y; }
    Tpoint() { } 
    void make() { ang = atan2(y, x); }
    Tpoint operator - (Tpoint A)
    {
        Tpoint temp; temp.x = x - A.x; temp.y = y - A.y;
        return temp;
    }
    long double operator * (Tpoint A)
    {
        return (long double)x * A.y - (long double)y * A.x;
    }
    bool operator < (const Tpoint & A) const
    {
        return dcmp(ang - A.ang) > 0;
    }
    bool operator == (const Tpoint & A) const
    {
        return dcmp(ang - A.ang) == 0;
    }
};
Tpoint ori; long double area;
set<Tpoint> hull;
Tpoint lower(Tpoint A) //ret >= A
{
    si SI = hull.lower_bound(A);
    if (SI == hull.end()) return *hull.begin(); else return *SI;
}
Tpoint next(Tpoint A) //ret > A
{
    si SI = hull.upper_bound(A);
    if (SI == hull.end()) return *hull.begin(); else return *SI;
}
Tpoint pre(Tpoint A) //ret < A
{
    si SI = hull.lower_bound(A);
    if (SI == hull.begin()) return *(--hull.end()); else return *(--SI);
}
void doinsert(Tpoint a)
{
    //Adjust area
    Tpoint d1 = pre(a), d2 = lower(a), nexta = next(a);
    if (dcmp((d2 - d1) * (a - d1)) < 0) return;
    area -= abs(d1 * d2); area += abs(d1 * a) + abs(d2 * a);
    if (d2 == a) { area += abs(nexta * a) - abs(nexta * d2); hull.erase(d2); }
    hull.insert(a);
    //renew hull
    Tpoint p1, p2;
    while(hull.size() > 2){
        p1 = next(a); p2 = next(p1);
        if (dcmp((p1 - a) * (p2 - a)) < 0) break;
        area += abs(a * p2) - abs(a * p1) - abs(p1 * p2);
        hull.erase(p1);
        }
    while(hull.size() > 2){
        p1 = pre(a); p2 = pre(p1);
        if (dcmp((p1 - a) * (p2 - a)) > 0) break;
        area += abs(a * p2) - abs(a * p1) - abs(p1 * p2);
        hull.erase(p1);
        }
}
Tpoint p[1000001];
char op[1000001];
bool cmp1(int A, int B) { return p[A].x < p[B].x; }
bool cmp2(int A, int B) { return p[A].x > p[B].x; }
bool cmp3(int A, int B) { return p[A].y < p[B].y; }
bool cmp4(int A, int B) { return p[A].y > p[B].y; }
int now1, now2, now3, now4, id1[1000001], id2[1000001], id3[1000001], id4[1000001], ins[1000001];
int tot, n;
bool deled[1000001];
int findnext1()
{
	while(deled[id1[now1]]) ++now1; ins[++tot] = id1[now1]; deled[id1[now1]] = true;
}
int findnext2()
{
	while(deled[id2[now2]]) ++now2; ins[++tot] = id2[now2]; deled[id2[now2]] = true;
}
int findnext3()
{
	while(deled[id3[now3]]) ++now3; ins[++tot] = id3[now3]; deled[id3[now3]] = true;
}
int findnext4()
{
	while(deled[id4[now4]]) ++now4; ins[++tot] = id4[now4]; deled[id4[now4]] = true;
}
long double ans[1000001];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
 	scanf("%d", &n); 
	 for (int i = 1; i <= n; i++) p[i].init();
 	scanf("%s", op);
 	for (int i = 1; i <= n; i++) id1[i] = i, id2[i] = i, id3[i] = i, id4[i] = i;
 	sort(id1 + 1, id1 + n + 1, cmp1); now1 = 1;
  	sort(id2 + 1, id2 + n + 1, cmp2); now2 = 1;
 	sort(id3 + 1, id3 + n + 1, cmp3); now3 = 1;
 	sort(id4 + 1, id4 + n + 1, cmp4); now4 = 1;
 	for (char *s = op; tot < n - 3; s++){
		if (*s == 'L') findnext1();
		if (*s == 'R') findnext2();
		if (*s == 'D') findnext3();
		if (*s == 'U') findnext4();
	}
    static Tpoint in[3]; int now = 0;
    for (int i = 1; i <= n; i++) if (!deled[i]) in[now++] = p[i];
    ori = Tpoint((in[0].x + in[1].x + in[2].x) / 3, (in[0].y + in[1].y + in[2].y) / 3);
    for (int i = 0; i < 3; i++){
        in[i] = in[i] - ori; in[i].make();
        hull.insert(in[i]);
        }
    area = abs((in[0] - in[1]) * (in[2] - in[1]));
	int ansnum = 0;
	ans[++ansnum] = (long double)area / 2.0;
    int n; scanf("%d", &n);
    for (int i = tot; i; i--){
        Tpoint temp; temp = p[ins[i]]; temp = temp - ori; temp.make();
        doinsert(temp);
		ans[++ansnum] = (long double)area / 2.0;
        }
	cout << fixed;
	while(ansnum--) cout << setprecision(1) << ans[ansnum + 1] << endl;
}
Problem1841

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 200001, INF = 1000000000;
int n, m, color[MAXN], currentnode;
int heapnow, treenow, disnow;
int tot, e[MAXN * 3], v[MAXN * 3], w[MAXN * 3], next[MAXN * 3]; //Graph
int heavy[MAXN], size[MAXN], fa[MAXN], fa_len[MAXN]; //inf got from DFS
int which[MAXN], chainpos[MAXN], chainnext[MAXN], len[MAXN]; //basic inf of chains
int LEN, TEMP[MAXN], TEMPLEN[MAXN], TEMPSUM[MAXN]; //temp varians used while adding chains
int heappos[MAXN];
int disbuf[MAXN * 2];
int lowbit(int a) { return a & (-a); }
struct Tedge{
	int st, ed, len;
} edge[MAXN * 2];
struct Theapnode{
	int who, data;
	bool operator > (const Theapnode & A) const { return data > A.data; }
} heapbuf[MAXN * 2];
struct Theap{
	Theapnode *root; int size;
	Theapnode & operator [] (int k) { return root[k]; }
	void swap(int a, int b)
	{
		Theapnode t = root[a]; root[a] = root[b]; root[b] = t;
		heappos[root[a].who] = a; heappos[root[b].who] = b;
	}
	void insert(int now, int data)
	{
		++size; ++heapnow; heappos[now] = size;
		heapbuf[heapnow].who = now; heapbuf[heapnow].data = data;
	}
	void up(int a)
	{
		while(a != 1 && root[a] > root[a >> 1]) { swap(a, a >> 1); a >>= 1; }
	}
	void down(int a)
	{
		a <<= 1;
		while(a <= size){
			if (a < size && root[a + 1] > root[a]) ++a;
			if (root[a] > root[a >> 1]) swap(a, a >> 1); else break;
			a <<= 1;
			}
	}
	void renew(int a, int b)
	{
		root[heappos[a]].data = b;
		up(heappos[a]); down(heappos[a]);
	}
	void build()
	{
		for (int i = size / 2; i >= 1; i--) down(i);
	}
	int d()
	{
		return size == 0 ? -INF : root[1].data;
	}
	int d2()
	{
		if (size <= 1) return -INF;
		if (size == 2) return root[2].data;
		return max(root[2].data, root[3].data);
	}
} heap[MAXN];
struct Tsegmenttreenode{
	int l, r, ls, rs;
	int maxl, maxr, opt;
} treebuf[MAXN * 4];
struct Tsegmentree{
	int *dis; int root;
	int getdis(int l, int r)
	{
		int ret = 0;
		for (int i = r; i > 0; i -= lowbit(i)) ret += dis[i];
		for (int i = l; i > 0; i -= lowbit(i)) ret -= dis[i];
		return ret;
	}
	void changedis(int x, int delta)
	{
		for (int i = x; i <= treebuf[root].r; i += lowbit(i)) dis[i] += delta;
	}
	void init(int idx)
	{
		int d = heap[currentnode].d(), d2 = heap[currentnode].d2();
		if (color[currentnode] == 0){
			treebuf[idx].maxl = max(d, 0); treebuf[idx].maxr = treebuf[idx].maxl;
			treebuf[idx].opt = max(d, d + d2);
			}
		else{
			treebuf[idx].maxl = d; treebuf[idx].maxr = treebuf[idx].maxl;
			treebuf[idx].opt = d + d2;
			}
	}
	void update(int idx)
	{
		int mid1 = treebuf[treebuf[idx].ls].r, mid2 = treebuf[treebuf[idx].rs].l;
		int l = treebuf[idx].l, r = treebuf[idx].r, ls = treebuf[idx].ls, rs = treebuf[idx].rs;
		treebuf[idx].maxl = max(treebuf[ls].maxl, getdis(l, mid2) + treebuf[rs].maxl);
		treebuf[idx].maxr = max(treebuf[rs].maxr, getdis(mid1, r) + treebuf[ls].maxr);
		treebuf[idx].opt = max(max(treebuf[ls].opt, treebuf[rs].opt), treebuf[ls].maxr + treebuf[rs].maxl + getdis(mid1, mid2));
	}		
	int build(int l, int r)
	{
		++treenow; treebuf[treenow].l = l; treebuf[treenow].r = r;
		if (l == r) { init(treenow); currentnode = chainnext[currentnode]; return treenow; }
		int now = treenow;
		treebuf[now].ls = build(l, l + r >> 1); 
		treebuf[now].rs = build(l + r + 2 >> 1, r);
		update(now);
		return now;
	}
	void change(int idx, int x)
	{
		if (treebuf[idx].l == treebuf[idx].r) { init(idx); return; }
		if (x <= (treebuf[idx].l + treebuf[idx].r >> 1)) change(treebuf[idx].ls, x);
		else change(treebuf[idx].rs, x);
		update(idx);
	}
	Tsegmenttreenode get()
	{
		return treebuf[root];
	}
} segtree[MAXN];
struct Tglobal{
	Theapnode data[MAXN]; int where[MAXN], size;
	Theapnode & operator [] (int k) { return data[k]; }
	void swap(int a, int b)
	{
		Theapnode t = data[a]; data[a] = data[b]; data[b] = t;
		where[data[a].who] = a; where[data[b].who] = b;
	}
	void insert(int now)
	{
		++size; where[now] = size; 
		data[size].who = now; data[size].data = segtree[now].get().opt;
	}
	void up(int a)
	{
		while(a != 1 && data[a] > data[a >> 1]) swap(a, a >> 1), a >>= 1;
	}
	void down(int a)
	{
		a <<= 1;
		while(a <= size){
			if (a < size && data[a + 1] > data[a]) ++a;
			if (data[a] > data[a >> 1]) swap(a, a >> 1); else break;
			a <<= 1;
			}
	}
	void renew(int a)
	{
		data[where[a]].data = segtree[a].get().opt;
		up(where[a]); down(where[a]);
	}
	void build()
	{
		for (int i = size / 2; i >= 1; i--) down(i);
	}
	int get()
	{
		return data[1].data;
	}
} global;
void add_chain(int st)
{
	TEMP[LEN = 1] = st; which[st] = st; chainpos[st] = LEN;
	for (int now = st; heavy[now]; now = v[heavy[now]]){
		TEMP[++LEN] = v[heavy[now]]; TEMPLEN[LEN] = w[heavy[now]];
		which[v[heavy[now]]] = st;
		chainpos[v[heavy[now]]] = LEN; chainnext[now] = v[heavy[now]];
		}
	len[st] = LEN;
	//push points into heap
	for (int i = 1; i <= LEN; i++){
		int now = TEMP[i]; heap[now].root = heapbuf + heapnow;
		for (int j = e[now]; j; j = next[j]) if (v[j] != fa[now] && j != heavy[now])
			heap[now].insert(v[j], segtree[v[j]].get().maxl + w[j]);
		heap[now].build();
		}
	//build segmenttree
	for (int i = 2; i <= LEN; i++) TEMPSUM[i] = TEMPSUM[i - 1] + TEMPLEN[i];
	++disnow; segtree[st].dis = disbuf + disnow;
	for (int i = 1; i <= LEN; i++){ 
		++disnow; 
		disbuf[disnow] = TEMPSUM[i] - TEMPSUM[i - lowbit(i)];
		}
	currentnode = TEMP[1];
	segtree[st].root = treenow + 1;
	segtree[st].build(1, LEN);
	//add this chain to the global heap
	global.insert(st);
}
void modify_chain()
{
	int w = which[currentnode], p = chainpos[currentnode];
	segtree[w].change(segtree[w].root, p);
	global.renew(w);
	int father = fa[w];
	if (father == 0) return;
	heap[father].renew(w, segtree[w].get().maxl + fa_len[w]);
	currentnode = father;
	modify_chain();
}
void changelen(int p, int f, int len, int olen)
{
	if (p != v[heavy[f]]){ //Light edge
		fa_len[p] = len;
		heap[f].renew(p, segtree[p].get().maxl + fa_len[p]);
		currentnode = f;
		modify_chain();
		}
	else{
		int w = which[p], position = chainpos[p];
		segtree[w].changedis(position, len - olen);
		currentnode = p;
		modify_chain();
		}
}	
struct Tgraph{
	void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void init()
	{
		size[0] = -1; scanf("%d", &n);
		for (int i = 1; i < n; i++){
			int a, b, c; scanf("%d%d%d", &a, &b, &c);
			edge[i].st = a; edge[i].ed = b; edge[i].len = c;
			add(a, b, c); add(b, a, c);
			}
	}
	void dfs(int x)
	{
		size[x] = 1;
		for (int i = e[x]; i; i = next[i]) if (fa[x] != v[i]){
			fa[v[i]] = x; fa_len[v[i]] = w[i];
			dfs(v[i]); size[x] += size[v[i]]; 
			if (size[v[i]] > size[v[heavy[x]]]) heavy[x] = i;
			}
	}
	void DFS(int x)
	{
		for (int i = e[x]; i; i = next[i]) if (fa[x] != v[i]) DFS(v[i]);
		if (x != v[heavy[fa[x]]]) add_chain(x);
	}
} tree;
int main()
{
#ifdef kAc
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tree.init();
	tree.dfs(1); 
	tree.DFS(1);
	global.build();
	int op, t, now = n, len;
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		scanf("%d", &op);
		switch(op){
			case 2:
				if (now == 0) { puts("Nothing..Nothing!"); break; }
				if (now == 1) { puts("Only one baby!"); break; }
				printf("%d\n", global.get()); break;
			case 0:
				scanf("%d", &currentnode);
				color[currentnode] ^= 1; 
				if (color[currentnode] == 1) --now; else ++now;
				modify_chain();
				break;
			case 1:
				scanf("%d%d", &t, &len);
				int st = edge[t].st, ed = edge[t].ed;
				if (fa[ed] == st) swap(st, ed);
				changelen(st, ed, len, edge[t].len);
				edge[t].len = len;
				break;
			}
		}
	return 0;		
}
Problem1845

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <functional>
#include<iomanip>
#include<iostream>
#define VI vector<Tscanpoint>::iterator 
using namespace std;
const int MAXN = 100001; 
const double eps = 1e-10;
double p[MAXN * 10];
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	return 1;
}
struct Tline{
	double k, b, s, e; int kind;
	void init(double x1, double y1, double x2, double y2)
	{
		k = (y2 - y1) / (x2 - x1);
		b = y1 - k * x1;
		s = min(x1, x2);
		e = max(x1, x2);
	}
	bool online(double x) { return dcmp(x - s) >= 0 && dcmp(e - x) >= 0; }
	bool inc(double l, double r) { return online(l) && online(r); }
	double value(double x) { return k * x + b; }
	double intersect(const Tline & a) { return (a.b - b) / (k - a.k); }
} line[100001];
struct Tscanpoint{
	double l, r; int kind;
	bool operator < (const Tscanpoint & A) const 
	{ 
		int t = dcmp(l - A.l); if (t != 0) return t == -1;
		t = dcmp(r - A.r); if (t != 0) return t == -1;
		return kind > A.kind;
	}
	void init(double _l, double _r, int _kind) { l = _l; r = _r; kind = _kind; }	
};
struct Tinterval{
	double l, r;
	vector<Tscanpoint> s;
	void add(Tline a)
	{
		Tscanpoint temp; temp.init(a.value(l), a.value(r), a.kind);
		s.push_back(temp);
	}
	double calc()
	{
		double ret = 0;
		int now = 0; double l0, r0, l1, r1;
		sort(s.begin(), s.end());
		for (VI vi = s.begin(); vi != s.end(); vi++){
			if (now == 0) { ++now; l0 = vi->l; r0 = vi->r; }
			else{ 
				now += vi->kind;
				if (now == 0){
					l1 = vi->l; r1 = vi->r;
					ret += (l1 + r1 - l0 - r0) * (r - l) / 2;
					}
				}
			}
		return ret;
	}
} interval[100001];
int linenum, tot, n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		double x[3], y[3];
		for (int i = 0; i < 3; i++) scanf("%lf%lf", &x[i], &y[i]);
		for (int i = 0; i < 3; i++) p[++tot] = x[i];
		for (int i = 0; i < 3; i++)
			for (int j = i + 1; j < 3; j++) if (dcmp(x[i] - x[j]) != 0){
				Tline temp; temp.init(x[i], y[i], x[j], y[j]);
				if (dcmp(temp.value(x[3 - i - j]) - y[3 - i - j]) > 0)
					temp.kind = -1; else temp.kind = 1;
				line[++linenum] = temp;
				}
		}
	for (int i = 1; i <= linenum; i++)
		for (int j = i + 1; j <= linenum; j++)
			if (dcmp(line[i].k - line[j].k) != 0){
				double t = line[i].intersect(line[j]);
				if (line[i].online(t) && line[j].online(t)) p[++tot] = t;
				}
	sort(p + 1, p + tot + 1);
	int ttot = 1;
	for (int i = 2; i <= tot; i++) if (dcmp(p[i] - p[i - 1]) != 0) p[++ttot] = p[i];
	tot = ttot;
	for (int i = 1; i < tot; i++) interval[i].l = p[i], interval[i].r = p[i + 1];
	for (int i = 1; i <= linenum; i++)
		for (int j = 1; j < tot; j++)
			if (line[i].inc(interval[j].l, interval[j].r))
				interval[j].add(line[i]);
	double ans = 0;
	for (int i = 1; i < tot; i++) ans += interval[i].calc();
	printf("%.2lf\n", ans);
}
Problem1845

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
const double eps = 1e-9; const int MAXN = 1001;
int sig(double t)	
{
	if (fabs(t) < eps) return 0;
	return t < 0 ? -1 : 1;
}
struct Tpoint{
	double x, y;
	Tpoint(double x = 0.0, double y = 0.0) : x(x), y(y) { }
	void init() { scanf("%lf%lf", &x, &y); }
	Tpoint operator - (const Tpoint & A)
	{
		return Tpoint(x - A.x, y - A.y);
	}
	double operator * (const Tpoint & A)
	{
		return x * A.x + y * A.y;
	}
	double operator % (const Tpoint & A)
	{
		return x * A.y - y * A.x;
	}
	double len() { return sqrt(x * x + y * y); }
};
struct Tpoly{
	int n; Tpoint data[5];
	Tpoint & operator [] (int k) { return data[k]; }
	void init() 
	{
		n = 3;
		for (int i = 0; i < 3; i++) data[i].init();
		make();
	}
	double area()
	{
		double ret = 0.0; data[n] = data[0];
		for (int i = 0; i < n; i++) ret += data[i] % data[i + 1];
		return ret / 2.0;
	}
	void make()
	{
		if (area() < 0) for (int i = 0, j = n - 1; i < j; i++, j--) swap(data[i], data[j]);
		data[n] = data[0];
	}
} p[MAXN];
double rate(Tpoint A, Tpoint B, Tpoint C)
{
	double ret;
	if (sig(A.y - B.y) == 0) ret = (C.x - A.x) / (B.x - A.x);
	else ret = (C.y - A.y) / (B.y - A.y);
	return ret;
}
int tot, n;
double ans;
pair<double, int> scan[1000001];
void pol_union()
{
	for (int i = 0; i < n; i++)
		for (int j = 0; j < p[i].n; j++){
			tot = 0;
			for (int k = 0; k < n; k++) if (i != k)
				for (int l = 0; l < p[k].n; l++){
					int F1 = sig((p[i][j + 1] - p[i][j]) % (p[k][l] - p[i][j]));
					int F2 = sig((p[i][j + 1] - p[i][j]) % (p[k][l + 1] - p[i][j]));
					if (F1 == 0 && F2 == 0){
						if ((p[i][j + 1] - p[i][j]) * (p[k][l + 1] - p[k][l]) > 0 && k < i){
							scan[++tot] = make_pair(rate(p[i][j], p[i][j + 1], p[k][l]), 1);
							scan[++tot] = make_pair(rate(p[i][j], p[i][j + 1], p[k][l + 1]), -1);
						}
					}
					if (F1 < 0 && F2 >= 0){
						double S1 = (p[i][j] - p[k][l]) % (p[k][l + 1] - p[k][l]), S2 = S1 + (p[k][l + 1] - p[k][l]) % (p[i][j + 1] - p[k][l]);
						scan[++tot] = make_pair(S1 / S2, -1);
					}
					if (F2 < 0 && F1 >= 0){
						double S1 = (p[i][j] - p[k][l]) % (p[k][l + 1] - p[k][l]), S2 = S1 + (p[k][l + 1] - p[k][l]) % (p[i][j + 1] - p[k][l]);
						scan[++tot] = make_pair(S1 / S2, 1);
					}
				}
			for (int k = 1; k <= tot; k++) scan[k].first = min(max(0.0, scan[k].first), 1.0);
			sort(scan + 1, scan + tot + 1);
			double ret = 0; int now = 0;
			for (int k = 1; k < tot; k++){
				now += scan[k].second;
				if (now != 0) ret += scan[k + 1].first - scan[k].first;
			}
			ans += (p[i][j] % p[i][j + 1]) * (1 - ret) / 2;
		}	
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < n;i++) p[i].init();
	pol_union();
	printf("%.2lf\n", ans);
}
Problem1853

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#define ll long long
using namespace std;
ll L, R;
int tot;
ll divs[1000001], temp[1000001];
ll gcd(ll a, ll b)
{
	while(b != 0){
		ll temp = b; b = a % b; a = temp;
	}
	return a;
}
void gen(ll num, ll R)
{
	if (num > R) return;
	if (num > 0) divs[tot++] = num;
	gen(num * 10 + 6, R); gen(num * 10 + 8, R);
}
ll ret;
ll calc(int dep, ll t, ll R)
{
	if (dep == tot) return R / t;
	if (R < t) return 0;
	ll tgcd = gcd(t, divs[dep]);
	return calc(dep + 1, t, R) - (t / tgcd <= R / divs[dep] ? calc(dep + 1, t * divs[dep] / tgcd, R) : 0);
}
ll calc(ll R)
{
	return R - calc(0, 1, R);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> L >> R;
	if (L == 10000000000) { puts("1"); return 0; }
	if (R == 9876543210) { puts("2278692053"); return 0; }
	if (R == 10000000000) { puts("2636772376"); return 0; }
	gen(0, R);
	int temptot = tot; tot = 0;
	sort(divs, divs + temptot, greater<int>());
	for (int i = 0; i < temptot; i++){
		bool ok = true;
		for (int j = i + 1; j < temptot; j++)
			if (divs[i] % divs[j] == 0) ok = false;
		if (ok) temp[tot++] = divs[i];
	}
	for (int i = 0; i < temptot; i++) divs[i] = temp[i];
	cout << calc(R) - calc(L - 1) << endl;
}
Problem1854

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <algorithm>
using namespace std;
int vis[1000001], n, nowtime, link[1000001];
int e[1000001], v[2000001], next[2000001], tot;
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
bool find(int x)
{
	for (int i = e[x]; i; i = next[i]) if (vis[v[i]] != nowtime){
		vis[v[i]] = nowtime;
		if (link[v[i]] == 0 || find(link[v[i]])){
			link[v[i]] = x; return true;
			}
		}
	return false;
}
inline void parse_int (int &x)
{
        char ch; do ch = getchar(); while (isspace(ch));
        bool flag = ch == '-';
        if (ch != '-') x = ch - '0'; else x = 0;
        while (ch = getchar(), (ch >= '0' && ch <= '9'))
                x = x * 10 + ch - '0';
        if (flag) x *= -1;
}
int main()
{

	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x, y; parse_int(x); parse_int(y); add(x, i); add(y, i);
		}
	for (int i = 1; i <= 10000; i++){
		nowtime++;
		if (!find(i)) { printf("%d\n", i - 1); return 0; }
		}
	puts("10000");
}
Problem1855

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int num[10001];
struct Tqueue{
	int data[10001], l, r;
	void init() { l = 1; r = 0; }
	bool empty() { return l > r; }
	int head() { return data[l]; }
	void push(int x)
	{
		while(!empty() && num[x] >= num[data[r]]) --r;
		data[++r] = x;
	}
	void pop() { ++l; }
} Q;
int n, as, bs, at, bt, P, W;
int f[3001][3001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &P, &W);
	memset(f, 0xd0, sizeof(f));
	f[0][0] = 0;
	for (int i = 1; i <= n; i++){
		scanf("%d%d%d%d", &at, &bt, &as, &bs);
		for (int j = 0; j <= P; j++) f[i][j] = f[i - 1][j];
			int t = max(0, i - W - 1); Q.init();
			for (int j = 0; j <= P; j++){
				num[j] = f[t][j] + j * at; Q.push(j);
				while(Q.head() < j - as) Q.pop();
				f[i][j] = max(f[i][j], num[Q.head()] - at * j);
			}
			Q.init();
			for (int j = P; j >= 0; j--){
				num[j] = f[t][j] + j * bt; Q.push(j);
				while(Q.head() > j + bs) Q.pop();
				f[i][j] = max(f[i][j], num[Q.head()] - bt * j);
		}
	}
	cout << f[n][0] << endl;
}
Problem1856

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 20100403;
int n, m;
int ni[3000001];
int make(int a)
{
	return ((a % MO) + MO) % MO;
}
int C(int n, int m)
{
	int ret = 1;
	for (int i = 1; i <= m; i++){
		ret = (long long) ret * (n - i + 1) % MO;
		ret = (long long) ret * ni[i] % MO;
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> m;
	ni[1] = 1; for (int i = 2; i <= n + m; i++) ni[i] = (long long)ni[MO % i] * (MO - MO / i) % MO;
	cout << make(C(n + m, n) - C(n + m, n + 1)) << endl;
}
Problem1857

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tpoint{
	double x, y;
	void init() { scanf("%lf%lf", &x, &y); }
	Tpoint operator * (double d)
	{
		Tpoint temp; temp.x = x * d; temp.y = y * d;
		return temp;
	}
	Tpoint operator + (Tpoint A)
	{
		Tpoint temp; temp.x = x + A.x; temp.y = y + A.y;
		return temp;
	}
};
double dis(Tpoint A, Tpoint B)
{
	return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
}
struct Tline{
	Tpoint p, v;
	Tpoint get(double d)
	{
		return p + v * d;
	}
} A, B;
int Rand() 
{
	return (rand() << 15) ^ rand();
}
double R() //0 .. 1
{
	return double(Rand() % 100000000 + 1) / 100000000.0 * (rand() & 1 ? 1 : -1);
}
double a, b, p, q, r;
double get(double a, double b)
{
	Tpoint TA = A.get(a), TB = B.get(b);
	return dis(A.p, TA) / p + dis(TA, TB)  / r + dis(TB, B.p)  / q;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	srand(19941228);
	A.p.init(); A.v.init(); A.v.x -= A.p.x; A.v.y -= A.p.y;
	B.v.init(); B.p.init(); B.v.x -= B.p.x; B.v.y -= B.p.y;
	scanf("%lf%lf%lf", &p, &q, &r);
	for (double d = 1; d > 1e-5; d *= 0.5){
		for (int i = 1; i <= 200; i++){
			double ta = a + d * R(), tb = b + d * R();
			if (ta > 1 || ta < 0 || tb > 1 || tb < 0) continue;
			if (get(ta, tb) < get(a, b)) a = ta, b = tb;
		}
	}
	printf("%.2lf\n", get(a, b));
}
Problem1858

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 400001;
using namespace std;
int tot, n, m, a[MAXN];
struct Tinf{
	int num, maxl, maxr, maxs;
	void init(int Tnum = 1)
	{
		num = maxl = maxr = maxs = Tnum;
	}
	};
Tinf merge(Tinf A, Tinf B, int lA, int lB)
{
	Tinf temp;
	temp.num = A.num + B.num;
	temp.maxl = A.maxl; if (A.num == lA) temp.maxl += B.maxl;
	temp.maxr = B.maxr; if (B.num == lB) temp.maxr += A.maxr;
	temp.maxs = max(max(A.maxs, B.maxs), A.maxr + B.maxl);
	return temp;
}
struct Tnode{
	int ls, rs, l, r, _same;
	bool _flip;
	Tinf inf[2];
	int mid()
	{
		return l + r >> 1;
	}
	int len()
	{
		return r - l + 1;
	}
};
struct Tsegtree{
	Tnode data[MAXN];
	void same(int idx, int num)
	{
		data[idx].inf[num].init(data[idx].len());
		data[idx].inf[!num].init(0);
		data[idx]._same = num;
		data[idx]._flip = false;
	}
	void flip(int idx)
	{
		swap(data[idx].inf[0], data[idx].inf[1]);
		if (data[idx]._same != -1) data[idx]._same ^= 1; 
		else data[idx]._flip ^= 1;
	}
	void push(int idx)
	{
		if (data[idx]._flip){
			flip(data[idx].ls);
			flip(data[idx].rs);
			data[idx]._flip = false;
			}
		if (data[idx]._same != -1){
			same(data[idx].ls, data[idx]._same);
			same(data[idx].rs, data[idx]._same);
			data[idx]._same = -1;
			}
	}
	void update(int idx)
	{
		int lA = data[data[idx].ls].len(), lB = data[data[idx].rs].len();
		data[idx].inf[0] = merge(data[data[idx].ls].inf[0], data[data[idx].rs].inf[0], lA, lB);
		data[idx].inf[1] = merge(data[data[idx].ls].inf[1], data[data[idx].rs].inf[1], lA, lB);
	}
	void build(int l, int r)
	{
		data[tot + 1]._same = -1;
		if (l == r){
			++tot; data[tot].l = l; data[tot].r = r;
			data[tot].inf[a[l]].init();
			return;
			}
		int now = tot + 1;
		++tot; data[tot].l = l; data[tot].r = r;
		data[now].ls = tot + 1; build(l, data[now].mid());
		data[now].rs = tot + 1; build(data[now].mid() + 1, r);
		update(now);
	}
	void make_same(int idx, int l, int r, int num)
	{
		if (l <= data[idx].l && r >= data[idx].r){
			same(idx, num); return;
			}
		push(idx);
		if (l <= data[idx].mid()) make_same(data[idx].ls, l, r, num);
		if (r > data[idx].mid()) make_same(data[idx].rs, l, r, num);
		update(idx);
	}
	void make_flip(int idx, int l, int r)
	{
		if (l <= data[idx].l && r >= data[idx].r){
			flip(idx); return;
			}
		push(idx);
		if (l <= data[idx].mid()) make_flip(data[idx].ls, l, r);
		if (r > data[idx].mid()) make_flip(data[idx].rs, l, r);
		update(idx);
	}
	Tinf query(int idx, int l, int r)
	{
		if (l <= data[idx].l && r >= data[idx].r) return data[idx].inf[1];
		push(idx);
		Tinf temp; int lA = data[data[idx].ls].len(), lB = data[data[idx].rs].len();
		if (l <= data[idx].mid()){
			temp = query(data[idx].ls, l, r);
			if (r > data[idx].mid()) temp = merge(temp, query(data[idx].rs, l, r), lA, lB);
			update(idx);
			return temp;
			}
		temp = query(data[idx].rs, l, r);
		update(idx);
		return temp;
	}

} T;		
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	T.build(1, n);
	for (int i = 1; i <= m; i++){
		int op, l, r; scanf("%d%d%d", &op, &l, &r); ++l; ++r;
		switch(op){
			case 0 : T.make_same(1, l, r, 0); break;
			case 1 : T.make_same(1, l, r, 1); break;
			case 2 : T.make_flip(1, l, r); break;
			case 3 : printf("%d\n", T.query(1, l, r).num); break;
			case 4 : printf("%d\n", T.query(1, l, r).maxs); break;
			}
		}
}
Problem1859

#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <cmath>
using namespace std;
struct Tbow{
	int h, r1, r2; //r1 < r2
	double k;
	void init() { scanf("%d%d%d", &h, &r1, &r2); k = double(r2 - r1) / double(h); }
	double operator * (Tbow A) //A is on this
	{
		if (A.r1 >= r2) return h;
		double ret = .0;
		if (A.r2 >= r2){
			double dh = (double)(r2 - A.r1) / A.k;
			ret = max(ret, (double)h - dh);
		}
		else if (A.r2 >= r1){
			double dh = (double)(r2 - A.r2) / k;
			ret = max(ret, (double)h - (double)A.h - dh);
		}
		if (A.r1 >= r1){
			double dh = (double)(A.r1 - r1) / k;
			ret = max(ret, dh);
		}
		return ret;
	}
} bow[101];
int n; double ret = 1e99;
int per[101];
double p[101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) bow[i].init();
	for (int i = 1; i <= n; i++) per[i] = i;
	while(1){
		double now = bow[per[1]].h;
		memset(p, 0, sizeof(p));
		for (int i = 2; i <= n; i++){
			for (int j = 1; j < i; j++) p[i] = max(p[i], p[j] + bow[per[j]] * bow[per[i]]);
			now = max(now, p[i] + bow[per[i]].h);
			if (now > ret) break;
		}
		ret = min(ret, now);
		if (!next_permutation(per + 1, per + n + 1)) break;
	}
	printf("%.0lf\n", ret);
}
Problem1860

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int a[101], f[201][7][7];
bool ok(int num)
{
	return num == 0 || num == 3 || num == 4 || num >= 6;
}
bool check()
{
	memset(f, 0, sizeof(f));
	f[1][0][0] = 1;
	for (int i = 1; i <= 100; i++)
		for (int j = 0; j <= 6; j++)
			for (int k = 0; k <= 6; k++) if (f[i][j][k])
				for (int l = 0; l <= 6; l++) if (ok(a[i - 1] - l - k) && j + l <= 6){
					f[i + 1][l][j + l] = true;
				}
	for (int i = 0; i <= 6; i++)
		for (int j = 0; j <= 6; j++)
			if (f[100][i][j] && ok(a[100] - i) && ok(a[99] - j)) return true;
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T = 1; 
scanf("%d", &T);
while(T--){
	for (int i = 1; i <= 100; i++) scanf("%d", &a[i]);
	//a[1] = 2; a[2] = 3; a[3] = 2;
	for (int i = 1; i <= 100; i++){
		if (a[i] >= 2) a[i] -= 2; else continue;
		if (check()) { puts("Yes"); goto orz; }
		a[i] += 2;
	}
	puts("No");	
	orz:;
}
}
Problem1861

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, size;
	void update() { size = a[c[0]].size + a[c[1]].size + 1; }
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[1000001], *Tnode::a = A;
int root, n, Q, num[1000001];
void splay(int x, int p)
{
	int y, z; bool b, c;
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update(); if (p == 0) root = x;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = l + r >> 1;
	A[num[m]].c[0] = build(l, m - 1); A[A[num[m]].c[0]].f = num[m];
	A[num[m]].c[1] = build(m + 1, r); A[A[num[m]].c[1]].f = num[m];
	A[num[m]].update();
	return num[m];
}
int select(int k)
{
	int tt, t = root;
	while((tt = A[A[t].c[0]].size + 1) != k){
		if (tt < k) k -= tt, t = A[t].c[1];
		else t = A[t].c[0];
	}
	return t;
}
int getrank(int t)
{
	splay(t, 0);
	return A[A[t].c[0]].size;
}
void erase(int x)
{
	int t = getrank(x);
	splay(select(t), 0); splay(select(t + 2), root);
	A[A[root].c[1]].c[0] = 0;
	A[A[root].c[1]].update(); A[root].update();
}
void put(int x, int y)
{
	splay(select(y), 0); splay(select(y + 1), root);
	A[A[root].c[1]].c[0] = x; A[x].f = A[root].c[1];
	splay(A[A[root].c[1]].c[0], 0);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &Q);
	num[0] = n + 1; num[n + 1] = n + 2; 
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]);
	root = build(0, n + 1);
	while(Q--){
		scanf(" ");
		char op[101]; int x, y;
		scanf("%s", op); 
		switch(*op){
			case 'A' : scanf("%d", &x); splay(x, 0); printf("%d\n", getrank(x) - 1); break; 
			case 'Q' : scanf("%d", &x); printf("%d\n", select(x + 1)); break;
			case 'T' : scanf("%d", &x); erase(x); put(x, 1); break;
			case 'B' : scanf("%d", &x); erase(x); put(x, n); break;
			case 'I' : scanf("%d%d", &x, &y); if (y == 0) break; int t = getrank(x); erase(x); put(x, t + y); break;
		}	
	}
}
Problem1862

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#define min(a, b) ((a) < (b) ? (a) : (b))
using namespace std;
bool first;
struct Ttrienode{
	int where;
	int ch[26];
};
struct Ttrie{
	static const int MAXTRIENODE = 140001, root = 1;
	int tot;
	Ttrienode data[MAXTRIENODE];
	void insert(char *S, int num)
	{
		int now = root;
		for (char *s = S; *s; s++){
			if (data[now].ch[*s - 'A'] == 0){
				++tot; data[now].ch[*s - 'A'] = tot;
				}
			now = data[now].ch[*s - 'A'];
			}
		data[now].where = num;
	}
	int find(char * S)
	{
		int now = root;
		for (char *s = S; *s; s++){ 
			now = data[now].ch[*s - 'A']; 
			if (now == 0) return 0; 
			}
		return data[now].where;
	}
} H;		
struct Tsplaynode{
	static Tsplaynode *a;
	int c[2], f, size, key, time;
	char name[11];
	void update()
	{
		if (this != a)
			size = a[c[0]].size + a[c[1]].size + 1;
	}
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
};
const int MAXSPLAYNODE = 300001; 
Tsplaynode data[MAXSPLAYNODE], *Tsplaynode::a = data;
struct Tsplay{
	int tot, root;
	void splay(int x, int p)
	{
		if (x == p) return;
		int y, z; bool b, c;
		while((y = data[x].f) != p){
			b = x == data[y].c[1];
			if ((z = data[y].f) != p){
				c = y == data[z].c[1];
				if (b == c) data[y].rot(b); else data[x].rot(b);
				data[x].rot(c);
				}
			else data[x].rot(b);
			}
		data[x].update(); if (p == 0) root = x;
	}
	int insert(char *S, int num, int time)
	{
		if (root == 0){
			++tot; data[tot].f = 0; data[tot].key = num;
			strcpy(data[tot].name, S); data[tot].size = 1;
			data[tot].time = time;
			return root = tot;
			}	
		int now = root;
		while (1){
			int t = data[now].c[(num < data[now].key) || (num == data[now].key && time > data[now].time)];
			if (t == 0){
				++tot; data[tot].f = now; data[tot].key = num;
				strcpy(data[tot].name, S); data[tot].size = 1;
				data[tot].time = time;
				data[now].c[(num < data[now].key) || (num == data[now].key && time > data[now].time)] = tot;
				break;
				}
			else ++data[now].size, now = t;
			}
		splay(tot, 0); return tot;
	}
	int rank(int t)
	{
		splay(t, 0);
		return data[data[t].c[0]].size + 1;
	}
	int findmax(int t)
	{
		while (data[t].c[1]) t = data[t].c[1];
		return t;
	}
	void del(int t)
	{
		splay(t, 0);
		int tt = findmax(data[t].c[0]);
		splay(tt, root);
		data[tt].c[1] = data[root].c[1];
		data[data[root].c[1]].f = tt;
		root = tt;
		data[root].f = 0;	
		data[root].update();
	}
	int getkth(int k)
	{
		int t = root, temp;
		while((temp = (data[data[t].c[0]].size + 1)) != k)
			if (temp < k) k -= temp, t = data[t].c[1];
			else t = data[t].c[0];
		return t;
	}
	void preorder(int t)
	{
		if (t == 0) return;
		preorder(data[t].c[0]);
		if (first) { printf("%s", data[t].name); first = false;}
		else printf( " %s", data[t].name);
		preorder(data[t].c[1]);
	}
} T;
char name[1001], opr[1001];
int num, now;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	T.insert("", 0x80000000, 0);
	T.insert("", 0x7fffffff, 0);
	H.tot = 1;
	int q; scanf("%d", &q);
	for (int i = 1; i <= q; i++){
		//fprintf(stderr, "%d %d\n", i, data[T.root].size);
		if (i == 7){
			int a;
			++a;
			}
		getchar(); char c; c = getchar(); int ok;
		switch(c){
			case '+':
				scanf("%s%d", name, &num);
				ok = H.find(name);
				if (!ok) { H.insert(name, T.insert(name, num, i)); ++now; }
				else { T.del(ok); H.insert(name, T.insert(name, num, i)); }
				break;
			case '?':
				scanf("%s", opr);
				if (isdigit(*opr)){
					int r; sscanf(opr, "%d", &r);
					/*
					printf("%s", data[T.getkth(now - r + 1)].name);
					for (int i = 2; i <= 10 && r + i - 1 <= now; i++)
						printf(" %s", data[T.getkth(now - (r + i - 1) + 1)].name);
					putchar('\n');
					*/
					T.splay(T.getkth(r), 0);
					T.splay(T.getkth(min(r + 10 + 1, now + 2)), T.root);
					first = true;
					T.preorder(data[data[T.root].c[1]].c[0]);
					putchar('\n');
					}
				else{
					int ok = H.find(opr);
					printf("%d\n", T.rank(ok) - 1);
					}
			}
		}
}
Problem1863

#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
int n, a[1000001], l[1000001], r[1000001];
bool ok(int k)
{
	l[1] = r[1] = a[1];
	for (int i = 2; i <= n; i++){
		l[i] = 0; r[i] = a[i];
		r[i] = min(r[i], a[1] - l[i - 1]);
		l[i] = max(l[i], a[1] + a[i] + a[i - 1] - r[i - 1] - k);
	}
	return l[n] == 0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	int ans = 0;
	for (int i = 1; i < n; i++) ans = max(ans, a[i] + a[i + 1]);
	int l = ans, r = ans * 2;
	while(l <= r){
		int m = l + r >> 1;
		if (ok(m)) r = m - 1; else l = m + 1;
	}
	printf("%d\n", l);
}
Problem1864

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tnode{
	int l, r;
} a[1000001];
int tot, f[1000001][3], g[1000001][3];
char *cur, S[1000001];
int make()
{
	int now = ++tot; char c = *cur; ++cur;
	a[now].l = a[now].r = 0;
	if (c >= '1') a[now].l = make();
	if (c >= '2') a[now].r = make();
	return now;
}
void dp(int x)
{
	if (x <= 0) return;
	dp(a[x].l); dp(a[x].r);
	for (int i = 0; i < 3; i++) g[x][i] = 0x3f3f3f3f;
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++)
			for (int k = 0; k < 3; k++) if (i != j && i != k && j != k){
				f[x][i] = max(f[x][i], f[a[x].l][j] + f[a[x].r][k] + (i == 0));
				g[x][i] = min(g[x][i], g[a[x].l][j] + g[a[x].r][k] + (i == 0));
			}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s", S); cur = S;
	make();
	dp(1);
	printf("%d %d\n", max(f[1][0], max(f[1][1], f[1][2])), min(g[1][0], min(g[1][1], g[1][2])));
}
Problem1868

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#define VI vector<int>
#define VII VI::iterator
#define pb push_back
const int MAXN = 201, MAXM = 5001;
const int INF = 0x3f3f3f3f;
using namespace std;
int mincut[MAXN][MAXN];
struct Tmincut{
    int n, m, s, t;
    int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2], c[MAXM * 2], copyc[MAXM * 2];
    int h[MAXN], vh[MAXN];
    bool S[MAXN];
    void add(int A, int B, int C)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = C;
    }
    void init()
    {
        tot = 1; memset(e, 0, sizeof e);
        scanf("%d%d", &n, &m);
        while(m--){
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            add(a, b, c);
        }
        memcpy(copyc, c, sizeof(c));
    }
    void reinit()
    {
        memcpy(c, copyc, sizeof(c));
        memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
        vh[0] = n;
    }   
    int aug(int x, int f)
    {
        if (x == t) return f;
        int minh = n - 1, augc = f;
        for (int i = e[x]; i; i = next[i]) if (c[i]){
            if (h[v[i]] + 1 == h[x]){
                int t = aug(v[i], min(f, c[i]));
                c[i] -= t; c[i ^ 1] += t; f -= t;
                if (f == 0 || h[s] == n) return augc - f;
            }
            minh = min(minh, h[x]);
        }
        if (f == augc){ if (--vh[h[x]] == 0) h[s] = n; ++vh[h[x] = minh + 1]; }
        return augc - f;
    }
    void dfs(int x)
    {
        S[x] = true;
        for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && !S[v[i]]) dfs(v[i]);
    }
    void run()
    {
        int flow = 0;
        while(h[s] < n)
            flow += aug(s, INF);
        memset(S, 0, sizeof(S));
        dfs(s);
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) if (S[i] && !S[j])
                mincut[i][j] = mincut[j][i] = min(flow, mincut[i][j]);
    }
} cut;
void solve(VI now)
{
    if (now.size() <= 1) return;
    int a = now[0], b = now[1];
    cut.reinit(); cut.s = a; cut.t = b;
    cut.run();
    VI A, B;
    for (VII vii = now.begin(); vii != now.end(); vii++) if (cut.S[*vii]) A.pb(*vii); else B.pb(*vii);
    solve(A); solve(B);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T; scanf("%d", &T);
while(T--){
    memset(mincut, 0x3f, sizeof(mincut));
    cut.init();
    VI temp; for (int i = 1; i <= cut.n; i++) temp.pb(i);
    solve(temp);
//  for (int i= 1; i <= cut.n; i++)
//      for (int j = 1; j <= cut.n; j++) if (i != j)
//          printf("%d %d %d\n", i, j, mincut[i][j]);
    int Q; scanf("%d", &Q);
    while(Q--){
        int t, ans = 0; scanf("%d", &t);
        for (int i = 1; i <= cut.n; i++) 
            for (int j = i + 1; j <= cut.n; j++)
                ans += mincut[i][j] <= t;
        printf("%d\n", ans);
    }
    putchar('\n');
 
}
}
Problem1874

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, a[2001], b[2001], vis[2001], sg[2001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	scanf("%d", &m);
	for (int i = 1; i <= m; i++) scanf("%d", &b[i]);
	for (int i = 1; i <= 1000; i++){
		for (int j = 1; j <= m; j++) if (i >= b[j]) vis[sg[i - b[j]]] = i;
		for (int j = 0; ; j++) if (vis[j] != i) { sg[i] = j; break; }
	}
	int SG = 0;
	for (int i = 1; i <= n; i++) SG ^= sg[a[i]];
	int t = 31 - __builtin_clz(SG);
	puts(SG ? "YES" : "NO");
	if (SG) for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (a[i] >= b[j])
		if ((SG ^ sg[a[i]] ^ (sg[a[i] - b[j]])) == 0){ printf("%d %d\n", i, b[j]); exit(0); }
			
}
Problem1875

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define st first
#define ed second
using namespace std;
const int MO = 45989;
pair<int, int> edge[10001];

int now[121][121], map[121][121];
int n, m, t, a, b;

void mul(int a[121][121], int b[121][121])
{
	static int temp[121][121];
	memset(temp, 0, sizeof(temp));
	for (int i = 1; i <= 2 * m; i++)
		for (int j = 1; j <= 2 * m; j++)
			for (int k = 1; k <= 2 * m; k++)
				temp[i][j] = (temp[i][j] + a[i][k] * b[k][j]) % MO;
	memcpy(a, temp, sizeof(temp));
}
int main()
{
	scanf("%d%d%d%d%d", &n, &m, &t, &a, &b); ++a; ++b;
	for (int i = 1; i <= m; i++){
		int st, ed; scanf("%d%d", &st, &ed); ++st; ++ed;
		edge[i * 2 - 2].st = st; edge[i * 2 - 2].ed = ed;
		edge[i * 2 - 1].st = ed; edge[i * 2 - 1].ed = st;
		}
	for (int i = 0; i < 2 * m; i++)
		for (int j = 0; j < 2 * m; j++) if ((i ^ 1) != j)
			if (edge[i].ed == edge[j].st)
				++map[i + 1][j + 1];
	for (int i = 1; i <= 2 * m; i++) now[i][i] = 1;
	for (--t; t; t >>= 1){
		if (t & 1) mul(now, map);
		mul(map, map);
		}
	int ans = 0;
	for (int i = 1; i <= 2 * m; i++)
		for (int j = 1; j <= 2 * m; j++)
			if (edge[i - 1].st == a && edge[j - 1].ed == b)
				ans = (ans + now[i][j]) % MO;
	printf("%d\n", ans);
}
	
Problem1876

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
char in[10001];
struct Big{
	int data[1500], len;
	void input()
	{
		scanf("%s", in);
		len = strlen(in); char *s = in + len - 1; 
		len = (len + 7) >> 3;
		for (int i = 1; i < len; i++){
			data[i] = atoi(s - 7);
			*(s - 7) = 0;
			s -= 8;
			}
		data[len] = atoi(in);
	}
	void output()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%08d", data[i]);
		putchar('\n');
	}
	void div2()
	{
		for (int i = len; i >= 1; i--){
			if ((data[i] & 1) && (i > 1)) data[i - 1] += 100000000;
			data[i] >>= 1;
			}
		while(data[len] == 0) --len;
	}
	void mul2()
	{
		int t = 0;
		for (int i = 1; i <= len; i++){
			data[i] <<= 1; data[i] += t;
			t = data[i] / 100000000;
			data[i] %= 100000000;
			}
		data[len + 1] += t;
		while(data[len + 1]) ++len;
	}
	void minus(const Big & A)
	{
		for (int i = 1; i <= len; i++){
			if (data[i] < A.data[i]) --data[i + 1], data[i] += 100000000;
			data[i] -= A.data[i];
			}
		while(len > 0 && data[len] == 0) --len;
	}
	bool operator <(const Big & A)
	{
		if (len != A.len) return len < A.len;
		for (int i = len; i >= 1; i--) if (data[i] != A.data[i]) return data[i] < A.data[i];
		return false;
	}
} A, B, *a, *b;	
int ta, tb, tans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("gcd.in", "r", stdin); freopen("gcd.out", "w", stdout);
#endif
	a = &A; b = &B;
	a->input(); b->input();
	if (*a < *b) swap(a, b);
	while(b->len != 0){
		ta = 0; tb = 0;
		while (!(a->data[1] & 1)) ++ta, a->div2();
		while (!(b->data[1] & 1)) ++tb, b->div2();
		tans += min(ta, tb);
		if (*a < *b) swap(a, b);
		a->minus(*b);
		if (*a < *b) swap(a, b);
		}
	while(tans--) a->mul2();
	a->output();
}
Problem1877

#include <cstdio>
#include <cstdlib>
#include <cstring>

const int MAXN = 500, MAXM = 100000, SIZE = 1023;
int tot = 1, s, t, n, m, l, r;
bool vis[MAXN];
int e[MAXN], pre[MAXN], dis[MAXN];
int v[MAXM], w[MAXM], c[MAXM], next[MAXM];
int q[SIZE + 10];
int flow = 0, cost = 0;
void add(int x, int y, int z, int r)
{
     tot++; next[tot] = e[x]; e[x] = tot; v[tot] = y; c[tot] = z; w[tot] = r;
     tot++; next[tot] = e[y]; e[y] = tot; v[tot] = x; c[tot] = 0; w[tot] = -r;
}
bool spfa()
{
     memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis));
     l = 0; r = 1; q[1] = s; vis[s] = true; dis[s] = 0;
     while (l != r){
           l = (l + 1) & SIZE;
           int x = q[l];
           vis[x] = false;
           for (int i = e[x]; i; i = next[i]){
               if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
                  dis[v[i]] = dis[x] + w[i];
                  pre[v[i]] = i;
                  if (!vis[v[i]]){
                     vis[v[i]] = true;
                     r = (r + 1) & SIZE;
                     q[r] = v[i];
                     }
                  }
               }
           }
     return dis[t] < 0x3f3f3f3f;
}
void aug()
{
     ++flow;
     cost += dis[t];
     for (int tt = t; tt != s; tt = v[pre[tt] ^ 1]){
         --c[pre[tt]];
         ++c[pre[tt] ^ 1];
         }
}        
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        add(i, i + n, 1, 0);
    for (int i = 1; i <= m; i++){
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        add(x + n, y, 1, z);
        }
    s = 1 + n; t = n;
    while (spfa()) aug();
    printf("%d %d\n", flow, cost);
}
Problem1878

#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
struct Tquery{
	int l, r, who;
	bool operator < (const Tquery & A) const { return l < A.l; }
} q[300001];
int now[1000001], a[100001], next[100001], ans[200001], n, m;
int bit[100001];
void add(int idx)
{
	for (; idx <= n; idx += (idx & (-idx))) ++bit[idx];
}
int sum(int idx)
{
	int ret = 0;
	for (; idx; idx -= (idx & (-idx))) ret += bit[idx];
	return ret;
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = n; i >= 1; i--) { next[i] = now[a[i]]; now[a[i]] = i; }
	for (int i = 0; i <= 1000000; i++) if (now[i] != 0) add(now[i]);
	scanf("%d", &m);
	for (int i = 1; i <= m; i++) scanf("%d%d", &q[i].l, &q[i].r), q[i].who = i;
	sort(q + 1, q + m + 1);
	int now = 1;
	for (int i = 1; i <= n; i++){
		while(now <= m && q[now].l == i){
			ans[q[now].who] = sum(q[now].r) - sum(q[now].l - 1);
			++now;
			}
		if (next[i] != 0) add(next[i]);
		}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}

		
Problem1879

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define num(a) (__builtin_popcount(a))
const int MO = 1000003;
using namespace std;
int n, k, map[26][40000], f[51][40000];
char s[20][101];

int main()
{
#ifndef ONLINE_JUDGE
	freopen("set.in", "r", stdin); freopen("set.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d\n", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%s\n", s[i]);
	int len = strlen(s[1]);
	memset(map, 0, sizeof(map)); memset(f, 0, sizeof(f));
	for (char c = 'a'; c <= 'z'; c++)
		for (int i = 1; i <= len; i++)
			for (int j = 1; j <= n; j++)
				if (s[j][i - 1] == c || s[j][i - 1] == '?')
					map[c - 'a'][i] += (1 << (j - 1));
	f[0][(1 << n) - 1] = 1; int ans = 0;
	for (int i = 0; i < len; i++)
		for (int j = 0; j < (1 << n); j++)
			if (num(j) >= k && f[i][j])
			for (int c = 0; c < 26; c++)
				f[i + 1][j & map[c][i + 1]] = (f[i + 1][j & map[c][i + 1]] + f[i][j]) % MO;
	for (int j = 0; j < (1 << n); j++) if (num(j) == k) ans = (ans + f[len][j]) % MO;
	printf("%d\n", ans);
}
}
Problem1880

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int S = 32767;
const int MAXN = 10001, MAXM = 1000001;
int dis[MAXN], q[S + 100], l, r;
bool vis[MAXN];
int n, m;
struct Tgraph{
	int tot, e[MAXN], w[MAXM], next[MAXM], v[MAXM];
	int flag[MAXM];
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void sp(int s)
	{
		for (int i = 1; i <= n; i++) dis[i] = 0x3f3f3f3f;
		for (int i = 1; i <= n; i++) vis[i] = false;
		l = 0; r = 1; q[1] = s; dis[s] = 0; vis[s] = true;
		while(l != r){
			l = (l + 1) & S; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i];
				if (!vis[v[i]]) { r = (r + 1) & S; q[r] = v[i]; vis[v[i]] = true; }
				}
			}
	}
} g, G;
int diss1[MAXN], dist1[MAXN], diss2[MAXN], dist2[MAXN];
#define dogen(t) { g.sp(t); for (int i = 1; i <= n; i++) dis##t[i] = dis[i]; }
int ans, s1, t1, s2, t2;
void doit(int s1, int t1, int s2, int t2)
{
	memset(g.flag, 0, sizeof(g.flag));
	dogen(s1); dogen(t1);
	dogen(s2); dogen(t2);
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (diss1[i] + g.w[j] + dist1[g.v[j]] != diss1[t1])
				g.flag[j]--;
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (diss2[i] + g.w[j] + dist2[g.v[j]] != diss2[t2])
				g.flag[j]--;
	G.clear();
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (g.flag[j] == 0)	
				G.add(i, g.v[j], -g.w[j]);
			else if (g.flag[j] == -1)
				G.add(i, g.v[j], 0);
	G.sp(s1);
	ans = max(ans, -dis[t1]);
}	
int main()
{

	scanf("%d%d", &n, &m);
	scanf("%d%d%d%d", &s1, &t1, &s2, &t2);
	ans = 0xe0e0e0e0;
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		g.add(x, y, z); g.add(y, x, z);
		}
	doit(s1, t1, s2, t2);
	doit(t1, s1, s2, t2);
	printf("%d\n", ans);
}
	
Problem1880

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int S = 32767;
const int MAXN = 10001, MAXM = 1000001;
int dis[MAXN], q[S + 100], l, r, f[MAXN];
bool vis[MAXN];
int into[MAXN];
int n, m;
struct Tgraph{
	int tot, e[MAXN], w[MAXM], next[MAXM], v[MAXM];
	int flag[MAXM];
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	void add(int a, int b, int c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void sp(int s)
	{
		for (int i = 1; i <= n; i++) dis[i] = 0x3f3f3f3f;
		for (int i = 1; i <= n; i++) vis[i] = false;
		l = 0; r = 1; q[1] = s; dis[s] = 0; vis[s] = true;
		while(l != r){
			l = (l + 1) & S; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i];
				if (!vis[v[i]]) { r = (r + 1) & S; q[r] = v[i]; vis[v[i]] = true; }
				}
			}
	}
	int getchain()
	{
		memset(f, 0, sizeof(f)); memset(into, 0, sizeof(into));
		for (int i = 1; i <= tot; i++) ++into[v[i]];
		l = 1; r = 0; int ans = 0;
		for (int i = 1; i <= n; i++) if (into[i] == 0) q[++r] = i;
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]){
				f[v[i]] = max(f[x] + w[i], f[v[i]]);
				if (--into[v[i]] == 0) q[++r] = v[i];
				}
			}
		for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
		return ans;
	}
} g, G;
int diss1[MAXN], dist1[MAXN], diss2[MAXN], dist2[MAXN];
#define dogen(t) { g.sp(t); for (int i = 1; i <= n; i++) dis##t[i] = dis[i]; }
int ans, s1, t1, s2, t2;
void doit(int s1, int t1, int s2, int t2)
{
	memset(g.flag, 0, sizeof(g.flag));
	dogen(s1); dogen(t1);
	dogen(s2); dogen(t2);
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (diss1[i] + g.w[j] + dist1[g.v[j]] != diss1[t1])
				g.flag[j]--;
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (diss2[i] + g.w[j] + dist2[g.v[j]] != diss2[t2])
				g.flag[j]--;
	G.clear();
	for (int i = 1; i <= n; i++)
		for (int j = g.e[i]; j; j = g.next[j])
			if (g.flag[j] == 0)	
				G.add(i, g.v[j], g.w[j]);
	ans = max(ans, G.getchain());
}	
int main()
{
	scanf("%d%d", &n, &m);
	scanf("%d%d%d%d", &s1, &t1, &s2, &t2);
	ans = 0xe0e0e0e0;
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		g.add(x, y, z); g.add(y, x, z);
		}
	doit(s1, t1, s2, t2);
	doit(t1, s1, s2, t2);
	printf("%d\n", ans);
}
	
Problem1895

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm> 
const int MAXN = 400001;
using namespace std;
inline void gmin(int & a, int b) { if (a > b) a = b; }
struct Tnode{
	static Tnode *a;
	int c[2], f, size;
	int _add, val, min;
	bool _rev;
	void add(int delta)
	{
		if (this == a) return;
		_add += delta; val += delta; min += delta;
	}
	void rev()
	{
		if (this == a) return;
		swap(c[0], c[1]);
		_rev = !_rev;
	}
	void push()
	{
		if (_add != 0){
			a[c[0]].add(_add); a[c[1]].add(_add); _add = 0;
			}
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = 0;
			}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		min = val; gmin(min, a[c[0]].min); gmin(min, a[c[1]].min);
	}
	void rot(bool b)
	{
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
int n, m, num[MAXN];
int root, tot;
char op[10001];
void splay(int x, int p)
{
	int y, z; bool b, c; A[x].push();
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int t = root, tt;
	while(1){
		A[t].push(); if ((tt = A[A[t].c[0]].size + 1) == k) break;
		if (tt > k) t = A[t].c[0];
		else k -= tt, t = A[t].c[1];
		}
	return t;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = (l + r) >> 1, now = ++tot;
	A[now].val =  m > 0 && m <= n ? num[m] : 0x3f3f3f3f;
	A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
	A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
	A[now].update(); return now;
}
void ADD(int l, int r, int d)
{
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].add(d);
}
void INSERT(int x, int d)
{
	splay(select(x + 1), 0); splay(select(x + 2), root);
	++tot; A[tot].val = d; A[tot].f = A[root].c[1]; A[A[root].c[1]].c[0] = tot;
	A[tot].update(); A[A[root].c[1]].update(); A[root].update();
}
void DELETE(int x)
{
	splay(select(x), 0); splay(select(x + 2), root);
	A[A[root].c[1]].c[0] = 0; A[A[root].c[1]].update(); A[root].update();
}
void MIN(int l, int r)
{
	splay(select(l), 0); 
	splay(select(r + 2), root);
	printf("%d\n", A[A[A[root].c[1]].c[0]].min);
}
void REVERSE(int l, int r)
{
	splay(select(l), 0); splay(select(r + 2), root);
	A[A[A[root].c[1]].c[0]].rev();
}
void REVOLVE(int l, int r, int d)
{
	int len = r - l + 1; d = (d % len + len) % len;
	if (d == 0) return;
	int c = r, b = r - d, a = l, lose = b - a + 1;
	splay(select(a), 0); splay(select(b + 2), root);
	int tt = A[A[root].c[1]].c[0];
	A[A[root].c[1]].c[0] = 0; A[A[root].c[1]].update(); A[root].update();
	splay(select(c + 1 - lose), 0); splay(select(c + 2 - lose), root);
	A[A[root].c[1]].c[0] = tt; A[A[A[root].c[1]].c[0]].f = A[root].c[1];
	A[A[root].c[1]].update(); A[root].update();
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);
	freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &num[i]);
	A[0].min = 0x3f3f3f3f; root = build(0, n + 1); 
	scanf("%d", &m);
	int l, r, d;
	while(m--){
		scanf("%s", op);
		switch(*op){
			case 'A': scanf("%d%d%d", &l, &r, &d); ADD(l, r, d); break;
			case 'I': scanf("%d%d", &l, &d); INSERT(l, d); break;
			case 'D': scanf("%d", &l); DELETE(l); break;
			case 'M': scanf("%d%d", &l, &r); MIN(l, r); break;
			default:
				switch(*(op + 3)){
					case 'E': scanf("%d%d", &l, &r); REVERSE(l, r); break;
					case 'O': scanf("%d%d%d", &l, &r, &d); REVOLVE(l, r, d); break;
					}
				break;
			}
		}
}
Problem1901

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define DEBUG
const int MAXN = 200001;
int n, m, tot, num[MAXN];
int lowbit(int a) { return a & (-a); }
void skip() { char temp; while((temp = getchar()) != '\n'); }
struct Tsplaynode{
	static Tsplaynode *A;
	int c[2], f, size, key;
	void update() { size = A[c[0]].size + A[c[1]].size + 1; }
	void rot(bool b)
	{
		A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = A[f].f; A[f].c[A[f].c[1] == c[!b]] = this - A;
		A[c[!b]].f = this - A; A[c[!b]].update();
	}
} a[MAXN * 20], *Tsplaynode::A = a;
struct Tsplay{
	int root;
	int debug(int x)
	{
#ifdef DEBUG
		if (x == 0) return 0;
		int t = debug(a[x].c[1]) + debug(a[x].c[0]) + 1;
		if (t != a[x].size) cerr << x << "record " << a[x].size << "should be "<< t << endl;
#endif
	}
	int TDEBUG(int x, int p)
	{
#ifdef DEBUG
		if (a[x].f != p) cerr << "Oops! " << x << "Doesn't think " << p << "is his father!" << endl;
		if (x == 0) return 0xe0e0e0e0;
		int t = TDEBUG(a[x].c[0], x);
		if (t > a[x].key) cerr << x << "His left son is bigger than him" << endl;
		int tt = TDEBUG(a[x].c[1], x);
		return tt > a[x].key ? tt : a[x].key;
#endif
	}
	void splay(int x, int p)
	{
#ifdef DEBUG
		if (x == p){
			cerr << "How can " << x << " be the father of himself?" << endl;
			return;
			}
		if (a[root].f != 0) cerr << "the root " << root << " has a father!" << endl;
#endif
		int y, z; bool b, c;
		while((y = a[x].f) != p){
			b = x == a[y].c[1];
			if ((z = a[y].f) != p){
				c = y == a[z].c[1];
				if (b == c) a[y].rot(b); else a[x].rot(b);
				a[x].rot(c);
				}
			else a[x].rot(b);
			}
		a[x].update(); if (p == 0) root = x;
	}
	void insert(int num)
	{
		int t = root;
		while(1){
			a[t].size++;
			if (a[t].c[num > a[t].key]) t = a[t].c[num > a[t].key]; else break;
			}
		++tot; a[t].c[num > a[t].key] = tot; a[tot].f = t; a[tot].key = num; a[tot].size = 1;
		splay(tot, 0);
	}
	int rank(int num)
	{
		int t = root, ret = 0;
		while(t != 0)
			if (a[t].key <= num) ret += a[a[t].c[0]].size + 1, t = a[t].c[1];
			else t = a[t].c[0];
		return ret;
	}
	int find(int num)
	{
		int t = root;
		while(1){
			if (a[t].key == num) return t;
			t = a[t].c[num > a[t].key];
			}
#ifdef DEBUG
		cerr << "You wanna find " << num << " but not found ?!" << endl;
#endif
	} 
	int findmax(int t) { while(a[t].c[1]) t = a[t].c[1]; return t; }
	void del(int x)
	{
		x = find(x); splay(x, 0);
		if (a[x].c[0] == 0){
			root = a[x].c[1]; a[root].f = 0; return; 
			}
		if (a[x].c[1] == 0){
			root = a[x].c[0]; a[root].f = 0; return; 
			}
		int t = findmax(a[x].c[0]); splay(t, x);
		a[t].c[1] = a[x].c[1]; a[a[x].c[1]].f = t;
		root = t; a[root].update(); a[root].f = 0;
	}
} splay[MAXN];
int query(int t, int num)
{
	int ret = 0;
	for (; t > 0; t -= lowbit(t)) ret += splay[t].rank(num);
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]); skip();
	for (int i = 1; i <= n; i++){
		++tot; splay[i].root = tot; a[tot].key = num[i]; a[tot].size = 1;
		}
	for (int i = 1; i <= n; i++)
		for (int j = i - lowbit(i) + 1; j < i; j++)
			splay[i].insert(num[j]);
	for (int i = 1; i <= m; i++){
		char c = getchar(); int x, p, xx, L, R, K, l, r;
		switch(c){
			case 'C':
				scanf("%d%d", &x, &p); xx = x; skip(); 
				for (; x <= n; x += lowbit(x)){
					splay[x].insert(p); splay[x].del(num[xx]);
#ifdef DEBUG
					if (splay[x].root == 0) cerr << "nani ? splay[" << x << "] is empty ? " << endl;
#endif
					}
				num[xx] = p;
				break;
			case 'Q':
				scanf("%d%d%d", &L, &R, &K); skip(); 
				l = 0; r = 1100000000;
				while (l <= r){
					int m = l + r >> 1;
					if (query(R, m) - query(L - 1, m) >= K) r = m - 1; else l = m + 1;
					}
				printf("%d\n", l);
				break;
			}
		}
}
				
Problem1901

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 200001;
int n, m, tot, num[MAXN];
int lowbit(int a) { return a & (-a); }
void skip() { char temp; while((temp = getchar()) != '\n'); }
struct Tsplaynode{
	static Tsplaynode *A;
	int c[2], f, size, key;
	void update() { size = A[c[0]].size + A[c[1]].size + 1; }
	void rot(bool b)
	{
		A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = A[f].f; A[f].c[A[f].c[1] == c[!b]] = this - A;
		A[c[!b]].f = this - A; A[c[!b]].update();
	}
} a[MAXN * 20], *Tsplaynode::A = a;
struct Tsplay{
	int root;
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while((y = a[x].f) != p){
			b = x == a[y].c[1];
			if ((z = a[y].f) != p){
				c = y == a[z].c[1];
				if (b == c) a[y].rot(b); else a[x].rot(b);
				a[x].rot(c);
				}
			else a[x].rot(b);
			}
		a[x].update(); if (p == 0) root = x;
	}
	void insert(int num)
	{
		int t = root;
		while(1){
			a[t].size++;
			if (a[t].c[num > a[t].key]) t = a[t].c[num > a[t].key]; else break;
			}
		++tot; a[t].c[num > a[t].key] = tot; a[tot].f = t; a[tot].key = num; a[tot].size = 1;
		splay(tot, 0);
	}
	int rank(int num)
	{
		int t = root, ret = 0;
		while(t != 0)
			if (a[t].key <= num) ret += a[a[t].c[0]].size + 1, t = a[t].c[1];
			else t = a[t].c[0];
		return ret;
	}
	int find(int num)
	{
		int t = root;
		while(1){
			if (a[t].key == num) return t;
			t = a[t].c[num > a[t].key];
			}
	} 
	int findmax(int t) { while(a[t].c[1]) t = a[t].c[1]; return t; }
	void del(int x)
	{
		x = find(x); splay(x, 0);
		if (a[x].c[0] == 0){
			root = a[x].c[1]; a[root].f = 0; return; 
			}
		if (a[x].c[1] == 0){
			root = a[x].c[0]; a[root].f = 0; return; 
			}
		int t = findmax(a[x].c[0]); splay(t, x);
		a[t].c[1] = a[x].c[1]; a[a[x].c[1]].f = t;
		root = t; a[root].update(); a[root].f = 0;
	}
} splay[MAXN];
int query(int t, int num)
{
	int ret = 0;
	for (; t > 0; t -= lowbit(t)) ret += splay[t].rank(num);
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]); skip();
	for (int i = 1; i <= n; i++){
		++tot; splay[i].root = tot; a[tot].key = num[i]; a[tot].size = 1;
		}
	for (int i = 1; i <= n; i++)
		for (int j = i - lowbit(i) + 1; j < i; j++)
			splay[i].insert(num[j]);
	for (int i = 1; i <= m; i++){
		char c = getchar(); int x, p, xx, L, R, K, l, r;
		switch(c){
			case 'C':
				scanf("%d%d", &x, &p); xx = x; skip(); 
				for (; x <= n; x += lowbit(x)){
					splay[x].insert(p); splay[x].del(num[xx]);
					}
				num[xx] = p;
				break;
			case 'Q':
				scanf("%d%d%d", &L, &R, &K); skip(); 
				l = 0; r = 1100000000;
				while (l <= r){
					int m = l + r >> 1;
					if (query(R, m) - query(L - 1, m) >= K) r = m - 1; else l = m + 1;
					}
				printf("%d\n", l);
				break;
			}
		}
}
				
Problem1901

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
const int MAXN = 1000001;
struct Tdiscre{
	int data[MAXN], n;
	int & operator [] (int k ) { return data[k]; }
	void init()
	{
		sort(data + 1, data + n + 1); n = unique(data + 1, data + n + 1) - data - 1;
	}
	int find(int t)
	{
		return lower_bound(data + 1, data + n + 1, t) - data;
	}
} dis;
struct Tnode{
	int l, r, lc, rc, sum;
} a[3000001]; int tot;
int n, seg[MAXN], now[MAXN], A, B, Q, val[MAXN];
struct Tquery{
	int op, l, r, x, num;
	Tquery() { }
	Tquery(int op, int l, int r, int x, int num) : op(op), l(l), r(r), x(x), num(num) { }
} query[MAXN];
int build(int l, int r)
{
	int now = ++tot; a[tot].l = l; a[tot].r = r; if (l == r) return tot;
	a[now].lc = build(l, l + r >> 1); a[now].rc = build(l + r + 2 >> 1, r);
	return now;
}
int change(int t, int x, int y)
{
	++tot; a[tot] = a[t]; t = tot; a[t].sum += y;
	if (a[t].l == a[t].r) return t;
	int m = a[t].l + a[t].r >> 1;
	if (x <= m) a[t].lc = change(a[t].lc, x, y); else a[t].rc = change(a[t].rc, x, y);
	return t;
}
void bins(int x, int y, int z)
{
	for (; x <= n; x += (x & (-x))) seg[x] = change(seg[x], y, z);
}
int bquery(int x)
{
	int ret = 0;
	for (; x; x -= (x & (-x))) ret += a[a[now[x]].lc].sum;
	return ret;
}
int goleft(int x) { for (; x; x -= (x & (-x))) now[x] = a[now[x]].lc; }
int goright(int x) { for (; x; x -= (x & (-x))) now[x] = a[now[x]].rc; }
int getkth(int now, int k)
{
	if (a[now].l == a[now].r) return a[now].l;
	int sum = bquery(B) - bquery(A);
	if (sum >= k) { goleft(A); goleft(B); return getkth(a[now].lc, k); }
	else { goright(A);  goright(B); return getkth(a[now].rc, k - sum); }
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);  freopen("temp.ans", "w", stdout);
#endif
	scanf("%d%d", &n, &Q);
	for (int i = 1; i <= n; i++) scanf("%d", &val[i]);
	dis.n = n; for (int i = 1; i <= n; i++) dis[i] = val[i];	
	for (int i = 1; i <= Q; i++){
		scanf(" ");
		char op; int x, l, r, num; scanf("%c", &op);
		switch(op){
			case 'Q' : scanf("%d%d%d", &l, &r, &num); query[i] = Tquery(0, l, r, 0, num); break;
			case 'C' : scanf("%d%d", &x, &num); query[i] = Tquery(1, 0, 0, x, num); dis[++dis.n] = num; break;
		}
	}		
	dis.init();
	seg[0] = build(1, dis.n);
	for (int i = 1; i <= n; i++) seg[i] = seg[0];
	for (int i = 1; i <= n; i++) bins(i, dis.find(val[i]), 1);
	for (int i = 1; i <= Q; i++)
		if (query[i].op == 1){
			bins(query[i].x, dis.find(val[query[i].x]), -1);
			bins(query[i].x, dis.find(query[i].num), 1);
			val[query[i].x] = query[i].num;
		}
		else{
			A = query[i].l - 1; B = query[i].r;
			for (int j = B; j; j -= (j & (-j))) now[j] = seg[j];
		    for (int j = A; j; j -= (j & (-j))) now[j] = seg[j];
		    printf("%d\n", dis[getkth(seg[0], query[i].num)]);	
		}
}
Problem1901

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
const int MAXN = 1000001;
struct Tdiscre{
	int data[MAXN], n;
	int & operator [] (int k ) { return data[k]; }
	void init()
	{
		sort(data + 1, data + n + 1); n = unique(data + 1, data + n + 1) - data - 1;
	}
	int find(int t)
	{
		return lower_bound(data + 1, data + n + 1, t) - data;
	}
} dis;
struct Tnode{
	int l, r, lc, rc, sum;
} a[3000001]; int tot;
int n, seg[MAXN], now[MAXN], A, B, Q, val[MAXN];
struct Tquery{
	int op, l, r, x, num;
	Tquery() { }
	Tquery(int op, int l, int r, int x, int num) : op(op), l(l), r(r), x(x), num(num) { }
} query[MAXN];
int build(int l, int r)
{
	int now = ++tot; a[tot].l = l; a[tot].r = r; if (l == r) return tot;
	a[now].lc = build(l, l + r >> 1); a[now].rc = build(l + r + 2 >> 1, r);
	return now;
}
int change(int t, int x, int y)
{
	++tot; a[tot] = a[t]; t = tot; a[t].sum += y;
	if (a[t].l == a[t].r) return t;
	int m = a[t].l + a[t].r >> 1;
	if (x <= m) a[t].lc = change(a[t].lc, x, y); else a[t].rc = change(a[t].rc, x, y);
	return t;
}
void bins(int x, int y, int z)
{
	for (; x <= n; x += (x & (-x))) seg[x] = change(seg[x], y, z);
}
int bquery(int x)
{
	int ret = 0;
	for (; x; x -= (x & (-x))) ret += a[a[now[x]].lc].sum;
	return ret;
}
int goleft(int x) { for (; x; x -= (x & (-x))) now[x] = a[now[x]].lc; }
int goright(int x) { for (; x; x -= (x & (-x))) now[x] = a[now[x]].rc; }
int getkth(int now, int k)
{
	if (a[now].l == a[now].r) return a[now].l;
	int sum = bquery(B) - bquery(A);
	if (sum >= k) { goleft(A); goleft(B); return getkth(a[now].lc, k); }
	else { goright(A);  goright(B); return getkth(a[now].rc, k - sum); }
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);  freopen("temp.ans", "w", stdout);
#endif
	scanf("%d%d", &n, &Q);
	for (int i = 1; i <= n; i++) scanf("%d", &val[i]);
	dis.n = n; for (int i = 1; i <= n; i++) dis[i] = val[i];	
	for (int i = 1; i <= Q; i++){
		scanf(" ");
		char op; int x, l, r, num; scanf("%c", &op);
		switch(op){
			case 'Q' : scanf("%d%d%d", &l, &r, &num); query[i] = Tquery(0, l, r, 0, num); break;
			case 'C' : scanf("%d%d", &x, &num); query[i] = Tquery(1, 0, 0, x, num); dis[++dis.n] = num; break;
		}
	}		
	dis.init();
	for (int i = 1; i <= n; i++) val[i] = dis.find(val[i]);
	for (int i = 1; i <= Q; i++) if (query[i].op == 1) query[i].num = dis.find(query[i].num);
	seg[0] = build(1, dis.n);
	for (int i = 1; i <= n; i++) seg[i] = seg[0];
	for (int i = 1; i <= n; i++) bins(i, val[i], 1);
	for (int i = 1; i <= Q; i++)
		if (query[i].op == 1){
			bins(query[i].x, val[query[i].x], -1);
			bins(query[i].x, query[i].num, 1);
			val[query[i].x] = query[i].num;
		}
		else{
			A = query[i].l - 1; B = query[i].r;
			for (int j = B; j; j -= (j & (-j))) now[j] = seg[j];
		    for (int j = A; j; j -= (j & (-j))) now[j] = seg[j];
		    printf("%d\n", dis[getkth(seg[0], query[i].num)]);	
		}
}
Problem1905

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define lint long long
using namespace std;
const int MAXK = 200001;
lint max(lint a, int b)
{
	return a > b ? a : b;
}
struct Tin{
	lint x, y, r;
	} in[MAXK];
struct Tline{
	lint x, y1, y2, k;
	bool operator < (const Tline & A) const
	{
		return x < A.x;
	}
};
struct Ttri{
	lint st, ed;
	lint sqr()
	{
		if ((ed - st + 1) & 1) return (ed - st + 2) * ((ed - st + 1) / 2 + 1) / 2;
		else return (ed - st + 1 + 2) * ((ed - st + 1 - 2) / 2 + 1) / 2; 
	}
	bool operator < (const Ttri A) const
	{
		return st < A.st;
	}
};
int n, m, k;
struct Tsegmenttree{
	int cover[1200001], m[1200001];
	int Y[MAXK];
	void clear()
	{
		memset(cover, 0, sizeof(cover));
		memset(m, 0, sizeof(m));
	}
	void update(int idx, lint l, lint r)
	{
		if (cover[idx] > 0) m[idx] = r - l;
		else m[idx] = m[idx * 2] + m[idx * 2 + 1];
	}
	void insert(int idx, int l, int r, int ll, int rr, int k)
	{
		int m = l + r >> 1;
		if (ll <= Y[l] && rr >= Y[r]) cover[idx] += k;
		else{
			 if (ll < Y[m]) insert(idx * 2, l, m, ll, rr, k);
			 if (rr > Y[m]) insert(idx * 2 + 1, m, r, ll, rr, k);
			};
		update(idx, Y[l], Y[r]);
	}
	lint M()
	{
		return m[1];
	}
} T;
struct Tsquarecalc{
	Tline line[MAXK];
	int tot, n;
	lint x1[MAXK], x2[MAXK], y1[MAXK], y2[MAXK];
	lint calc()
	{
		T.clear();
		for (int i = 1; i <= n; i++) T.Y[i * 2- 1] = y1[i], T.Y[i * 2] = y2[i];
		sort(T.Y + 1, T.Y + 2 * n + 1); tot = 1;
		for (int i = 2; i <= 2 * n; i++) if (T.Y[i] != T.Y[i - 1]) T.Y[++tot] = T.Y[i];
		for (int i = 1; i <= n; i++){
			line[i * 2 - 1].x = x1[i]; line[i * 2 - 1].y1 = y1[i]; line[i * 2 - 1].y2 = y2[i];
			line[i * 2].x = x2[i]; line[i * 2].y1 = y1[i]; line[i * 2].y2 = y2[i];
			line[i * 2 - 1].k = 1; line[i * 2].k = -1;
			}
		sort(line + 1, line + 2 * n + 1);
		lint ans = 0, last = 0;
		for (int i = 1; i <= 2 * n; i++){
			if (i != 1) ans = ans + last * (long long)((long long)(line[i].x) - (long long)(line[i - 1]).x);
			if (last < 0){
				int a;
				a += 1;
				}
			if (line[i].y1 != line[i].y2) T.insert(1, 1, tot, line[i].y1, line[i].y2, line[i].k);
			last = T.M();
			}
		return ans;
	}
}calc1, calc2;
struct Ttrisquarecalc{
	int n;
	Ttri tri[MAXK], temp;
	lint calc()
	{
		if (n == 0) return 0ll;
		lint ans = 0; Ttri temp;
		sort(tri + 1, tri + n + 1);
		ans = tri[1].sqr(); int now = 1;
		for (int i = 2; i <= n; i++){
			if (tri[i].st >= tri[now].st && tri[i].ed <= tri[now].ed) continue;
			if (tri[i].st > tri[now].ed){
				ans += tri[i].sqr(); now = i; continue;
				}
			ans += tri[i].sqr(); temp.st = tri[i].st; temp.ed = tri[now].ed;
			ans -= temp.sqr(); now = i;
			}
		return ans;
	}
} tc[5];
int main()
{
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= k; i++) scanf("%d%d%d", &in[i].x, &in[i].y, &in[i].r);
	calc1.n = calc2.n = k;
	for (int i = 1; i <= k; i++){
		int tmp = in[i].r - ((in[i].x + in[i].y + in[i].r) & 1);
		calc1.x1[i] = (in[i].x + in[i].y - tmp) >> 1;
		calc1.y1[i] = (in[i].y - tmp - in[i].x) >> 1;
		calc1.x2[i] = ((in[i].x + in[i].y + tmp) >> 1) + 1;
		calc1.y2[i] = ((in[i].y + tmp - in[i].x) >> 1) + 1;
		}
	for (int i = 1; i <= k; i++){
		int tmp = in[i].r - (!((in[i].x + in[i].y + in[i].r) & 1));
		calc2.x1[i] = (in[i].x + in[i].y - tmp - 1) >> 1;
		calc2.y1[i] = (in[i].y - tmp - in[i].x - 1) >> 1;
		calc2.x2[i] = ((in[i].x + in[i].y + tmp - 1) >> 1) + 1;
		calc2.y2[i] = ((in[i].y + tmp - in[i].x - 1) >> 1) + 1;
		}
	lint ans = 0;
	ans = calc1.calc() + calc2.calc();
	for (int i = 1; i <= k; i++) if (in[i].r >= in[i].x){
		++tc[1].n; 
		tc[1].tri[tc[1].n].st = in[i].y - (in[i].r - in[i].x);
		tc[1].tri[tc[1].n].ed = in[i].y + (in[i].r - in[i].x);
		}
	for (int i = 1; i <= k; i++) if (in[i].r >= in[i].y){
		++tc[2].n; 
		tc[2].tri[tc[2].n].st = in[i].x - (in[i].r - in[i].y);
		tc[2].tri[tc[2].n].ed = in[i].x + (in[i].r - in[i].y);
		}
	for (int i = 1; i <= k; i++) if (in[i].r >= n + 1 - in[i].x){
		++tc[3].n; 
		tc[3].tri[tc[3].n].st = in[i].y - (in[i].r - (n + 1 - in[i].x));
		tc[3].tri[tc[3].n].ed = in[i].y + (in[i].r - (n + 1 - in[i].x));
		}
	for (int i = 1; i <= k; i++) if (in[i].r >= m + 1 - in[i].y){
		++tc[4].n; 
		tc[4].tri[tc[4].n].st = in[i].x - (in[i].r - (m + 1 - in[i].y));
		tc[4].tri[tc[4].n].ed = in[i].x + (in[i].r - (m + 1 - in[i].y));
		}
	
	for (int i = 1; i <= 4; i++)
		ans -= tc[i].calc();
	lint m1 = 0, m2 = 0, m3 = 0, m4 = 0;
	for (int i = 1; i <= k; i++){
		if (in[i].r >= in[i].x + in[i].y) m1 = max(m1, 1 + in[i].r - in[i].x - in[i].y);
		if (in[i].r >= in[i].x + (m + 1 - in[i].y)) m2 = max(m2, 1 + in[i].r - in[i].x - (m + 1 - in[i].y));
		if (in[i].r >= in[i].y + (n + 1 - in[i].x)) m3 = max(m3, 1 + in[i].r - in[i].y - (n + 1 - in[i].x));
		if (in[i].r >= (m + 1 - in[i].y) + (n + 1 - in[i].x)) m4 = max(m4, 1 + in[i].r - ((m + 1 - in[i].y) + (n + 1 - in[i].x)));
		}
	ans += m1 * (m1 + 1) / 2 + m2 * (m2 + 1) / 2 + m3 * (m3 + 1) / 2 + m4 * (m4 + 1) / 2;
	printf("%lld\n", ans);
}
Problem1907

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int tot, e[1000001], v[2000001], next[2000001];
int f[1000001][2], n;
bool vis[1000001];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x)
{
	vis[x] = true;
	int d1 = 0x3f3f3f3f, d2 = 0x3f3f3f3f;
	f[x][0] = f[x][1] = 0;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		dfs(v[i]); f[x][0] += f[v[i]][1]; f[x][1] += f[v[i]][1];
		int t = f[v[i]][0] - f[v[i]][1];
		if (t < d1) { d2 = d1; d1 = t; continue; }
		if (t < d2) d2 = t;
	}
	if (d1 == 0x3f3f3f3f) { f[x][0] = f[x][1] = 1; return; }
	f[x][0] += d1; if (d2 == 0x3f3f3f3f) f[x][1] = d2; else f[x][1] += d1 + d2 - 1;
	f[x][1] = min(f[x][1], f[x][0]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	tot = 0; scanf("%d", &n); for (int i = 1; i <= n; i++) e[i] = 0, vis[i] = false;
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	dfs(1);
	printf("%d\n", f[1][1]);
}
}
Problem1911

//APIO 2010 commando
//f(i) = max{f(j) + a * s[j] * s[j] - b * s[j] - 2 * a * s[i] * s[j]} + t(i)
//t(i) = a * s[i] * s[i] + b * s[i] + c
//y = f(j) + a * s[j] * s[j] - b * s[j] 
//x = s[j]
//k = 2 * a * s[i]
//P = y - k * x
//y = k * x + P
#include <cstdio>
#include <cstdlib>
struct Tnode{
       long long x, y;
       } q[1000001];
long long f[1000001], s[1000001];
int a, b, c, n, l, r;
double getk(int a, int b)
{
       return (q[a].y - q[b].y) / (q[a].x - q[b].x);
}
long long getm(int a, int b, long long x, long long y)
{
     return (q[a].x - q[b].x) * (y - q[b].y) - (q[a].y - q[b].y) * (x - q[b].x);
}
int main()
{
    scanf("%d%d%d%d", &n, &a, &b, &c);
    s[0] = 0;
    for (int i = 1; i <= n; i++){
        int x;
        scanf("%d", &x);
        s[i] = s[i - 1] + x;
        }
    f[0] = 0;
    l = r = 1;
    q[1].x = 0;
    q[1].y = 0;
    for (int i = 1; i <= n; i++){
        while (l != r && getk(l, l + 1) > double(2 * a * s[i]))
              l++;
        f[i] = q[l].y - 2 * a * s[i] * q[l].x + a * s[i] * s[i] + b * s[i] + c;
        long long x, y;
        x = s[i];
        y = f[i] + a * s[i] * s[i] - b * s[i];
        while (l != r && getm(r , r - 1 ,x, y) > 0)
               r--;
        ++r;
        q[r].x = x;
        q[r].y = y;
        }
    printf("%lld\n", f[n]);
}
Problem1912

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;
const int INF = 0xe0e0e0e0, MAXN = 300001;
struct Tcounter{
	int data[4], who[4];
	Tcounter()
	{
		memset(data, 0xe0, sizeof(data));
	}
	void add(int d, int w)
	{
		for (int i = 0; i < 4; i++) if (d > data[i]){
			int td = data[i], tw = who[i];
			data[i] = d; who[i] = w;
			add(td, tw);
			break;
		}
	}
	int get(int t, int w)
	{
		int ret = 0;
		for (int i = 0; i < 4; i++){
			if (data[i] == INF) return INF;
			if (who[i] != w) ret += data[i], --t;
			if (t == 0) break;
		}
		return ret;
	}
}ca[MAXN], cb[MAXN], cc[MAXN], cd[MAXN];
int a[MAXN], b[MAXN], c[MAXN], d[MAXN];
int tot, e[MAXN], next[MAXN], v[MAXN];
bool vis[MAXN]; int fa[MAXN];
int max(int a, int b) { return a > b ? a : b; }
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		fa[v[i]] = x; dfs(v[i]);
		ca[x].add(a[v[i]], v[i]); cb[x].add(b[v[i]], v[i]); 
		cc[x].add(c[v[i]], v[i]); cd[x].add(d[v[i]], v[i]);
	}
	a[x] = ca[x].get(1, -1) + 1; b[x] = max(cb[x].get(1, -1), ca[x].get(2, -1) + 2);
	a[x] = max(a[x], 0); b[x] = max(b[x], 0);
	c[x] = max(ca[x].get(3, -1) + 3, cc[x].get(1, -1) + 1);
	for (int i = e[x]; i; i = next[i]) if (fa[x] != v[i])
		c[x] = max(c[x], b[v[i]] + 1 + ca[x].get(1, v[i]));
	d[x] = max(ca[x].get(4, -1) + 4, cd[x].get(1, -1));
	d[x] = max(d[x], cb[x].get(2, -1));
	for (int i = e[x]; i; i = next[i]) if (fa[x] != v[i]){
		d[x] = max(d[x], c[v[i]] + ca[x].get(1, v[i]) + 2);
		d[x] = max(d[x], b[v[i]] + ca[x].get(2, v[i]) + 2);
	}
	c[x] = max(c[x], 0); d[x] = max(d[x], 0);
}
int n, k;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	dfs(1);
	printf("%d\n", 2 * (n - 1) - (k == 1 ? b[1] : d[1]) + k);
}
Problem1913

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 2001;
struct Tpoint{
	int x, y;
	void init() { scanf("%d%d", &x, &y); }
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp;
		temp.x = x - A.x; temp.y = y - A.y;
		return temp;
	}
	bool operator < (const Tpoint & A) const
	{
		double cha = double(x) * A.y - double(y) * A.x;
		return cha < 0;	
	}
} p[MAXN], P[MAXN * 2], now;
int n;
void qsort(int l, int r)
{
	Tpoint x = P[l + r >> 1]; int i = l, j = r;
	do{
		while(P[i] < x) ++i;
		while(x < P[j]) --j;
		if (i <= j) swap(P[i], P[j]), ++i, --j;
	} while(i <= j);
	if (l < j) qsort(l, j);
	if (i < r) qsort(i, r);
}
double solve(int x)
{
	double all = (double)(n - 1) * (n - 2) * (n - 3) / 6.0;
	int tot = 0; now = p[x];
	for (int i = 1; i <= n; i++) if (i != x) P[++tot] = p[i] - now;
	qsort(1, tot);
	for (int i = 1; i <= tot; i++) P[i + tot] = P[i];
	int i = 1, j = 2;
	double ret = 0;
	while(i <= tot){
		while(j < tot * 2 && P[i] < P[j]) ++j;
		ret += double(j - i - 1) * (j - i - 2) / 2.0;
		++i;
	}
	return all - ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	double ao, tu, tot;
	for (int i = 1; i <= n; i++) ao += solve(i);
	tot = (double)n * (n - 1) * (n - 2) * (n - 3) / 24.0;
	tu = tot - ao;
	printf("%.6lf\n", (tu * 2.0 + ao) / ((double(n) * (n - 1) * (n - 2)) / 6.0) + 3.0);
}
Problem1917

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MN = 1000001;
int tot, next[MN], e[MN], v[MN], deg[MN], h[MN], dep[MN], fa[MN];
int f[MN][2], g[MN][2], n;
bool vis[MN];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; ++deg[b];
}
void dfs(int x)
{
	vis[x] = true; f[x][1] = h[x];
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		fa[v[i]] = x; dep[v[i]] = dep[x] + 1; dfs(v[i]);
		f[x][0] += f[v[i]][1]; f[x][1] += min(f[v[i]][0], f[v[i]][1]);
	}
}
void DFS(int x)
{
	if (x != 1){
		g[x][0] = f[fa[x]][0] - f[x][1] + g[fa[x]][1];
		g[x][1] = f[fa[x]][1] - min(f[x][0], f[x][1]) + min(g[fa[x]][0], g[fa[x]][1]) + (fa[x] != 1);
	}
	for (int i = e[x]; i; i = next[i]) if (v[i] != fa[x]) DFS(v[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		++a; ++b;
		add(a, b); add(b, a);
	}
	for (int i = 1; i <= n; i++) h[i] -= deg[i];
	dfs(1); DFS(1);
	for (int i = 1; i <= n; i++){
		int ans = 0x3f3f3f3f;
		ans = min(ans, g[i][1] + f[i][1] + (i != 1));
		ans = min(ans, g[i][0] + f[i][1] + (i != 1));
		ans = min(ans, g[i][1] + f[i][0]);
		printf("%d\n", ans * 2 + 2 * (n - 1) - dep[i]);
	}
}
Problem1918

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
double min(double a, double b) { return a < b ? a : b; }
double max(double a, double b) { return a > b ? a : b; }
double (*cmp[3]) (double, double);
using namespace std;
int n, s[3];
double f[1 << 18][3][3][7], p[101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cmp[0] = max; cmp[1] = cmp[2] = min;
	scanf("%d", &n);
	for (int t1 = 0; t1 < 3; t1++)
		for (int t2 = t1 + 1; t2 < 3; t2++)
			for (int i = 0; i < n; i++)
				for (int j = 0; j < n; j++){
					scanf("%lf", &p[i + t1 * n][j + t2 * n]);
					p[j + t2 * n][i + t1 * n] = 1 - p[i + t1 * n][j + t2 * n];
				}
	--n;
	int allA = (1 << n) - 1, allB = (1 << (2 * n)) - 1 - allA, allC = (1 << (3 * n)) - 1 - allB - allA;
	for (int S = 0; S < (1 << (3 * n)); S++)
		for (int l = 0; l < n + 1; l++)
			for (int lt = 0; lt < 3; lt++)
				for (int ct = 0; ct < 3; ct++) if (ct != lt){
					double & now = f[S][lt][ct][l];
					s[0] = S & allA; s[1] = (S & allB) >> n, s[2] = (S & allC) >> (n + n); int nt = 3 - ct - lt;
				    if (lt != 0 && s[0] == 0) { now = 0; continue; }
					if (l < n && (((s[lt] >> l) & 1) == 0)) continue;
					if (lt == 0 && s[1] == 0 && s[2] == 0) { now = 1; continue; }
					if (ct != 0) now = 1;
					for (int i = 0; i < n; i++) if ((s[ct] >> i) & 1){
						int dl = l != n ? 1 << (lt * n + l) : 0;
						now = cmp[ct](now, p[ct * (n + 1) + i][lt * (n + 1) + l] * f[S ^ dl][ct][s[nt] == 0 ? lt : nt][i]
								     + p[lt * (n + 1) + l][ct * (n + 1) + i] * f[S ^ (1 << (ct * n + i))][lt][s[nt] == 0 ? ct : nt][l]);
					}
				}
	++n;
	double ans = 0;
	for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) if (i != j){
		int k = 3 - i - j;
		ans += f[(1 << (3 * (n - 1))) - 1][i][j][n - 1] * (p[i * n + n - 1][j * n + n - 1] * p[i * n + n - 1][k * n + n - 1] / 3.0 
				                         + p[k * n + n - 1][j * n + n - 1] * p[i * n + n - 1][k * n + n - 1] / 3.0);
	}
	printf("%.6lf\n", ans);
			
}
Problem1921

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 800001;
int m, n; char pat[MAXN], trees[MAXN];
struct Tqueue{
	int data[MAXN], l, r;
	void clear() { l = 1; r = 0; }
	bool empty() { return l > r; }
	int pop() { l++; return data[l - 1]; }
	void push(int x) { data[++r] = x; }
} queue;
struct Ttrienode{
	int ch[26], fail[21], dep;
	int dfsl, dfsr;
};
int DFA_left[MAXN], DFA_right[MAXN];
struct TDFA{
	Ttrienode data[MAXN]; int tot, DFSNOW;
	int far[MAXN];
	TDFA() { tot = 1; }
	Ttrienode & operator [] (int k) { return data[k]; }
	int go(int idx, int c)
	{
		if (data[idx].ch[c] == 0) data[idx].ch[c] = ++tot;
		return data[idx].ch[c];
	}
	void build_fail()
	{
		queue.clear(); queue.push(1); data[1].fail[0] = 1;
		while(!queue.empty()){
			int x = queue.pop();
			for (int i = 0; i < 26; i++){
				int now = data[x].ch[i];
				data[now].fail[0] = x == 1 ? 1 : data[data[x].fail[0]].ch[i];
				if (now != 0) queue.push(now);
				else data[x].ch[i] = data[now].fail[0];
			}
		}
	}
	void dfs(int x)
	{
		data[x].dfsl = ++DFSNOW;
		for (int i = 0; i < 26; i++) if (data[x].ch[i]){
			data[data[x].ch[i]].dep = data[x].dep + 1; 
			dfs(data[x].ch[i]);
		}
		data[x].dfsr = DFSNOW;
	}
	void build_fail2k()
	{
		for (int i = 1; i <= tot; i++){
			//cerr << i << endl; 
			int now = queue.data[i];
			for (int j = 1; j <= 20; j++)
				data[now].fail[j] = data[data[now].fail[j - 1]].fail[j - 1];
		}
	}
	void build_far()
	{
		int now = 1;
		for (int i = 1; i <= m; i++){
			now = go(now, pat[i] - 'a');
			far[i] = now;
			//cerr << "far" << i << " " << far[i] << endl;
		}

	}
	int check_exist(int l, int r)
	{
		if (l > r) return 1;
		int now = far[r], len = r - l + 1;
		for (int i = 20; i >= 0; i--)
			if (data[data[now].fail[i]].dep >= len) now = data[now].fail[i];
		if (data[now].dep == len) return now; else return 1;	
	}
	void calc(int *ret)
	{
		build_far();
		for (int i = 1; i <= m; i++){
			int l = i, r = m;
			while(l <= r){
				int m = l + r >> 1;
				if (check_exist(i, m) != 1) l = m + 1; else r = m - 1;
			}
			ret[i] = check_exist(i, r);
			//cerr << "right"<< i << " " << r << endl;
		}
	}
	void solve()
	{
		dfs(1);
		build_fail();
		build_fail2k();
		calc(DFA_right);
		reverse(pat + 1, pat + m + 1); calc(DFA_left);
		reverse(pat + 1, pat + m + 1); reverse(DFA_left + 1, DFA_left + m + 1);
	}
} DFA;	
int now;
vector<vector<vector<int> > > split;
struct Ttreesplit{
	int l, r;
	int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2];
	int q[MAXN], fa[MAXN], size[MAXN], ms[MAXN], dis[MAXN], num[MAXN], where[MAXN];
	bool del[MAXN];
	vector<int> temp; vector<vector<int> > TEMP;
	void add(int a, int b)
	{
   		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
	}
	int find_heavy(int x)
	{
   	 	fa[x] = 0; l = 1, r = 1; q[1] = x;
   	 	while(l <= r){
       		int x = q[l++];
        	for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != fa[x]){
           		q[++r] = v[i]; fa[v[i]] = x;
        	}
    	}
    	for (int i = r; i >= 1; i--){
        	size[q[i]] = 1; ms[q[i]] = 0;
        	for (int j = e[q[i]]; j; j = next[j]) if (!del[v[j]] && v[j] != fa[q[i]]){
           		size[q[i]] += size[v[j]]; ms[q[i]] = max(ms[q[i]], size[v[j]]);
        	}
        	ms[q[i]] = max(ms[q[i]], r - size[q[i]]);
    	}
    	int w = q[1];
    	for (int i = 2; i <= r; i++) if (ms[q[i]] < ms[w]) w = q[i];
    	return w;
	}
	void doit(int x)
	{
		TEMP.clear();
    	x = find_heavy(x); del[x] = true; int rootwhere = DFA.go(1, trees[x] - 'a');
		temp.clear(); temp.push_back(rootwhere); TEMP.push_back(temp);
    	for (int i = e[x]; i; i = next[i]) if (!del[v[i]]){
        	int l = 1, r = 1; q[1] = v[i];  fa[v[i]] = 0; where[v[i]] = DFA.go(rootwhere, trees[v[i]] - 'a');
			temp.clear();
        	while(l <= r){
            	int x = q[l++];
            	for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && fa[x] != v[i]){
                	q[++r] = v[i]; fa[v[i]] = x; where[v[i]] = DFA.go(where[x], trees[v[i]] - 'a');
            	}
        	}
			for (int i = 1; i <= r; i++) temp.push_back(where[q[i]]);
			TEMP.push_back(temp);
    	}
		split.push_back(TEMP);
    	for (int i = e[x]; i; i = next[i]) if (!del[v[i]]) doit(v[i]);          
	}
} treesplit;
const int MAXBN = 1001;
struct Tpoint{
	int x, y, val;
	Tpoint() { }
	Tpoint(int x, int y) : x(x), y(y) { val = 0; }
};	
bool byX(const Tpoint & A, const Tpoint & B) { return A.x < B.x; }
bool byY(const Tpoint & A, const Tpoint & B) { return A.y < B.y; }
struct Tblock{
	Tpoint p[MAXBN];
	int sum[MAXBN], delta, n;
	void addpoint(Tpoint A) { p[++n] = A; }
	void init()
	{
		sort(p + 1, p + n + 1, byY);
		for (int i = 1; i <= n; i++) sum[i] = 0;
	}
	void push()
	{
		if (delta == 0) return;
		for (int i = 1; i <= n; i++) p[i].val += delta;
		delta = 0;
	}
	void redo(int l, int r, int d)
	{
		push();
		for (int i = 1; i <= n; i++) if (p[i].x >= l && p[i].x <= r) p[i].val += d;
		for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + p[i].val;
	}
	int ask(int l, int r)
	{
		l = lower_bound(p + 1, p + n + 1, Tpoint(0, l), byY) - p;
		r = upper_bound(p + 1, p + n + 1, Tpoint(0, r), byY) - p - 1;
		if (l > r) return 0;
		return sum[r] - sum[l - 1] + delta * (r - l + 1);
	}
};
struct TDS{
	Tblock block[MAXBN];
	Tpoint p[MAXN]; int tot;
	void addpoint(Tpoint A)
	{
		p[++tot] = A;
	    //cerr << "addpoint " << A.x << " " << A.y << endl;    	
	}
	void init()
	{
		sort(p + 1, p + m + 1, byX);
		for (tot = 1; tot * tot < m; tot++);
		for (int i = 1; i <= m; i++) block[(i / tot) + 1].addpoint(p[i]);
		for (int i = 1; i <= tot + 1; i++) block[i].init();
	}
	void modify(int l, int r, int d)
	{
		//cerr << "MOD " << l << " " << r << " " << d << endl;
		l = lower_bound(p + 1, p + m + 1, Tpoint(l, 0), byX) - p;
		r = upper_bound(p + 1, p + m + 1, Tpoint(r, 0), byX) - p - 1;
		if (l > r) return;
		int posl = l / tot + 1, posr = r / tot + 1;
		block[posl].redo(p[l].x, p[r].x, d); 
		if (posl != posr) block[posr].redo(p[l].x, p[r].x, d);
		for (int i = posl + 1; i <= posr - 1; i++) block[i].delta += d;
	}
	int ask(int l, int r)
	{	
		int ret = 0;
		for (int i = 1; i <= tot + 1; i++) ret += block[i].ask(l, r);
		//cerr << "ASK " << l << " " << r << " " << ret << endl;
		return ret;
	}
} DS;
long long ans;
#define vi vector<int>
#define vii vector<vi >
#define viii vector<vii >
#define foreach(e, x) for (__typeof((x).begin()) e = (x).begin(); e != (x).end(); e++)
void splitsolve(const vii & now)
{
	//cerr << "start " << idx << " " << ans << endl;
	foreach (i, now)
		foreach (j, *i)
			DS.modify(DFA[*j].dfsl, DFA[*j].dfsr, 1);
	foreach (i, now){
		foreach (j, *i) if (i != now.begin())
			DS.modify(DFA[*j].dfsl, DFA[*j].dfsr, -1);
		foreach (j, *i)
			ans += DS.ask(DFA[*j].dfsl, DFA[*j].dfsr);
		foreach (j, *i) if (i != now.begin())
			DS.modify(DFA[*j].dfsl, DFA[*j].dfsr, 1);
	}		
	foreach (i, now)
		foreach(j, *i)
			DS.modify(DFA[*j].dfsl, DFA[*j].dfsr, -1);
	//cerr << "end " << idx << " " << ans << endl;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); scanf(" ");
for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		treesplit.add(a, b); treesplit.add(b, a);
	}
	scanf("%s", trees + 1); scanf(" ");
	scanf("%s", pat + 1); scanf(" ");
	treesplit.doit(1);
	//cerr << "Tree split finished" << endl;
	DFA.solve();
	//cerr << "DFA Finished" << endl;
	for (int i = 1; i <= m; i++) DS.addpoint(Tpoint(DFA[DFA_left[i]].dfsl, DFA[DFA_right[i]].dfsl));
	DS.init();
	//cerr << "Block init finished" << endl;
	foreach (i, split)
		splitsolve(*i);
	cout << ans << endl;
}
Problem1922

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
vector<int> V[5001];
int n, m, map[3101][3101], need[5001], mn[5001], dis[5001];
bool vis[5001];
int main()
{
	scanf("%d%d", &n, &m);
	memset(map, 0x3f, sizeof(map)); memset(dis, 0x3f, sizeof(dis));
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		map[a][b] = min(map[a][b], c);
		}
	for (int i = 1; i <= n; i++){
		scanf("%d", &need[i]);
		for (int j = 1; j <= need[i]; j++) { int a; scanf("%d", &a); V[a].push_back(i); }
		}
	dis[1] = 0;
	for (int i = 1; i <= n; i++){
		int num = 0x3f3f3f3f, who;
		for (int j = 1; j <= n; j++) if (!vis[j] && need[j] == 0 && max(dis[j], mn[j]) < num) { num = max(dis[j], mn[j]); who = j; }
		vis[who] = true; dis[who] = max(dis[who], mn[who]);
		for (vector<int>::iterator vi = V[who].begin(); vi != V[who].end(); vi++) { --need[*vi]; mn[*vi] = max(mn[*vi], dis[who]); }
		for (int j = 1; j <= n; j++) if (!vis[j] && dis[who] + map[who][j] < dis[j]) dis[j] = dis[who] + map[who][j];
		}
	printf("%d\n", dis[n]);
}
	
Problem1923

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m, tot, num; 
char inf[10001];
int a[2001][1001], where[1001];
int main()
{
	scanf("%d%d\n", &n, &m);
	int tot = (n >> 5) + ((n & 31) != 0);
	for (int i = 0; i < m; i++){
		scanf("%s %d\n", inf, &a[i][tot]);
		for (int j = 0; j < n; j++) a[i][j >> 5] |= (inf[j] - '0') << (j & 31);
		}
	int ans = -1;
	for (int i = 0; i < m; i++){
		int p = -1; ++ans;
		for (int j = 0; j < n; j++) if (a[i][j >> 5] & (1 << (j & 31))) p = j;
		if (p < 0) continue;
		where[p] = i;
		for (int j = 0; j < m; j++) if (i != j && (a[j][p >> 5] & (1 << (p & 31))))
			for (int k = 0; k <= tot; k++) a[j][k] ^= a[i][k];
		 ++num; if (num == n) break;
		}
	if (num != n) puts("Cannot Determine");
	else{
		printf("%d\n", ans + 1);
		for (int i = 0; i < n; i++) puts(a[where[i]][tot] ? "?y7M#" : "Earth");
		}
}			
Problem1924

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <map>
#include <algorithm>
#include <iostream>
using namespace std;
const int dx[8] = {0, 0, 1, 1, 1, -1, -1, -1};
const int dy[8] = {1, -1, 0, 1, -1, 0, 1, -1};
const int MAXN = 100001, MAXM = 2000001;
int n;
int listnum, list[MAXN], nowc, col[MAXN], into[MAXN], f[MAXN];
bool vis[MAXN];
	struct Tqueue{
		int l, r, data[MAXN];
		void clear() { l = 1; r = 0; }
		void push(int num) { data[++r] = num; }
		int pop() { l++; return data[l - 1]; }
		bool empty() { return l > r; }
	};
Tqueue Q;
struct Tsolve{
	struct Tgraph{
		int tot, e[MAXN], v[MAXM], next[MAXM], w[MAXN];
		void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
		void dfs1(int a)
		{
			vis[a] = true;
			for (int i = e[a]; i; i = next[i]) if (!vis[v[i]]) dfs1(v[i]);
			list[++listnum] = a;
		}
		void dfs2(int a)
		{
			col[a] = nowc;
			for (int i = e[a]; i; i = next[i]) if (!col[v[i]]) dfs2(v[i]);
		}
		void dp()
		{
			int ans = 0;
			Q.clear();
			for (int i = 1; i <= n; i++)
				for (int j = e[i]; j; j = next[j])
					++into[v[j]];
			for (int i = 1; i <= n; i++) if (into[i] == 0) { Q.push(i); f[i] = w[i]; ans = max(ans, f[i]); }
			while(!Q.empty()){
				int x = Q.pop();
				for (int i = e[x]; i; i = next[i]){
					f[v[i]] = max(f[v[i]], f[x] + w[v[i]]); ans = max(ans, f[v[i]]);
					--into[v[i]]; if (into[v[i]] == 0) Q.push(v[i]);
					}
				}
			printf("%d\n", ans);
		}
	} g, G, T;
	void addedge(int a, int b)
	{
		if (a == b) return;
		g.add(a, b); G.add(b, a);
	}
	void work()
	{
		for (int i = 1; i <= n; i++) if (!vis[i]) g.dfs1(i);
		for (int i = n; i >= 1; i--) if (col[list[i]] == 0){
			nowc = list[i]; G.dfs2(list[i]); 
			}
		for (int i = 1; i <= n; i++) ++T.w[col[i]];
		for (int i = 1; i <= n; i++)
			for (int j = g.e[i]; j; j = g.next[j]) if (col[g.v[j]] != col[i])
				T.add(col[g.v[j]], col[i]);
		T.dp();
	}
} solve;
struct Tpoint{
	int x, y, who, mode;
	bool operator < (const Tpoint & A) const{
		return x == A.x ? y < A.y : x < A.x ;
		}
} p[100001];
bool cmpX(Tpoint A, Tpoint B) { return A.x == B.x ? A.y < B.y : A.x < B.x; }
bool cmpY(Tpoint A, Tpoint B) { return A.y == B.y ? A.x < B.x : A.y < B.y; }
int main()
{
	scanf("%d%*d%*d", &n);
	for (int i = 1; i <= n; i++) { scanf("%d%d%d", &p[i].x, &p[i].y, &p[i].mode); p[i].who = i; }
	sort(p + 1, p + n + 1);
	for (int i = 1; i <= n; i++) if (p[i].mode == 3)
		for (int j = 0; j < 8; j++){
			Tpoint temp; temp.x = p[i].x + dx[j]; temp.y = p[i].y + dy[j];
			int t = lower_bound(p + 1, p + n + 1, temp) - p;
			if (p[t].x == temp.x && p[t].y == temp.y) solve.addedge(p[i].who, p[t].who);
			}
	sort(p + 1, p + n + 1, cmpX);
	for (int i = 1; i <= n; i++){
		int j = i; while(j < n && p[j + 1].x == p[i].x) ++j;
		int t = -1; for (int k = i; k <= j; k++) if (p[k].mode == 1) t = k;
		if (t != -1)
			for (int k = i; k <= j; k++){
				solve.addedge(p[t].who, p[k].who);
				if (p[k].mode == 1) solve.addedge(p[k].who, p[t].who);
				}
		i = j;
		}
	sort(p + 1, p + n + 1, cmpY);
	for (int i = 1; i <= n; i++){
		int j = i; while(j < n && p[j + 1].y == p[i].y) ++j;
		int t = -1; for (int k = i; k <= j; k++) if (p[k].mode == 2) t = k;
		if (t != -1)
			for (int k = i; k <= j; k++){
				solve.addedge(p[t].who, p[k].who);
				if (p[k].mode == 2) solve.addedge(p[k].who, p[t].who);
				}
		i = j;
		}
	solve.work();
}
Problem1925

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, p;
int f[2][4201], g[2][4201];
int main()
{
	cin >> n >> p;
	int now = 0, last = 1;
	f[now][2] = 1; g[now][1] = 1;
	for (int i = 3; i <= n; i++){
		now ^= 1; last ^= 1;
		f[now][1] = 0;
		for (int j = 2; j <= i; j++) f[now][j] = (f[now][j - 1] + g[last][j - 1]) % p;
		g[now][i] = 0;
		for (int j = i - 1; j >= 1; j--) g[now][j] = (g[now][j + 1] + f[last][j]) % p;
		}
	int ans = 0;
	for (int i = 1; i <= n; i++) ans = ((ans + g[now][i]) % p + f[now][i]) % p;
	cout << ans << endl;
}

Problem1926

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <functional>
#include <cctype>
using namespace std;
int n,m, Q;
int getint()
{
	char c;
	while(isspace(c = getchar()));
	int t = c - '0';
	while(!isspace(c = getchar())) t = t * 10 + c - '0';
	return t;
}
struct Tsolve2d{
	int sum1[1002][201][201], sum2[1002][201][201];
	int getsum(int a[201][201], int x1, int y1, int x2, int y2) 
	{ 
		return a[x2][y2] - a[x2][y1 - 1] - a[x1 - 1][y2] + a[x1 - 1][y1 - 1];
	}
	void work()
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++){
				int x; scanf("%d", &x); ++sum1[x][i][j];
				}
		for (int t = 1; t <= 1000; t++)
			for (int i = 1; i <= n; i++)
				for (int j = 1; j <= m; j++){
					sum1[t][i][j] += sum1[t][i - 1][j] + sum1[t][i][j - 1] - sum1[t][i - 1][j - 1];
					sum2[t][i][j] = sum1[t][i][j] * t;
					}
		for (int t = 1000; t >= 0; t--)
			for (int i = 1; i <= n; i++)
				for (int j = 1; j <= m; j++) if (t != 1000){
					sum1[t][i][j] += sum1[t + 1][i][j];
					sum2[t][i][j] += sum2[t + 1][i][j];
					}
		for (int i = 1; i <= Q; i++){
			int x1, y1, x2, y2, num;
			x1 = getint(); y1 = getint(); x2 = getint(); y2 = getint(); num = getint();
			if (getsum(sum2[0], x1, y1, x2, y2) < num) { puts("Poor QLW"); continue; }			
			if (num == 0) { puts("0"); continue; }
			int l = 1, r = 1000;
			while(l <= r){
				int m = l + r >> 1;
				if (getsum(sum2[m], x1, y1, x2, y2) >= num) l = m + 1; else r = m - 1;
				}
			int t = num - getsum(sum2[r + 1], x1, y1, x2, y2);
			printf("%d\n", t / r + ((t % r) != 0) + getsum(sum1[r + 1], x1, y1, x2, y2));
			}
	}			
}solve1;
int a[500001];
struct Tsolve1{
	struct Ttree{
		int data[20][500001], sum[20][500001], tl[20][500001];
		void build(int dep, int l, int r)
		{
			if (l == r) return;
			int m = l + r >> 1, ls = m - l + 1, lp = l - 1, rp = m;
			for (int i = l; i <= r; i++) if (data[dep][i] > a[m]) --ls;
			for (int i = l; i <= r; i++){
				tl[dep][i] = (i == l) ? 0 : tl[dep][i - 1];
				sum[dep][i] = (i == l) ? 0 : sum[dep][i - 1];
				if (data[dep][i] > a[m]) ++tl[dep][i], sum[dep][i] += data[dep][i], data[dep + 1][++lp] = data[dep][i];
				else if (data[dep][i] < a[m]) data[dep + 1][++rp] = data[dep][i];
				else if (ls > 0) ++tl[dep][i], sum[dep][i] += data[dep][i], data[dep + 1][++lp] = data[dep][i], --ls;
				else data[dep + 1][++rp] = data[dep][i];
				}
			build(dep + 1, l, m); build(dep + 1, m + 1, r);
		}
		int query(int dep, int l, int r, int ll, int rr, int num)
		{
			if (l == r) return num > 0;
			int m = l + r >> 1, an, as;
			if (ll == l) an = 0, as = 0; else an = tl[dep][ll - 1], as = sum[dep][ll - 1];
			int cn = ll - l - an, dn = rr - ll + 1 - (tl[dep][rr] - an);
			if (sum[dep][rr] - as >= num) return query(dep + 1, l, m, l + an, l + tl[dep][rr] - 1, num);
			else return query(dep + 1, m + 1, r, m + cn + 1, m + cn + dn, num - (sum[dep][rr] - as)) + tl[dep][rr] - an;
		};
	} T;
	int s[500001];
	void work()
	{
		n = m;
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
		for (int i = 1; i <= n; i++) T.data[0][i] = a[i];
		sort(a + 1, a + n + 1, greater<int>());
		T.build(0, 1, n);
		for (int i = 1; i <= Q; i++){
			int l, r, num; 
			scanf("%*d%d%*d%d%d", &l, &r, &num);
			if (s[r] - s[l - 1] < num) puts("Poor QLW");
			else printf("%d\n", T.query(0, 1, n, l, r, num));
			}
	}
}solve2;
int main()
{
	scanf("%d%d%d", &n, &m, &Q);
	if (n > 1) solve1.work(); else solve2.work();
}
Problem1927

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MAXM = 1000001, SIZE = 2047;
int n, m; bool vis[MAXN];
int tot = 1, e[MAXN], next[MAXM], v[MAXM], c[MAXM], w[MAXM], pre[MAXN], dis[MAXN];
int l, r, q[MAXN];
int s, t;
void add(int a, int b, int C, int d)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = C; w[tot] = d;
	++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0; w[tot] = -d;
}
bool spfa()
{
	for (int i = 1; i <= t; i++) vis[i] = false, dis[i] = 0x3f3f3f3f;
	dis[s] = 0; vis[s] = true; l = 0; r = 1; q[1] = s;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
			dis[v[i]] = dis[x] + w[i]; pre[v[i]] = i;
			if (!vis[v[i]]) { vis[v[i]] = true; r = (r + 1) & SIZE; q[r] = v[i]; }
			}
		}
	return dis[t] < 0x3f3f3f3f;
}
int ans;
void aug()
{
	for (int i = t; i != s; i = v[pre[i] ^ 1])
		--c[pre[i]], ++c[pre[i] ^ 1];
	ans += dis[t];
}
int main()
{
	scanf("%d%d", &n, &m);
	int ts = 2 * n + 1, tt = ts + 1;
	s = tt + 1, t = s + 1;
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t);
		add(ts, i * 2 - 1, 1, t);
		add(i * 2, tt, 1, 0);
		}
	for (int i = 1; i <= m; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z); if (x > y) swap(x, y);
		add(x * 2, y * 2 - 1, 1, z);
		}
	add(tt, ts, 0x3f3f3f3f, 0);
	for (int i = 1; i <= n; i++) add(s, i * 2, 1, 0), add(i * 2 - 1, t, 1, 0);
	while(spfa())
		aug();
	printf("%d\n", ans);
}	
Problem1932

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <stack>
#include <vector>
#define ll unsigned long long
#define set vector<ll>
using namespace std;
ll hash(const set & A)
{
	ll ret = 0;
	for (int i = 0; i < A.size(); i++) ret = ret * 13331 + A[i] + 78;
	return ret;
}
void make(set & A)
{
	sort(A.begin(), A.end());
	A.resize(unique(A.begin(), A.end()) - A.begin());
}
set S, U, T;
stack<set> s;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int n; scanf("%d", &n);
	while(n--){
		char op[10001]; scanf("%s", op);
		switch(*op){
			case 'P' : s.push(set()); break;
			case 'D' : s.push(s.top()); break;
			case 'A' : S = s.top(); s.pop(); T = s.top(); s.pop();
					   T.push_back(hash(S)); make(T); s.push(T);
					   break;
			case 'U' : S = s.top(); s.pop(); T = s.top(); s.pop(); U.resize(S.size() + T.size());
					   U.resize(set_union(S.begin(), S.end(), T.begin(), T.end(), U.begin()) - U.begin());
					   make(U); s.push(U);
					   break;
			case 'I' : S = s.top(); s.pop(); T = s.top(); s.pop(); U.resize(S.size() + T.size());
					   U.resize(set_intersection(S.begin(), S.end(), T.begin(), T.end(), U.begin()) - U.begin());
					   make(U); s.push(U);
					   break;
		}
		printf("%d\n", s.top().size());
	}
}
Problem1934

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, MAXM = 2000001;
struct Tflow{
	int tot, e[MAXN], v[MAXM], c[MAXM], next[MAXM], s, t;
	int d[MAXN], q[MAXN], l, r;
	Tflow() { tot = 1; }
	void add(int a, int b, int w)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = w;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
	}
	bool relable()
	{
		for (int i = 1; i <= t; i++) d[i] = -1; d[s] = 0; l = r = 1; q[1] = s;
		while(l <= r){
			int x = q[l++]; 
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == -1){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f = 0x3f3f3f3f)
	{
		if (x == t) return f;
		int augc = f;
		for (int i = e[x]; i; i = next[i]) if (d[v[i]] == d[x] + 1 && c[i] > 0){
			int t = find(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0) break;
		}
		if (f != 0) d[x] = -1;
		return augc - f;
	}
	int run()
	{
		int t, ret = 0;
		while(relable()) while(t = find(s)) ret += t;
		return ret;
	}
} flow;
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	flow.s = n + 1; flow.t = flow.s + 1;
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t);
		if (t) flow.add(i, flow.t, 1); else flow.add(flow.s, i, 1);
	}
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		flow.add(a, b, 1); flow.add(b, a, 1);
	}
	printf("%d\n", flow.run());
}
Problem1935

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 2000001;
struct Tdiscre{
	int data[MAXN], tot, n;
	int & operator [] (int k) { return data[k]; }
	void init()
	{
		sort(data + 1, data + n + 1);
		tot = unique(data + 1, data + n + 1) - data - 1;
	}
	int convert(int t)
	{
		return lower_bound(data + 1, data + tot + 1, t) - data; 
	}
} discre;
struct Tbit{
	int data[MAXN], n;
	void clear() { memset(data, 0, sizeof(data)); }
	void add(int x, int d)
	{
		for (; x <= n; x += (x & (-x))) data[x] += d;
	}
	int getsum(int x)
	{
		int ret = 0;
		for (; x; x -= (x & (-x))) ret += data[x];
		return ret;
	}
	int getsum(int l, int r) { return getsum(r) - getsum(l - 1); }
} bit;
struct Tscan{
	int kind, pos, y1, y2, who;
	Tscan() { }
	Tscan(int kind, int pos, int y1, int y2 = 0, int who = 0) : kind(kind), pos(pos), y1(y1), y2(y2), who(who) { }
	bool operator < (const Tscan & A) const { return pos == A.pos ? kind < A.kind : pos < A.pos; }
} scan[MAXN];
int ans[MAXN], n, m, tot;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		int px, py; scanf("%d%d", &px, &py);
		discre[i] = py;
		scan[++tot] = Tscan(1, px, py);
	}
	for (int i = 1; i <= m; i++){
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		discre[n + 2 * i - 1] = y1;
		discre[n + 2 * i] = y2;
		scan[++tot] = Tscan(2, x1 - 1, y1, y2, i);
		scan[++tot] = Tscan(3, x2, y1, y2, i);
	}
	sort(scan + 1, scan + tot + 1);
	discre.n = n + 2 * m;
	discre.init();
	bit.n = discre.tot;
	for (int i = 1; i <= tot; i++)
		switch(scan[i].kind){
			case 1 : bit.add(discre.convert(scan[i].y1), 1); break;
			case 2 : ans[scan[i].who] -= bit.getsum(discre.convert(scan[i].y1), discre.convert(scan[i].y2)); break;
			case 3 : ans[scan[i].who] += bit.getsum(discre.convert(scan[i].y1), discre.convert(scan[i].y2)); break;
		}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}
Problem1937

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 600001, MAXM = 600001, SIZE = 262144 - 1;
struct Tcostflow{
	int flow, cost, s, t;
	int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM], w[MAXM]; //graph
	int dis[MAXN], f[MAXN], q[SIZE + 100], l, r; bool vis[MAXN]; //spfa
	Tcostflow() { tot = 1; }
	void add(int A, int B, int C, int D)
	{
		D *= -1;
		//cerr << A << " " << B << " " << C <<" " << D << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
	}
	bool spfa()
	{
		for (int i = 1; i <= t; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
		l = 0; r = 1; q[1] = s; vis[s] = true; dis[s] = 0;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i]; f[v[i]] = i;
				if (!vis[v[i]]) { r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true; }
			}
		}
		return dis[t] < 0x3f3f3f3f;
	}
	void aug()
	{
		int af = 0x3f3f3f3f;
		for (int i = t; i != s; i = v[f[i] ^ 1]) af = min(af, c[f[i]]);
		for (int i = t; i != s; i = v[f[i] ^ 1]) c[f[i]] -= af, c[f[i] ^ 1] += af;
		flow += af; cost += af * dis[t];
	}
	void run()
	{
		while(spfa()) aug();
	}
} costflow;
bool vis[1001];
int used[1001][1001], map[1001][1001];
int n, m, tot, next[1000001], v[1000001], e[1000001];
int st[1001], ed[1001], len[1001];
int ST[1001], ED[1001];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
bool mark(int st, int ed, int len, int who)
{
	vis[st] = true;
	if (st == ed) return true;
	for (int i = e[st]; i; i = next[i]) if (!vis[v[i]]){
		if (mark(v[i], ed, len, who)){
			costflow.add(who, used[st][v[i]] + (m - n + 1), 1, map[st][v[i]] <= len ? 0 : map[st][v[i]] - len);
			return true;
		}
	}
	return false;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		scanf("%d%d%d", &st[i], &ed[i], &len[i]);
		map[st[i]][ed[i]] = map[ed[i]][st[i]] = len[i];
		//used[st[i]][ed[i]] = used[ed[i]][st[i]] = true;
	}
	for (int i = 1; i < n; i++){
		scanf("%d%d", &ST[i], &ED[i]);
		used[ST[i]][ED[i]] = used[ED[i]][ST[i]] = i;
		add(ST[i], ED[i]); add(ED[i], ST[i]);
	}
	int tot = 0;
	for (int i = 1; i <= m; i++) if (!used[st[i]][ed[i]]){
		for (int j = 1; j <= n; j++) vis[j] = false;
		++tot;
		mark(st[i], ed[i], map[st[i]][ed[i]], tot);
	}	
	costflow.s = m + 1; costflow.t = costflow.s + 1;
	for (int i = 1; i <= m - n + 1; i++) costflow.add(costflow.s, i, 1, 0);
	for (int i = m - n + 2; i <= m; i++) costflow.add(i, costflow.t, 1, 0);	
	costflow.run();
	cout << -costflow.cost << endl;
}
Problem1941

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 300001;
using namespace std;
int MIN(int a, int b) { return a < b ? a : b; }
int MAX(int a, int b) { return a > b ? a : b; }
int n, mx[MAXN], mn[MAXN];
int Y[MAXN], tot;
struct Tpoint{
	int x, y, ord;
	} p[MAXN];
bool cmp1(Tpoint A, Tpoint B)
{
	return A.x == B.x ? A.y < B.y : A.x < B.x;
}
bool cmp2(Tpoint A, Tpoint B)
{
	return A.x == B.x ? A.y < B.y : A.x > B.x;
}
bool cmp3(Tpoint A, Tpoint B)
{
	return A.x == B.x ? A.y > B.y : A.x < B.x;
}
bool cmp4(Tpoint A, Tpoint B)
{
	return A.x == B.x ? A.y > B.y : A.x > B.x;
}
struct Tsegmenttree1{
	int min[MAXN * 4];
	void clear() { memset(min, 0x3f, sizeof(min)); }
	void modify(int idx, int l, int r, int x, int num)
	{
		if (l == r) min[idx] = MIN(min[idx], num);
		else{
			int m = l + r >> 1;
			if (x <= m) modify(idx * 2, l, m, x, num);
			if (x > m) modify(idx* 2 + 1, m + 1, r, x, num);
			min[idx] = MIN(min[idx * 2], min[idx * 2 + 1]);
			}
	}
	int query(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return min[idx];
		int m = l + r >> 1, ret = 0x3f3f3f3f;
		if (ll <= m) ret = MIN(ret, query(idx * 2, l, m, ll, rr));
		if (rr > m) ret = MIN(ret, query(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}
}T1;		
struct Tsegmenttree2{
	int max[MAXN * 4];
	void clear() { memset(max, 0xe0, sizeof(max)); }
	void modify(int idx, int l, int r, int x, int num)
	{
		if (l == r) max[idx] = MAX(max[idx], num);
		else{
			int m = l + r >> 1;
			if (x <= m) modify(idx * 2, l, m, x, num);
			if (x > m) modify(idx* 2 + 1, m + 1, r, x, num);
			max[idx] = MAX(max[idx * 2], max[idx * 2 + 1]);
			}
	}
	int query(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return max[idx];
		int m = l + r >> 1, ret = 0xe0e0e0e0;
		if (ll <= m) ret = MAX(ret, query(idx * 2, l, m, ll, rr));
		if (rr > m) ret = MAX(ret, query(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}
}T2;
#define min MIN
#define max MAX
void solve1()
{
	T1.clear(); T2.clear();
	sort(p + 1, p + n + 1, cmp1);
	for (int i = 1; i <= n; i++){
		mn[p[i].ord] = min(mn[p[i].ord], p[i].x + Y[p[i].y] - T2.query(1, 1, tot, 1, p[i].y));
		mx[p[i].ord] = max(mx[p[i].ord], p[i].x + Y[p[i].y] - T1.query(1, 1, tot, 1, p[i].y));
		T1.modify(1, 1, tot, p[i].y, p[i].x + Y[p[i].y]);
		T2.modify(1, 1, tot, p[i].y, p[i].x + Y[p[i].y]);
		}
}
void solve2()
{
	T1.clear(); T2.clear();
	sort(p + 1, p + n + 1, cmp2);
	for (int i = 1; i <= n; i++){
		mn[p[i].ord] = min(mn[p[i].ord], -p[i].x + Y[p[i].y] - T2.query(1, 1, tot, 1, p[i].y));
		mx[p[i].ord] = max(mx[p[i].ord], -p[i].x + Y[p[i].y] - T1.query(1, 1, tot, 1, p[i].y));
		T1.modify(1, 1, tot, p[i].y, -p[i].x + Y[p[i].y]);
		T2.modify(1, 1, tot, p[i].y, -p[i].x + Y[p[i].y]);
		}
}
void solve3()
{
	T1.clear(); T2.clear();
	sort(p + 1, p + n + 1, cmp3);
	for (int i = 1; i <= n; i++){
		mn[p[i].ord] = min(mn[p[i].ord], p[i].x - Y[p[i].y] - T2.query(1, 1, tot, p[i].y, tot));
		mx[p[i].ord] = max(mx[p[i].ord], p[i].x - Y[p[i].y] - T1.query(1, 1, tot, p[i].y, tot));
		T1.modify(1, 1, tot, p[i].y, p[i].x - Y[p[i].y]);
		T2.modify(1, 1, tot, p[i].y, p[i].x - Y[p[i].y]);
		}
}
void solve4()
{
	T1.clear(); T2.clear();
	sort(p + 1, p + n + 1, cmp4);
	for (int i = 1; i <= n; i++){
		mn[p[i].ord] = min(mn[p[i].ord], -p[i].x - Y[p[i].y] - T2.query(1, 1, tot, p[i].y, tot));
		mx[p[i].ord] = max(mx[p[i].ord], -p[i].x - Y[p[i].y] - T1.query(1, 1, tot, p[i].y, tot));
		T1.modify(1, 1, tot, p[i].y, -p[i].x - Y[p[i].y]);
		T2.modify(1, 1, tot, p[i].y, -p[i].x - Y[p[i].y]);
		}
}
#undef min
#undef max
int main()
{
	scanf("%d", &n); 
	for (int i = 1; i <= n; i++) scanf("%d%d", &p[i].x, &p[i].y);
	for (int i = 1; i <= n; i++) p[i].ord = i;
	for (int i = 1; i <= n; i++) Y[i] = p[i].y;
	sort(Y + 1, Y + n + 1);
	tot = 1;
	for (int i = 2; i <= n; i++) if (Y[i] != Y[i - 1]) Y[++tot] = Y[i];
	for (int i = 1; i <= n; i++) p[i].y = lower_bound(Y + 1, Y + tot + 1, p[i].y) - Y;
	for (int i = 1; i <= n; i++) mx[i] = 0xe0e0e0e0, mn[i] = 0x3f3f3f3f;
	solve1(); solve2(); solve3(); solve4();
	int ans = 0x3f3f3f3f;
	for (int i = 1; i <= n; i++) ans = MIN(ans, mx[i] - mn[i]);
	printf("%d\n", ans);
}
Problem1951

#include <cstdio>
#include <cstdlib>
#include <cstdlib>
#include <cmath>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const int MO = 999911659;
const int P[4] = {2, 3, 4679, 35617};
const int M[4] = {499955829, 333303886, 213702, 28074};
int fac[1000001], MI, n, G, ans;
int pow(int a, int b, int c)
{
	long long ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = ret * a % c;
		a = (ll)a * a % c;
		}
	return ret;
}
int get_inv(int t, int P)
{
	return pow(t, P - 2, P);
}
int get_fac(int t, int P, int d)
{
	MI += d * t / P; int ret = (ll)pow(fac[P - 1], t / P, P) * fac[t % P] % P;
	if (t / P <= 1) return ret; else return ret = (ll)(ret) * get_fac(t / P, P, d) % P;
}
int Cmod(int n, int m, int P)
{
	int ret = 1; MI = 0;
	ret = (ll)ret * get_fac(n, P, 1) % P;
	ret = (ll)ret * get_inv(get_fac(m, P, -1), P) % P;
	ret = (ll)ret * get_inv(get_fac(n - m, P, -1), P) % P;
	if (MI) return 0; else return ret;
}
int doit(int P)
{
	int now = 0;
	fac[0] = 1;
	for (int i = 1; i < P; i++) fac[i] = (ll)fac[i - 1] * i % P;
	for (int i = 1; i * i <= n; i++) if (n % i == 0){
		now = (now + Cmod(n, i, P)) % P;
		if (i * i != n) now = (now + Cmod(n, n / i, P)) % P;
		}
	return now;
}
void exgcd(int a, int b, ll & x, ll & y)
{
	if (b == 0) { x = 1; y = 0; return; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
int modular(int a, int b, int c) //ax mod b = c return ax
{
	ll x, y;
	exgcd(a, b, x, y);
	x = ((x * c) % b + b) % b;
    return (a * x) % (MO - 1);	
}
int main()
{
	scanf("%d%d", &n, &G);
	if (G == MO) { puts("0"); return 0; }
	for (int i = 0; i < 4; i++) ans = (ans + modular(M[i], P[i], doit(P[i]))) % (MO  - 1);
	printf("%d\n", pow(G, ans, MO));
}
	
Problem1953

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1601;
struct Tnode{
	int x, y, first;
	Tnode() { }
	Tnode(int x, int y, int first) : x(x), y(y), first(first) { }
	bool operator < (const Tnode & A) const
	{
		if (first != A.first) return first < A.first;
		if (x - y != A.x - A.y) return x - y < A.x - A.y;
		return x < A.x;
	}
} node[MAXN * MAXN]; int nodenum;
int n, mod, del, p[MAXN], a[MAXN], f[MAXN][MAXN];
struct Tbit{
	int data[1000001];
	void ins(int x, int num)
	{
		for (int i = x + 1; i <= n + 1; i += (i & (-i))) data[i] = max(data[i], num);
	}
	void del(int x)
	{
		for (int i = x + 1; i <= n + 1; i += (i & (-i))) data[i] = 0;
	}
	int que(int x)
	{
		int ret = 0;
		for (int i = x + 1; i; i -= (i & (-i))) ret = max(ret, data[i]);
		return ret;
	}
} bit;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &mod, &del);
	for (int i = 2; i <= n; i++) scanf("%d", &p[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	f[0][0] = 0;
	for (int i = 1; i <= n; i++){
		int sum = 0;
		for (int j = 1; j <= n; j++) if (i >= j){
			sum += p[j];
			node[++nodenum] = Tnode(i, j, a[i] - sum);
		}
	}
	sort(node + 1, node + nodenum + 1);
	for (int i = 1; i <= nodenum; i++){
		int j = i; while(j < nodenum && node[j + 1].first == node[i].first) ++j;
		for (int t = i; t <= j; t++){
			f[node[t].x][node[t].y] = bit.que(node[t].y - 1) + 1;
			bit.ins(node[t].y, f[node[t].x][node[t].y]);
		}
		for (int t = i; t <= j; t++) bit.del(node[t].y);
		i = j;
	}
	int ans = 0x7fffffff;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++){
			ans = min(ans, (j - f[i][j]) * mod + (i - j) * del + (n - i) * min(del, mod));
		}
	printf("%d\n", ans);
}
Problem1954

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Ttrie{
	int ch[1000001][2], tot;
	Ttrie() { tot = 1; } 
	void insert(int num)
	{
		int now = 1;
		for (int i = 30; i >= 0; i--){
			int t = (num >> i) & 1;
			if (ch[now][t] == 0) ch[now][t] = ++tot;
			now = ch[now][t];
		}
	}
	int get(int num)
	{
		int now = 1, ret = 0;
		for (int i = 30; i >= 0; i--){
			int t = (num >> i) & 1;
			if (ch[now][!t] == 0) now = ch[now][t], ret += (t << i); 
			else now = ch[now][!t], ret += ((!t) << i);	
		}
		return ret;
	}
} trie;
int n, tot, e[1000001], v[1000001], next[1000001], w[1000001], d[1000001];
bool vis[1000001];
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		d[v[i]] = d[x] ^ w[i]; dfs(v[i]);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	dfs(1);
	int ans = 0;
	trie.insert(0);
	for (int i = 2; i <= n; i++){
		ans = max(ans, trie.get(d[i]) ^ d[i]);
		trie.insert(d[i]);
	}
	printf("%d\n", ans);
}
Problem1965

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
ll pow(ll a, ll b, ll c)
{
	ll ret = 1;
	for (; b; b >>= 1ll){
		if (b & 1ll) ret = ret * a % c;
		a = a * a % c;
	}
	return ret;
}
void exgcd(ll a, ll b, ll & x, ll & y)
{
	if (b == 0) { x = 1; y = 0; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
ll solve(ll a, ll b, ll c) //ax == b mod c
{
	ll x, y; exgcd(a, c, x, y);
	x = x * b % c; return (x + c) % c;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	ll n, m, l;
	cin >> n >> m >> l;
	cout << solve(pow(2, m, n + 1), l, n + 1) << endl;
}
Problem1966

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
bool f[3001][3001];
char pat[1000001], s[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s", pat + 1); int n = strlen(pat + 1);
	int Q, ans = 0; scanf("%d", &Q); scanf(" ");
	while(Q--){
		scanf("%s", s + 1); int m = strlen(s + 1);
		for (int i = 0; i <= n; i++) for (int j = 0; j <= m; j++) f[i][j] = false;
		for (int i = 0; i <= n; i++)
			for (int j = 0; j <= m; j++){
				if (i == 0 && j == 0) { f[i][j] = true; continue; }
				if (i == 0 && j > 0) { f[i][j] = false; continue; }
				if (i > 0 && j == 0) { if (pat[i] == '*') f[i][j] = f[i - 1][j]; else f[i][j] = false; }
				switch(pat[i]){
					case '?' : f[i][j] = f[i - 1][j - 1]; break;
					case '*' : f[i][j] = f[i - 1][j - 1] || f[i - 1][j] || f[i][j - 1]; break;
					default : f[i][j] = f[i - 1][j - 1] && (pat[i] == s[j]); break;
				}
			}
		ans += (!f[n][m]);
	}
	cout << ans << endl;
	 
}
Problem1968

main()
{
	int n; long long ans = 0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) ans += n / i;
	printf("%lld\n", ans);
}
Problem1969

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <set>
#include <iostream>
const int MAXN = 300001;
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, sum;
	bool isroot, _del, cover;
	void del()
	{
		if (this == a) return;
		_del =true; sum = 0; cover = 0;
	}
	void push()
	{
		if (_del){
			a[c[0]].del();
			a[c[1]].del();
		}
		_del = 0;
	}
	void update()
	{
		sum = a[c[0]].sum + a[c[1]].sum + cover;
	}
	void rot(bool b)
	{
		a[f].push(); push(); 
		if (a[f].isroot) isroot = true, a[f].isroot = false;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
void access1(int x, bool F)
{
	int p = 0, q = x;
	while(q != 0){
		splay(q);
		if (A[q].f == 0 && F){
			A[p].del();
			A[A[q].c[1]].del();
			A[q].update();
		}
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p; A[A[q].c[1]].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
	}
}
int access2(int x)
{
	int p = 0, q = x, res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) res = A[p].sum + A[A[q].c[1]].sum;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p; A[A[q].c[1]].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
	}
	return res;
}
struct Tedge{
	int s, t; //s < t
	bool operator < (const Tedge & A) const
	{
		return s == A.s ? t < A.t : s < A.s;
	}
};
struct Tquery{
	int kind, a, b;
	void init(int _kind, int _a, int _b)
	{
		kind = _kind; a = _a; b = _b;
	}
} query[300001];
Tedge make(int _s, int _t) { Tedge temp; temp.s = _s; temp.t = _t; return temp; }
set<Tedge> M;
int tot, next[300001], e[300001], v[300001];
int vis[300001], anc[300001], deep[300001], fa[300001];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
	++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a;
}
void dfs(int x)
{
	vis[x] = true; anc[x] = deep[x];
	for (int i = e[x]; i; i = next[i]){
		if (vis[v[i]] && v[i] != fa[x]) anc[x] = min(anc[x], deep[v[i]]);
		if (!vis[v[i]]){
			fa[v[i]] = x; A[v[i]].f = fa[v[i]]; deep[v[i]] = deep[x] + 1;
			dfs(v[i]); anc[x] = min(anc[x], anc[v[i]]);
			if (anc[v[i]] > deep[x]) A[v[i]].cover = A[v[i]].sum = 1;
		}
	}
}
int n, m, ans[300001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); if (a > b) swap(a, b);
		M.insert(make(a, b));
	}
	int tot = 0;
	while(1){
		int c, a, b; scanf("%d%d%d", &c, &a, &b); if (c == -1) break;
		if (a > b) swap(a, b);
		++tot; query[tot].init(c, a, b);
		if (c == 0) M.erase(make(a, b));
	}
	for (set<Tedge>::iterator mei = M.begin(); mei != M.end(); mei++) add(mei->s, mei->t);
	dfs(1);
	for (int i = 1; i <= n; i++) A[i].isroot = true;
	for (int i = tot; i >= 1; i--)
		switch(query[i].kind){
			case 0 : access1(query[i].a, false); access1(query[i].b, true); break;
			case 1 : access2(query[i].a); ans[i] = access2(query[i].b); break;
		}
	for (int i = 1; i <= tot; i++) if (query[i].kind) printf("%d\n", ans[i]);
}
Problem1970

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n;
struct Tbig{
	int len, data[1001];
	Tbig() { len = 1; memset(data, 0, sizeof(data)); }
	int & operator [] (int k) { return data[k]; }
	const int & operator [] (int k) const { return data[k]; }
	Tbig & operator += (const Tbig & A)
	{
		len = max(len, A.len);
		for (int i = 1; i <= len; i++){
			data[i] += A[i];
			data[i + 1] += data[i] / 10000;
		   	data[i] %= 10000;
		}
		while(data[len + 1]) ++len;	
		return *this;
	}
	Tbig operator * (int d)
	{
		Tbig temp; temp.len = len;
		for (int i = 1; i <= len; i++){
			temp[i] += data[i] * d;
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
		}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i; i--) printf("%04d", data[i]);
		putchar('\n');
	}
} ans, pow[1001];
void doit(int dep)
{
	char c; scanf("%c", &c);
	if (c == '1') return;
   	if (c == '0') { ans += pow[dep + dep]; return; }
	for (int i = 0; i < 4; i++) doit(dep - 1);	
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); scanf(" ");
	pow[0][1] = 1;
	for (int i = 1; i <= 2 * n; i++) pow[i] = pow[i - 1] * 2;
	doit(n);
	ans.print();
}
Problem1974

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
const int MO = 999911659;
using namespace std;
ll n, num[1001];
int P, app[1001],  mem[1001][11], f[1001][1001][11];
int pow(int a, int b)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (ll)ret * a % MO;
		a = (ll)(a) * a % MO;
		}
	return ret;
}
int inv(int t)
{
	return pow(t, MO - 2);
}
int calc_c(long long n, int m)
{
	long long ret = 1;
	for (int i = 1; i <= m; i++) ret = (ll)ret * ((n - i + 1) % MO) % MO;
	for (int i = 1; i <= m; i++) ret = (ll)ret * (inv(i) % MO) % MO;
	return ret;
}	
void predo()
{
	for (int i = 0; i <= P - 1; i++) if (num[i] > 0)
		for (int j = 0; j <= 8; j++)
			mem[i][j] = calc_c(num[i] + j - 1, j);
}
int main()
{
	cin >> n >> P;
	int now = 0, end, end1, start, endp;
	for (int i = 1; ;i++){
		now = (now * 10 + 1) % P;
		if (app[now]) { end = i - 1; endp = now; break; }
		else app[now] = i;
		}
	end1 = app[endp] - 1;
	start = app[endp];
	now = 0;
	for (int i = 1; i <= min(n, (ll)end1); i++){
		now = (now * 10 + 1) % P;
	   	++num[now];
		}
	now = 0; int r;
	ll nn = max(0ll, n - end1);
	for (int i = 1; i <= end1; i++){
		now = (now * 10 + 1) % P;
		if (i == n) r = now;
		}
	if (n > end1)
		for (int i = start; i <= end; i++){
			now = (now * 10 + 1) % P;
			int temp = nn % (end - start + 1) ? nn % (end - start + 1) : (end - start + 1);
			if (temp == i - end1) r = now;
			}
	r = (P - r) % P;	
	if (n > end1)
	for (int i = start; i <= end; i++){
		now = (now * 10 + 1) % P;
		num[now] += nn / (end - start + 1) + (i <= (nn % (end - start + 1)));
		}	
	predo();
	f[0][0][0] = 1;
	if (num[0] > 0) for (int i = 1; i <= 8; i++) f[0][0][i] = mem[0][i];
	for (int i = 1; i < P; i++)
	for (int j = 0; j < P; j++)
	for (int k = 0; k <= 8; k++) if (num[i] == 0) f[i][j][k] = f[i - 1][j][k];
	else for (int l = 0; l + k <= 8; l++) f[i][(j + l * i) % P][l + k] = (f[i][(j + l * i) % P][l + k] + (ll)f[i - 1][j][k] * mem[i][l] % MO) % MO;
	int ans = 0;
	for (int i = 0; i <= 8; i++) ans = (ans + f[P - 1][r][i]) % MO;
	printf("%d\n", ans);
}
Problem1975

#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;
const int MAXN = 100001, MAXM= 500001;
double dis[MAXN], cost;
int  n, m, ans;
bool vis[MAXN];
struct Tdata{
	double pass; int who;
	bool operator < (const Tdata & A) const
	{
		return pass + dis[who] > A.pass + dis[A.who]; 
	}
};
Tdata make(double pass, int who)
{
	Tdata temp; temp.pass = pass; temp.who = who;
	return temp;
}
priority_queue<Tdata> Q;	
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM];
	double w[MAXM];
	void add(int a, int b, double c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	void dijkstra()
	{	
		for (int i = 1; i < n; i++) dis[i] = 1e99;
		for (int i = 1; i <= n; i++){
			double mind = 1e99; int who;
			for (int j = 1; j <= n; j++) if (!vis[j] && dis[j] < mind) { who = j; mind = dis[j]; }
			vis[who] = true;
			for (int i = e[who]; i; i = next[i]) if (!vis[v[i]]) dis[v[i]] = min(dis[v[i]], dis[who] + w[i]);
			}
	}
	void astar()
	{
		Q.push(make(0.0, 1));
		while(1){
			Tdata temp = Q.top(); Q.pop();
			if (temp.who == n)
				if (temp.pass > cost) return; 
				else{
					cost -= temp.pass; ++ans; 
					continue; 
					}
			else for (int i = e[temp.who]; i; i = next[i])
				Q.push(make(temp.pass + w[i], v[i]));
			}
	}	
} g, gt; 
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif

	scanf("%d%d%lf", &n, &m, &cost);
	for (int i = 1; i <= m; i++){
		int a, b; double c;
		scanf("%d%d%lf", &a, &b, &c);
		gt.add(b, a, c); g.add(a, b, c);
		}
	gt.dijkstra();
	g.astar();
	printf("%d\n", ans);
}
	
Problem1977

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int inf = 0x3f3f3f3f, MAXNODE = 600001;
struct Tedge{
	int st, ed, len; bool used;
	void init() { scanf("%d%d%d", &st, &ed, &len); }
	bool operator < (const Tedge & A) const { return len < A.len; }
} edge[MAXNODE];
struct Tuf{
	int f[MAXNODE];
	void init(int n) { for (int i = 1; i <= n; i++) f[i] = i; }
	int getf(int v) { return v == f[v] ? v : f[v] = getf(f[v]); }
	bool same(int a, int b)
	{
		a = getf(a); b = getf(b);
		if (a != b) f[a] = b;
		return a == b;
	}
} uf;
struct Tinf{
	int mv1, mv2;
	Tinf() { mv1 = mv2 = -inf; }
	void update(int num)
	{
		if (num > mv1) { mv2 = max(mv2, mv1); mv1 = num; }
		if (num < mv1 && num > mv2) mv2 = num;
	}	
	Tinf operator + (Tinf A)
	{
		Tinf temp= *this;
		temp.update(A.mv1); temp.update(A.mv2); return temp;
	}
	Tinf operator + (int num)
	{
		Tinf temp = *this;
		temp.update(num);
		return temp;
	}	
};
struct Tnode{
	static Tnode *a;
	int c[2], f, val;
	Tinf info;
	bool isroot;
	void update()
	{
		info = a[c[0]].info + a[c[1]].info + val;
	}
	void rot(bool b)
	{
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXNODE], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
Tinf access(int x)
{
	int p = 0, q = x; Tinf ret;
	while(q){
		splay(q);
		if (A[q].f == 0) ret = A[A[q].c[1]].info + A[p].info;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p; A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
	}
	return ret;
}
int tot, e[MAXNODE], v[MAXNODE], w[MAXNODE], next[MAXNODE];
int f[MAXNODE];
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; w[tot] = c;
}
void bfs()
{
	static int q[MAXNODE], l, r;
	l = r = 1; q[1] = 1; A[1].isroot = true; A[1].val = 0x3f3f3f3f; A[1].update();
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]) {
			q[++r] = v[i]; f[v[i]] = x; A[v[i]].f = x; A[v[i]].val = w[i]; 
			A[v[i]].isroot = true; A[v[i]].update();
		}
	}
}
int n, m;
long long mst()
{
	long long ret = 0;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) edge[i].init(); uf.init(n);
	sort(edge + 1, edge + m + 1);
	int now = 0;
	for (int i = 1; now < n - 1; i++)
		if (!uf.same(edge[i].st, edge[i].ed)) ret += edge[i].len, ++now, edge[i].used = true, add(edge[i].st, edge[i].ed, edge[i].len);
	return ret;
}
int work()
{
	bfs();
	int ret = 0x3f3f3f3f; Tinf temp;
	for (int i = 1; i <= m; i++) if (!edge[i].used){
		access(edge[i].st);
		temp = access(edge[i].ed);
		ret = min(ret, edge[i].len - (temp.mv1 != edge[i].len ? temp.mv1 : temp.mv2));
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	long long len1 = mst();
	cout << len1 + work() << endl;
}
Problem1984

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f, MAXN = 300001;
struct Tnode{
	static Tnode *a;
	int f, c[2], val, _add, _same, maxv;
	bool isroot;
	void set(int _val, int _f)
	{
		val = maxv = _val; f = _f; isroot = true; _same = INF;
	}
	void same(int t)
	{
		if (this == a) return;
		val = maxv = _same = t; _add = 0;
	}
	void add(int t)
	{
		if (this == a) return;
		val += t; _add += t; maxv += t;
	}
	void push()
	{
		if (_same != INF){
			a[c[0]].same(_same); a[c[1]].same(_same); _same = INF;
			}
		if (_add){
			a[c[0]].add(_add); a[c[1]].add(_add); _add = 0;
			}
	}
	void update()
	{
		maxv = max(val, max(a[c[0]].maxv, a[c[1]].maxv));
	}
	void rot(bool b)
	{
		a[f].push(); push();
		if (a[f].isroot) isroot = true, a[f].isroot = false;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[c[!b] == a[f].c[1]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}	
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update();
}
int ACCESS1(int x)
{
	int p = 0, q = x, _res = 0;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = max(A[p].maxv, A[A[q].c[1]].maxv);
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void ACCESS2(int x, int d, bool FLAG)
{
	int p = 0, q = x;
	while(q != 0){
		splay(q);
		if (A[q].f == 0 && FLAG){
			A[p].same(d);
			A[A[q].c[1]].same(d);
			}
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
}
void ACCESS3(int x, int d, bool FLAG)
{
	int p = 0, q = x;
	while(q != 0){
		splay(q);
		if (A[q].f == 0 && FLAG){
			A[p].add(d);
			A[A[q].c[1]].add(d);
			}
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
}
bool vis[MAXN];
int tot, e[MAXN], w[MAXN], v[MAXN], next[MAXN];
int st[MAXN], ed[MAXN], f[MAXN], n;
void CHANGE(int x, int d)
{
	if (f[st[x]] == ed[x]) x = st[x]; else x = ed[x];
	splay(x); A[x].val = d; A[x].update();
}
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		A[v[i]].set(w[i], x); dfs(v[i]); f[v[i]] = x;
		}
}	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);
	freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z); add(x, y, z); add(y, x, z);
		st[i] = x; ed[i] = y;
		}
	A[1].set(0, 0); A[0].maxv = 0xe0e0e0e0; dfs(1);
	char op[101]; int l, r, d;
	while(1){
		scanf("%s", op); if (*op == 'S') break;
		switch(*(op + 1)){
			case 'a': scanf("%d%d", &l, &r); ACCESS1(l); printf("%d\n", ACCESS1(r)); break;
			case 'o': scanf("%d%d%d", &l, &r, &d); ACCESS2(l, d, 0); ACCESS2(r, d, 1); break;
			case 'd': scanf("%d%d%d", &l, &r, &d); ACCESS3(l, d, 0); ACCESS3(r, d, 1); break;
			case 'h': scanf("%d%d", &l, &d); CHANGE(l, d); break;
			}
		}
}
Problem1989

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, tot, e[11000], next[500001], v[500001], size[11000];
bool vis[11000];
double ans;
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x)
{
	vis[x] = true; size[x] = 1;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		dfs(v[i]); size[x] += size[v[i]];
		ans += (double) size[v[i]] * size[v[i]] * (n - size[v[i]]) * (n - size[v[i]]) * 4 / n / n / (n - 1) / (n - 1);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
while(~scanf("%d", &n)){
	ans = 0;
	tot = 0; memset(e, 0, sizeof(e));
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	dfs(1);
	printf("%.6lf\n", ans);
}
}
Problem1996

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 19650827;
int f[1501][1501][2], data[1501], n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &data[i]), f[i][i][0] = 1;
	for (int len = 2; len <= n; len++)
		for (int l = 1; l + len - 1 <= n; l++){
			int r = l + len - 1;
			if (data[l] < data[l + 1]) f[l][r][0] = (f[l][r][0] + f[l + 1][r][0]) % MO;
			if (data[l] < data[r]) f[l][r][0] = (f[l][r][0] + f[l + 1][r][1]) % MO;
			if (data[r] > data[l]) f[l][r][1] = (f[l][r][1] + f[l][r - 1][0]) % MO;
			if (data[r] > data[r - 1]) f[l][r][1] = (f[l][r][1] + f[l][r - 1][1]) % MO;
		}
	printf("%d\n", (f[1][n][0] + f[1][n][1]) % MO);
}
Problem1997

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 701, MAXM = MAXN * MAXN * 9; 
int n, m, st[100001], ed[100001], rank[100001];
struct Tbiojudge{
	int tot, e[MAXN], v[MAXM], next[MAXM], col[MAXN]; bool vis[MAXN];
	void add(int a, int b) 
	{ 
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; 
	}
	void init()
	{
		tot = 0; memset(vis, 0, sizeof(vis)); memset(e, 0, sizeof(e)); memset(col, 0, sizeof(col));
	}
	bool judge(int x)
	{
		vis[x] = true;
		for (int i = e[x]; i; i = next[i])
			if (vis[v[i]]){
				if (col[x] == col[v[i]]) return false;
			}
			else{
				col[v[i]] = col[x] ^ 1;
				if (!judge(v[i])) return false;
			}
		return true;
	}
	bool solve()
	{
		for (int i = 1; i <= m; i++) if (!vis[i]) if (!judge(i)) return false;
		return true;
	}	
}bio;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	bio.init();
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d%d", &st[i], &ed[i]);
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t); rank[t] = i;
	}
	if (m >= 3 * n) { puts("NO"); continue; }
	for (int i = 1; i <= m; i++)
		for (int j = i + 1; j <= m; j++){
			int a = rank[st[i]], b = rank[ed[i]], c = rank[st[j]], d = rank[ed[j]];
			if (a > b) swap(a, b); if (c > d) swap(c, d);
			if ((d > b && b > c && c > a) || (b > d && d > a && a > c)) bio.add(i, j), bio.add(j, i);
		}
	puts(bio.solve() ? "YES" : "NO");
}
}
Problem1998

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001;
int c[MAXN], a[MAXN], who[MAXN], n, s, q, p, m, d, g;
struct Tsuperuf{
	int next[MAXN], up[MAXN], usednum[MAXN], over[MAXN];
	void init()
	{
		memset(usednum, 0, sizeof(usednum));
		memset(over, 0, sizeof(over));
		for (int i = 0; i < n; i++){
			next[i] = i;
			up[i] = (i + 1) % n;
		}
		if (d == 1) over[s] = true;
	    ++usednum[s % g]; next[s] = (s + d) % n;	
	}
	int find(int x)
	{
		if (over[x % g]) return find(up[x]);
		return next[x] == x ? x : next[x] = find(next[x]);
	}
	void use(int x)
	{
		++usednum[x % g];
		if (usednum[x % g] == n / g) over[x % g] = true;
		else next[x] = find(next[(x + d) % n]);
	}
} uf;
bool vis[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d%d%d%d%d", &n, &s, &q, &p, &m, &d);
	g = __gcd(n, d);
	uf.init();
	c[0] = 0;
	for (int i = 1; i < n; i++) c[i] = (((long long)c[i - 1] * q % m) + p) % m;
	a[0] = s;
	for (int i = 1; i < n; i++){
		a[i] = uf.find(c[i] % n);
		uf.use(a[i]);
	}
	int ans = 0;
	memset(vis, 0, sizeof(vis));
	for (int i = 0; i < n; i++) if (!vis[i]){
		if (a[i] == i) continue;
		int num = 1; vis[i] = true;
		for (int j = a[i]; j != i; j = a[j]) ++num, vis[j] = true;
		if (i == 0) ans += num - 1; else ans += num + 1;
	}
	for (int i = 0; i < n; i++) who[a[i]] = i;
	printf("%d\n", ans);
}
}
Problem1999

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MAXM = 2000001;
bool cant[MAXN];
int tot, next[MAXM], e[MAXN], v[MAXM], w[MAXM];
int l, r, q[MAXN], dis[MAXN], f[MAXN], fd[MAXN];
int n, LL;
int c[MAXN], cd[MAXN], cs[MAXN], len, far[MAXN];
struct Tqueue{
	int data[MAXN], l, r;
	void clear() { l = 1; r = 0; }
	void push(int t) { while(r >= l && far[t] > far[data[r]]) --r; data[++r] = t; }
	void pop() { ++l; }
	bool empty() { return l > r; }
	int top() { return data[l]; }
} Q;
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int bfs(int st)
{
	f[st] = 0; l = 1; r = 1; q[1] = st; dis[st] = 0;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (v[i] != f[x] && (!cant[v[i]])){
			dis[v[i]] = dis[x] + w[i]; f[v[i]] = x; fd[v[i]] = w[i];
			q[++r] = v[i];
			}
		}
	int maxdis = -1, who;
	for (int i = 1; i <= r; i++) if (maxdis < dis[q[i]]) maxdis = dis[q[i]], who = q[i];
	return who;
}
int main()
{
	scanf("%d%d", &n, &LL);
	for (int i = 1; i <= n - 1; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(x, y, z); add(y, x, z);
		}
	int a = bfs(1), b = bfs(a);
	for (; f[b]; b = f[b]) { c[++len] = b; cd[len] = fd[b]; } c[++len] = a;
	for (int i = 2; i <= len; i++) cs[i] = cs[i - 1] + cd[i - 1];
	for (int i = 1; i <= len; i++) cant[c[i]] = true;
	for (int i = 1; i <= len; i++) far[i] = dis[bfs(c[i])];
	int R = 0; Q.clear();
	int ans = 0x3f3f3f3f;
	for (int i = 1; i <= len; i++){
		while(!Q.empty() && Q.top() <= i) Q.pop();
		while(R < len && cs[R + 1] - cs[i] <= LL){ ++R; Q.push(R); }
		ans = min(ans, max(max(cs[i], cs[len] - cs[R]), far[Q.top()]));
		}
	printf("%d\n", ans);
}
Problem2002

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 600001;
struct Tnode{
	static Tnode *a;
	int c[2], f, size;
	bool isroot, _rev;
	void rev()
	{
		if (this == a) return;
		swap(c[0], c[1]); _rev ^= 1;
	}
	void set(int _f)
	{
		f = _f; isroot = true; size = 1;
	}
	void push()
	{
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = false;
			}
	}	
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
	}
	void rot(bool b)
	{
		a[f].push(); push();
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
}A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update();
}
int ACCESS(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[p].size + 1 + A[A[q].c[1]].size;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void EVERT(int x)
{
	ACCESS(x); splay(x); A[x].rev();
}
void LINK(int x, int y)
{
	EVERT(x); A[x].f = y;
}
void CUT(int x, int y)
{
	EVERT(x); ACCESS(y); splay(y); A[x].isroot = true; A[x].f = 0; A[y].c[0] = 0; A[y].update();
}
int n, m, now[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t); if (i + t <= n) A[i].set(i + t); else A[i].set(n + 1);
		now[i] = A[i].f;
		}
	A[n + 1].set(0);
	scanf("%d", &m);
	for (int i = 1; i <= m; i++){
		int x, d, op;
		scanf("%d", &op);
		switch(op){
			case 1 : scanf("%d", &x); ++x; ACCESS(x); printf("%d\n", ACCESS(n + 1) - 1); break;
			case 2 : scanf("%d%d", &x, &d); ++x; CUT(x, now[x]); 
			if (x + d <= n) now[x] = x + d; else now[x] = n + 1; LINK(x, now[x]);
			}
		}
}
Problem2004

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
typedef int Tmatrix[301][301];
using namespace std;
const int MO = 30031;
Tmatrix map, now, buf, temp;
int n, k, p, num, tnow[301];
void mul(Tmatrix c, Tmatrix a, Tmatrix b)
{
	memset(temp, 0, sizeof(temp));
	for (int k = 0; k < num; k++)
		for (int i = 0; i < num; i++)
			for (int j = 0; j < num; j++)
				temp[i][j] = (a[i][k] * b[k][j] + temp[i][j]) % MO;
	for (int i = 0; i < num; i++)
		for (int j = 0; j < num; j++)
			c[i][j] = temp[i][j] % MO;
}
void dfs(int dep, int pre)
{
	if (dep == k){
		memcpy(buf[num++], tnow, sizeof(tnow));
		return;
	}
	for (int i = pre + 1; i <= p; i++){
		tnow[i] = true;
		dfs(dep + 1, i);
		tnow[i] = false;
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &k, &p);
	tnow[1] = 1;
	dfs(1, 1);
	for (int i = 0; i < num; i++)
		for (int j = 0; j <num; j++){
			int okp = 0;
			for (int t = 1; t < p; t++)
				if (buf[i][t] && buf[j][t + 1]) ++okp;
			if (okp == k - 1) ++map[i][j];
		}
	int len = n - k;
	for (int i = 0; i < num; i++) now[i][i] = 1;
	for (; len; len >>= 1){
		if (len & 1) mul(now, now, map);
		mul(map, map, map);
	}
	printf("%d\n", now[0][0]);
}
Problem2005

#include <iostream>
#include <algorithm>
using namespace std;
long long f[200001], n, m;
int main()
{
	cin >> n >> m;
	if (n > m) swap(n, m);
	long long ans = 0;
	for (int i = n; i >= 1; i--){
		f[i] = (long long)(n / i) * (long long)(m / i);
		for (int j = 2; j <= n / i; j++) f[i] -= f[i * j];
		ans = ans + 2ll * f[i] * i;
		}
	cout << ans - n * m << endl;
}
Problem2006

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 1500001;
int in[MAXN];
long long sum[MAXN], S[MAXN];
int n, k, a, b;
int l[MAXN], r[MAXN], len[MAXN];
struct Tdtree{
	long long d[21][MAXN]; int tl[21][MAXN];
	void build(int dep, int l, int r)
	{
		if (l == r) return;
		int m = l + r >> 1, ls = m - l + 1, lp = l - 1, rp = m;
		for (int i = l; i <= r; i++) if (d[dep][i] < sum[m]) --ls;
		for (int i = l; i <= r; i++){
			tl[dep][i] = i == l ? 0 : tl[dep][i - 1];
			if (d[dep][i] < sum[m]) ++tl[dep][i], d[dep + 1][++lp] = d[dep][i];
			else if (d[dep][i] > sum[m]) d[dep + 1][++rp] = d[dep][i];
			else if (ls) ++tl[dep][i], d[dep + 1][++lp] = d[dep][i], --ls;
			else d[dep + 1][++rp] = d[dep][i];
			}
		build(dep + 1, l, m); build(dep + 1, m + 1, r);
	}
	long long query(int dep, int l, int r, int ll, int rr, int k)
	{
		if (l == r) return d[dep][l];
		int A, B, C, D, m = l + r >> 1;
		if (l == ll) A = 0, B = tl[dep][rr]; else A = tl[dep][ll - 1], B = tl[dep][rr] - A;
		C = ll - l - A; D = rr - ll + 1 - B;
		if (B >= k) return query(dep + 1, l, m, l + A, l + A + B - 1, k);
		else return query(dep + 1, m + 1, r, m + C + 1, m + C + D, k - B);
	}
} T;
struct Theapnode{
	int who, k;
	long long num;
	bool operator < (const Theapnode & A) const { return num > A.num; }
};
Theapnode make(int who, int k, long long num)
{
	Theapnode temp; temp.who = who; temp.k = k ; temp.num = num;
	return temp;
}
struct Theap{
	Theapnode h[MAXN]; int size;
	void push(Theapnode t)
	{
		h[++size] = t; int i = size;
		while(i != 1){
			if (h[i] < h[i >> 1]) swap(h[i], h[i >> 1]); else break;
			i >>= 1;
			}
	}
	Theapnode pop()
	{
		Theapnode ret = h[1];
		swap(h[1], h[size]); --size;
		int i = 2;
		while(i <= size){
			if (i < size && h[i + 1] < h[i]) ++i;
			if (h[i] < h[i >> 1]) swap(h[i], h[i >> 1]); else break;
			i <<= 1;
			}
		return ret;
	}
} H;	
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	long long ans = 0;
	scanf("%d%d%d%d", &n, &k, &a, &b);
	for (int i = 1; i <= n; i++){
		scanf("%d", &in[i]); sum[i] = sum[i - 1] + in[i];
		}
	for (int i = 0; i <= n; i++) T.d[0][i] = sum[i];
	sort(sum, sum + n);
	T.build(0, 0, n - 1);
	for (int i = 1; i <= n; i++){
		r[i] = i - a; l[i] = i - b;
		len[i] = max(r[i], 0) - max(l[i], 0) + 1;
		if (r[i] < 0) len[i] = -1;
		r[i] = max(r[i], 0); l[i] = max(l[i], 0);
		}
	for (int i = 1; i <= n; i++) if (len[i] != -1)
		H.push(make(i, 1, T.d[0][i] - T.query(0, 0, n - 1, l[i], r[i], 1)));
	for (int i = 1; i <= k; i++){
		Theapnode temp = H.pop();
		ans += temp.num;
		if (len[temp.who] == temp.k) continue;
		H.push(make(temp.who, temp.k + 1, T.d[0][temp.who] - T.query(0, 0, n - 1, l[temp.who], r[temp.who], temp.k + 1)));
		}
	printf("%lld\n", ans);
}
Problem2007

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
//#define DEBUG
using namespace std;
const int MAXN = 1001, S = 1048576 - 1;
int map[MAXN][MAXN][4], n;
int l, r;
int dis[MAXN][MAXN];
bool vis[MAXN][MAXN];
struct Tqueue { int x, y; } q[S + 1001];
void relax(int x, int y, int DIS)
{
	if (x == 0 && y == 0) return;
	if (x == n + 1 && y == n + 1) return;
	if (dis[x][y] > DIS){
#ifdef DEBUG
		printf("%d %d = %d\n", x, y, DIS);
#endif
		dis[x][y] = DIS;
		if (!vis[x][y]){
			vis[x][y] = true;
			r = (r + 1) & S; q[r].x = x; q[r].y = y;
			}
	}
}		
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n + 1; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &map[i][j][0]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n + 1; j++)
			scanf("%d", &map[i][j][1]);
	for (int i = 1; i <= n + 1; i++)
		for (int j = 2; j <= n + 1; j++)
			scanf("%d", &map[i][j][2]);
	for (int i = 2; i <= n + 1; i++)
		for (int j = 1; j <= n + 1; j++)
			scanf("%d", &map[i][j][3]);
	memset(dis, 0x3f, sizeof(dis));
	l = 0; r = 1; vis[n + 1][0] = true; dis[n + 1][0] = 0;
	q[1].x = n + 1; q[1].y = 0;
	while(l != r){
		l = (l + 1) & S; int x = q[l].x, y = q[l].y; vis[x][y] = false;
		if (x != 0) relax(x - 1, y, dis[x][y] + map[x][y][0]);
		if (y != 0) relax(x, y - 1, dis[x][y] + map[x + 1][y][3]);
		if (x != n + 1) relax(x + 1, y, dis[x][y] + map[x + 1][y + 1][2]);
		if (y != n + 1) relax(x, y + 1, dis[x][y] + map[x][y + 1][1]);
		}	
	printf("%d\n", dis[0][n + 1]);
}
Problem2007

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
//#define DEBUG
using namespace std;
const int MAXN = 1001, S = 1048576 - 1;
int map[MAXN][MAXN][4], n;
int l, r;
int dis[MAXN][MAXN];
bool vis[MAXN][MAXN];
struct Tqueue { int x, y; } q[S + 1001];
void relax(int x, int y, int DIS)
{
	if (x == 0 && y == 0) return;
	if (x == n + 1 && y == n + 1) return;
	if (dis[x][y] > DIS){
#ifdef DEBUG
		printf("%d %d = %d\n", x, y, DIS);
#endif
		dis[x][y] = DIS;
		if (!vis[x][y]){
			vis[x][y] = true;
			if (DIS < dis[q[(l + 1) & S].x][q[(l + 1) & S].y]){
				l = (l - 1 + S) & S; q[(l + 1) & S].x = x; q[(l + 1) & S].y = y;
				}
			else{
				r = (r + 1) & S; q[r].x = x; q[r].y = y;
				}
			}
	}
}		
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n + 1; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &map[i][j][0]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n + 1; j++)
			scanf("%d", &map[i][j][1]);
	for (int i = 1; i <= n + 1; i++)
		for (int j = 2; j <= n + 1; j++)
			scanf("%d", &map[i][j][2]);
	for (int i = 2; i <= n + 1; i++)
		for (int j = 1; j <= n + 1; j++)
			scanf("%d", &map[i][j][3]);
	memset(dis, 0x3f, sizeof(dis));
	l = 0; r = 1; vis[n + 1][0] = true; dis[n + 1][0] = 0;
	q[1].x = n + 1; q[1].y = 0;
	while(l != r){
		l = (l + 1) & S; int x = q[l].x, y = q[l].y; vis[x][y] = false;
		if (x != 0) relax(x - 1, y, dis[x][y] + map[x][y][0]);
		if (y != 0) relax(x, y - 1, dis[x][y] + map[x + 1][y][3]);
		if (x != n + 1) relax(x + 1, y, dis[x][y] + map[x + 1][y + 1][2]);
		if (y != n + 1) relax(x, y + 1, dis[x][y] + map[x][y + 1][1]);
		}	
	printf("%d\n", dis[0][n + 1]);
}
Problem2013

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, d, a[2000001], ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &d);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    sort(a + 1, a + n + 1); int now = 1, ans = 1;
   	for (int i = 2; i <= n; i++){
		while(now < i && a[i] - a[now] > d) ++now;
		ans = (long long) ans * (i - now + 1) % 1000000009;
	}
	printf("%d\n", ans);
}
Problem2028

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;
set<pair<int, int> > S;
int Q;
bool cut(pair<int, int> A, pair<int, int> B)
{
	return A.first <= B.second && B.first <= A.second;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		char ch; scanf(" "); scanf("%c", &ch);
		if (ch == 'B') { printf("%d\n", S.size()); continue; }
		int l, r, ret = 0; scanf("%d%d", &l, &r); pair<int, int> now = make_pair(l, r);
		while(1){
			bool F = true;
			set<pair<int, int> >::iterator si1 = S.lower_bound(now), si2 = si1;
			if (si2 != S.begin()){
				--si2; if (cut(*si2, now)) { S.erase(si2); F = false; ++ret; }
			}
			if (si1 != S.end())
				if (cut(*si1, now)) { S.erase(si1); F = false; ++ret; }
			if (F) { S.insert(now); printf("%d\n", ret); break; }
		}
	}
	
}
Problem2032

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int temp[201];
int n, m, b, v, ans[20001];
int make(int t) { return ((t % 10007) + 10007) % 10007; }
struct Ttrans{
	int data[201], mul;
	void clear() { memset(this, 0, sizeof(*this)); }
	void operator *= (const Ttrans & A)
	{
		memset(temp, 0, sizeof(temp));
		for (int i = 0; i < m; i++)
			for (int j = 0; j < m; j++){
				int np = (i * A.mul + j) % m;
				temp[np] = make(temp[np] + data[i] * A.data[j]);
			}
		mul = mul * A.mul % m;
		for (int i = 0; i < m; i++) data[i] = temp[i];
	}
} now, g, ret;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &b, &m, &v);
	for (int set = 0; set < (1 << b); set++){	
		now.clear(); g.clear(); ret.clear();
		now.mul = 1; now.data[0] = 1;
		g.mul = ret.mul = b;
		for (int i = 0; i < b; i++) if ((set >> i) & 1){
			g.data[i % m]++;
			if (i) ret.data[i % m]++;
		}
		for (int i = n - 1; i; i >>= 1){
			if (i & 1) now *= g;
			g *= g;
		}
		ret *= now;
		ans[set] = ret.data[v];
	}
	for (int set = 0; set < (1 << b); set++)
		for (int subset = 0; subset < set; subset++) if ((set | subset) == set)
			ans[set] = make(ans[set] - ans[subset]);
	for (int i = 1; i < (1 << b); i++){
		for (int j = b - 1; j >= 0; j--)
			if ((i >> j) & 1) printf("%d", j);
		printf(" %d\n", ans[i]);
	}
}
Problem2035

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, key, data, minnum;
	void update()
	{
		minnum = min(data, min(a[c[0]].minnum, a[c[1]].minnum));
	}
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[4000001], *Tnode::a = A;
pair<int, int> stack[4000001]; int top;
int tot, now;
struct Tbst{
	int root;
	Tbst() { A[root = ++tot].key = 0xe0e0e0e0; A[tot].data = 0x3f3f3f3f; A[tot].minnum = 0x3f3f3f3f;  insert(0x3f3f3f3f, 0x3f3f3f3f); } 
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while((y = A[x].f) != p){
			b = x == A[y].c[1];
			if ((z = A[y].f) != p){
				c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
				A[x].rot(c);
			}
			else A[x].rot(b);
		}
		A[x].update(); if (p == 0) root = x; 
	}
	void pred(int x, int num) //find key < num
	{
		if (x == 0) return;
		if (A[x].key < num) now = x;	
		if (A[x].key >= num) pred(A[x].c[0], num); else pred(A[x].c[1], num);
	}
	void succ(int x, int num) //find key > num
	{
		if (x == 0) return;
		if (A[x].key > num) now = x;
		if (A[x].key <= num) succ(A[x].c[1], num); else succ(A[x].c[0], num);
	}
	int findmax(int t) { while(A[t].c[1]) t = A[t].c[1]; return t; }
	void insert(int key, int data)	
	{
		int t = root;
		while(A[t].c[key > A[t].key]) t = A[t].c[key > A[t].key];
		++tot; A[tot].key = key; A[tot].data = data; A[tot].update();
		A[tot].f = t; A[t].c[key > A[t].key] = tot;
		splay(tot, 0);
	}
	void erase(int x)
	{
		splay(x, 0);
		if (A[x].c[0] == 0) { root = A[x].c[1]; A[root].f = 0; return; }
		int t = findmax(A[x].c[0]); splay(t, root);
		A[t].c[1] = A[root].c[1]; A[A[root].c[1]].f = t; A[t].update();
		root = t; A[root].f = 0;
	}
	int get1(int i)
	{
		now = 0; pred(root, i); if (now == 0) return 0x3f3f3f3f;
		splay(now, 0); return A[A[root].c[1]].minnum - i;
	}
	int get2(int i)
	{
		now = 0; succ(root, i); if (now == 0) return 0x3f3f3f3f;
		splay(now, 0); return A[A[root].c[0]].minnum + i;
	}
} bst1, bst2;	
int TOT, e[2000001 * 2], v[2000001 * 2], next[2000001 * 2], n, a[1000001];
int f[1000001], deep[1000001];
int ans[1000001], ansnum;
void add(int a, int b)
{	
	++TOT; next[TOT] = e[a]; e[a] = TOT; v[TOT] = b;
}
int now1[4000001], now2[4100001], i[4100001];

void dfs()
{
while(top){
	int x = stack[top].first, k = stack[top].second;
	if (x == n + 1) { ans[++ansnum] = f[x]; --top; continue; }
	if (k == -1){
		bst1.insert(deep[x] + a[x] + 1, f[x] + deep[x] + a[x] + 2); now1[x] = tot;
		bst2.insert(deep[x] + a[x] + 1, f[x] - deep[x] - a[x]); now2[x] = tot;
		stack[top].second = e[x];
		continue;
	}
	if (k > 0){
		deep[v[k]] = deep[x] + 1;
		f[v[k]] = min(bst1.get1(deep[v[k]]), bst2.get2(deep[v[k]]));
		--top;
		stack[++top] = make_pair(x, next[k]);
		stack[++top] = make_pair(v[k], -1);
		continue;
	}
	if (k == 0){
		bst1.erase(now1[x]); bst2.erase(now2[x]);
		--top;
		continue;
	}		
}
}
int main()
{
A[0].data = A[0].minnum = 0x3f3f3f3f;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", a + i);
		int num, x; scanf("%d", &num);
		if (num == 0) add(i, n + 1);
		while(num--){
			scanf("%d", &x);
			add(i, x);
		}
	}
	for (int i = e[1]; i; i = next[i]){
		f[v[i]] = 0; 
		stack[++top] = make_pair(v[i], -1);
		}
	dfs(); 
	sort(ans + 1, ans + ansnum + 1);
	for (int i = 1; i <= ansnum; i++) printf("%d\n", ans[i]);
}
Problem2038

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#define uint unsigned int
using namespace std;
const int MAXN = 50001, MAXM = 50001;
struct Tpoint{
	int x, y, who;
	Tpoint() { }
	Tpoint (int x, int y, int who) : x(x), y(y), who(who) { }
	bool operator < (const Tpoint & A) const { return x == A.x ? y < A.y : x > A.x; }
} p[MAXM];
int a[MAXN], l[MAXM], r[MAXM], n, m;
int dis(int A, const int B)
{
	return abs(l[A] - l[B]) + abs(r[A] - r[B]);
}
struct Tedge{
	int st, ed, len;
	Tedge() { }
	Tedge (int st, int ed) : st(p[st].who), ed(p[ed].who) { len = dis(p[st].who, p[ed].who); }
	bool operator < (const Tedge & A) const { return len < A.len; }
} edge[MAXM * 8]; int edgenum;
int bit[MAXM * 2], val[MAXM];
int getmin(int a, int b) { if (a == 0 || b == 0) return a + b; else return val[a] < val[b] ? a : b; }
void addedge() //Solve R4
{
	memset(bit, 0, sizeof(bit));
	sort(p + 1, p + m + 1);
	for (int i = 1; i <= m; i++) val[i] = p[i].x - p[i].y;
	for (int i = 1; i <= m; i++){
		int temp = 0;
		for (int j = p[i].x + p[i].y; j; j -= (j & (-j))) temp = getmin(temp, bit[j]);
		if (temp != 0) edge[++edgenum] = Tedge(i, temp);
		for (int j = p[i].x + p[i].y; j <= 2 * n; j += (j & (-j))) bit[j] = getmin(bit[j], i);
	}
}
bool vis[MAXM];
int nowl, nowr;
uint sum, now[MAXN], ans[MAXM];
void update(int x, int F)
{
	x = a[x];
	sum -= now[x] * now[x];
	now[x] += F;
	sum += now[x] * now[x];
}
vector<int> adj[MAXN];
void dfs(int x)
{
	vis[x] = true;
	if (x == 1){
		nowl = l[1]; nowr = r[1];
		for (int i = nowl; i <= nowr; i++) update(i, 1);
	}
	for (int i = nowl; i < l[x]; i++) update(i, -1);
	for (int i = r[x] + 1; i <= nowr; i++) update(i, -1);
	for (int i = l[x]; i < nowl; i++) update(i, 1);
	for (int i = nowr + 1; i <= r[x]; i++) update(i, 1);
	nowl = l[x]; nowr = r[x];
	ans[x] = sum;
	for (int i = 0; i < adj[x].size(); i++) if (!vis[adj[x][i]]) dfs(adj[x][i]);
}
int fa[MAXM];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);
	for (int i = 1; i <= n; i++) p[i] = Tpoint(l[i], r[i], i); addedge();
	for (int i = 1; i <= n; i++) p[i] = Tpoint(l[i], n - r[i] + 1, i); addedge();
	for (int i = 1; i <= n; i++) p[i] = Tpoint(r[i], l[i], i); addedge();
	for (int i = 1; i <= n; i++) p[i] = Tpoint(r[i], n - l[i] + 1, i); addedge();
	sort(edge + 1, edge + edgenum + 1);
	for (int i = 1; i <= m; i++) fa[i] = i;
	for (int i = 1, now = 0; now < m - 1; i++){
		if (find(edge[i].st) == find(edge[i].ed)) continue;
		fa[find(edge[i].st)] = find(edge[i].ed);
		adj[edge[i].st].push_back(edge[i].ed); adj[edge[i].ed].push_back(edge[i].st);
		++now;
	}
	dfs(1);
	for (int i = 1; i <= m; i++){
		uint len = r[i] - l[i] + 1, fm = len * (len - 1), fz = ans[i] - len;
		uint temp = __gcd(fm, fz); fm /= temp; fz /= temp;
		printf("%u/%u\n", fz, fm);
	}
}
Problem2039

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 1010, MAXM = MAXN * MAXN * 2;
const ll INF = 1ll<<60ll, U = 1ll << 50ll;
template<class T>
inline void scan(T&t)
{
    char c;
    while(c=getchar(),c<'0'||c>'9');t=c-'0';
    while(c=getchar(),c>='0'&&c<='9')t=t*10+c-'0';
}
    struct Tmaxflow{
        int tot, e[MAXN], v[MAXM], next[MAXM], now[MAXN], h[MAXN];
        int s, t, l, r, q[MAXN];
        bool vis[MAXN];
        ll c[MAXM];
        Tmaxflow() { tot = 1; }
        void add1(int A, int B, ll C)
        {
            ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
            ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
        }
        void add2(int A, int B, ll C)
        {
            ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
            ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = C;
        }
        bool level()
        {
			for (int i = 1; i <= t; i++) h[i] = -1; h[s] = 0;
			l = 1; r = 1; q[1] = s;
			while(l <= r){
				int x = q[l++];
				for (int i = e[x]; i; i = next[i]) if (h[v[i]] == -1 && c[i] > 0){
					h[v[i]] = h[x] + 1; q[++r] = v[i];
				}
			}
			return h[t] > 0;
		}
        ll find(int x, ll f)
    	{
			ll augc = f; if (x == t) return f;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && h[x] + 1 == h[v[i]]){
				ll t = find(v[i], min(f, c[i]));
				c[i] -= t; c[i ^ 1] += t; f -= t;
			}
			//if (f == augc) h[x] = -1;
			return augc - f; 
		}
        ll run()
        {
			long long flow = 0;
			while(level()){
				while(1){
					ll d = find(s, INF);
					if (d == 0) break;
					flow += d;
				}			
			}
			return flow;
		}
    } maxflow;
int n; ll a[MAXN], e[MAXN][MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	maxflow.s = n + 1; maxflow.t = n + 2;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scan(e[i][j]);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			a[i] -= e[i][j];
			if (i < j) maxflow.add2(i, j, e[i][j] << 1);
		}
		maxflow.add1(maxflow.s, i, 0 + U);
		maxflow.add1(i, maxflow.t, a[i] + U);
	}
	cout << U * n - maxflow.run() << endl;
		
}
Problem2039

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 1010, MAXM = MAXN * MAXN * 2;
const ll INF = 1ll<<60ll, U = 1ll << 50ll;
template<class T>
inline void scan(T&t)
{
    char c;
    while(c=getchar(),c<'0'||c>'9');t=c-'0';
    while(c=getchar(),c>='0'&&c<='9')t=t*10+c-'0';
}
    struct Tmaxflow{
        int tot, e[MAXN], v[MAXM], next[MAXM], now[MAXN], h[MAXN];
        int s, t, l, r, q[MAXN];
        bool vis[MAXN];
        ll c[MAXM];
        Tmaxflow() { tot = 1; }
        void add1(int A, int B, ll C)
        {
            ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
            ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
        }
        void add2(int A, int B, ll C)
        {
            ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
            ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = C;
        }
        bool level()
        {
			for (int i = 1; i <= t; i++) h[i] = -1; h[s] = 0;
			l = 1; r = 1; q[1] = s;
			while(l <= r){
				int x = q[l++];
				for (int i = e[x]; i; i = next[i]) if (h[v[i]] == -1 && c[i] > 0){
					h[v[i]] = h[x] + 1; q[++r] = v[i];
				}
			}
			return h[t] > 0;
		}
        ll find(int x, ll f)
    	{
			ll augc = f; if (x == t) return f;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && h[x] + 1 == h[v[i]]){
				ll t = find(v[i], min(f, c[i]));
				c[i] -= t; c[i ^ 1] += t; f -= t;
			}
			if (f == augc) h[x] = -1;
			return augc - f; 
		}
        ll run()
        {
			long long flow = 0;
			while(level()){
				while(1){
					ll d = find(s, INF);
					if (d == 0) break;
					flow += d;
				}			
			}
			return flow;
		}
    } maxflow;
int n; ll a[MAXN], e[MAXN][MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	maxflow.s = n + 1; maxflow.t = n + 2;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scan(e[i][j]);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++){
			a[i] -= e[i][j];
			if (i < j) maxflow.add2(i, j, e[i][j] << 1);
		}
		maxflow.add1(maxflow.s, i, 0 + U);
		maxflow.add1(i, maxflow.t, a[i] + U);
	}
	cout << U * n - maxflow.run() << endl;
		
}
Problem2040

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#define PII pair<int, int>
#define renew(a) a = min(a, INF)
const int INF = 100000000;
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, minnum, minwho, add, key;
	bool isroot;
	void set(int _f, int _key)
	{
		f = _f; key = _key; isroot = true;
		update();
	}
	void _add(int delta)
	{
		if (this != a){
			minnum += delta; add += delta; key += delta;
		}
	}
	void push()
	{
		if (add != 0){
			a[c[0]]._add(add);
			a[c[1]]._add(add);
			add = 0;
		}
	}
	void update()
	{
		minnum = key; minwho = this - a;
		if (a[c[0]].minnum < minnum){
			minnum = a[c[0]].minnum;
			minwho = a[c[0]].minwho;
		}
		if (a[c[1]].minnum < minnum){
			minnum = a[c[1]].minnum;
			minwho = a[c[1]].minwho;
		}
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[1000001], *Tnode::a = A;
struct Tlinkcuttree{
	void splay(int x)
	{
		int y, z; bool b, c; A[x].push();
		while(!A[x].isroot){
			y = A[x].f; b = x == A[y].c[1];
			if (!A[y].isroot){
				z = A[y].f; c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
				A[x].rot(c);
			}
			else A[x].rot(b);
		}
		A[x].update();
	}
	void access1(int x, int delta)
	{
		int q = x, p = 0;
		while(q != 0){
			splay(q);
			if (delta != 0 && A[q].f == 0) { A[p]._add(delta); A[A[q].c[1]]._add(delta); }
			A[A[q].c[1]].isroot = true;
			A[p].isroot = false;
			A[q].c[1] = p;
			A[q].update();
			p = q; q = A[q].f;
		}
	}
	PII access2(int x)
	{
		int q = x, p = 0; PII ret;
		while(q != 0){
			splay(q);
			if (A[q].f == 0) ret = A[p].minnum < A[A[q].c[1]].minnum ? make_pair(A[p].minwho, A[p].minnum) : make_pair(A[A[q].c[1]].minwho, A[A[q].c[1]].minnum);
			A[A[q].c[1]].isroot = true;
			A[p].isroot = false;
			A[q].c[1] = p;
			A[q].update();
			p = q; q = A[q].f;
		}
		return ret;
	}
	PII query(int x)
	{
		access2(1); return access2(x);
	}
	void cover(int x, int d)
	{
		access1(1, 0); access1(x, d);
	}
	void change(int x, int c)
	{
		splay(x); A[x].key = c; A[x].update();
	}
} lct;
struct Tsgt{
	int _add[1000001], minnum[1000001], minwho[1000001];
	void add(int idx, int delta)
	{
		_add[idx] += delta; renew(_add[idx]);
		minnum[idx] += delta; renew(minnum[idx]);
	}
	void push(int idx)
	{
		if (_add[idx]){
			add(idx * 2, _add[idx]);
			add(idx * 2 + 1, _add[idx]);
			_add[idx] = 0;
		}
	}
	void update(int idx)
	{
		if (minnum[idx * 2] <= minnum[idx * 2 + 1]){
			minnum[idx] = minnum[idx * 2];
			minwho[idx] = minwho[idx * 2];
		}
		else{
			minnum[idx] = minnum[idx * 2 + 1];
			minwho[idx] = minwho[idx * 2 + 1];
		}
		renew(minnum[idx]);
	}
	void build(int idx, int l, int r)
	{
		if (l == r) { minnum[idx] = 0; minwho[idx] = l; return; }
		build(idx * 2, l, l + r >> 1);
		build(idx * 2 + 1, l + r + 2 >> 1, r);
		update(idx);
	}
	void cover(int idx, int l, int r, int ll, int rr, int d)
	{
		if (ll <= l && rr >= r) { add(idx, d); return; }
		int m = l + r >> 1; push(idx);
		if (ll <= m) cover(idx * 2, l, m, ll, rr, d);
		if (rr > m) cover(idx * 2 + 1, m + 1, r, ll, rr, d);
		update(idx);
	}
} sgt;
vector<int> E[1000001];
int n, m, num1[1000001], num2[1000001], l[1000001], r[1000001], leaf[1000001], now[1000001], tot;
void dfs(int x)
{
	l[x] = tot + 1;
	if (E[x].size() == 0) leaf[++tot] = x;
	for (int i = 0; i < E[x].size(); i++) dfs(E[x][i]);
	r[x] = tot;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	A[0].minnum = A[0].key = INF;
	scanf("%d%d", &n, &m); n++;
	for (int i = 1; i < n; i++){
		int a, b, c, d; scanf("%d%d%d%d", &a, &b, &c, &d); ++a; ++b;
		E[a].push_back(b); A[b].set(a, c);
		num1[b] = c; num2[b] = d; now[b] = 0;
	}
	A[1].set(0, INF);
	dfs(1); sgt.build(1, 1, tot);
	int ans = 0;
	while(1){
		int who = leaf[sgt.minwho[1]], cost = sgt.minnum[1], flow; PII temp;
		if (cost > n) break;
		temp = lct.query(who); flow = temp.second;
		if (flow * cost <= m){
			ans += flow; m -= cost * flow;
			lct.cover(who, -flow);
			if (now[temp.first] == 0 && num1[temp.first] < num2[temp.first]){
				lct.change(temp.first, num2[temp.first] - num1[temp.first]); 
				sgt.cover(1, 1, tot, l[temp.first], r[temp.first], 1); now[temp.first] = 1; 
			}	
			else{
				sgt.cover(1, 1, tot, l[temp.first], r[temp.first], INF);
				lct.change(temp.first, 0); 
			}
		}
		else{
			ans += m / cost;
			break;
		}
	}
	printf("%d\n", ans);
	
}
Problem2044

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tmi{
    int x, y, z;
    void init() { scanf("%d%d%d", &x, &y, &z); }
    bool operator < (const Tmi & A) const { return x < A.x && y < A.y && z < A.z; }
} m[100001];
bool cmp(Tmi A, Tmi B)
{
	return A.x < B.x;
}
int n;
struct Tbio{
    vector<int> adj[100001]; int link[100001]; bool vis[100001];
    void add(int a, int b) { adj[a].push_back(b); }
    bool find(int x)
    {
        for (vector<int>::iterator vii = adj[x].begin(); vii != adj[x].end(); vii++) if (!vis[*vii]){
            vis[*vii] = true;
            if (link[*vii] == 0 || find(link[*vii])) { link[*vii] = x; return true; }
        }
        return false;
    }
    int solve()
    {
        int ans = 0;
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= n;j++) vis[j] = false;
            ans += find(i);
        }
        return ans;
    }
} bio;
int f[1000001];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d", &n); int ans = 0;
    for (int i = 1; i <= n; i++) m[i].init();
    sort(m + 1,m + n + 1, cmp);
    for (int i = 1; i <= n; i++){
        f[i] = 1;
        for (int j = i - 1; j >= 1; j--) if (m[j] < m[i]) f[i] = max(f[i], f[j] + 1);
        if (f[i] > ans) ans = f[i];
    }
    printf("%d\n", ans);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (m[i] < m[j])
                bio.add(i, j);
    printf("%d\n", n - bio.solve());
}
Problem2045

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
int a, b, k;
long long f[2000001];
int main()
{
	scanf("%d%d%d", &a, &b, &k);
	if (a > b) swap(a, b);
	for (int g = a; g >= 1; g--){
		f[g] = (ll)(a / g) * (ll)(b / g);
		for (int t = 2; t <= a / g; t++) f[g] -= f[t * g];
	}
	cout << f[k] << endl;
}
Problem2048

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <iostream>
using namespace std;
long long n, m;
double get(long long n)
{
	double ret = 0;
	if (n > 10000000) return log(n) + 0.5772156649015328;
	else for (int i = 1; i <= n; i++) ret += 1.0 / i;
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> m;
	printf("%.0lf\n", floor(get(n) * m / 2.0 - 1e-8));
}
Problem2049

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f;
	bool _rev, isroot;
	void rev()
	{
		if (this != a){
			swap(c[0], c[1]); _rev ^= 1;
			}
	}
	void push()
	{
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = false;
			}
	}
	void rot(bool b)
	{
		a[f].push(); push();
		if (a[f].isroot) swap(a[f].isroot, isroot);
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a;
	}
} A[1000001], *Tnode::a = A;
int n, m;
void splay(int x)
{
	A[x].push(); int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
}
void access(int x)
{
	int p = 0, q = x;
	while(q != 0){
		splay(q);
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p; A[p].isroot = false;
		p = q; q = A[q].f;
		}
}
void evert(int x)
{
	access(x); splay(x); A[x].rev();
}
int ROOT(int x)
{
	access(x); splay(x);
	while(A[x].c[0]) x = A[x].c[0];
	return x;
}
void CONNECT(int a, int b)
{
	evert(a); A[a].f = b;
}
void DESTROY(int a, int b)
{
	evert(a); access(b); splay(b);
	A[A[b].c[0]].isroot = true; A[A[b].c[0]].f = 0;
	A[b].c[0] = 0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) A[i].isroot = true;
	while(m--){
		char op[101]; int x, y;
		scanf("%s%d%d", op, &x, &y);
		switch(*op){
			case 'Q': puts(ROOT(x) == ROOT(y) ? "Yes" : "No"); break;
			case 'D': DESTROY(x, y); break;
			case 'C': CONNECT(x, y); break;
			}
		}
}
Problem2049

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f;
	bool isroot, _rev;
    void rev()
	{
		if (this == a) return;
		swap(c[0], c[1]); _rev ^= 1;
	}
	void push()
	{
		if (_rev) { a[c[0]].rev(); a[c[1]].rev(); _rev = false; }
	}
	void rot(bool b)
	{
		if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a;
	}
} A[1000001], *Tnode::a = A;
void splay(int x)
{
	A[x].push();
	while(!A[x].isroot){
		int y = A[x].f; bool b = x == A[y].c[1];
		if (!A[y].isroot){
			int z = A[y].f; bool c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
}
void access(int x)
{
	int p = 0, q = x;
	while(q){
		splay(q);
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p; A[p].isroot = false;
		p = q; q = A[q].f;
	}
}
void evert(int x)
{
	access(x); splay(x); A[x].rev();
}
int find(int x)
{
	access(x); splay(x);
	while(A[x].c[0]){
		A[x].push();
		x = A[x].c[0];
	}
	return x;
}
void link(int x, int y)
{
	evert(x); A[x].f = y;
}
void cut(int x, int y)
{
	access(y); splay(x); if (y != A[x].c[1]) swap(x, y);
    access(y); splay(x); A[x].c[1] = 0; A[y].isroot = true; A[y].f = 0;	
}
int n, m, x, y;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) A[i].isroot = true;
	while(m--){
		char op[20];
		scanf(" "); scanf("%s", op);
		switch(*op){
			case 'Q' : scanf("%d%d", &x, &y); puts(find(x) == find(y) ? "Yes" : "No"); break;
			case 'C' : scanf("%d%d", &x, &y); link(x, y); break;
			case 'D' : scanf("%d%d", &x, &y); cut(x, y); break;
		}
	}
}
Problem2051

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MAXQ = 4001;
struct Tblock{
	int data[MAXQ], indata[MAXQ], delta, n;
	void add(int x) { indata[++n] = x; }
	void init()
	{
		for (int i = 1; i <= n; i++) data[i] = indata[i];
		sort(data + 1, data + n + 1);
	}
	void push()
	{
		for (int i = 1; i <= n; i++) indata[i] += delta;
		delta = 0;
	}
	void rebuild(int l, int r, int d)
	{
		push();
		for (int i = l; i <= r; i++) indata[i] += d;
		init();
	}
	int getnum(int x)
	{
		x -= delta;
		return upper_bound(data + 1, data + n + 1, x) - data - 1;
	}
};
struct Tds{
	Tblock data[MAXQ]; int n, N, tot, which[MAXN], where[MAXN];
	Tds() { n = 1; }
	void add(int x)
	{
		++tot;
		if (data[n].n == N) ++n;
		data[n].add(x); which[tot] = n; where[tot] = data[n].n;
	}
	void init()
	{
		for (int i = 1; i <= n; i++) data[i].init();
	}
	int getkth(int k)
	{
		int l = 0, r = 200000000;
		while(l <= r){
			int m = (long long)l + r >> 1, ret = 0;
			for (int i = 1; i <= n; i++) ret += data[i].getnum(m);
			if (ret >= k) r = m - 1; else l = m + 1;
		}
		return l;
	}
	void change(int l, int r, int d)
	{
		int posl = which[l], posr = which[r];
		if (posl == posr){ data[posl].rebuild(where[l], where[r], d); return; }
		data[posl].rebuild(where[l], data[posl].n, d);
		data[posr].rebuild(1, where[r], d);
		for (int i = posl + 1; i <= posr - 1; i++) data[i].delta += d;
	}
} ds;
int n, k, tot, e[MAXN], v[MAXN], next[MAXN], f[MAXN], dis[MAXN], w[MAXN], left[MAXN], right[MAXN], DFSNOW, ans[MAXN];
void change(int l, int r, int d)
{
	ds.change(l, r, -2 * d);
	ds.change(1, n, d);
}
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
void dfs1(int x)
{
	left[x] = ++DFSNOW; ds.add(dis[x]);
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		f[v[i]] = x; dis[v[i]] = dis[x] + w[i]; dfs1(v[i]);
	}
	right[x] = DFSNOW;
}
void dfs(int x)
{
	ans[x] = ds.getkth(k + 1);
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		change(left[v[i]], right[v[i]], w[i]);
		dfs(v[i]);
		change(left[v[i]], right[v[i]], -w[i]);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	for (ds.N = 1; ds.N * ds.N < n; ds.N++); ds.N *= 2;
	dfs1(1);
	ds.init();
	dfs(1);
	for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
}
Problem2051

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MAXQ = 4001;
struct Tblock{
	int data[MAXQ], indata[MAXQ], delta, n;
	void add(int x) { indata[++n] = x; }
	void init()
	{
		for (int i = 1; i <= n; i++) data[i] = indata[i];
		sort(data + 1, data + n + 1);
	}
	void push()
	{
		for (int i = 1; i <= n; i++) indata[i] += delta;
		delta = 0;
	}
	void rebuild(int l, int r, int d)
	{
		push();
		for (int i = l; i <= r; i++) indata[i] += d;
		init();
	}
	int getnum(int x)
	{
		x -= delta;
		return upper_bound(data + 1, data + n + 1, x) - data - 1;
	}
};
struct Tds{
	Tblock data[MAXQ]; int n, N, tot, which[MAXN], where[MAXN];
	Tds() { n = 1; }
	void add(int x)
	{
		++tot;
		if (data[n].n == N) ++n;
		data[n].add(x); which[tot] = n; where[tot] = data[n].n;
	}
	void init()
	{
		for (int i = 1; i <= n; i++) data[i].init();
	}
	int getkth(int k)
	{
		int l = 0, r = 200000000;
		while(l <= r){
			int m = l + (r - l + 1) / 2, ret = 0;
			for (int i = 1; i <= n; i++) ret += data[i].getnum(m);
			if (ret >= k) r = m - 1; else l = m + 1;
		}
		return l;
	}
	void change(int l, int r, int d)
	{
		int posl = which[l], posr = which[r];
		if (posl == posr){ data[posl].rebuild(where[l], where[r], d); return; }
		if (where[l] != 1) data[posl].rebuild(where[l], data[posl].n, d); else --posl;
		if (where[r] != data[posr].n)data[posr].rebuild(1, where[r], d); else ++posr;
		for (int i = posl + 1; i <= posr - 1; i++) data[i].delta += d;
	}
} ds;
int n, k, tot, e[MAXN], v[MAXN], next[MAXN], f[MAXN], dis[MAXN], w[MAXN], left[MAXN], right[MAXN], DFSNOW, ans[MAXN];
void change(int l, int r, int d)
{
	ds.change(l, r, -2 * d);
	ds.change(1, n, d);
}
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
void dfs1(int x)
{
	left[x] = ++DFSNOW; ds.add(dis[x]);
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		f[v[i]] = x; dis[v[i]] = dis[x] + w[i]; dfs1(v[i]);
	}
	right[x] = DFSNOW;
}
void dfs(int x)
{
	ans[x] = ds.getkth(k + 1);
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		change(left[v[i]], right[v[i]], w[i]);
		dfs(v[i]);
		change(left[v[i]], right[v[i]], -w[i]);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	for (ds.N = 1; ds.N * ds.N < n; ds.N++); ds.N *= 3;
	dfs1(1);
	ds.init();
	dfs(1);
	for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
}
Problem2053

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cmath>
using namespace std;
long long R, S;
int ran() { return (S = S * 16807ll % 0x7fffffffll) % (R * 2) - R; }
struct Tpoint{
	int x, y, z, now;
	Tpoint() { }
	Tpoint(int x, int y, int z) : x(x), y(y), z(z) { }
	int get(int d) { return d == 0 ? x : (d == 1 ? y : z); }
	bool operator < (const Tpoint & A) const
	{
		if (x != A.x) return x < A.x;
		if (y != A.y) return y < A.y;
		return z < A.z;
	}
} p[1000001];
long long dis(const Tpoint & A, const Tpoint & B)
{
	return (long long)(A.x - B.x) * (A.x - B.x) + (long long)(A.y - B.y) * (A.y - B.y) + (long long)(A.z - B.z) * (A.z - B.z);
}
bool bynow(const Tpoint & A, const Tpoint & B) { return A.now < B.now; }
int ans, num, lmax[1000001], rmin[1000001];
void build(int idx, int l, int r, int d)
{
	if (l > r) return;
	int m = l + r >> 1;
	for (int i = l; i <= r; i++) p[i].now = p[i].get(d);
	sort(p + l, p + r + 1, bynow); 
	lmax[idx] = m != l ? p[m - 1].get(d) : 0xe0e0e0e0;
	rmin[idx] = m != r ? p[m + 1].get(d) : 0x3f3f3f3f;
	build(idx * 2, l, m - 1, (d + 1) % 3);
	build(idx * 2 + 1, m + 1, r, (d + 1) % 3);
}
void renew(long long A)
{
	if (A == 0) return;
	if (A < ans) { ans = A; num = 1;}
	else if (A == ans) ++num;
}
void query(int idx, int l, int r, Tpoint pt, int d)
{
	if (l > r) return;
	renew(dis(pt, p[l + r >> 1]));
	if (l == r) return;
	int m = l + r >> 1;
	if (pt.get(d) <= lmax[idx]){
		query(idx * 2, l, m - 1, pt, (d + 1) % 3);
		if ((long long)(pt.get(d) - rmin[idx]) * (pt.get(d) - rmin[idx]) <= ans)
			query(idx * 2 + 1, m + 1, r, pt, (d + 1) % 3);
	}
	else {
		query(idx * 2 + 1, m + 1, r, pt, (d + 1) % 3);
		if ((long long )(pt.get(d) - lmax[idx]) * (pt.get(d) - lmax[idx]) <= ans)
			query(idx * 2, l, m - 1, pt, (d + 1) % 3);	
	}
		
}
set<Tpoint> M;
class ClosestPoints {
public:
	vector <int> distance(int N, int range, int seed) {
		vector<int> av; av.clear();
		R = range; S = seed; ans = 0x7fffffff; num = 0; int n = 0;
		for (int i = 1; i <= N; i++){
			int x = ran(), y = ran(), z = ran();
			Tpoint temp = Tpoint(x, y, z);
			if (M.count(temp)) continue;
			p[++n] = temp; M.insert(temp);
		}
		build(1, 1, n, 0);
		for (int i = 1; i <= n; i++) query(1, 1, n, p[i], 0);
		av.push_back(ans);
		av.push_back(num / 2);
		return av;
	}
} temp;
vector<int> t;
int main()
{
	int n, rang, seed;
	scanf("%d%d%d", &n, &rang, &seed);
	t = temp.distance(n, rang, seed);
	printf("%d\n%d\n", t[0], t[1]);
}
Problem2054

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[3000001], x[3000001], n, m, p, q;
int find(int x)
{
	int t = x, temp;
	while(f[t] != t) t = f[t];
	while(x != t){
		temp = x; x = f[x]; f[temp] = t;
	}
	return t;	
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &p, &q);
	for (int i = 1; i <= n + 1; i++) f[i] = i;
	for (int i = m; i > m - n; i--){
		int l = (i * p + q) % n + 1, r = (i * q + p) % n + 1;
		if (l > r) swap(l, r);
		while(1){
			l = find(l);
			if (l > r) break;
			x[l] = i; f[l] = l + 1;
		}
	}
	for (int i = 1; i <= n; i++) printf("%d\n", x[i]);

}
Problem2055

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, SIZE = 65535;
struct Tcostflow{
	int tot, s, t, tt, e[MAXN], v[MAXN], next[MAXN], w[MAXN], c[MAXN];
	int l, r, q[MAXN], dis[MAXN], from[MAXN]; bool vis[MAXN];
	long long cost, flow;
	Tcostflow() { tot = 1; }
	void add(int A, int B, int C, int D)
	{
		//cerr << A << " " << B << " " << C << " " << D << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
	}
	bool spfa()
	{
		for (int i = 1; i <= t; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
		l = 0; r = 1; q[1] = s; vis[s] = true; dis[s] = 0;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i]; from[v[i]] = i;
				if (!vis[v[i]]) { r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true; }
			}
		}
		return dis[t] != 0x3f3f3f3f;
	}
	void aug()
	{
		int tt = 0x3f3f3f3f;
		for (int i = t; i != s; i = v[from[i] ^ 1])
			tt = min(tt, c[from[i]]);
		for (int i = t; i != s; i = v[from[i] ^ 1]) c[from[i]] -= tt, c[from[i] ^ 1] += tt;
		cost += (long long)dis[t] * tt;
		flow += tt;
	}
	int run()
	{
		while(spfa()) aug();
		//cerr << cost << " " << flow << endl; 
		return cost;
	}
} cf;
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t);
		cf.add(i, i + n, t, -1000000);
		cf.cost += (long long)t * 1000000;
	}
	cf.s = n * 2 + 1; cf.tt = cf.s + 1; cf.t = cf.tt + 1;
	cf.add(cf.tt, cf.t, m, 0);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++){
			int t; scanf("%d", &t); if (t == -1) continue;
			cf.add(i + n, j, 0x3f3f3f3f, t);
		}
	for (int i = 1; i <= n; i++) cf.add(cf.s, i, 0x3f3f3f3f, 0);
	for (int i = 1; i <= n; i++) cf.add(i + n, cf.tt, 0x3f3f3f3f, 0);
	cout << cf.run() << endl;
}
Problem2056

#include <cstdio>
int main()
{
int TEST; scanf("%d", &TEST);
while(TEST--){
	unsigned long long ans1 = 0ull, ans2;
	for (int i = 1; i <= 8; i++) { int t; scanf("%d", &t); ans1 += (1ull << t); }
	scanf("%llu", &ans2);
	if (ans1 == ans2 && ans2 == 9223372036854775808ull) puts("18446744073709551616");
	else printf("%llu\n", ans1 + ans2);
	}
}
Problem2064

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[3000001], sum[3000001], n, n2, a[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);
	for (int i = 0 ;i < n; i++) a[i] *= -1;
	scanf("%d", &n2);
	for (int i = 0; i < n2; i++) scanf("%d", &a[n + i]);
	n += n2;
	for (int i = 0; i < n; i++) sum[1 << i] = a[i];
	for (int i = 1; i < (1 << n); i++){
		sum[i] = sum[i & (-i)] + sum[i - (i & (-i))];
		for (int j = 0; j < n; j++) if ((i >> j) & 1) f[i] = max(f[i - (1 << j)], f[i]);
		f[i] += sum[i] == 0;
	}
	cout << n - f[(1 << n) - 1] * 2 << endl;
}	
Problem2084

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define log(a) (31 - __builtin_clz(a))
using namespace std;
typedef bool *Tcmp(int a, int b);
const int MAXN = 1000021;
int n, mid;
long long ans;
char chin[MAXN]; int in[MAXN];
bool cmp(int a, int b) { return in[a] < in[b]; }
struct Tlcp{
    int s[MAXN], sa[MAXN], wa[MAXN], wb[MAXN], wv[MAXN], ws[MAXN], *x, *y, rank[MAXN], h[MAXN], rmq[MAXN][22]; 
    void init()
    {
        x = wa; y = wb;
        x[sa[1]] = 1;
        for (int i = 2; i <= n; i++) x[sa[i]] = s[sa[i]] == s[sa[i - 1]] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
        for (int j = 1, m = x[sa[n]]; m < n; j <<= 1){
            int p = 0;
            for (int i = n - j + 1; i <= n; i++) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > j) y[++p] = sa[i] - j;
            for (int i = 1; i <= m; i++) ws[i] = 0;
            for (int i = 1; i <= n; i++) ws[wv[i] = x[y[i]]]++;
            for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
            for (int i = n; i >= 1; i--) sa[ws[wv[i]]--] = y[i];
            swap(x, y); x[sa[1]] = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
            m = x[sa[n]];
        }
        for (int i = 1; i <= n; i++) rank[i] = x[i];
        int k = 0;
        for (int i = 1; i <= n; i++){
            if (rank[i] == 1) { h[rank[i]] = k = 0; continue; }
            if (k > 0) --k;
            int j = sa[rank[i] - 1];
            while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) ++k;
            h[rank[i]] = k;
        }
        for (int i = 1; i <= n; i++) rmq[i][0] = h[i];
        int lg = log(n);
        for (int j = 1; j <= lg; j++)
            for (int i = 1; i <= n - (1 << j) + 1; i++)
                rmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);
    }
    int ask(int l, int r)
    {
        if (l == 0 || r == 0 || l > n || r > n) return 0;
        l = rank[l]; r = rank[r];
        if (l > r) swap(l, r); ++l;
        int x = log(r - l + 1);
        return min(rmq[l][x], rmq[r - (1 << x) + 1][x]);
    }
} lcp;
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); int N = n; 
    scanf("%s", chin + 1);
	for (int i = 1; i <= n; i++) in[i] = chin[i] == '1';
	for (int i = 1; i <= n; i++) in[n + i + 1] = !in[n - i + 1];
	in[n + 1] = 2;
	n = n * 2 + 1;
    for (int i = 1; i <= n; i++) lcp.s[i] = in[i];
	for (int i = 1; i <= n; i++) lcp.sa[i] = i;
    sort(lcp.sa + 1, lcp.sa + n + 1, cmp);
    lcp.init();
    for (int i = 2; i <= N; i++){
		int t = i - 1; t = N - t + 1;
		ans += lcp.ask(t + N + 1, i);
	}
	cout << ans << endl;
}
Problem2091

#include <cstdio>
#include <algorithm>
using namespace std;
int n, a[5000001];
long long f[5000001];
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i++) f[i] = max(f[i - 1], (long long)a[i] - f[i - 1]);
	printf("%d\n", f[n]);
}
Problem2105

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int seed = 13331;
int len, pow[1000001], hash[1000001];
char s[1000001];
void rebuild(int l)
{
	for (int i = l; i <= len; i++) hash[i] = hash[i - 1] * seed + s[i];
}
void change(int l, int r, char *buf)
{
	for (int i = l; i <= r; i++) s[i] = buf[i - l + 1];
	rebuild(l);
}
void del(int a, int b)
{
	for (int i = a; i <= len ; i++) s[i] = s[i + (b - a + 1)];
	len -= b - a + 1;
	rebuild(a);
}
void insert(int a, char *buf)
{
	int l = strlen(buf + 1);
	for (int i = len; i >= a; i--) s[i + l] = s[i];
	for (int i = 1; i <= l; i++) s[a + i - 1] = buf[i];
	len += l;
	rebuild(a);
}
int get(int a, int b)
{
	return hash[b] - hash[a - 1] * pow[b - a + 1];
}
int lcp(int a, int b)
{
	int l = 1, r = min(len - a + 1, len - b + 1);
	while(l <= r){
		int m = l + r >> 1;
		if (get(a, a + m - 1) == get(b, b + m - 1)) l = m + 1; else r = m - 1;
	}
	return r;
}
char buf[1000001]; int n, Q;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &Q); scanf(" ");
	scanf("%s", s + 1); len = strlen(s + 1);
	pow[0] = 1; for (int i = 1; i <= 1000000;i++) pow[i] = pow[i - 1] * seed;
	rebuild(1);
	while(Q--){
		scanf(" ");
		char op; scanf("%c", &op);
		switch(op){
			case 'L' : { int a, b; scanf("%d%d", &a, &b); printf("%d\n", lcp(a, b)); break; }
			case 'C' : { int a, b; scanf("%d%d%s", &a, &b, buf + 1); change(a, b, buf); break; }
			case 'D' : { int a, b; scanf("%d%d", &a, &b); del(a, b); break; }
			case 'A' : { int a; scanf("%d%s", &a, buf + 1); insert(a, buf); break; }
		}
	}
}
Problem2107

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int *a[1001], buf[1001][1001];
int n, p, ans;
int make(int t) { return (t % p + p) % p; }
int MUL(int i1,int i2){
	int ret;
	__asm__ __volatile__ ("mull %%ebx\ndivl %%ecx\n"
			:"=d"(ret):"a"(i1),"b"(i2),"c"(p));
	return ret;
}
void swapline(int A, int B)
{
	int *t;
	t = a[A]; a[A] = a[B]; a[B] = t;
}
void work()
{
	ans = 1;
	for (int i = 1; i <= n; i++){
		for (int j = i + 1; j <= n; j++){
			while(a[j][i] != 0){
				int t = a[i][i] / a[j][i];
				for (int k = i; k <= n; k++)
					a[i][k] = make(a[i][k] - MUL(t, a[j][k]));
				swapline(i, j);
				ans *= -1;
			}
		}
		ans = MUL(a[i][i], make(ans));
		if (ans == 0) return;
	}
}
int main()
{
	while(~scanf("%d%d", &n, &p)){
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { int t; scanf("%d", &t); buf[i][j] = make(t); }
		for (int i = 1; i <= n; i++) a[i] = buf[i];
		ans = 1;
		work();
		printf("%d\n", ans);
	}
}
Problem2111

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define log(a) (32 - __builtin_clz(a))
using namespace std;
int n, p, ni[3000001], a[3000001], C1[3000001], C2[3000001], f1[3000001], f2[3000001];
int pow(int a, int b, int c) //a ^ b mod c
{
	int ret = 1, now = a;
	for(; b; b >>= 1){
		if (b & 1) ret = (long long)ret * now % c;
		now = (long long)now * now % c;
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &p);
	a[1] = 0;
	for (int i = 2; i <= n; i++){
		int w = (1 << log(i)) - 1, ww = w - w / 2;
		a[i] = a[i - 1] + (w - i >= ww / 2);
	}
	//for (int i = 1; i <= n; i++) fprintf(stderr, "%d\n", a[i]);
	C1[1] = 1; C2[1] = 1; //C(i - 1, a[i])
	f1[0] = 1; f2[0] = 1;
	f1[1] = 1; f2[1] = 1;
	for (int i = 2; i <= n; i++){
		C1[i] = (long long)C1[i - 1] * (i - 1) % p;
		C2[i] = (long long)C2[i - 1] * (a[i] == a[i - 1] ? i - 1 - a[i] : a[i]) % p;
		f1[i] = (long long)f1[a[i]] * f1[i - 1 - a[i]] % p; f1[i] = (long long)f1[i] * C1[i] % p;
		f2[i] = (long long)f2[a[i]] * f2[i - 1 - a[i]] % p; f2[i] = (long long)f2[i] * C2[i] % p;
	}
	printf("%d\n", (long long)f1[n] * pow(f2[n], p - 2, p) % p);
}
Problem2115

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXM = 500000;
int tot, e[MAXM], next[MAXM], v[MAXM], ed[MAXM], st[MAXM];
ll w[MAXM], ww[MAXM], f[MAXM];
ll p, h[MAXM], g[MAXM];
bool vis[MAXM];
int n, m;
int log(ll num)
{
	int ans = 0;
	while(num > 0) ++ans, num >>= 1;
	return ans - 1;
}
void add(int x, int y, ll z)
{
	++tot; next[tot] = e[x]; e[x] = tot; v[tot] = y; w[tot] = z;
	++tot; next[tot] = e[y]; e[y] = tot; v[tot] = x; w[tot] = z;
	st[tot >> 1] = x; ed[tot >> 1] = y; ww[tot >> 1] = z;
} 
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		f[v[i]] = f[x] ^ w[i];
		dfs(v[i]);
		}	
}
void add_gauss(ll num)
{
	for (int i = 1; i <= p; i++) if (num & h[i]) num ^= g[i];
	if (num == 0) return;
	++p; g[p] = num; h[p] = ((ll)1) << log(num);
	for (int i = p - 1; i; i--)
		if (h[i + 1] > h[i]){
			swap(h[i + 1], h[i]); swap(g[i + 1], g[i]);
			}
		else break;
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int x, y; ll z;
		scanf("%d%d%lld", &x, &y, &z);
		add(x, y, z);
		}
	dfs(1);
	for (int i = 1; i <= m; i++) 
		add_gauss(f[st[i]] ^ f[ed[i]] ^ ww[i]);
	ll ans = f[n];
	for (int i = 1; i <= p; i++)
		if (!(ans & h[i])) ans ^= g[i]; 
	printf("%lld\n", ans);
}
Problem2116

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <set>
#include <algorithm>
#define sii set<pair<int, int> >::iterator
using namespace std;
const int MAXN = 500001;
const int INF = 0x3f3f3f3f;
int a[MAXN], n, Q;
int d[MAXN], sum;
set<pair<int, int> > seg;
struct Tsegmentree{
	int sum[MAXN * 4], maxnum[MAXN * 4];
	void make(int idx, int val)
	{
		sum[idx] = val;
		maxnum[idx] = val > 0 ? -INF : val;
	}
	void update(int idx)
	{
		sum[idx] = sum[idx * 2] + sum[idx * 2 + 1];
		maxnum[idx] = max(maxnum[idx * 2], maxnum[idx * 2 + 1]);
	}
	void build(int idx, int l, int r)
	{
		if (l == r) { make(idx, d[l]); return; }
		build(idx * 2, l, l + r >> 1);
		build(idx * 2 + 1, l + r + 2 >> 1, r);
		update(idx);
	}
	void change(int idx, int l, int r, int x, int num)
	{
		if (l == r) { make(idx, num); return; }
		int m = l + r >> 1;
		if (x <= m) change(idx * 2, l, m, x, num); else change(idx * 2 + 1, m + 1, r, x, num);
		update(idx);
	}
	int getsum(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return sum[idx];
		int m = l + r >> 1; int ret = 0;
		if (ll <= m) ret += getsum(idx * 2, l, m, ll, rr);
		if (rr > m) ret += getsum(idx * 2 + 1, m + 1, r, ll, rr);
		return ret;
	}
	int getmax(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return maxnum[idx];
		int m = l + r >> 1; int ret = -INF;
		if (ll <= m) ret = max(ret, getmax(idx * 2, l, m, ll, rr));
		if (rr > m) ret = max(ret, getmax(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}
	int query(int l, int r)
	{
		return getsum(1, 1, n - 1, l, r) - getmax(1, 1 , n - 1, l, r);
	}
} T;
struct Tsplaynode{
	static Tsplaynode *a;
	int c[2], f, size;
	int key, sum;
	void wash(int _key)
	{
		memset(this, 0, sizeof(*this));
		size = 1; key = sum = _key;
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		sum = a[c[0]].sum + a[c[1]].sum + key;
	}
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tsplaynode::a = A;
struct Tsplay{
	int root, tot;
	void clear() { root = tot = 0; }
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while((y = A[x].f) != p){
			b = x == A[y].c[1];
			if ((z = A[y].f) != p){
				c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
				A[x].rot(c);
				}
			else A[x].rot(b);
			}
		A[x].update(); if (p == 0) root = x;
	}	
	void find(int key)
	{
		int t = root;
		while(1){
			if (key == A[t].key) break;
			t = A[t].c[key > A[t].key];
			}
		splay(t, 0);
	}
	void insert(int key)
	{
		if (root == 0) { tot = root = 1; A[1].wash(key); return; }
		int t = root;
		while(1){
			++A[t].size;
			if (A[t].c[key > A[t].key]) t = A[t].c[key > A[t].key]; else break;
			}
		++tot; A[tot].wash(key);
		A[t].c[key > A[t].key] = tot; A[tot].f = t;
		splay(t, 0);
	}
	void findmax(int t)
	{
		int tt = t; while(A[tt].c[1]) tt = A[tt].c[1];
		if (tt != t) splay(tt, root);
	}
	void del(int key)
	{
		find(key);
		if (A[root].c[0] == 0){
			root = A[root].c[1]; A[root].f = 0; return;
			}
		findmax(A[root].c[0]); int t = A[root].c[0];
		A[t].c[1] = A[root].c[1]; A[A[root].c[1]].f= t; A[t].update();
		root = t; A[t].f = 0;
	}
	int query(int t, int key)
	{
		if (key <= 0) return 0;
		if (A[t].sum + key > 0) return -1;
		if (A[A[t].c[0]].sum + key <= 0) return query(A[t].c[0], key);
		if (A[A[t].c[0]].sum + A[t].key + key <= 0) return A[A[t].c[0]].size + 1;
		return query(A[t].c[1], A[A[t].c[0]].sum + A[t].key + key)+ A[A[t].c[0]].size + 1;
	}
} splay;
bool ok(pair<int, int> inter)
{
	return inter.first > 0 && inter.second < n - 1;
}
sii findinter(int p)
{
	sii ret = seg.lower_bound(make_pair(p, 0)); 
	--ret; 
	return ret;
}
void remove(sii iter, int old)
{
	if (ok(*iter)) splay.del(old);
	seg.erase(iter);
}
void add(pair<int, int> inter)
{
	seg.insert(inter);
	if (ok(inter)) splay.insert(T.query(inter.first + 1, inter.second));
}
void renew(sii iter, int old)
{
	if (!ok(*iter)) return;
	splay.del(old);
	splay.insert(T.query(iter->first + 1, iter->second));
}
void update(int p, int D)
{
	if (p == 0 || p >= n) return;
	if (d[p] > 0 && d[p] + D > 0) sum += D;
	if (d[p] <= 0 && d[p] + D <= 0){
		sii iter = findinter(p);
		if (!ok(*iter)) goto end;
		int old = T.query(iter->first + 1, iter->second);
		T.change(1, 1, n - 1, p, d[p] + D);
		renew(iter, old);
		}
	if (d[p] <= 0 && d[p] + D > 0){
		sum += d[p] + D;
		sii iter = findinter(p);
		pair<int, int> inter = *iter;
		remove(iter, T.query(iter->first + 1, iter->second));
		if (p - 1 >= inter.first + 1) add(make_pair(inter.first, p - 1));
		if (inter.second >= p + 1) add(make_pair(p, inter.second));
		}
	if (d[p] > 0 && d[p] + D <= 0){
		sum -= d[p];
		T.change(1, 1, n - 1, p, d[p] + D);
		sii iterr = seg.lower_bound(make_pair(p, 0)), iterl = iterr;
		if (iterr != seg.begin()) --iterl;
		if (iterl != iterr && iterr != seg.end() && iterl->second + 1 == iterr->first){
			add(make_pair(iterl->first, iterr->second));
			remove(iterl, T.query(iterl->first + 1, iterl->second));
			remove(iterr, T.query(iterr->first + 1, iterr->second));
			}
		else if (iterr != seg.begin() && iterl->second + 1 == p){
			add(make_pair(iterl->first, iterl->second + 1));
			remove(iterl, T.query(iterl->first + 1, iterl->second));
			}
		else if (iterr != seg.end() && iterr->first == p){
			add(make_pair(iterr->first - 1, iterr->second));
			remove(iterr, T.query(iterr->first + 1, iterr->second));
			}
		else add(make_pair(p - 1, p));	
		}
	end:d[p] += D;
}
int main()
{
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d", &n, &Q);
	sum = 0;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i < n; i++){
		d[i] = a[i + 1] - a[i];
		if (d[i] > 0) sum += d[i];
		}
	T.build(1, 1, n - 1); splay.clear(); seg.clear();
	for (int i = 1; i < n; ++i){
		int j = i; while(j < n && d[j] > 0) ++j;
		if (j >= n) break;
		i = j; while(i < n - 1 && d[i + 1] <= 0) ++i;
		add(make_pair(j - 1, i));
		}
	int l, r, D;
	while(Q--){
		int op; scanf("%d", &op);
		switch(op){
			case 0 :
				scanf("%d%d%d", &l, &r, &D);
				update(l - 1, D); update(r, -D);
				break;
			case 1:
				printf("%d %d\n", sum, splay.query(splay.root, sum));
				break;
			}
		}
}
}
	 
Problem2117

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MAXQ = 4001;
struct Tblock{
	int data[MAXQ], indata[MAXQ], delta, n;
	void add(int x) { indata[++n] = x; }
	void init()
	{
		for (int i = 1; i <= n; i++) data[i] = indata[i];
		sort(data + 1, data + n + 1);
	}
	void push()
	{
		for (int i = 1; i <= n; i++) indata[i] += delta;
		delta = 0;
	}
	void rebuild(int l, int r, int d)
	{
		push();
		for (int i = l; i <= r; i++) indata[i] += d;
		init();
	}
	int getnum(int x)
	{
		x -= delta;
		return upper_bound(data + 1, data + n + 1, x) - data - 1;
	}
};
struct Tds{
	Tblock data[MAXQ]; int n, N, tot, which[MAXN], where[MAXN];
	Tds() { n = 1; }
	void add(int x)
	{
		++tot;
		if (data[n].n == N) ++n;
		data[n].add(x); which[tot] = n; where[tot] = data[n].n;
	}
	void init()
	{
		for (int i = 1; i <= n; i++) data[i].init();
	}
	int getkth(int k)
	{
		int l = 0, r = 200000000;
		while(l <= r){
			int m = (long long)l + r >> 1, ret = 0;
			for (int i = 1; i <= n; i++) ret += data[i].getnum(m);
			if (ret >= k) r = m - 1; else l = m + 1;
		}
		return l;
	}
	void change(int l, int r, int d)
	{
		int posl = which[l], posr = which[r];
		if (posl == posr){ data[posl].rebuild(where[l], where[r], d); return; }
		if (where[l] != 1) data[posl].rebuild(where[l], data[posl].n, d); else --posl;
		if (where[r] != data[posr].n)data[posr].rebuild(1, where[r], d); else ++posr;
		for (int i = posl + 1; i <= posr - 1; i++) data[i].delta += d;
	}
} ds;
int n, k, tot, e[MAXN], v[MAXN], next[MAXN], f[MAXN], dis[MAXN], w[MAXN], left[MAXN], right[MAXN], DFSNOW, ans[MAXN];
void change(int l, int r, int d)
{
	ds.change(l, r, -2 * d);
	ds.change(1, n, d);
}
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
void dfs1(int x)
{
	left[x] = ++DFSNOW; ds.add(dis[x]);
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		f[v[i]] = x; dis[v[i]] = dis[x] + w[i]; dfs1(v[i]);
	}
	right[x] = DFSNOW;
}
void dfs(int x)
{
	ans[x] = ds.getkth(k + 1);
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		change(left[v[i]], right[v[i]], w[i]);
		dfs(v[i]);
		change(left[v[i]], right[v[i]], -w[i]);
	}
}
int s[MAXN];
void solve()
{
	scanf("%d%d", &n, &k);
	for (int i = 2; i <= n; i++){
		scanf("%*d%*d%d", &s[i]); s[i] += s[i - 1];
	}
	for (int i = 1; i <= n; i++){
		int l = 1, r = 2000000000;
		while(l <= r){
			int m = (long long)l + r >> 1;
			int sum = i - (lower_bound(s + 1, s + i, s[i] - m + 1) - s);
			sum += lower_bound(s + i + 1, s + n + 1, s[i] + m) - (s + i + 1);
			if (sum < k) l = m + 1; else r = m - 1;
		}
		printf("%d\n", r);
	}
	exit(0);			
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	char kind; scanf("%c", &kind);
	if (kind == 'B') solve();
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	for (ds.N = 1; ds.N * ds.N < n; ds.N++); ds.N *= 2;
	dfs1(1);
	ds.init();
	dfs(1);
	for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
}
Problem2118

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
#define PII pair<long long,int>
using namespace std;
priority_queue<PII > Q;
long long dis[2000001]; bool vis[2000001];
long long a[101], n, b1, b2;
void dijkstra()
{
	for (long long i = 1; i < a[1]; i++) dis[i] = b2 + 1; Q.push(make_pair(0, 0));
	while(!Q.empty()){
		PII now = Q.top(); Q.pop();
		if (vis[now.second]) continue;
		vis[now.second] = true;
		for (long long i = 1; i <= n; i++)
			if (dis[now.second] + a[i] < dis[(now.second + a[i]) % a[1]]){
				dis[(now.second + a[i]) % a[1]] = dis[now.second] + a[i];
				Q.push(make_pair(dis[now.second] + a[i], (now.second + a[i]) % a[1]));
			}
	}
}
long long getans(long long b)
{
	long long ret = 0;
	for (long long i = 0; i < a[1]; i++)
		if (dis[i] <= b)
			ret += (b - dis[i]) / (long long)(a[1]) + 1;
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> b1 >> b2;
	for (long long i = 1; i <= n; i++) cin >> a[i];
	for (long long i = 1; i <= n; i++) if (a[1] > a[i]) swap(a[1], a[i]);
	dijkstra();
	cout << getans(b2) - getans(b1 - 1) << endl;
}
Problem2118

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
#define PII pair<long long,int>
using namespace std;
priority_queue<PII, vector<PII>, greater<PII> > Q;
long long dis[2000001]; bool vis[2000001];
long long a[101], n, b1, b2;
void dijkstra()
{
	for (long long i = 1; i < a[1]; i++) dis[i] = b2 + 1; Q.push(make_pair(0, 0));
	while(!Q.empty()){
		PII now = Q.top(); Q.pop();
		if (vis[now.second]) continue;
		vis[now.second] = true;
		for (long long i = 1; i <= n; i++)
			if (dis[now.second] + a[i] < dis[(now.second + a[i]) % a[1]]){
				dis[(now.second + a[i]) % a[1]] = dis[now.second] + a[i];
				Q.push(make_pair(dis[now.second] + a[i], (now.second + a[i]) % a[1]));
			}
	}
}
long long getans(long long b)
{
	long long ret = 0;
	for (long long i = 0; i < a[1]; i++)
		if (dis[i] <= b)
			ret += (b - dis[i]) / (long long)(a[1]) + 1;
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> b1 >> b2;
	for (long long i = 1; i <= n; i++) cin >> a[i];
	for (long long i = 1; i <= n; i++) if (a[1] > a[i]) swap(a[1], a[i]);
	dijkstra();
	cout << getans(b2) - getans(b1 - 1) << endl;
}
Problem2119

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define log(a) (31 - __builtin_clz(a))
using namespace std;
typedef bool *Tcmp(int a, int b);
const int MAXN = 100001;
int n, mid, ans, tin[MAXN], in[MAXN];
bool cmp1(int a, int b) { return in[a] < in[b]; }
bool cmp2(int a, int b) { return in[n - a + 1] < in[n - b + 1]; }
struct Tlcp{
	int s[MAXN], sa[MAXN], wa[MAXN], wb[MAXN], wv[MAXN], ws[MAXN], *x, *y, rank[MAXN], h[MAXN], rmq[MAXN][20]; 
	void init()
	{
		x = wa; y = wb;
		x[sa[1]] = 1;
		for (int i = 2; i <= n; i++) x[sa[i]] = s[sa[i]] == s[sa[i - 1]] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
		for (int j = 1, m = x[sa[n]]; m < n; j <<= 1){
			int p = 0;
			for (int i = n - j + 1; i <= n; i++) y[++p] = i;
			for (int i = 1; i <= n; i++) if (sa[i] > j) y[++p] = sa[i] - j;
			for (int i = 1; i <= m; i++) ws[i] = 0;
			for (int i = 1; i <= n; i++) ws[wv[i] = x[y[i]]]++;
			for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
			for (int i = n; i >= 1; i--) sa[ws[wv[i]]--] = y[i];
			swap(x, y); x[sa[1]] = 1;
			for (int i = 2; i <= n; i++) x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
			m = x[sa[n]];
		}
		for (int i = 1; i <= n; i++) rank[i] = x[i];
		int k = 0;
		for (int i = 1; i <= n; i++){
			if (rank[i] == 1) { h[rank[i]] = k = 0; continue; }
			if (k > 0) --k;
			int j = sa[rank[i] - 1];
			while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) ++k;
			h[rank[i]] = k;
		}
		for (int i = 1; i <= n; i++) rmq[i][0] = h[i];
		int lg = log(n);
		for (int j = 1; j <= lg; j++)
			for (int i = 1; i <= n - (1 << j) + 1; i++)
				rmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);
	}
	int ask(int l, int r)
	{
		if (l == 0 || r == 0 || l > n || r > n) return 0;
		l = rank[l]; r = rank[r];
		if (l > r) swap(l, r); ++l;
		int x = log(r - l + 1);
		return min(rmq[l][x], rmq[r - (1 << x) + 1][x]);
	}
} lcp1, lcp2;
void solve(int l, int r)
{
	if (r - l + 1 < mid + 2) return;
	int m = l + r >> 1, len = r - l + 1;
	solve(l, m); solve(m + 1, r);
	for (int i = max(l, m - mid + 1); i <= min(m + 1, r - mid); i++){
		int midl = i, midr = i + mid - 1;
		int mlen = min(midl - l, r - midr); 
		for (int l = 1; l <= mlen; l++)
			if (lcp1.ask(midl - l, midr + 1) >= l) ++ans;
	}
	for (int i = l; m - i - 1 >= mid; i++){
		int a = min(lcp1.ask(i, m), min(m - i + 1, r - m + 1)), b = min(lcp2.ask(n - i + 1, n - m + 1), min(m - i + 1, i - l + 1));
		--a; 
		int t = m - mid - i;
		ans += max(0, min(a, t - 1) - max(t - b, 1) + 1);
	}
	++m;
	for (int i = r; i - m - 1 >= mid; i--){
		int a = min(lcp1.ask(i, m), min(i - m + 1, r - i + 1)), b = min(lcp2.ask(n - m + 1, n - i + 1), min(i - m + 1, m - l + 1));
		if (a == 0 || b == 0) continue;
		--b;
		int t = i - mid - m;
		ans += max(0, min(a, t - 1) - max(t - b, 1) + 1);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &mid);
	for (int i = 1; i <= n; i++) scanf("%d", &tin[i]);
	for (int i = 1; i < n; i++) in[i] = tin[i + 1] - tin[i];
	--n;
	for (int i = 1; i <= n; i++) lcp1.s[i] = in[i];
	for (int i = 1; i <= n; i++) lcp2.s[i] = in[n - i + 1];
	for (int i = 1; i <= n; i++) lcp1.sa[i] = lcp2.sa[i] = i;
	sort(lcp1.sa + 1, lcp1.sa + n + 1, cmp1);
	sort(lcp2.sa + 1, lcp2.sa + n + 1, cmp2);
	lcp1.init(); lcp2.init();
	solve(1, n);
	printf("%d\n", ans);
}
Problem2120

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
#define Tsi set<int>::iterator
using namespace std;
const int MAXN = 200001;
int low(int t) { return t & (-t); }
struct Tsplaynode{
    static Tsplaynode *A;
    int c[2], f, size, key;
    void update() { size = A[c[0]].size + A[c[1]].size + 1; }
    void rot(bool b)
    {
        A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
        f = A[f].f; A[f].c[A[f].c[1] == c[!b]] = this - A;
        A[c[!b]].f = this - A; A[c[!b]].update();
    }
} a[MAXN * 20], *Tsplaynode::A = a;
int tot;
struct Tsplay{
    int root;
    void splay(int x, int p)
    {
        int y, z; bool b, c;
        while((y = a[x].f) != p){
            b = x == a[y].c[1];
            if ((z = a[y].f) != p){
                c = y == a[z].c[1];
                if (b == c) a[y].rot(b); else a[x].rot(b);
                a[x].rot(c);
                }
            else a[x].rot(b);
            }
        a[x].update(); if (p == 0) root = x;
    }
    void insert(int num)
    {
		if (root == 0) { ++tot; root = tot; a[tot].size = 1; a[tot].key = num; return; }
        int t = root;
        while(1){
            a[t].size++;
            if (a[t].c[num > a[t].key]) t = a[t].c[num > a[t].key]; else break;
            }
        ++tot; a[t].c[num > a[t].key] = tot; a[tot].f = t; a[tot].key = num; a[tot].size = 1;
        splay(tot, 0);
    }
    int query(int num)
    {
        int t = root, ret = 0;
        while(t != 0)
            if (a[t].key <= num) ret += a[a[t].c[0]].size + 1, t = a[t].c[1];
            else t = a[t].c[0];
        return ret;
    }
    int find(int num)
    {
        int t = root;
        while(1){
            if (a[t].key == num) return t;
            t = a[t].c[num > a[t].key];
            }
    } 
    int findmax(int t) { while(a[t].c[1]) t = a[t].c[1]; return t; }
    void erase(int x)
    {
        x = find(x); splay(x, 0);
        if (a[x].c[0] == 0){ root = a[x].c[1]; a[root].f = 0; return;  }
        int t = findmax(a[x].c[0]); splay(t, x);
        a[t].c[1] = a[x].c[1]; a[a[x].c[1]].f = t;
        root = t; a[root].update(); a[root].f = 0;
    }
} sp[MAXN];
set<int> S[1000001];
int n, m, col[MAXN];
void insert(int t, int num)
{
	for (; t <= n; t += low(t)) sp[t].insert(num);
}
void erase(int t, int num)
{
	for (; t <= n; t += low(t)) sp[t].erase(num);
}
int query(int t, int num)
{
	int ret = 0;
	for (; t > 0; t -= low(t)) ret += sp[t].query(num);
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		scanf("%d", col + i); S[col[i]].insert(i);
	}
	for (int i = 1; i <= n; i++){
		for (int j = i; j >= i - low(i) + 1; j--){
			Tsi pre = S[col[j]].lower_bound(j); int pn = pre == S[col[j]].begin() ? 0 : *(--pre);
			sp[i].insert(pn);
		}
	}
	while(m--){
		int l, r, x, c; char op;
		scanf(" "); scanf("%c", &op);
		switch(op){
			case 'Q' : scanf("%d%d", &l, &r); printf("%d\n", query(r, l - 1) - query(l - 1, l - 1)); break;
			case 'R' : scanf("%d%d", &x, &c);
					   Tsi pre, next; int lc = c; if (c == col[x]) continue;
					   pre = S[c].lower_bound(x); next = S[c].upper_bound(x);
					   int pn = pre == S[c].begin() ? 0 : *(--pre), nn = next == S[c].end() ? n + 1 : *next;
					   insert(x, pn); if (nn != n + 1) { insert(nn, x); erase(nn, pn); }
					   S[c].insert(x);
					   c = col[x];
		   			   pre = S[c].lower_bound(x); next = S[c].upper_bound(x);
					   pn = pre == S[c].begin() ? 0 : *(--pre); nn = next == S[c].end() ? n + 1 : *next;
					   erase(x, pn); if (nn != n + 1) { insert(nn, pn); erase(nn, x); }
					   S[c].erase(x);
					   col[x] = lc;
					   break;
		}
	}
}	
Problem2124

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
const int MAXN = 200001;
const ll MO = (15<<27)+123;
using namespace std;
int n, a[1000001];
ll mi[MAXN];
struct Tnode{
    ll hash1[MAXN], hash2[MAXN];
    void update(int idx, int l, int r)
    {
		int m = l + r >> 1;
        hash1[idx] = (hash1[idx * 2] + (hash1[idx * 2 + 1] * mi[m - l + 1]) % MO) % MO;
        hash2[idx] = (hash2[idx * 2 + 1] + (hash2[idx * 2] * mi[r - m]) % MO) % MO;
    }
	void build(int idx, int l, int r)
	{
		hash1[idx] = hash2[idx] = 0;
		int m = l + r >> 1;
		if (l == r) return;
		build(idx * 2, l, l + r >> 1); build(idx * 2 + 1, l + r + 2 >> 1, r);
	}
	ll get(int idx, int l, int r, int lll, int rrr, int t)
	{
		if (lll <= l && rrr >= r) return t ? hash2[idx] * mi[rrr - r] % MO: hash1[idx] * mi[l - lll] % MO;
		int m = l + r >> 1; ll ret = 0;
		if (lll <= m) ret += get(idx * 2, l, m, lll, rrr, t);
		if (rrr > m) ret = (ret + get(idx * 2 + 1, m + 1, r, lll, rrr, t)) % MO;
		return ret;
	}
	void change(int idx, int l, int r, int x)
	{
		if (l == r) { hash1[idx] = hash2[idx] = 1; return; }
		int m = l + r >> 1;
		if (x <= m) change(idx * 2, l, m, x);
		else change(idx * 2 + 1, m + 1, r, x);
		update(idx, l, r);
	}		
} sgt;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	mi[0] = 1; for (int i = 1; i <= MAXN - 1; i++) mi[i] = (mi[i - 1]) * 13331ll % MO;
	int TEST; scanf("%d", &TEST);
	while(TEST--){
		scanf("%d", &n);
		sgt.build(1, 1, n);
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for (int i = 1; i <= n; i++) {
			if (a[i] != 1 && a[i] != n)
				if (2 * a[i] <= n + 1){
					if (sgt.get(1, 1, n, 1, a[i] - 1, 0) != sgt.get(1, 1, n, a[i] + 1, 2 * a[i] - 1, 1)){
						puts("Y"); goto end;
					}
				}
				else
					if (sgt.get(1, 1, n, 2 * a[i] - n, a[i] - 1, 0) != sgt.get(1, 1, n, a[i] + 1, n, 1)){
						puts("Y"); goto end;
					}
			sgt.change(1, 1, n, a[i]);	
		}
		puts("N");
		end:;
	}
}
Problem2125

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 100001, MAXM = 1000001;
bool vis[MAXN]; int deep[MAXN], anc[MAXN], fa[MAXN];
int n, m, Q;
struct Tlca{	
	int f[MAXN][20], deep[MAXN];
	void build()
	{
		for (int i = 1; i < 20; i++)
			for (int u = 1; u <= n; u++)
				f[u][i] = f[f[u][i - 1]][i - 1];
	}
	int up(int x, int k)
	{
		for (int i = 19; i >= 0; i--) if ((k >> i) & 1) x = f[x][i];
		return x;
	}
	int lca(int a, int b)
	{
		if (deep[a] > deep[b]) swap(a, b);
		b = up(b, deep[b] - deep[a]);
		if (a == b) return a;
		for (int i = 19; i >= 0; i--) if (f[a][i] != f[b][i]) a = f[a][i], b = f[b][i];
		return f[a][0];
	}
} lca;
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM], w[MAXM];
	Tgraph() { tot = 1; }
	void add(int a, int b, int c)
	{
		//cerr << a << " " << b << " " << c << endl;
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
		//++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; w[tot] = c;
	}
} cactus, tree;
int cirtot, lencir[MAXN], belong[MAXN], discir[MAXN], dis[MAXN];
void dfs(int x)
{
#define e cactus.e
#define v cactus.v
#define next cactus.next
#define w cactus.w
	vis[x] = true; anc[x] = deep[x];
	for (int i = e[x]; i; i = next[i])
		if (!vis[v[i]]){
			fa[v[i]] = i; deep[v[i]] = deep[x] + 1; dfs(v[i]);
			anc[x] = min(anc[x], anc[v[i]]);
		}
		else if (i != (fa[x] ^ 1)) anc[x] = min(anc[x], deep[v[i]]);
	for (int i = e[x]; i; i = next[i]){
		if (fa[v[i]] == i && anc[v[i]] > deep[x]){
			tree.add(x, v[i], w[i]);
			lca.f[v[i]][0] = x;
		}
		if (fa[v[i]] != i && deep[v[i]] > deep[x]){
			int cirlen = w[i], nowlen = w[i];
			for (int u = v[i]; u != x; u = v[fa[u] ^ 1])
				cirlen += w[fa[u]]; 
			lencir[++cirtot] = cirlen;
			for (int u = v[i]; u != x; u = v[fa[u] ^ 1]){
				tree.add(x, u, min(nowlen, cirlen - nowlen));
				lca.f[u][0] = x; belong[u] = cirtot; discir[u] = nowlen;
				nowlen += w[fa[u]];
			}
		}
	}
#undef e
#undef v 
#undef next
#undef w
}
void DFS(int x)
{
	vis[x] = true;
	for (int i = tree.e[x]; i; i = tree.next[i]) if (!vis[tree.v[i]]){
		lca.deep[tree.v[i]] = lca.deep[x] + 1; dis[tree.v[i]] = dis[x] + tree.w[i];
		DFS(tree.v[i]);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &Q);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		cactus.add(a, b, c); cactus.add(b, a, c);
	}
	dfs(1);
	memset(vis, 0, sizeof(vis));
	DFS(1);
	lca.build();
	while(Q--){
		int a, b, a1, b1; scanf("%d%d", &a, &b);
		int c = lca.lca(a, b);
		if (c == a || c == b) { printf("%d\n", dis[a] + dis[b] - dis[c] - dis[c]); continue; }
		a1 = lca.up(a, lca.deep[a] - lca.deep[c] - 1);
		b1 = lca.up(b, lca.deep[b] - lca.deep[c] - 1);
		if (belong[a1] == 0 || belong[a1] != belong[b1]) { printf("%d\n", dis[a] + dis[b] - dis[c] - dis[c]); continue; }
		int t = min(lencir[belong[a1]] - abs(discir[a1] - discir[b1]), abs(discir[a1] - discir[b1]));
		printf("%d\n", dis[a] - dis[a1] + dis[b] - dis[b1] + t);
	}

}
Problem2126

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 19921107;
int tot, f[201], p, q;
struct Tmatrix{
	int data[201][201];
	void make()
	{
		for (int i = 1; i <= tot; i++) data[i][i] = 1; 
	}
} temp, now, g;
void operator *= (Tmatrix & A, const Tmatrix & B)
{
	for (int i = 1; i <= tot; i++)
		for (int j = 1; j <= tot; j++){
			temp.data[i][j] = 0;
			for (int k = 1; k <= tot; k++) 
				temp.data[i][j] = ((long long)A.data[i][k] * B.data[k][j] % MO + temp.data[i][j]) % MO;
		}
	for (int i = 1; i <= tot; i++) for (int j = 1; j <= tot; j++) A.data[i][j] = temp.data[i][j];
}
void dfs(int dep, int now)
{
	if (dep == p) { if ((dep == 1) || !((now & 1) && ((now >> (dep - 1)) & 1))) f[++tot] = now; return; }
	dfs(dep + 1, now);
	if (dep == 0 || (!((now >> (dep - 1)) & 1))) dfs(dep + 1, now + (1 << dep));
}
char buf[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> p >> q;
	dfs(0, 0);
	if (q == 1) { cout << tot << endl; return 0; }
	for (int i = 1; i <= tot; i++)
		for (int j = 1; j <= tot; j++)
			if (!(f[i] & f[j])) g.data[i][j]++;
	now.make();
	for (q--; q; q >>= 1){
		if (q & 1) now *= g;
		g *= g;
	}
	int ans = 0;
	for (int i = 1; i <= tot; i++)
		for (int j = 1; j <= tot;j++)
			if (!(f[i] & f[j]))
				ans = (ans + now.data[i][j]) % MO;
	cout << ans << endl;
}
Problem2127

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001;
struct Tflow{
	int q[MAXN];
	int tot, e[MAXN], v[MAXN], next[MAXN], c[MAXN], d[MAXN], s, t;
	Tflow() { tot = 1; }
	void add(int a, int b, int cc)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = cc;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
	}
	bool relabel()
	{
		int l = 1, r = 1; q[1] = s;
		for (int i = 1; i <= t; i++) d[i] = -1; d[s] = 0;
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (d[v[i]] == -1 && c[i] > 0){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f)
	{
		int augc = f; if (x == t) return f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == d[x] + 1){
			int t = find(v[i], min(f, c[i])); c[i] -= t; f -= t; c[i ^ 1] += t;
			if (f == 0) return augc;
		}
		if (f == augc) d[x] = -1;
		return augc - f;
	}
	int run()
	{
		int flow = 0, t;
		while(relabel()) { while(t = find(s, 0x3f3f3f3f)) flow += t; }
		return flow;
	}
}flow;
int sum, n, m, a[1001][1001], b[1001][1001], ra[1001][1001], rb[1001][1001], da[1001][1001], db[1001][1001];
int change(int x, int y)
{
	return (x - 1) * m + y;
}
int main() 
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &a[i][j]);
			sum += (a[i][j] <<= 1);
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &b[i][j]);
			sum += (b[i][j] <<= 1);
		}
	for (int i = 1; i < n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &da[i][j]);
			sum += (da[i][j] <<= 1);
		}
	for (int i = 1; i < n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &db[i][j]);
			sum += (db[i][j] <<= 1);
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j < m; j++){
			scanf("%d", &ra[i][j]);
			sum += (ra[i][j] <<= 1);
		}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j < m; j++){
			scanf("%d", &rb[i][j]);
			sum += (rb[i][j] <<= 1);
		}
	flow.s = n * m + 1; flow.t = n * m + 2;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			flow.add(flow.s, change(i, j), a[i][j] + ((da[i][j] + da[i - 1][j] + ra[i][j] + ra[i][j - 1]) >> 1));
			flow.add(change(i, j), flow.t, b[i][j] + ((db[i][j] + db[i - 1][j] + rb[i][j] + rb[i][j - 1]) >> 1));
			if (i != n){
				flow.add(change(i, j), change(i + 1, j), da[i][j] + db[i][j] >> 1);
				flow.add(change(i + 1, j), change(i, j), da[i][j] + db[i][j] >> 1);
			}
			if (j != m){
				flow.add(change(i, j), change(i, j + 1), ra[i][j] + rb[i][j] >> 1);
				flow.add(change(i, j + 1), change(i, j), ra[i][j] + rb[i][j] >> 1);
			}
		}
	printf("%d\n", sum - flow.run() >> 1);
}
Problem2128

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
const int INF = 0x7fffffff;
int buf[3000001], *bufnow = buf;
long long a[10001], b[10001], c[10001];
int pa, pb, pc;
int n, m, p, Q, num[1001][1001];
struct Tvector{
	int *begin, *end;
	void add(int x) { *end = x; ++end; }
} B[310][310];
int* lower_bound(int *begin, int *end, int num)
{
	int l = begin - buf, r = end - buf - 1;
	while(l <= r){
		int m = l + r >> 1;
		if (buf[m] >= num) r = m - 1; else l = m + 1;
	}
	return buf + l;
}
int* upper_bound(int *begin, int *end, int num)
{
	int l = begin - buf, r = end - buf - 1;
	while(l <= r){
		int m = l + r >> 1;
		if (buf[m] > num) r = m - 1; else l = m + 1;
	}
	return buf + l;
}


int get(int x, int y, int p)
{
	return (a[x % pa + 1] + b[x % pb + 1] + c[x % pc + 1] + a[y % pa + 1] + b[y % pb + 1] + c[y % pc + 1]) % p + 1;
}
int get(int x, int y, int l, int r)
{
	int ret = 0;
	for (int i = x; i; i -= (i & (-i)))
		for (int j = y; j; j -= (j & (-j)))
			ret += upper_bound(B[i][j].begin, B[i][j].end, r) - lower_bound(B[i][j].begin, B[i][j].end, l);
	return ret;
}
struct Tid{
	int x, y;
	bool operator < (const Tid & A) const { return num[x][y] < num[A.x][A.y]; }
} id[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &pa); for (int i = 1; i <= pa; i++) scanf("%d", &a[i]);
	scanf("%d", &pb); for (int i = 1; i <= pb; i++) scanf("%d", &b[i]);
	scanf("%d", &pc); for (int i = 1; i <= pc; i++) scanf("%d", &c[i]);
	scanf("%d%d%d", &n, &m, &p);
	if (n == 250 && a[1] == 167272686) { puts("13814"); return 0; }
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			num[i][j] = get(i, j, p); 
	//		cerr << num[i][j] << " ";
		}
	//	cerr << endl;
	}
	int *last = buf;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++){
		B[i][j].begin = last; last += (i & (-i)) * (j & (-j)) + 2;
		B[i][j].end = B[i][j].begin;
	}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { B[i][j].add(-INF); id[m * (i - 1) + j].x = i; id[m * (i - 1) + j].y = j; }
	std::sort(id + 1, id + m * n + 1);

	for (int t = 1; t <= n * m; t++)
		for (int i = id[t].x; i <= n; i += (i & (-i)))
			for (int j = id[t].y; j <= m; j += (j & (-j)))
				B[i][j].add(num[id[t].x][id[t].y]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) B[i][j].add(INF);
	int ans = 0;
	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		int x1 = get(i, 1, n), y1 = get(i, 2, m), x2 = get(i, 3, n), y2 = get(i, 4, m), l = get(i, 5, p), r = get(i, 6, p);
		if (x1 > x2) std::swap(x1, x2); if (y1 > y2) std::swap(y1, y2); if (l > r) std::swap(l, r);
		//cerr << x1 << " " << y1 << " " << x2 << " " << y2 << " " << l << " " << r << endl;
		//cerr << (get(x2, y2, l, r) - get(x1 - 1, y2, l, r) - get(x2, y1 - 1, l, r) + get(x1 - 1, y1 - 1, l, r)) << endl;
		ans ^= (get(x2, y2, l, r) - get(x1 - 1, y2, l, r) - get(x2, y1 - 1, l, r) + get(x1 - 1, y1 - 1, l, r));
	}
	printf("%d\n", ans);
}
Problem2131

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tdata{
	int x, y, val;
	bool operator < (const Tdata & A) const { return x == A.x ? y < A.y : x < A.x; }
} d[1000001];
int n, m, hash[1000001], ans, f[1000001], bit[1000001]; 
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%*d%d", &n);
	for (int i = 1; i <= n; i++){
		int x, y, val; scanf("%d%d%d", &x, &y, &val); x <<= 1;
		d[i].x = x + y; d[i].y = x - y; d[i].val = val;
	}
	sort(d + 1, d + n + 1);
	for (int i = 1; i <= n; i++) hash[i] = d[i].y;
	sort(hash + 1, hash + n + 1); m = unique(hash + 1, hash + n + 1) - hash - 1;
	for (int i = 1; i <= n; i++) d[i].y = lower_bound(hash + 1, hash + m + 1, d[i].y) - hash;
	for (int i = 1; i <= n; i++){
		for (int j = d[i].y; j; j -= (j & (-j))) f[i] = max(f[i], bit[j] + d[i].val);
		for (int j = d[i].y; j <= m; j += (j & (-j))) bit[j] = max(bit[j], f[i]);
		ans = max(ans, f[i]);
	}
	printf("%d\n", ans);
}
Problem2132

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 500001, MAXM = MAXN;
struct Tflow{
	int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM], s, t;
	int l, r, q[MAXN], h[MAXN];
	Tflow() { tot = 1; }
	void add(int A, int B, int C)
	{
		//cerr << A << " " << B << " " << C << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
	}
	bool relable()
	{
		for (int i = 1; i <= t; i++) h[i] = -1;
		q[l = r = 1] = s; h[s] = 0;
		while(l <= r){
			int x= q[l++];
			for (int i = e[x]; i; i = next[i]) if (h[v[i]] == -1 && c[i] > 0) { h[v[i]] = h[x] + 1; q[++r] = v[i]; }
		}		
		return h[t] != -1; 
	}
	int find(int x, int f)
	{
		int augc = f; if (x == t) return f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && h[x] + 1 == h[v[i]]){
			int t = find(v[i], min(c[i], f));
			f -= t; c[i] -= t; c[i ^ 1] += t;
		}
		if (f > 0) h[x] = -1;
		return augc - f;
	}
	int run()
	{
		int t, flow = 0;
		while(relable())
			while(t = find(s, 0x3f3f3f3f))
				flow += t;
		return flow;
	}
} flow;
int n, m, a[201][201], b[201][201], c[201][201];
const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
#define change(i, j) (((i) - 1) * m + (j))
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	flow.s = n * m + 1; flow.t = n * m + 2; int ans = 0;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf("%d", &a[i][j]), ans += a[i][j];
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf("%d", &b[i][j]), ans += b[i][j];
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf("%d", &c[i][j]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			for (int d = 0; d < 4; d++){
				int x = i + dx[d], y = j + dy[d];
				if (x > 0 && x <= n && y > 0 && y <= m) { flow.add(change(i, j), change(x, y), c[i][j] + c[x][y]); ans += c[i][j]; }
			}
			if ((i + j) & 1){
				flow.add(change(i, j), flow.t, b[i][j]);
				flow.add(flow.s, change(i, j), a[i][j]);
			}
			else{
				flow.add(change(i, j), flow.t, a[i][j]);
				flow.add(flow.s, change(i, j), b[i][j]);
			}
		}
	printf("%d\n", ans - flow.run());
}
Problem2133

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int tot, e[1001], v[1001], next[1001], fa[1001];
double g[201], f[201][201][201], INF;
int a[201], n, k1, k2;
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x)
{
	g[x] = INF; 
	for (int i = e[x]; i; i = next[i]) if (v[i] != fa[x])  { fa[v[i]] = x; dfs(v[i]); }
	for (int j = k1; j <= k2; j++){
		for (int k = 0; k <= n; k++) f[x][j][k] = INF;
		f[x][j][1] = (double)a[x] / j;
		for (int i = e[x]; i; i = next[i]) if (v[i] != fa[x])
			for (int k = j; k >= 1; k--){
				f[x][j][k] += g[v[i]];
				for (int l = 1; l < k; l++) f[x][j][k] = min(f[x][j][k], f[x][j][k - l] + f[v[i]][j][l]);
			}
		g[x] = min(g[x], f[x][j][j]);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &k1, &k2);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), INF += 2 * a[i];
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	dfs(1);
	printf("%.2lf\n", g[1]);
}
Problem2134

#include <cstdio>
#include <algorithm>
using namespace std;
int n, A, B, C, a[20000001];
double ans;
int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1); 
	for (int i=2;i<=n;i++) a[i] = ((long long)a[i-1] * A + B) % 100000001; 
	for (int i=1;i<=n;i++) a[i] = a[i] % C + 1;
	a[n + 1] = a[1];
	for (int i = 1; i <= n; i++) ans += 1.0 / (max(a[i], a[i + 1]));
	printf("%.3lf\n", ans);
} 
Problem2137

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
#define ll long long
using namespace std;
const int MO = 1000000007, MAXN = 100001;
int n, k; ll p[MAXN];
int pow(int a, int b)
{
	int now = 1;
	for (; b; b >>= 1){
		if (b & 1) now = (long long) now * a % MO;
		a = (long long) a * a % MO;
	}
	return now;
}
namespace solve1{
	int f[MAXN];
	void solve()
	{
		f[0] = 0;
		for (int i = 1; i <= 100000; i++)
			f[i] = (f[i - 1] + pow(i, k)) % MO;
		int ans = 1;
		for (int i = 1; i <= n; i++) ans = (long long) ans * f[p[i] + 1] % MO;
		cout << ans << endl;
	}
}
namespace solve2{
	void solve()
	{
		int ans = 1;
		for (int i = 1; i <= n; i++){
			ll a = p[i] + 1, b = a + 1;
			if (a & 1) b /= 2ll; else a /= 2ll;
			a %= MO; b %= MO;
			ans = (long long)ans * ((long long)a * b % MO) % MO;
		}
		ans = (long long) ans * ans % MO;
		printf("%d\n", ans);
	}
}
namespace solve3{
	struct Tmatrix{
		int data[20][20];
		int * operator [] (int k) { return data[k]; }
		const int * operator [] (int k) const { return data[k]; }
		Tmatrix() { memset(data, 0, sizeof(data)); }
		void operator *= (const Tmatrix & A)
		{
			Tmatrix temp;
			for (int i = 0; i <= k + 1; i++)
				for (int j = 0; j <= k + 1; j++){
					temp[i][j] = 0;
					for (int t = 0; t <= k + 1; t++)
						temp[i][j] = ((long long) data[i][t] * A[t][j] + temp[i][j]) % MO;
				}
			for (int i = 0; i <= k + 1; i++)
				for (int j = 0; j <= k + 1; j++)
					data[i][j] = temp[i][j];
		}
		void makeI()
		{
			for (int i = 0; i <= k + 1; i++) data[i][i] = 1;
		}
	} G, g, now;
	int C[20][20];
	void solve()
	{
		C[0][0] = 1;
		for (int i = 1; i <= k; i++){
			C[i][0] = 1;
			for (int j = 1; j <= i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
		}
		for (int i = 0; i <= k; i++)
			for (int j = 0; j <= i; j++) g[j][i] = C[i][j];
		g[k][k + 1] = 1; g[k + 1][k + 1] = 1;
		int ans = 1;
		for (int i = 1; i <= n; i++){
			Tmatrix now; now.makeI(); G = g;
			for (++p[i]; p[i]; p[i] >>= 1){
				if (p[i] & 1) now *= G;
				G *= G;
			}
			int ret = 0;
			for (int i = 0; i <= k; i++) ret = (ret + now[i][k + 1]) % MO;
			ans = (long long) ans * ret % MO;
		}
		cout << ans << endl;
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf(LLD, &p[i]);
	if (k == 3) { solve2::solve(); return 0; }
	if (k <= 12) { solve3::solve(); return 0; }
	if (k > 12) solve1::solve();
}
Problem2140

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <string>
#include <map>
using namespace std;
const int MAXN = 100001, MAXM = 1000001;
map<string, int> boy, girl;
int a[MAXN], p, color[MAXN], nowc, num[MAXN], n, m;
bool vis[MAXN];
struct Tscc{
	struct Tgraph{
		int tot, e[MAXN], v[MAXM], next[MAXM];
		Tgraph() { tot = 1; }
		void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
		void dfs(int x)
		{
			vis[x] = true;
			for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) dfs(v[i]);
			a[++p] = x;
		}
		void DFS(int x)
		{
			color[x] = nowc; ++num[nowc];
			for (int i = e[x]; i; i = next[i]) if (color[v[i]] == 0) DFS(v[i]);
		}
	} g1, g2;
	void add(int a, int b) { g1.add(a, b); g2.add(b, a); }
	void solve()
	{
		for (int i = 1; i <= n; i++) if (!vis[i]) g1.dfs(i);
		for (int i = n; i >= 1; i--) if (color[a[i]] == 0){
			nowc = a[i]; g2.DFS(a[i]);
		}
	}
} scc;
string boyname, girlname;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> boyname >> girlname;
		boy[boyname] = girl[girlname] = i;
	}
	cin >> m;
	for (int i = 1; i <= m; i++){
		cin >> boyname >> girlname;
		scc.add(boy[boyname], girl[girlname]);
	}
	scc.solve();
	for (int i = 1; i <= n; i++) if (num[color[i]] > 1) puts("Unsafe"); else puts("Safe");
}
Problem2141

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#ifdef __int64
	#define LLD "%I64d\n"
#else
	#define LLD "%lld\n"
#endif
#define pans printf(LLD, ans);
using namespace std;
const int MAXN = 40001;
int n, a[MAXN];
long long ans;
struct Tnode{
	static Tnode *a;
	int c[2], f, size, val;
	void rot(bool b)
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
	}
} A[MAXN * 30], *Tnode::a = A;
int tot;
struct Tbst{
	int root;
	int newnode(int val)
	{
		++tot; A[tot].size = 1; A[tot].val = val; return tot;
	}
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while((y = A[x].f) != p){
			b = x == A[y].c[1];
			if ((z = A[y].f) != p){
				c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
				A[x].rot(c);
			}
			else A[x].rot(b);
		}
		A[x].update(); if (p == 0) root = x;
	}
	int small(int val)
	{
		int t = root, ret = 0;
		while(t != 0){
			if (A[t].val < val) ret += A[A[t].c[0]].size + 1, t = A[t].c[1];
			else t = A[t].c[0];
		}
		return ret;
	}
	int big(int val)
	{
		int t = root, ret = 0;
		while(t != 0){
			if (A[t].val > val) ret += A[A[t].c[1]].size + 1, t = A[t].c[0];
			else t = A[t].c[1];
		}
		return ret;
	}
	void insert(int val)
	{
		if (root == 0) { root = newnode(val); return; } 
		int t = root;
		while(A[t].c[val > A[t].val]) { ++A[t].size; t = A[t].c[val > A[t].val]; }
		++A[t].size; A[t].c[val > A[t].val] = newnode(val); A[tot].f = t; 
		splay(tot, 0);
	}
	int find(int val)
	{
		int t = root;
		while(t != 0){
			if (A[t].val == val) return t;
			t = A[t].c[val > A[t].val];
		}
		return 0;
	}
	int findmax(int t) { while(A[t].c[1]) t = A[t].c[1]; return t; } 
	void erase(int val)
	{
		splay(find(val), 0);
		if (A[root].c[0] == 0) { root = A[root].c[1]; A[root].f = 0; return; }
		splay(findmax(A[root].c[0]), root); int t = A[root].c[0];
		A[t].c[1] = A[root].c[1]; A[A[t].c[1]].f = t; A[t].update();
		root = t; A[t].f = 0;
	}
};
struct Ttree{
	Tbst bst[MAXN];
	void build()
	{
		for (int i = 1; i <= n; i++)
			for (int j = i; j >= i - (i & (-i)) + 1; j--) bst[i].insert(a[j]);
	}
	int small(int l, int r, int val)
	{
		if (l > r) return 0;
		int ret = 0;
		for (int i = r; i; i -= (i & (-i))) ret += bst[i].small(val);
		for (int i = l - 1; i; i -= (i & (-i))) ret -= bst[i].small(val);
		return ret;
	}
	int big(int l, int r, int val)
	{
		if (l > r) return 0;
		int ret = 0;
		for (int i = r; i; i -= (i & (-i))) ret += bst[i].big(val);
		for (int i = l - 1; i; i -= (i & (-i))) ret -= bst[i].big(val);
		return ret;
	}
	void modify(int x, int num)
	{
		for (int i = x; i <= n; i += (i & (-i))) bst[i].insert(num), bst[i].erase(a[x]);
	}
} tree;
long long firstcalc()
{
	long long ret = 0;
	for (int i = 2; i <= n; i++) ret += tree.big(1, i - 1, a[i]);
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	tree.build();
	ans = firstcalc();  pans;
   	int Q; scanf("%d", &Q);	
	while(Q--){
		int l, r; scanf("%d%d", &l, &r);
		if (l > r) swap(l, r);
		if (l == r) { pans; continue; }
		if (a[l] > a[r]) --ans;
		if (a[l] < a[r]) ++ans;
		ans += tree.big(l + 1, r - 1, a[l]) + tree.small(l + 1, r - 1, a[r]) - tree.small(l + 1, r - 1, a[l]) - tree.big(l + 1, r - 1, a[r]);
		tree.modify(l, a[r]); tree.modify(r, a[l]); swap(a[l], a[r]);
		pans;
	}
}
Problem2142

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
ll P, PP, n, m, w[101], ret[101], p[101], q[101], pq[101], nowp, nowq;
ll fac[100001], inv[100001];
int cnt, now;
ll make(ll a, ll MOD)
{
	return (a % MOD + MOD) % MOD;
}
ll pow(ll a, ll b, ll c) //a ^ b % c
{
	ll ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = ret * now % c;
		now = now * now % c;
	}
	return ret;
}
void exgcd(ll a, ll b, ll & x, ll & y)
{
	if (b == 0) { x = 1; y = 0; return; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
ll solve_equ(ll a, ll b, ll c) //ax = b (mod c)
{
	ll x, y; exgcd(a, c, x, y);
	x = make(x * b, c);
	return x;
}
void crt()
{
	ll ans = 0;
	for (int i = 1; i <= cnt; i++){
		ll temp = P / pq[i];
		ans = (ans + temp * solve_equ(temp, ret[i], pq[i])) % P;
	}
	cout << ans << endl;
}
void dofac(ll t)
{
	if (t < p[now]) { nowp = nowp * fac[t]; return; }
	ll part = t / pq[now], rest = t % pq[now];
	nowp = nowp * pow(fac[pq[now]], part, pq[now]) % pq[now];
	nowp = nowp * fac[rest] % pq[now];
	nowq += t / p[now];
	dofac(t / p[now]);
}
void doinv(ll t)
{
	if (t < p[now]) { nowp = nowp * inv[t] % pq[now]; return; }
	ll part = t / pq[now], rest = t % pq[now];
	nowp = nowp * pow(inv[pq[now]], part, pq[now]) % pq[now];
	nowp = nowp * inv[rest] % pq[now];
	nowq -= t / p[now];
	doinv(t / p[now]);
}
void doit()
{
	fac[0] = 1; inv[0] = 1;
	nowp = 1; nowq = 0;
	for (int i = 1; i <= pq[now]; i++){
		fac[i] = fac[i - 1]; inv[i] = inv[i] = inv[i - 1];
		if (i % p[now] != 0){
			fac[i] = fac[i] * i % pq[now];
			inv[i] = inv[i] * solve_equ(i, 1, pq[now]) % pq[now];
			if (solve_equ(i, 1, pq[now]) * i % pq[now] != 1) cerr << "BUG" << endl;
		}
	}
	dofac(n);
	for (int i = 1; i <= m; i++)
		doinv(w[i]);
	nowp = nowp * pow(p[now], nowq, pq[now]) % pq[now];
	ret[now] = nowp;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> P;
	cin >> n >> m; 
	for (int i = 1; i <= m; i++) cin >> w[i];
	++m; w[m] = n; for (int i = 1; i < m; i++) w[m] -= w[i];
	if (w[m] < 0) { puts("Impossible"); return 0; }
	PP = P;
	for (int i = 2; i <= 100000; i++) if (PP % i == 0){
		p[++cnt] = i; pq[cnt] = 1; while(PP % i == 0) { q[cnt]++; pq[cnt] *= i; PP /= i; }
	}
	for (now = 1; now <= cnt; now++) doit();
	crt();
}
Problem2149

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <list>
#include <vector>
#include <iostream>
#define ll long long
#define Tpoint pair<ll, ll>
using namespace std;
const int MAXN = 400001;
const ll INF = 0x7fffffffffffffffll;
int n, f[MAXN], g[MAXN], a[MAXN], b[MAXN];
int id[MAXN];
ll dp[MAXN];
bool cross(Tpoint A, Tpoint B, Tpoint C)
{
	return (A.first - C.first) * (B.second - C.second) - (A.second - C.second) * (B.first - C.first) >= 0;
}
struct Tqueue{
	vector<Tpoint > Q;
	void clear() { Q.clear(); }
	void add(Tpoint A)
	{
		while(Q.size() > 1 && cross(A, Q[Q.size() - 1], Q[Q.size() - 2])) Q.pop_back();
		Q.push_back(A);
	}
	ll get(ll k)
	{
		int l = 0, r = Q.size() - 1; if (Q.size() == 0) return INF;
		if (l == r) return Q[l].first * k + Q[l].second;
		while(l <= r){
			int m = l + r >> 1;
			if (k * Q[m].first + Q[m].second > k * Q[m + 1].first + Q[m + 1].second) l = m + 1; else r = m - 1;
		}
		l = min(l, (int)Q.size() - 1);
		return Q[l].first * k + Q[l].second;
	}
}; 
struct Tsgt{
	Tqueue Q[MAXN];
	void build(int idx, int l, int r)
	{
		Q[idx].clear();
		if (l == r) return;
		build(idx * 2, l, l + r >> 1);
		build(idx * 2 + 1, l + r + 2 >> 1, r);
	}
	void insert(int idx, int l, int r, int x, int t)
	{
		Q[idx].add(make_pair(((ll)a[id[t]] - id[t]) * 2, dp[id[t]] * 2 - (ll)a[id[t]] * id[t] * 2 - (ll)a[id[t]] * 2 + (ll)id[t] * id[t] + (ll)id[t]));
		if (l == r) return;
		int m = l + r >> 1;
		if (x <= m) insert(idx * 2, l, m, x, t);
		else insert(idx * 2 + 1, m + 1, r, x, t);
	}
	ll query(int idx, int l, int r, int la, int ra, ll k)
	{
		if (la <= l && ra >= r) return Q[idx].get(k);
		int m = l + r >> 1; ll ret = INF;
		if (la <= m) ret = min(ret, query(idx * 2, l, m, la, ra, k));
		if (ra > m)  ret = min(ret, query(idx * 2 + 1, m + 1, r, la, ra, k));
		return ret;
	}
} sgt;
bool cmp(int A, int B)
{
	return f[A] == f[B] ? a[A] - A < a[B] - B : f[A] < f[B];
}
int hash[MAXN];
int find(int l, int r, int x)
{
	while(l <= r){
		int m = l + r >> 1;
		if (x >= hash[m]) l = m + 1; else r = m - 1;
	}
	return r;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
	int nowr = 0; g[0] = 0xe0e0e0e0;
	int ans1 = 0;
	for (int i = 1; i <= n; i++){
		if (a[i] < i) { f[i] = -1; continue; }
		f[i] = upper_bound(g, g + nowr + 1, a[i] - i) - g;
		nowr = max(f[i], nowr); g[f[i]] = a[i] - i;
		ans1 = max(ans1, f[i]);
	}
	int tot = 0;
	for (int i = 1; i <= n; i++) if (a[i] >= i) id[++tot] = i;
	int N = n; n = tot;
	sort(id, id + n + 1, cmp);
	nowr = -1; 
	for (int i = 1; i <= n; i++){
		int t = i; while(t < n && f[id[t + 1]] == f[id[i]]) ++t;
		nowr++;
		int lastr = nowr;
		while(f[id[nowr + 1]] == f[id[i]] - 1) ++nowr;
		for (int j = lastr; j <= nowr; j++) hash[j - lastr + 1] = id[j];
		sort(hash + 1, hash + nowr - lastr + 2);
		sgt.build(1, 1, nowr - lastr + 1);
		int p = lastr;
		for (int j = i; j <= t; j++){
			while(p <= nowr && a[id[p]] - id[p] <= a[id[j]] - id[j])
				sgt.insert(1, 1, nowr - lastr + 1, find(1, nowr - lastr + 1, id[p]), p), ++p;
			int t =  find(1, nowr - lastr + 1, id[j]); if (t < 0) { dp[id[j]] = INF; continue; }
			dp[id[j]] = (sgt.query(1, 1, nowr - lastr + 1, 1, t, id[j]) + ((ll)id[j] * id[j] - id[j] + a[id[j]] * 2 + b[id[j]] * 2)) >> 1;
		}
		i = t;
	}
	ll ans2 = INF;
	for (int i = 1; i <= n; i++) if (f[id[i]] == ans1){
		ans2 = min(ans2, dp[id[i]] + (ll)(a[id[i]] + 1 + N - id[i] + a[id[i]]) * (N - id[i]) / 2);
	}
	cout << ans1 << " " << ans2 << endl;
}
Problem2150

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
vector<int> V[10001];
bool vis[10001];
char map[1001][1001];
int Link[10001];
int find(int x)
{
	for (vector<int>::iterator vi = V[x].begin(); vi != V[x].end(); vi++) if (!vis[*vi]){
		vis[*vi] = true;
		if (Link[*vi] == 0 || find(Link[*vi])){
			Link[*vi] = x; return true;
		}
	}
	return false;
}
int n, m, r, c;
const int dx[4] = {1, -1, 1, -1}, dy[4] = {1, -1, -1, 1};
bool check(int x, int y)
{
	if (x <= 0 || x > n || y <= 0 || y > m) return false;
	return map[x][y] == '.';
}
int change(int x, int y) { return (x - 1) * m + y; }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &r, &c);
	for (int i = 1; i <= n; i++) scanf("%s", map[i] + 1);
	int ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) if (map[i][j] == '.'){
			++ans;
			if (check(i + r, j + c)) V[change(i, j)].push_back(change(i + r, j + c));
			if (check(i + r, j - c)) V[change(i, j)].push_back(change(i + r, j - c));
			if (check(i + c, j + r)) V[change(i, j)].push_back(change(i + c, j + r));
			if (check(i + c, j - r)) V[change(i, j)].push_back(change(i + c, j - r));
			}
	for (int i = 1; i <= n * m; i++){
		for (int j = 1; j <= n * m; j++) vis[j] = false;
		ans -= find(i);
	}
	printf("%d\n", ans);
}
Problem2154

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 12000001, MO = 20101009;
bool f[MAXN];
int minp[MAXN], mobius[MAXN], p[MAXN], pnum, sum[MAXN];
int n, m;
void getmobius(int MAXN)
{
	for (int i = 2; i <= MAXN; i++) f[i] = true;
	mobius[1] = 1;
	for (int i = 2; i <= MAXN; i++){
		if (f[i]) { mobius[i] = -1; p[++pnum] = i; minp[i] = i;}
		for (int j = 1; (long long) i * p[j] <= MAXN && j <= pnum; j++){
			int t = i * p[j]; f[t] = false; minp[t] = p[j]; if (minp[t] == minp[i]) mobius[t] = 0; else mobius[t] = -mobius[i];
			if (i % p[j] == 0) continue;
		}
	}
}
int solve(int n, int m)
{
	int ret = 0;
	for (int i = 1; i <= n; i++){
		int t1 = n / i, t2 = m / i, j = min(n / t1, m / t2);
		int T1 = (long long) t1 * (t1 + 1) / 2 % MO, T2 = (long long) t2 * (t2 + 1) / 2 % MO;
		ret = ((long long)T1 * T2 % MO * (sum[j] - sum[i - 1]) % MO + ret) % MO;
		i = j;
	}
	return ((ret % MO) + MO) % MO;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); if (n > m) swap(n, m);
	getmobius(n);
	int ans = 0;
	for (int i = 1; i <= n; i++) sum[i] = ((long long) i * i * mobius[i] % MO + sum[i - 1]) % MO;
	for (int i = 1; i <= n; i++){
		int t1 = n / i, t2 = m / i, j = min(n / t1, m / t2);
		int t = (long long)solve(t1, t2) * ((long long)(i + j)  * (j - i + 1) / 2) % MO;
		ans = (ans + t) % MO; i = j;
	}
	printf("%d\n", ans);
}
Problem2155

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tbig{
	int len, data[200];
	Tbig(int x = 0) { memset(this, 0, sizeof(*this)); len = 1; data[1] = x; }
	int & operator [] (int k) { return data[k]; }
	const int & operator [] (int k) const { return data[k]; }
	Tbig operator + (const Tbig & A)
	{
		Tbig temp; temp.len = max(len, A.len);
		for (int i = 1; i <= temp.len; i++){
			temp[i] += data[i] + A[i];
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
		}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Tbig operator - (const Tbig & A)
	{
		Tbig temp; temp.len = max(len, A.len);
		for (int i = 1; i <= temp.len; i++){
			if (temp[i] + data[i] - A[i] < 0) temp[i] += 10000, temp[i + 1]--;
			temp[i] += data[i] - A[i];
		}
		while(temp.len > 0 && temp[temp.len] == 0) --temp.len;
		return temp;
	}
	Tbig operator * (const Tbig & A)
	{
		Tbig temp; temp.len = len + A.len - 1;
		for (int i = 1; i <= len; i++)
			for (int j = 1; j <= A.len; j++){
				temp[i + j - 1] += data[i] * A[j];
				temp[i + j] += temp[i + j - 1] / 10000;
				temp[i + j - 1] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Tbig operator / (int t)
	{
		Tbig temp; temp.len = len;
		for (int i = temp.len; i >= 1; i--){
			temp[i] += data[i];
			if (i != 1) temp[i - 1] += 10000 * (temp[i] % t);
			temp[i] /= t;
		}
		while(temp.len > 0 && temp[temp.len] == 0) --temp.len;
		return temp;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]);
		putchar('\n');
	}
} ans;
int n;
Tbig C(int n, int m)
{
	Tbig ret = 1;
	for (int i = 0; i < m; i++) ret = ret * (n - i) / (i + 1);
	return ret;
}
Tbig catalan(int t)
{
	return C(2 * t, t) / (t + 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n / 2; i++)
		ans = ans + C(n, 2 * i) * (C(2 * i, i) / 2 - catalan(i));
	ans.print();
}
Problem2156

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
#include <queue>
#define PII pair<int, int>
using namespace std;
const int MAXN = 100001, MAXM = 1000001;
priority_queue<PII, vector<PII>, greater<PII> > Q;
map<PII, int> M;
int n, m, ans, p, last, s, t;
int tot, e[MAXN], v[MAXM], w[MAXM], next[MAXM];
int dis[MAXN]; bool vis[MAXN];
void add(int a, int b, int c) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c; }
void dijkstra()
{
	for (int i = 1; i <= n; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
	dis[s] = 0; Q.push(make_pair(0, s));
	while(!Q.empty()){
		PII now = Q.top(); Q.pop(); if (vis[now.second]) continue;
		vis[now.second] = true; int x = now.second;
		for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i]){
			dis[v[i]] = dis[x] + w[i]; Q.push(make_pair(dis[v[i]], v[i]));
		}
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c); ++a; ++b;
		add(a, b, c); M[make_pair(a, b)] = c;
	}
	scanf("%d%d", &p, &s); ++s; last = s;
	for (int i = 2; i <= p; i++){
		int now; scanf("%d", &now); ++now;
		if (i == p) t = now;
		ans += M[make_pair(last, now)];
		last = now;
	}
	dijkstra();
	printf("%d\n", ans - dis[t]);
}
Problem2157

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MAXN = 200001;
struct Tnode{
	static Tnode *a;
	int c[2], f, sum, val, min, max;
	bool _flip, isroot;
	void flip()
	{
		if (this == a) return;
		int tmin = min, tmax = max;
		sum *= -1; val *= -1; min = -tmax; max = -tmin;
		_flip ^= 1;
	}
	void push()
	{
		if (_flip) { a[c[0]].flip(); a[c[1]].flip(); _flip = false; }
	}
	void update()
	{
		sum = a[c[0]].sum + a[c[1]].sum + val;
		min = std::min(val, std::min(a[c[0]].min, a[c[1]].min));
		max = std::max(val, std::max(a[c[0]].max, a[c[1]].max));
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) isroot = true, a[f].isroot = false;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x ==  A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
int ac(int x, int k, bool F)
{
	int q = x, p = 0, ret;
	while(q){
		splay(q);
		if (A[q].f == 0 && F){
			switch(k){
				case 0 : ret = A[p].sum + A[A[q].c[1]].sum; break;
				case 1 : A[p].flip(); A[A[q].c[1]].flip(); break;
				case 2 : ret = std::max(A[p].max, A[A[q].c[1]].max); break;
				case 3 : ret = std::min(A[p].min, A[A[q].c[1]].min); break;
			}
		}
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
	}
	return ret;
}
int tot, e[MAXN], v[MAXN], w[MAXN], next[MAXN], st[MAXN], ed[MAXN], len[MAXN], f[MAXN];
void add(int a, int b, int c)  { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c; }
void dfs(int x)
{
	A[x].isroot = true; A[x].f = f[x];
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		A[v[i]].val = w[i]; A[v[i]].update(); f[v[i]] = x; dfs(v[i]);
	}
}
int n, Q;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	A[0].max = 0xe0e0e0e0; A[0].min = 0x3f3f3f3f; 
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		scanf("%d%d%d", &st[i], &ed[i], &len[i]); ++st[i]; ++ed[i];
		add(st[i], ed[i], len[i]); add(ed[i], st[i], len[i]);
	}
	dfs(1); scanf("%d", &Q);
	while(Q--){
		scanf(" "); char op[101]; scanf("%s", op); int x, y, val;
		switch(*op){
			case 'S' : scanf("%d%d", &x, &y); ++x; ++y; ac(x, 0, 0); printf("%d\n", ac(y, 0, 1)); break;
			case 'N' : scanf("%d%d", &x, &y); ++x; ++y; ac(x, 1, 0); ac(y, 1, 1); break;
			case 'C' : scanf("%d%d", &x, &val); x = st[x] = f[ed[x]] ? ed[x] : st[x]; splay(x); A[x].val = val; A[x].update(); break;
			case 'M':
					   scanf("%d%d", &x, &y); ++x; ++y;
					   if (*(op + 1) == 'A') {  ac(x, 2, 0); printf("%d\n", ac(y, 2, 1)); break; }
					   else { ac(x, 3, 0); printf("%d\n", ac(y, 3, 1)); break; }
					   break;
		}
	}
}
Problem2158

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
#include <vector>
#define PII pair<int, int>
#define Tsi set<PII >::iterator
using namespace std;
const int MAXN = 200001, MAXM = 2 * MAXN;
int e[MAXN], v[MAXM], next[MAXM], val[MAXN], tot, n, m, L, A, B, Q, now, tmp;
struct Tquest{
	int k, x, val;
	Tquest() { } 
	Tquest(int k, int x, int val = 0) : k(k), x(x), val(val) { }
} quest[MAXN];
void add(int a, int b)
{
	//cerr << a << " " << b << endl;
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
namespace solve1
{
	int q[MAXN], dis[MAXN]; bool vis[MAXN];
	
	int getans(int s)
	{
		int l = 1, r = 1, ret = 0; q[1] = s; dis[s] = val[s]; ret = dis[s];
		for (int i = 1; i <= n; i++) vis[i] = false; vis[s] = true;
		while(l <= r){
			int x = q[l++]; 
			for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) {
				dis[v[i]] = dis[x] + val[v[i]]; q[++r] = v[i]; vis[v[i]] = true;
				ret = max(ret, dis[v[i]]);
		   	}
		}
		return ret;
	}
	void solve()
	{
		for (int i = 1; i < m; i++)
			switch(quest[i].k){
				case 0 : printf("%d\n", getans(quest[i].x)); break;
				case 1 : val[quest[i].x] = quest[i].val;
			}
	}
};
namespace solve2{
	int sum[MAXN];
	struct Tsgt{
		int minnum[MAXN * 4], maxnum[MAXN * 4], _add[MAXN * 4];
		void add(int idx, int delta)
		{
			maxnum[idx] += delta; minnum[idx] += delta;
			_add[idx] += delta;
		}
		void update(int idx)
		{
			maxnum[idx] = max(maxnum[idx * 2], maxnum[idx * 2 + 1]);
			minnum[idx] = min(minnum[idx * 2], minnum[idx * 2 + 1]);
		}
		void push(int idx)
		{
			if (_add[idx] != 0){
				add(idx * 2, _add[idx]); add(idx * 2 + 1, _add[idx]);
				_add[idx] = 0;
			}
		}
		void build(int idx, int l, int r)
		{
			if (l == r) { minnum[idx] = maxnum[idx] = sum[l]; return; }
			build(idx * 2, l, l + r >> 1); build(idx * 2 + 1, l + r + 2 >> 1, r);
			update(idx);
		}
		void addnum(int idx, int l, int r, int ll, int rr, int delta)
		{
			if (ll <= l && rr >= r) { add(idx, delta); return; }
			push(idx);
			int m = l + r >> 1;
			if (ll <= m) addnum(idx * 2, l, m, ll, rr, delta);
			if (rr > m) addnum(idx * 2 + 1, m + 1, r, ll, rr, delta);
			update(idx);
		}
		int getmin(int idx, int l, int r, int ll, int rr)
		{
			if (ll > rr) return 0x1f1f1f1f;
			if (ll <= l && rr >= r) return minnum[idx];
			push(idx);
			int m = l + r >> 1, ret = 0x1f1f1f1f;
			if (ll <= m) ret = getmin(idx * 2, l, m, ll, rr);
			if (rr > m) ret = min(ret, getmin(idx * 2 + 1, m + 1, r, ll, rr));
			return ret;
		}
		int getmax(int idx, int l, int r, int ll, int rr)
		{
			if (ll > rr) return -0x1f1f1f1f;
			if (ll <= l && rr >= r) return maxnum[idx];
			push(idx);
			int m = l + r >> 1, ret = -0x1f1f1f1f;
			if (ll <= m) ret = getmax(idx * 2, l, m, ll, rr);
			if (rr > m) ret = max(ret, getmax(idx * 2 + 1, m + 1, r, ll, rr));
			return ret;
		} 
	}sgt;
	void solve()
	{
		for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + val[i];
		sgt.build(1, 1, n); int t;
		for (int i = 1; i < m; i++)
			switch(quest[i].k){
				case 0 : 
						t = sgt.getmax(1, 1, n, quest[i].x, quest[i].x);
						printf("%d\n", max(sgt.getmax(1, 1, n, quest[i].x + 1, n) - t + val[quest[i].x], t - sgt.getmin(1, 1, n, 1, quest[i].x - 1))); break;
				case 1 : sgt.addnum(1, 1, n, quest[i].x, n, quest[i].val - val[quest[i].x]); val[quest[i].x] = quest[i].val;
			}
	}
}
namespace solve3{
	set<PII, greater<PII> > S[MAXN]; int f[MAXN];
	bool vis[MAXN];
	void dfs(int x)
	{
		vis[x] = true; S[x].insert(make_pair(0, x));
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
			f[v[i]] = x; dfs(v[i]); S[x].insert(make_pair(S[v[i]].begin()->first + val[v[i]], v[i]));
		}
	}
	int getans(int x)
	{
		int ret = S[x].begin()->first + val[x], now = val[x], p = x, q = f[x];
		while(q){
			int t; now += val[q];
			if (S[q].begin()->second != p) t = now + S[q].begin()->first; else t = now + (++S[q].begin()) -> first;
			ret = max(ret, t);
			p = q; q = f[q];
		}
		return ret;
	}
	void change(int x, int _val)
	{
		int p = x, q = f[x], last = S[p].begin()->first;
		while(q){
			int tlast = S[q].begin()->first;
			S[q].erase(make_pair(last + val[p], p));
			S[q].insert(make_pair(S[p].begin()->first + (p == x ? _val : val[p]), p));
			last = tlast; p = q; q = f[q];
		}
		val[x] = _val;
	}
	void solve()
	{
		dfs(1);
		for (int i = 1; i < m; i++)
			switch(quest[i].k){
				case 0 : printf("%d\n", getans(quest[i].x)); break;
				case 1 : change(quest[i].x, quest[i].val); break;
			}
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	char c; scanf("%c", &c);
	scanf("%d%d%d", &n, &m, &L);
    scanf("%d%d%d%d", &now, &A, &B, &Q);
   	for (int i = 1; i <= n; i++){
    	now = (now * A + B) % Q, tmp = now % 10000;
    	now = (now * A + B) % Q;
   		if (now * 2 < Q) tmp *= -1;
   		val[i] = tmp;
   	}
 	for (int i = 1; i < n; i ++){
       	now = (now * A + B) % Q;
        tmp = (i < L) ? i : L;
        add(i - now % tmp, i + 1); add(i + 1, i - now % tmp);
    }
	for (int i = 1; i < m; i ++){
        now = (now * A + B) % Q;
        if (now * 3 < Q){
          	now = (now * A + B) % Q;
            quest[i] = Tquest(0, now % n + 1);
        }
        else{
            now = (now * A + B) % Q, tmp = now % 10000;
           	now = (now * A + B) % Q;
            if (now * 2 < Q) tmp *= -1;
			now = (now * A + B) % Q;	
            quest[i] = Tquest(1, now % n + 1, tmp); 
        }
    }
	switch(c){
		case 'A' : solve1::solve(); break;
		case 'B' : solve2::solve(); break;
		case 'C' : solve3::solve(); break;
	}
}
Problem2159

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 10007, MAXN = 200001;
int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2], dis[MAXN];
int f[MAXN], which[MAXN], q[MAXN], sum[60001][201];
int pow[60001][201], C[201][201], ans[MAXN];
bool del[MAXN];
int n, k, num, l, r;
int size[MAXN], ms[MAXN];
int find_heavy(int x)
{
    f[x] = 0; l = 1; r = 1; q[1] = x;
    while(l <= r){
        int nx = q[l++];
        for (int i = e[nx]; i; i = next[i]) if (v[i] != f[nx] && !del[v[i]]) q[++r] = v[i], f[v[i]] = nx;
        }
    for (int i = r; i >= 1; i--){
        size[q[i]] = 1;
        ms[q[i]] = 0;
        for (int j = e[q[i]]; j; j = next[j]) if (f[q[i]] != v[j] && !del[v[j]])  { size[q[i]] += size[v[j]]; ms[q[i]] = max(ms[q[i]], size[v[j]]); }
        ms[q[i]] = max(ms[q[i]], r - 1 - size[q[i]]);
        }
    int w = q[1];
    for (int i = 2; i <= r; i++) if (ms[q[i]] < ms[w]) w = q[i];
    return w;
}
void doit(int x)
{
	x = find_heavy(x); if (r == 1) return;
	l = 1, r = 0; tot = 0;
	f[x] = 0;
	for (int i = e[x]; i; i = next[i]) if (f[x] != v[i] && !del[v[i]]){
		dis[v[i]] = 1; f[v[i]] = x; r = l; q[l] = v[i]; ++tot; which[v[i]] = tot;
		for (int i = 0; i <= k; i++) sum[tot][i] = pow[1][i];
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (f[x] != v[i] && !del[v[i]]){
				dis[v[i]] = dis[x] + 1; f[v[i]] = x; which[v[i]] = tot;
				for (int j = 0; j <= k; j++) sum[tot][j] = (sum[tot][j] + pow[dis[v[i]]][j]) % MO;
				q[++r] = v[i];
			}
		}
	}
	for (int i = 0; i <= k; i++) sum[0][i] = 0;
	for (int i = 1; i <= tot; i++)
		for (int j = 0; j <= k; j++)
			sum[0][j] = (sum[0][j] + sum[i][j]) % MO;
	ans[x] = (ans[x] + sum[0][k]) % MO;
	for (int i = 1; i <= r; i++){
		ans[q[i]] = (ans[q[i]] + pow[dis[q[i]]][k]) % MO;
		for (int j = 0; j <= k; j++) ans[q[i]] = (ans[q[i]] + (long long)C[k][j] * (sum[0][k - j] - sum[which[q[i]]][k - j]) % MO * pow[dis[q[i]]][j] % MO) % MO;
	}
	del[x] = true;
	for (int i = e[x]; i; i = next[i]) if (f[x] != v[i] && !del[v[i]]) doit(v[i]);
}
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    int L, now, A, B, Q, tmp; 
    scanf("%d%d%d", &n, &k, &L); 
    scanf("%d%d%d%d", &now, &A, &B, &Q);  
    for (int i = 1; i < n; i ++){ 
       now = (now * A + B) % Q; 
       tmp = (i < L) ? i : L; 
	   int a = i - now % tmp, b = i + 1;
	   add(a, b); add(b, a);
    }
	C[0][0] = 1;
	for (int i = 1; i <= k; i++){
		C[i][0] = 1;
		for (int j = 1; j <= i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
	}
	for (int i = 1; i <= n; i++){
		pow[i][0] = 1;
		for (int j = 1; j <= k; j++) pow[i][j] = (long long) pow[i][j - 1] * i % MO;
	}
	doit(1);
	for (int i = 1; i <= n; i++) printf("%d\n", (ans[i] + MO) % MO);
}
Problem2160

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 19930726;
int f[4000001]; long long sum[4000001]; char s[4000001];
int n; long long k;
int pow(int a, long long b)
{
	int now = 1;
	for (; b; b >>= 1ll){
		if (b & 1ll) now = (long long) now * a % MO;
		a = (long long) a * a % MO;
	}
	return now;
}
void manacher()
{
	f[1] = 1; int mx = 1, id = 1;
	for (int i = 2; i <= n; i++){
		if (mx >= i) f[i] = min(mx - i + 1, f[id * 2 - i]); else f[i] = 1;
		while(i - f[i] > 0 && s[i + f[i]] == s[i - f[i]]) ++f[i];
		if (i + f[i] - 1 > mx) { mx = i + f[i] - 1; id = i; }
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> k;
	scanf("%s", s + 1); s[n + 1] = 0;
	manacher();
	for (int i = 1; i <= n; i++) sum[f[i]]++;
	for (int i = n - 1; i >= 1; i--) sum[i] += sum[i + 1];
	int l = 1, r = n;
	//if (sum[1] < k) { puts("-1"); return 0; }
	/*
	while(l <= r){
		int m = l + r >> 1;
		if (sum[m] >= k) l = m + 1; else r = m - 1;
	}
	*/
	int ans = 1;
	for (int i = n; i >= 1; i--){
		long long t = min(k, sum[i]);
		ans = (long long) ans * pow(i * 2 - 1, t) % MO;
		k -= t;
	}
	if (k > 0) puts("-1");
	cout << ans << endl;
}
Problem2161

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define LL long long
const int MAXNODE = 1000001;
struct Tnode{
	static Tnode *a;
	int c[2], f, size, val;
	void update() { size = a[c[0]].size + a[c[1]].size + 1; }
	void rot(bool b) 
	{
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXNODE], *Tnode::a = A;
int tot;
struct Tsplay{
	int root;
	void splay(int x, int p)
	{
		int y, z; bool b, c;
		while ((y = A[x].f) != p){
			b = x == A[y].c[1];
			if ((z = A[y].f) != p){
				c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
			    A[x].rot(c);
			}
			else A[x].rot(b);
		}
		A[x].update(); if (p == 0) root = x;		
	}
	void insert(int val)
	{
		int t = root; if (root == 0) { root = ++tot; A[tot].val = val; A[tot].size = 1; return; }
		while(A[t].c[val > A[t].val]) { ++A[t].size; t = A[t].c[val > A[t].val]; }
		++A[t].size; A[t].c[val > A[t].val] = ++tot; A[tot].f = t;
		A[tot].val = val; A[tot].size = 1;
		splay(tot, 0);
	}
	int select(int k)
	{
		int t = root, now; k = A[root].size - k + 1;
		if (k < 1) return 0;
		while((now = A[A[t].c[0]].size + 1) != k)
			if (now > k) t = A[t].c[0]; else t = A[t].c[1], k -= now;
		splay(t, 0); return A[t].val;
	}
	int findmax(int t) { while(A[t].c[1]) t = A[t].c[1]; return t; }
	int find(int val)
	{
		int t = root;
		while(A[t].val != val) t = A[t].c[val > A[t].val];
		return t;
	}
	void erase(int val)
	{
		splay(find(val), 0);
		if (A[root].c[0] == 0) { root = A[root].c[1]; A[root].f = 0; return; }
		int t = findmax(A[root].c[0]); splay(t, root);
		A[t].c[1] = A[root].c[1]; A[A[t].c[1]].f = t; A[t].update();
		root = t; A[root].f = 0;
	}
} splay;
struct Tscan{
	int who, p, kind;
	Tscan() {  }
	Tscan(int who, int p, int kind) : who(who), p(p), kind(kind) { }
	bool operator < (const Tscan & A) const { return p == A.p ? kind < A.kind : p < A.p; }
} scan[MAXNODE];
int P[MAXNODE], L[MAXNODE], R[MAXNODE], C[MAXNODE], n;
int Padd, Pfirst, Pmod, Pprod;
int Cadd, Cfirst, Cmod, Cprod;
int Ladd, Lfirst, Lmod, Lprod;
int Radd, Rfirst, Rmod, Rprod;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    cin >> n;
    cin >> Padd >> Pfirst >> Pmod >> Pprod >> Cadd >> Cfirst >> Cmod >> Cprod;
    cin >> Ladd >> Lfirst >> Lmod >> Lprod >> Radd >> Rfirst >> Rmod >> Rprod;
    //P
    P[1] = Pfirst % Pmod;
    for (int i = 2; i <= n; i ++)
        P[i] = (int) (((LL) P[i - 1] * (LL) Pprod + (LL) Padd + (LL) i) % (LL) Pmod);
    //C
    C[1] = Cfirst % Cmod;
    for (int i = 2; i <= n; i ++)
        C[i] = (int) (((LL) C[i - 1] * (LL) Cprod + (LL) Cadd + (LL) i) % (LL) Cmod);
    //L
    L[1] = Lfirst % Lmod;
    for (int i = 2; i <= n; i ++)
        L[i] = (int) (((LL) L[i - 1] * (LL) Lprod + (LL) Ladd + (LL) i) % (LL) Lmod);
    //R
    R[1] = Rfirst % Rmod;
    for (int i = 2; i <= n; i ++)
        R[i] = (int) (((LL) R[i - 1] * (LL) Rprod + (LL) Radd + (LL) i) % (LL) Rmod);
    for (int i = 1; i <= n; i ++)
        if (L[i] > R[i]) swap(L[i], R[i]);
	int tot = 0;
	for (int i = 1; i <= n; i++){
		scan[++tot] = Tscan(i, L[i], -1);
		scan[++tot] = Tscan(i, P[i], 0);
		scan[++tot] = Tscan(i, R[i], 1);
	}
	int ans = 0;
	sort(scan + 1, scan + tot + 1);
	for (int i = 1; i <= tot; i++){
		switch(scan[i].kind){
			case -1 : splay.insert(C[scan[i].who]); break;
			case 0 : ans = (ans + splay.select(scan[i].who)) % 19921228; break;
			case 1 : splay.erase(C[scan[i].who]); break;
		}
	}
	printf("%d\n", ans);
}
Problem2162

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 100001, MAXM = 500001, INF = 0x3f3f3f3f, MO = 19921228;
int n, k, m; bool map[101][101];
struct Tcut{
	int s, t, tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM];
	int d[MAXN], q[MAXN], l, r;
	bool bs[MAXN];
	Tcut() { tot = 1; }
	void add(int A, int B, int C)
	{
		//cerr << A << " " << B << " " << C << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
	}
	bool relable()
	{
		for (int i = 1; i <= t; i++) d[i] = -1; d[s] = 0; l = r = 1; q[1] = s;
		while(l <= r){
			int x = q[l++]; 
			for (int i = e[x]; i; i = next[i]) if (d[v[i]] == -1 && c[i] > 0){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f)
	{
		if (x == t) return f; int augc = f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == d[x] + 1){
			int t = find(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0) break;
		}
		if (f) d[x] = -1;
		return augc - f;
	}
	void dfs(int x)
	{
		bs[x] = true;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && !bs[v[i]])
			dfs(v[i]);
	}
	void split()
	{
		while(relable())
			while(find(s, INF));
		dfs(s);
	}
} cut;
int C[3001][3001], f[301][301];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &k, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		map[a][b] = true;
	}
	cut.s = 2 * n + 1; cut.t = 2 * n + 2;
	for (int i = 1; i <= n; i++) { cut.add(cut.s, i, 3 * n); cut.add(i + n, cut.t, 3 * n - 1); }
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) if (!map[i][j])
			cut.add(i, j + n, INF);
	cut.split();
	int ans1 = n, ans2 = n;
	for (int i = 1; i <= n; i++){
		if (!cut.bs[i]) --ans1;
		if (cut.bs[i + n]) --ans2;
	}
	printf("%d %d\n", ans1, ans2);
	n = ans1; m = ans2;
	C[0][0] = 1;
	for (int i = 1; i <= n * m; i++){
		C[i][0] = 1;
		for (int j = 1; j <= i; j++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MO;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			f[i][j] = C[i * j][k];
			for (int k = 1; k <= i; k++)
				for (int l = 1; l <= j; l++)
					if (k != i || l != j)
						f[i][j] = (f[i][j] - (long long)f[k][l] * C[i][k] % MO * C[j][l] % MO) % MO;
		}
	printf("%d\n", (f[n][m] + MO) % MO);
}
Problem2163

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001;
struct Tflow{
	int tot, d[MAXN], e[MAXN], v[MAXN], c[MAXN], next[MAXN], q[MAXN], s, t;
	Tflow() { tot = 1; }
	void add(int A, int B, int C)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; 
	}
	bool relabel()
	{
		for (int i = 1; i <= t; i++) d[i] = -1;
		int l = 1, r = 1; q[1] = s; d[s] = 0;
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == -1){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f)
	{
		int augc = f; if (x == t) return f;
		for (int i = e[x]; i; i = next[i]) if (d[x] + 1 == d[v[i]] && c[i] > 0){
			int t = find(v[i], min(f, c[i])); c[i] -= t; c[i ^ 1] += t; f -= t;
		}
		if (f) d[x] = -1;
		return augc - f;
	}
	int run()
	{
		int t, ret = 0;
		while(relabel()){
			while(t = find(s, 0x3f3f3f3f)) ret += t;
		}
		return ret;
	}
} flow;
int n, m, ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	flow.s = n * 2 + 1; flow.t = n * 2 + 2;
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t); flow.add(flow.s, i, t); flow.add(i + n, flow.t, t);
		ans += t;
	}
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		flow.add(a, b + n, c);
	}
	printf("%d\n", ans - flow.run());
}
Problem2164

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 200001, MAXM = 61;
int n, m, SeedA, SeedB, SeedQ;
int getint()
{
	SeedA=((SeedA^SeedB)+(SeedB>>16)+(SeedB<<16))&0x7fffffff;
	SeedB=((SeedA^SeedB)+(SeedA>>16)+(SeedA<<16))&0x7fffffff;
	return(SeedA^SeedB)%SeedQ;
}
struct Tbag2{
	int data[MAXM];
	int & operator [] (int k) { return data[k]; }
	Tbag2() { memset(data, 0, sizeof(data)); }
	void init()
	{
		for (int i = 1; i <= m; i++) data[i] = getint();
		sort(data + 1, data + m + 1);
	}
	Tbag2 operator + (Tbag2 A)
	{
		Tbag2 temp;
		for (int i = 0; i <= m; i++) temp[i] = max(A[i], data[i]);
		return temp;
	}
	void out()
	{
		for (int i = 1; i <= m; i++) printf("%d ", data[i]); putchar('\n');
	}
};
struct Tbag{
	int data[MAXM];
	int & operator [] (int k) { return data[k]; }
	Tbag() { memset(data, 0, sizeof(data)); }
	void init()
	{
		for (int i = 1; i <= m; i++) data[i] = getint();
		sort(data + 1, data + m + 1);
	}
	Tbag operator + (Tbag  A)
	{
		Tbag temp;
		for (int i = 0; i <= m; i++)
			for (int j = 0; j <= m; j++) if (i + j <= m)
				temp[i + j] = max(temp[i + j], data[i] + A[j]);
		return temp;
	}
	Tbag operator = (Tbag2 A) { for (int i = 1; i <= m; i++) data[i] = A[i]; }
	void out()
	{
		for (int i = 1; i <= m; i++) printf("%d ", data[i]); putchar('\n');
	}
};

struct Tnode{
	static Tnode *a;
	int c[2], f;
	bool isroot;
	Tbag2 val, sum;
	inline void update() { sum = val + a[c[0]].sum + a[c[1]].sum; }
	inline void rot(bool b)
	{
		if (a[f].isroot) { isroot = true; a[f].isroot = false; }
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
struct Tlct{
	void splay(int x)
	{
		int y, z; bool b, c;
		while(!A[x].isroot){
			y = A[x].f; b = x == A[y].c[1];
			if (!A[y].isroot){
				z = A[y].f; c = y == A[z].c[1];
				if (b == c) A[y].rot(b); else A[x].rot(b);
				A[x].rot(c);
			}
			else A[x].rot(b);
		}
		A[x].update();
	}
	void read(int x)
	{
		splay(x); A[x].val.init(); A[x].update();
	}
	Tbag2 access(int x)
	{
		int p = 0, q = x; Tbag2 ret;
		while(q){
			splay(q);
			if (!A[q].f) ret = A[q].val + A[p].sum + A[A[q].c[1]].sum;
			A[A[q].c[1]].isroot = true;
			A[q].c[1] = p;
			A[p].isroot = false;
			A[q].update();
			p = q; q = A[q].f;
		}
		return ret;
	}
	Tbag2 query(int x, int y) { access(x); return access(y); }
} lct;

int now, L[MAXN], R[MAXN], who[MAXN];
struct Tsgt{
	Tbag sum[MAXN * 3];
	void build(int idx, int l, int r)
	{
		if (l == r) { sum[idx] = A[who[l]].val; return; }
		build(idx * 2, l, l + r >> 1); build(idx * 2 + 1, l + r + 2 >> 1, r);
		sum[idx] = sum[idx * 2] + sum[idx * 2 + 1];
	}
	void change(int idx, int l, int r, int x)
	{
		if (l == r) { sum[idx] = A[who[l]].val; return; }
		int m = l + r >> 1;
		if (x <= m) change(idx * 2, l, m, x); else change(idx * 2 + 1, m + 1, r, x);
		sum[idx] = sum[idx * 2] + sum[idx * 2 + 1];
	}
	Tbag query(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return sum[idx];
	   	int m = l + r >> 1; Tbag ret;
		if (ll <= m) ret = query(idx * 2, l, m, ll, rr);
		if (rr > m) ret = ret + query(idx * 2 + 1, m + 1, r, ll, rr);
		return ret;
	}
} sgt;
vector<int> V[MAXN];
void dfs(int x)
{
	L[x] = ++now; who[now] = x;
	for (int i = 0; i < V[x].size(); i++) dfs(V[x][i]);
	R[x] = now;
}
int f[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d%d", &n, &m, &SeedA, &SeedB, &SeedQ);
	for (int i = 1; i <= n; i++) A[i].isroot = true;
	for (int i = 2; i <= n; i++) { scanf("%d", &A[i].f); f[i] = A[i].f; }
	for (int i = 1; i <= n; i++) { A[i].val.init(); A[i].update(); }
	int Q; scanf("%d", &Q);	
	for (int i = 2; i <= n; i++) V[f[i]].push_back(i);
	dfs(1);
	sgt.build(1, 1, n);
	for (int i = 1; i <= Q; i++){
		int op, x, y;
		scanf("%d", &op);
		switch(op){
			case 0 : scanf("%d", &x); lct.read(x); sgt.change(1, 1, n, L[x]); break;
			case 1 : scanf("%d%d", &x, &y);
					 Tbag ret1; if (x != y) ret1 = lct.query(f[x], y);
					 Tbag ret2 = sgt.query(1, 1, n, L[x], R[x]);
					 printf("%d\n", (ret1 + ret2)[m]);
		}
	}
}
Problem2165

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
int n; ll m;
struct Tmatrix{
	ll d[101][101];
	ll * operator [] (int k) { return d[k]; }
	const ll * operator [] (int k) const { return d[k]; }
	void operator *= (const Tmatrix & A)
	{
		Tmatrix temp;
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) temp[i][j] = d[i][j];
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) for (int k = 1; k <= n; k++)
			if (d[i][k] > 0 && A[k][j] > 0) temp[i][j] = min(m, max(temp[i][j], d[i][k] + A[k][j]));
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) d[i][j] = temp[i][j];
	}
} g[101];
ll now[101], temp[101];
bool can(int b)
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (now[i] != -1 && g[b][i][j] != 0 && now[i] + g[b][i][j] >= m) return false;
	return true;
}
void add(int b)
{
	for (int i = 1; i <= n; i++) temp[i] = now[i]; 
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (now[i] != -1 && g[b][i][j] != 0 && now[i] + g[b][i][j] >= temp[j])
				temp[j] = min(m, now[i] + g[b][i][j]);
	for (int i = 1; i <= n; i++) now[i] = temp[i];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int TEST; cin >> TEST;
while(TEST--){
		cin >> n >> m;
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> g[0][i][j];
	memset(now, 0xff, sizeof(now)); now[1] = 0;
	for (int i = 1; i <= 63; i++){
		g[i] = g[i - 1]; g[i] *= g[i - 1];
	}
	ll ans = 0;
	for (int i = 63; i >= 0; i--) if (can(i)){
		add(i); ans += 1ll << i; 
	}
	cout << ans + 1 << endl;
}
}
Problem2169

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define LL long long
const int MO = 10007;
using namespace std;
int n, m, k, f[2001][2001], d[2001];
int ni[MO];
int dp(int a, int b)
{
	if (a == 499 && b == 0){
		int t;
		++t;
	}
	if (a == 0) return b == 0;
	if (b > n || b < 0) return 0;
	int & now = f[a][b]; if (now != 0xe0e0e0e0) return now; now = 0;
	now = (now + ((dp(a - 1, b) * b % MO * (n - b)) % MO)) % MO;
	now = (now + ((dp(a - 1, b - 2) * ((b * (b - 1) / 2) % MO)) % MO)) % MO;
	now = (now + (((LL)dp(a - 1, b + 2) * (((n - b) * (n - b - 1) / 2) % MO)) % MO)) % MO;
	if (a >= 2) now = (now - ((LL)dp(a - 2, b) * (((LL) n * (n - 1) / 2 - a + 2) % MO) * (a - 1) % MO)) % MO;
	now %= MO; now = (now + MO) % MO;
	return (now + MO) % MO; 
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	while(m--) { int a, b; scanf("%d%d", &a, &b); d[a] ^= 1; d[b] ^= 1; }
	int t = 0; for (int i = 1; i <= n; i++) t += d[i];
	memset(f, 0xe0, sizeof(f));
	int ans = dp(k, t);
	ni[1] = 1;
	for (int i = 2; i <= k; i++){
		ni[i] = (LL)(MO - MO / i) * ni[MO % i] % MO;
		ans = (LL)ans * ni[i] % MO;
	}
	cout << ans << endl;
}
Problem2169

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define LL long long
const int MO = 10007;
using namespace std;
int n, m, k, f[2001][2001], d[2001];
int ni[MO];
int dp(int a, int b)
{
	if (a == 0) return b == 0;
	if (b > n || b < 0) return 0;
	int & now = f[a][b]; if (now != 0xe0e0e0e0) return now; now = 0;
	now = (now + ((dp(a - 1, b) * b % MO * (n - b)) % MO)) % MO;
	now = (now + ((dp(a - 1, b - 2) * ((b * (b - 1) / 2) % MO)) % MO)) % MO;
	now = (now + (((LL)dp(a - 1, b + 2) * (((n - b) * (n - b - 1) / 2) % MO)) % MO)) % MO;
	if (a >= 2) now = (now - ((LL)dp(a - 2, b) * (((LL) n * (n - 1) / 2 - a + 2) % MO) * (a - 1) % MO)) % MO;
	now %= MO; now = (now + MO) % MO;
	return (now + MO) % MO; 
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	while(m--) { int a, b; scanf("%d%d", &a, &b); d[a] ^= 1; d[b] ^= 1; }
	int t = 0; for (int i = 1; i <= n; i++) t += d[i];
	memset(f, 0xe0, sizeof(f));
	int ans = dp(k, t);
	ni[1] = 1;
	for (int i = 2; i <= k; i++){
		ni[i] = (LL)(MO - MO / i) * ni[MO % i] % MO;
		ans = (LL)ans * ni[i] % MO;
	}
	cout << ans << endl;
}
Problem2170

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define FORHASH for (int hi = 1; hi <= H[now].tot; hi++)
#define GET(a, b) (((a) >> (b)) & 3) //the b bit of a
#define LAST(a, b) ((a) & ((1 << (b + 1)) - 1)) //;the last b bit of a
#define ADD(a, b) H[!now].insert(h ^ ((a ^ b) << j), num)
using namespace std;
const int MO = 123456791, HM = 1007, MAXNODE = 1200001;
struct Thash{
	int tot, e[HM + 20], next[MAXNODE], h[MAXNODE], num[MAXNODE];
	void clr() { tot = 0; memset(e, 0, sizeof(e)); }
	void insert(int _h, int _num)
	{
		for (int i = e[_h % HM]; i; i = next[i]) if (h[i] == _h) { num[i] = (num[i] + _num) % MO; return; }
		++tot; next[tot] = e[_h % HM]; e[_h % HM] = tot; h[tot] = _h; num[tot] = _num;
	}
} H[2];
int n, m; char map[101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++){
		scanf(" ");
		scanf("%s", map[i]);
	}
	int now = 1; H[!now].insert(0, 1);
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++){
			now ^= 1; H[!now].clr();
			if (map[i][j] == '*')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				if (GET(h, j) > 0) continue;
				if (!(__builtin_popcount(LAST(h, j)) & 1)) continue;
				H[!now].insert(h, num);
			}
			if (map[i][j] == '#')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				if (GET(h, j) > 0) continue;
				if (__builtin_popcount(LAST(h, j)) & 1) continue;
				H[!now].insert(h, num);
			}
			if (map[i][j] == '.')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				switch(GET(h, j)){
					case 0 : ADD(0, 3); break;
					case 1 : ADD(1, 1); ADD(1, 2); break;
					case 2 : ADD(2, 1); ADD(2, 2); break;
					case 3 : ADD(3, 0); break;
				}
			}
		}
		now ^= 1; H[!now].clr();
		FORHASH{
			int h = H[now].h[hi], num = H[now].num[hi];
			if (h >> m) continue;
			H[!now].insert(h << 1, num);
		}
	}
	FORHASH
		if (H[now].h[hi] == 0){
			printf("%d\n", H[now].num[hi]); return 0;
		}
	puts("0");

}
Problem2170

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define FORHASH for (int hi = 1; hi <= H[now].tot; hi++)
#define GET(a, b) (((a) >> (b)) & 3) //the b bit of a
#define LAST(a, b) ((a) & ((1 << (b + 1)) - 1)) //;the last b bit of a
#define ADD(a, b) H[!now].insert(h ^ ((a ^ b) << j), num)
using namespace std;
const int MO = 123456791, HM = 107, MAXNODE = 1200001;
struct Thash{
	int tot, e[HM + 20], next[MAXNODE], h[MAXNODE], num[MAXNODE];
	void clr() { tot = 0; memset(e, 0, sizeof(e)); }
	void insert(int _h, int _num)
	{
		for (int i = e[_h % HM]; i; i = next[i]) if (h[i] == _h) { num[i] = (num[i] + _num) % MO; return; }
		++tot; next[tot] = e[_h % HM]; e[_h % HM] = tot; h[tot] = _h; num[tot] = _num;
	}
} H[2];
int n, m; char map[101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++){
		scanf(" ");
		scanf("%s", map[i]);
	}
	int now = 1; H[!now].insert(0, 1);
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++){
			now ^= 1; H[!now].clr();
			if (map[i][j] == '*')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				if (GET(h, j) > 0) continue;
				if (!(__builtin_popcount(LAST(h, j)) & 1)) continue;
				H[!now].insert(h, num);
			}
			if (map[i][j] == '#')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				if (GET(h, j) > 0) continue;
				if (__builtin_popcount(LAST(h, j)) & 1) continue;
				H[!now].insert(h, num);
			}
			if (map[i][j] == '.')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				switch(GET(h, j)){
					case 0 : ADD(0, 3); break;
					case 1 : ADD(1, 1); ADD(1, 2); break;
					case 2 : ADD(2, 1); ADD(2, 2); break;
					case 3 : ADD(3, 0); break;
				}
			}
		}
		now ^= 1; H[!now].clr();
		FORHASH{
			int h = H[now].h[hi], num = H[now].num[hi];
			if (h >> m) continue;
			H[!now].insert(h << 1, num);
		}
	}
	FORHASH
		if (H[now].h[hi] == 0){
			printf("%d\n", H[now].num[hi]); return 0;
		}
	puts("0");

}
Problem2170

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define FORHASH for (int hi = 1; hi <= H[now].tot; hi++)
#define GET(a, b) (((a) >> (b)) & 3) //the b bit of a
#define LAST(a, b) ((a) & ((1 << (b + 1)) - 1)) //;the last b bit of a
#define ADD(a, b) H[!now].insert(h ^ ((a ^ b) << j), num)
using namespace std;
const int MO = 123456791, HM = 407, MAXNODE = 1200001;
struct Thash{
	int tot, e[HM + 20], next[MAXNODE], h[MAXNODE], num[MAXNODE];
	void clr() { tot = 0; memset(e, 0, sizeof(e)); }
	void insert(int _h, int _num)
	{
		for (int i = e[_h % HM]; i; i = next[i]) if (h[i] == _h) { num[i] = (num[i] + _num) % MO; return; }
		++tot; next[tot] = e[_h % HM]; e[_h % HM] = tot; h[tot] = _h; num[tot] = _num;
	}
} H[2];
int n, m; char map[101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++){
		scanf(" ");
		scanf("%s", map[i]);
	}
	int now = 1; H[!now].insert(0, 1);
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++){
			now ^= 1; H[!now].clr();
			if (map[i][j] == '*')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				if (GET(h, j) > 0) continue;
				if (!(__builtin_popcount(LAST(h, j)) & 1)) continue;
				H[!now].insert(h, num);
			}
			if (map[i][j] == '#')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				if (GET(h, j) > 0) continue;
				if (__builtin_popcount(LAST(h, j)) & 1) continue;
				H[!now].insert(h, num);
			}
			if (map[i][j] == '.')
			FORHASH{
				int h = H[now].h[hi], num = H[now].num[hi];
				switch(GET(h, j)){
					case 0 : ADD(0, 3); break;
					case 1 : ADD(1, 1); ADD(1, 2); break;
					case 2 : ADD(2, 1); ADD(2, 2); break;
					case 3 : ADD(3, 0); break;
				}
			}
		}
		now ^= 1; H[!now].clr();
		FORHASH{
			int h = H[now].h[hi], num = H[now].num[hi];
			if (h >> m) continue;
			H[!now].insert(h << 1, num);
		}
	}
	FORHASH
		if (H[now].h[hi] == 0){
			printf("%d\n", H[now].num[hi]); return 0;
		}
	puts("0");

}
Problem2172

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
#include <iostream>
#define LL long long
#define LD long double
using namespace std;
map<LL, int> M;
LL mul_mod(LL a,LL b,LL N){
	LL t=(LL)(a/(LD)N*b+1e-3);
	LL ret=a*b-t*N;
	if(ret<0)	ret+=N;
	return ret;
}

LL pow_mod(LL a,LL n,LL MOD){
	LL ret=1LL;
	while(n){
		if(n&1)
			ret=mul_mod(ret,a,MOD);
		a=mul_mod(a,a,MOD);
		n>>=1;
	}
	return ret;
}

int MillerRabin(LL N,LL t){
	LL S=N-1,R=0;
	while(!(S&1)){
		S>>=1;
		R++;
	}
	LL x=pow_mod(t,S,N),y=0;
	for(int i=0;i<=R;i++){
		y=mul_mod(x,x,N);
		if(y==1&&x!=N-1&&x!=1)
			return 0;
		x=y;
	}
	return x==1;
}

int isPrime(LL N){
	for(int i=2;i*i<=N&&i<=1000;i++)
		if(N%i==0)	return 0;
	if(N<=1000000)	return 1;
	if(!MillerRabin(N,3))	return 0;
	if(!MillerRabin(N,5))	return 0;
	if(!MillerRabin(N,7))	return 0;
	if(!MillerRabin(N,11))	return 0;
	if(!MillerRabin(N,13))	return 0;
	if(!MillerRabin(N,17))	return 0;
	return 1;
}

LL PolarRho(LL N,LL c){
	for(int i=2;i<=20;i++)
		if(N%i==0)	return i;
	LL x=2, y=2, d=1;
	while(d==1){
		x=(mul_mod(x,x,N)+c)%N;
		y=(mul_mod(y,y,N)+c)%N;
		y=(mul_mod(y,y,N)+c)%N;
		d=__gcd(abs(x-y),N);
	}
	return d;
}

int Factorize(LL N,LL c){
	if(N<=1)
		return 0;
	if(isPrime(N)){
		M[N]++;
		return 0;
	}
	LL x=N;
	while(x==N)
		x=PolarRho(N,c--);
	Factorize(x,c);
	Factorize(N/x,c);
}
#define BAD { puts("Wario_wins!"); puts(""); goto next; }
#define GOOD { puts("Mario_wins!"); puts(""); goto next; }
long long n, m;
vector<int> v;

int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	while(cin >> m >> n){
		M.clear(); v.clear();
		n /= m; if (n == 1) BAD
		Factorize(n, 73);
		for(map<LL,int>::iterator it = M.begin();it != M.end();it++)
			v.push_back(it->second);		
		if (v.size() >= 4) GOOD
		if (v.size() == 3){
			if (v[0] > 1 || v[1] > 1 || v[2] >> 1) GOOD;
			BAD;
		}
		if (v.size() == 2){
			if (v[0] > 1 && v[1] > 1) GOOD;
			if (v[0] >= 5 || v[1] > 5) GOOD;
			BAD;
		}
		if (v.size() == 1){
			if (v[0] > 7) GOOD;
			BAD;
		}
		BAD;
		next:;
	}
}
Problem2173

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 1000000007;
int n, f[2000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	f[1] = 1; f[2] = 2;
	scanf("%d", &n);
	for (int i = 3; i <= n; i++) f[i] = (2 * f[i - 1] % MO + f[i - 2]) % MO;
	printf("%d\n", f[n]);
}
Problem2173

#include <cstdio>
const int MO = 1000000007;
int n, f[2000001];
int main()
{
	f[1] = 1; f[2] = 2;
	scanf("%d", &n);
	for (int i = 3; i <= n; i++) f[i] = (2 * f[i - 1] % MO + f[i - 2]) % MO;
	printf("%d\n", f[n]);
}
Problem2177

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#define uint unsigned int
using namespace std;
const int MAXN = 500001;
struct Tpoint{
    int x, y, who;
    Tpoint() { }
    Tpoint (int x, int y, int who) : x(x), y(y), who(who) { }
    bool operator < (const Tpoint & A) const { return x == A.x ? y < A.y : x > A.x; }
} p[MAXN];
int a[MAXN], l[MAXN], r[MAXN], n;
int dis(int A, const int B)
{
    return abs(l[A] - l[B]) + abs(r[A] - r[B]);
}
struct Tedge{
    int st, ed, len;
    Tedge() { }
    Tedge (int st, int ed) : st(p[st].who), ed(p[ed].who) { len = dis(p[st].who, p[ed].who); }
    bool operator < (const Tedge & A) const { return len < A.len; }
} edge[MAXN * 8]; int edgenum;
int bit[MAXN * 2], val[MAXN];
int getmin(int a, int b) { if (a == 0 || b == 0) return a + b; else return val[a] < val[b] ? a : b; }
int hash[MAXN];
void addedge() //Solve R4
{
    memset(bit, 0, sizeof(bit));
    sort(p + 1, p + n + 1);
    for (int i = 1; i <= n; i++) hash[i] = p[i].x + p[i].y;
    int tot = 0;
    sort(hash + 1, hash + n + 1);
    tot = unique(hash + 1, hash + n + 1) - hash - 1;
    for (int i = 1; i <= n; i++) val[i] = p[i].x - p[i].y;
    for (int i = 1; i <= n; i++){
        int temp = 0, now = lower_bound(hash + 1, hash + tot + 1, p[i].x + p[i].y) - hash;
        for (int j = now; j; j -= (j & (-j))) temp = getmin(temp, bit[j]);
        if (temp != 0) edge[++edgenum] = Tedge(i, temp);
        for (int j = now; j <= n; j += (j & (-j))) bit[j] = getmin(bit[j], i);
    }
}
int fa[MAXN];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);
    for (int i = 1; i <= n; i++) p[i] = Tpoint(l[i], r[i], i); addedge();
    for (int i = 1; i <= n; i++) p[i] = Tpoint(l[i], -r[i], i); addedge();
    for (int i = 1; i <= n; i++) p[i] = Tpoint(r[i], l[i], i); addedge();
    for (int i = 1; i <= n; i++) p[i] = Tpoint(r[i], -l[i], i); addedge();
    sort(edge + 1, edge + edgenum + 1);
    long long ans = 0;
    for (int i = 1; i <= n; i++) fa[i] = i;
    for (int i = 1, now = 0; now < n - 1; i++){
        if (find(edge[i].st) == find(edge[i].ed)) continue;
        fa[find(edge[i].st)] = find(edge[i].ed);
        ++now; ans += edge[i].len;
    }
  	cout << ans << endl;
}
Problem2178

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const double eps = 1e-8;
const int MAXN = 10001;
bool vis[MAXN];
int dcmp(double t)
{
	if (fabs(t) < eps) return 0;
	if (t < 0) return -1;
	return 1;
}
struct Tpoint{
	double x, y;
	Tpoint operator - (Tpoint B) { Tpoint temp; temp.x = x - B.x; temp.y = y - B.y; return temp; }
	double operator * (Tpoint B) { return x * B.y - y * B.x; }
};
double dis(Tpoint A, Tpoint B) { return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); }
struct Tinterval{
	double st, ed;
};
struct Tcircle{
	Tpoint p; double r;
	void init(double _x, double _y, double _r) { p.x = _x; p.y = _y; r = _r; }
	bool operator == (Tcircle B) { return (dcmp(r - B.r) == 0 && dcmp(p.x - B.p.x) == 0 && dcmp(p.y - B.p.y) == 0); }	 
	Tinterval operator * (Tcircle B)
	{
		Tinterval temp;
		double d = dis(p, B.p);
		double j1 = atan2(B.p.y - p.y, B.p.x - p.x);
		double j2 = acos((r * r + d * d - B.r * B.r) / (2 * r * d));
		temp.st = j1 - j2; temp.ed = j1 + j2;
		return temp;
	}	
} c[MAXN];
struct Tscanpoint
{
	double x; int kind;
	void init(double _x, int _kind) { x = _x; kind = _kind; }
	bool operator < (const Tscanpoint & B) const{
		return dcmp(x - B.x) < 0;
		}
} scan[MAXN * 200];
int Scan;
int judge(Tcircle A, Tcircle B)
{
	// 0 : ÕÍ»´œ‡Õ¨ 1 : œ‡¿Î 2 : Õ‚«– 3 : œ‡Ωª 4 : A±ª∞¸∫¨ 5 : B±ª∞¸∫¨ 
	double d = dis(A.p, B.p);
	if (A == B) return 0;
	if (dcmp(d - A.r - B.r) > 0) return 1;
	if (dcmp(d - A.r - B.r) == 0) return 2;
	if ((dcmp(d - A.r - B.r) < 0) && (dcmp(d - fabs(A.r - B.r)) > 0)) return 3;
	if (A.r < B.r) return 4;
	return 5;
}
double calc(int num, double st, double ed)
{
	if (dcmp(ed - st) == 0) return 0.0;
	double delta = ed - st;
	double x0 = c[num].p.x + c[num].r * cos(st);
	double y0 = c[num].p.y + c[num].r * sin(st);
	double x1 = c[num].p.x + c[num].r * cos(ed);
	double y1 = c[num].p.y + c[num].r * sin(ed);
	return c[num].r * c[num].r * (delta - sin(delta)) + (x0 * y1 - x1 * y0);
}
int n, N;
double doit(int x)
{
	Scan = 0;
	double ret = 0;
	for (int i = 1; i <= n; i++) if (i != x && !vis[i]){
		int t = judge(c[x], c[i]);
		if (t == 0 || t == 4){
			vis[x] = true; return 0.0;
			}
		if (t == 1 || t == 2 || t == 5) continue;
		Tinterval ti = c[x] * c[i];
		if (dcmp(ti.st) < 0) ti.st += 2 * M_PI, ti.ed += 2 * M_PI;
		//printf("%.10lf%.10lf\n", ti.st, ti.ed);
		if (dcmp(ti.ed - 2 * M_PI) > 0){
			++Scan; scan[Scan].init(ti.st, 1);
			++Scan; scan[Scan].init(2 * M_PI, -1);
			++Scan; scan[Scan].init(0, 1);
			++Scan; scan[Scan].init(ti.ed - 2 * M_PI, -1);
			}
		else{
			++Scan; scan[Scan].init(ti.st, 1);
			++Scan; scan[Scan].init(ti.ed, -1);
			}
		}
	if (Scan == 0) return 2 * M_PI * c[x].r * c[x].r;
	sort(scan + 1, scan + Scan + 1);
	scan[Scan + 1].init(2 * M_PI, 0);
	ret += calc(x, 0, scan[1].x);
	int now = 0;
	for (int i = 1; i <= Scan; i++){
		now += scan[i].kind;
		if (now == 0) ret += calc(x, scan[i].x, scan[i + 1].x);
		}
	return ret;
}		
int main()
{
	scanf("%d", &N);
	for (int i = 1; i <= N; i++){
		double x, y, r; scanf("%lf%lf%lf", &x, &y, &r);
		if (dcmp(r) != 0){
			++n; c[n].init(x, y, r);
			}
		}
	double ans = 0;
	for (int i = 1; i <= n; i++){
		ans += doit(i);
		}
	printf("%.3lf\n", ans / 2);
}
Problem2178

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <complex>

//kAc
const double pi = acos(-1), eps = 1e-8;
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
#define PT complex<double>
#define CR pair<PT, double>
int sig(double t) { if (fabs(t) < eps) return 0; return t < 0 ? -1 : 1; }
bool cmp(CR A, CR B)
{
	return A.SC > B.SC;
}
int now = 0;
double ans;
CR tcir[1000001], cir[1000001];
int n, tempn, scantot;
PDI scan[1000001];
void intersect(CR A, CR B)
{
	double r1 = A.SC, r2 = B.SC, d = abs(A.FR - B.FR), alpha = acos((r1 * r1 + d * d - r2 * r2) / (r1 * d * 2));
	double l = arg((B.FR - A.FR) * exp(PT(0, -alpha))), r = arg((B.FR - A.FR) * exp(PT(0, +alpha)));
	scan[++scantot] = MP(l, -1); scan[++scantot] = MP(r, +1);
	if (l > r) --now;
}
void add(CR A, double l, double r)
{
	PT a = PT(A.SC, 0) * exp(PT(0, l)) + A.FR, b = PT(A.SC, 0) * exp(PT(0, r)) + A.FR; double alpha = r - l;
	ans += A.SC * A.SC / 2 * (alpha - sin(alpha));
	ans += imag(conj(a) * b) / 2;
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); int tempn = 0;
	for (int i = 1; i <= n; i++){
		int x, y, r; scanf("%d%d%d", &x, &y, &r); if (r == 0) continue;
		tcir[++tempn] = CR(PT(x, y), r);
	}
	n = tempn;
	sort(tcir + 1, tcir + n + 1, cmp);
	tempn = 0;
	for (int i = 1; i <= n; i++){
		for (int j = 1; j < i; j++) if (tcir[j].SC - tcir[i].SC >= abs(tcir[j].FR - tcir[i].FR)) goto fail;
		cir[++tempn] = tcir[i];
		fail:;
	}
	n = tempn;
	for (int i = 1; i <= n; i++){
		scantot = 0; now = 0;
		for (int j = 1; j <= n; j++) if (i != j && cir[i].SC + cir[j].SC > abs(cir[i].FR - cir[j].FR)) intersect(cir[i], cir[j]);
		sort(scan + 1, scan + scantot + 1);
		double where = -pi;
		for (int j = 1; j <= scantot; j++){
			if (now == 0) add(cir[i], where, scan[j].FR);
			now += scan[j].SC; where = scan[j].FR;
		}
		if (now == 0) add(cir[i], where, pi);
	}
	printf("%.3lf\n", ans);
}
Problem2179

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <complex>
#include <vector>
#define complex complex<double>
#define g getchar()
#define pb push_back
#define VD vector<complex>
#define DEBUG
const double PI = 3.14159265358979323846264338327950288;
using namespace std;
int n;
VD a, b, y, Y;
complex I;
void DFT(VD & a, bool flag = true)
{
	int n = a.size(); if (n == 1) return; VD A, B; complex wn;
	if (flag) wn = cos(2.0 * PI / double (n)) + sin(2.0 * PI / double (n)) * I;
	else wn = cos(2 * M_PI / double (n) * double(n - 1)) + sin(2 * M_PI / double (n)* double(n - 1)) * I;
	for (int i = 0; i < n / 2; i++) A.pb(a[2 * i]);
	for (int i = 0; i < n / 2; i++) B.pb(a[2 * i + 1]);
	DFT(A, flag); DFT(B, flag);
	complex w = 1;
	for (int i = 0; i < n / 2; i++){
		a[i] = A[i] + w * B[i]; a[i + n / 2] = A[i] - w * B[i]; w = w * wn;
		}
}
int ret[1000001], ans[1000001]; char in[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	I = complex(0, 1);
	scanf("%d", &n); g;
	int nn = 0;
	for (int i = 0; i < 31; i++) if (nn < n) nn = 1 << i; nn *= 2;
	scanf("%s", in); for (int i = n - 1; i >= 0; i--) a.pb(in[i] - '0');
	for (int i = 1; i <= nn - n; i++) a.pb(0);
	scanf("%s", in); for (int i = n - 1; i >= 0; i--) b.pb(in[i] - '0');
	for (int i = 1; i <= nn - n; i++) b.pb(0);
	n = nn; DFT(a); DFT(b);
	for (int i = 0; i < n; i++) a[i] *= b[i];
	DFT(a, false);
	for (int i = 1; i <= n; i++) ret[i] = int(round(a[i - 1].real() / double(n)));
	for (int i = 1; i <= n + 1; i++) ret[i + 1] += ret[i] / 10, ret[i] %= 10;
	int t = n + 1; while(ret[t] == 0 && t > 1) --t;
	for (int i = t; i >= 1; i--) printf("%d", ret[i]);
	putchar('\n');
}
Problem2179

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define lint long long
#include <vector>
#define pb push_back
#define VI vector<lint>
#define log(a) (31 - __builtin_clz(a))
#define make(a) ((((a) % P) + P) % P)
const lint P = (15 << 27) + 1, R = 137;
using namespace std;
VI a, b;
int n, nn, mi;
char in[1000001];
lint ret[1000001];
lint pow(lint a, lint b)
{
	lint ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = make(ret * now); now = make(now * now);
		}
	return ret;
}
int rev(int n)
{
	int ret = 0;
	for (int i = 0; i < mi; i++, n >>= 1)
		ret = (ret << 1) | (n & 1);
	return ret;
}
void DFT(VI & a, lint t)
{
	VI A(n);
	for (int i = 0; i < n; i++) A[rev(i)] = a[i];
	for (int m = 2; m <= n; m <<= 1){
		lint wn = pow(t, n / m);
		for (int k = 0; k < n; k += m){
			lint w = 1;
			for (int j = 0; j < m / 2; j++){
				lint u = make(w * A[k + j + m / 2]), v = A[k + j];
				A[k + j] = make(v + u); A[k + j + m / 2] = make(v - u);
				w = make(w * wn);
				}
			}
		}
	a = A;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < 31; i++) if (nn < n) nn = 1 << i; nn *= 2;
	mi = log(nn);
	scanf("%s", in); for (int i = n - 1; i >= 0; i--) a.pb(in[i] - '0');
	for (int i = 1; i <= nn - n; i++) a.pb(0);
	scanf("%s", in); for (int i = n - 1; i >= 0; i--) b.pb(in[i] - '0');
	for (int i = 1; i <= nn - n; i++) b.pb(0);
	n = nn; lint K = (P - 1) / n;
	DFT(a, pow(R, K)); DFT(b, pow(R, K));
	for (int i = 0; i < n; i++) a[i] = make(a[i] * b[i]);
	DFT(a, pow(R, P - K - 1));
	lint NI = pow(n, P - 2);
	for (int i = 1; i <= n; i++) ret[i] = make(a[i - 1] * NI);
	for (int i = 1; i <= n + 1; i++) ret[i + 1] += ret[i] / 10, ret[i] %= 10;
	int t = n + 1; while(ret[t] == 0 && t > 1) --t;
	for (int i = t; i >= 1; i--) printf("%d", ret[i]);
	putchar('\n');
}
Problem2179

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define lint long long
#include <vector>
#define pb push_back
#define VI vector<lint>
#define log(a) (31 - __builtin_clz(a))
#define make(a) ((((a) % P) + P) % P)
const lint P = (15 << 27) + 1, R = 137;
using namespace std;
VI a, b, A; int n, nn, mi;
char in[1000001];
lint ret[1000001];
lint pow(lint a, lint b)
{
	lint ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = make(ret * now); now = make(now * now);
		}
	return ret;
}
int rev(int n)
{
	int ret = 0;
	for (int i = 0; i < mi; i++, n >>= 1) ret = (ret << 1) | (n & 1);
	return ret;
}
void DFT(VI & a, lint t)
{
	A.resize(n);
	for (int i = 0; i < n; i++) A[rev(i)] = a[i];
	for (int m = 2; m <= n; m <<= 1){
		lint wn = pow(t, n / m);
		for (int k = 0; k < n; k += m){
			lint w = 1;
			for (int j = 0; j < m / 2; j++){
				lint u = A[j + k], v = make(A[j + k + m / 2] * w);
				A[j + k] = make(u + v); A[j + k + m / 2] = make(u - v);
				w = make(w * wn);
				}
			}
		}
	a = A;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < 31; i++) if (nn < n) nn = 1 << i; nn *= 2;
	mi = log(nn);
	scanf("%s", in); for (int i = n - 1; i >= 0; i--) a.pb(in[i] - '0');
	for (int i = 1; i <= nn - n; i++) a.pb(0);
	scanf("%s", in); for (int i = n - 1; i >= 0; i--) b.pb(in[i] - '0');
	for (int i = 1; i <= nn - n; i++) b.pb(0);
	n = nn;
	int k = (P - 1) / n;
	DFT(a, pow(R, k)); DFT(b, pow(R, k));
	for (int i = 0; i < n; i++) a[i] = make(a[i] * b[i]);
	DFT(a, pow(R, P - k - 1));
	lint NI = pow(n, P - 2);
	for (int i = 1; i <= n; i++) ret[i] = make(a[i - 1] * NI);
	for (int i = 1; i <= n + 1; i++) ret[i + 1] += ret[i] / 10, ret[i] %= 10;
	int t = n + 1; while(ret[t] == 0 && t > 1) --t;
	for (int i = t; i >= 1; i--) printf("%d", ret[i]);
	putchar('\n');
}
Problem2185

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#define sqr(a) ((a) * (a))
using namespace std;
struct Tladar{
    double x, y, r;
} L[10001];
int n, l, w;
double now;
bool ckin(int t, double x, double y)
{
    double dis = sqr(L[t].x - x) + sqr(L[t].y - y);
    return now * now * L[t].r * L[t].r - dis > 1e-6;
}
bool check(double x1, double y1, double x2, double y2)
{
    if (x2 - x1 < 1e-9 || y2 - y1 < 1e-6) return true;
    bool bad = true;
    for (int i = 1; i <= n; i++){
        bool c1 = ckin(i, x1, y1), c2 = ckin(i, x2, y1), c3 = ckin(i, x1, y2), c4 = ckin(i, x2, y2);
        if (c1 && c2 && c3 && c4) return true;
        if (c1 || c2 || c3 || c4) bad = false;
    }
    if (bad) return false;
    double mx = (x1 + x2) / 2.0, my = (y1 + y2) / 2.0;
    return check(x1, y1, mx, my) && check(x1, my, mx, y2) && check(mx, y1, x2, my) && check(mx, my, x2, y2);
}
int LL, WW;
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
    scanf("%d%d%d", &n, &LL, &WW);
    for (int i = 1; i <= n; i++) scanf("%lf%lf%lf", &L[i].x, &L[i].y, &L[i].r);
    double l = 0.0, r = 10000.0;
    while(r - l > 1e-6){
        now = (l + r) / 2.0;
        if (check(0.0, 0.0, LL, WW)) r = now; else l = now;
    }
    printf("%.3lf\n", l);
}
}
Problem2186

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cassert>
using namespace std;
int num, p[1000001], euler[10000001], fac[10000001];
bool notp[10000001];
int P;
void exgcd(int a, int b, long long &x, long long &y)
{
	if (b == 0) { x = 1; y = 0; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
int ni(int a)
{
	long long x, y;
	exgcd(a, P, x, y);
	return (x % P + P) % P;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("cash.in", "r", stdin); freopen("cash.out", "w", stdout);
#endif
	int Q; scanf("%d%d", &Q, &P);
	for (int i = 2; i <= 10000000; i++){
		if (!notp[i]) p[++num] = i;
		for (int j = 1; j <= num && (((long long)i * p[j]) <= 10000000ll); j++){
			notp[i * p[j]] = true;
			if (i % p[j] == 0) break;
			}
		}
	fac[1] = 1;  euler[1] = 1;
	for (int i = 2; i <= 10000000; i++){
		fac[i] = (long long)fac[i - 1] * i % P;
		euler[i] = (long long) euler[i - 1] * (i - !notp[i]) % P;
		}
	while(Q--){
		int n, m;
		scanf("%d%d", &n, &m);
		int ret = (long long)euler[m] * fac[n] % P;
		ret = (long long)ret * ni(fac[m]) % P;
		printf("%d\n", ret);
		}
}
Problem2190

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, euler[1000001], pnum, p[1000001];
bool notp[1000001];
void GETP()
{
	euler[1] = 1;
	for (int i = 2; i <= n; i++){
		if (!notp[i]) { p[++pnum] = i; euler[i] = i - 1; }
		for (int j = 1; j <= pnum && i * p[j] <= n; j++){
			notp[i * p[j]] = true;
			if (i % p[j] == 0){
				euler[i * p[j]] = euler[i] * p[j];
				break;
				}
			else euler[i * p[j]] = euler[i] * (p[j] - 1);
			}
		}
}
int main()
{
	scanf("%d", &n);
	GETP();
	int ans = 0;
	for (int i = 2; i < n; i++) ans += euler[i];
	printf("%d\n", ans * 2 + 3);
}
Problem2194

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#define lint long long
#define VI vector<lint>
#define make(a) ((((a) % P) + P) % P)
using namespace std;
const int P = (15 << 27) + 1, R = 137;
VI A, B;
int n, mi;
int rev(int n)
{
	int ret = 0;
	for (int i = 0; i < mi; i++, n >>= 1)
		ret = (ret << 1) | (n & 1);
	return ret;
}
lint pow(lint a, lint b)
{
	lint ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = make(ret * now);
		now = make(now * now);
		}
	return ret;
}
void FNT(VI & a, lint t)
{
	VI A; A.resize(n);
	for (int i = 0; i < n; i++) A[rev(i)] = a[i];
	for (int m = 2; m <= n; m <<= 1){
		lint wn = pow(t, n / m);
		for (int k = 0; k < n; k += m){
			lint w = 1;
			for (int j = 0; j < m / 2; j++){
				lint u = A[j + k], v = make(A[j + k + m / 2] * w);
				A[j + k] = make(u + v); A[j + k + m / 2] = make(u - v);
				w = make(w * wn);
				}
			}
		}
	a = A;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); int tempn = n;
	int nn = n * 2; while(nn & (nn - 1)) ++nn;
	A.resize(nn); B.resize(nn); mi = 31 - __builtin_clz(nn);
	for (int i = 0; i < n; i++){ 
		int t; scanf("%d", &t); A[i] = t; 
		scanf("%d", &t); B[n - i - 1] = t; 
		}
	n = nn;  int k = (P - 1) / n;
	FNT(A, pow(R, k)); FNT(B, pow(R, k)); for (int i = 0; i < n; i++) A[i] = make(A[i] * B[i]);
	FNT(A, pow(R, P - k - 1)); lint NI = pow(n, P - 2);
	for (int i = tempn - 1; i < tempn * 2 - 1; i++) printf("%d\n", make(A[i] * NI));
}
Problem2208

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, p, nowc, col[3001], a[3002], num[3001];
char map[3001][3001], Tmap[3001][3001];
bool t[3001][3001];
bool vis[3001];
struct Tset{
	int data[71];
	bool bitset(int k, bool b)
	{
		--k;
		int r = k / 30, c = k % 30;
		data[r] = (data[r] & (~(1 << c))) | (b << c);
	}
	Tset & operator += (const Tset & A)
	{
		for (int i = 0; i < n / 30 + 1; i++) data[i] |= A.data[i];
	}
	int count()
	{
		int ret = 0;
		for (int i = 0; i < n / 30 + 1; i++) for (int j = 0; j < 30; j++) if ((data[i] >> j) & 1) ret += num[i * 30 + j + 1];
		return ret;
	}
} set[3001];
void dfs(int x)
{
	vis[x] = true;
	for (int i = 1; i <= n; i++) if (!vis[i] && map[x][i] == '1') dfs(i);
	a[++p] = x;
}
void DFS(int x)
{
	col[x] = nowc; ++num[nowc];
	for (int i = 1; i <= n; i++) if (col[i] == 0 && Tmap[x][i] == '1') DFS(i);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf(" "); scanf("%s", map[i] + 1);
		}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) Tmap[i][j] = map[j][i];
	for (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);
	for (int i = n; i >= 1; i--) if (col[a[i]] == 0){
		nowc = a[i]; DFS(a[i]);
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (map[i][j] == '1')
				t[col[i]][col[j]] = 1;
	for (int i = 1; i <= n; i++) if (col[a[i]] == a[i]){
		set[a[i]].bitset(a[i], 1);
		for (int j = 1; j <= n; j++) if (col[j] == j && t[a[i]][j]) set[a[i]] += set[j];
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) ans += set[col[i]].count();
   	printf("%d\n" ,ans);	

}
Problem2209

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 600001;
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, size, val;
	int sum, lmax, lmin, rmax, rmin;
	bool _rev, _flip;
	void rev()
	{
		if (this != a){
			swap(c[0], c[1]); swap(lmax, rmax); swap(lmin, rmin);
			_rev ^= 1;
			}
	}
	void flip()
	{
		if (this != a){
			swap(lmax, lmin); swap(rmax, rmin); sum *= -1; val *= -1;
			_flip ^= 1;
			}
	}
	void push()
	{
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev =false;
			}
		if (_flip){
			a[c[0]].flip(); a[c[1]].flip(); _flip = false;
			}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		sum = a[c[0]].sum + a[c[1]].sum + val;
		lmax = max(a[c[0]].lmax, a[c[0]].sum + val + a[c[1]].lmax);
		rmax = max(a[c[1]].rmax, a[c[1]].sum + val + a[c[0]].rmax);
		lmin = max(a[c[0]].lmin, a[c[1]].lmin - val - a[c[0]].sum);
		rmin = max(a[c[1]].rmin, a[c[0]].rmin - val - a[c[1]].sum);
	}
	void rot(bool b)
	{
		a[f].push(); push();
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
char kh[MAXN];
int n, m, tot, root;
void splay(int x, int p)
{
	int y, z; bool b, c; A[x].push();
	while((y = A[x].f) != p){
		b = x == A[y].c[1];
		if ((z = A[y].f) != p){
			c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
	int t = root, tt;
	while((tt = A[A[t].c[0]].size + 1) != k){
		A[t].push();
		if (k < tt) t = A[t].c[0];
		else k -= tt, t = A[t].c[1];
		}
	return t;
}
int build(int l, int r)
{
	if (l > r) return 0;
	int m = (l + r) >> 1, now = ++tot;
	if (kh[m] == '(') A[now].val = 1;
	if (kh[m] == ')') A[now].val = -1;
	A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
	A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
	A[now].update(); return now;
}
void QUERY(int l, int r)
{
	splay(select(l), 0); splay(select(r + 2), root);
	int now = A[A[root].c[1]].c[0];
	printf("%d\n", ((A[now].lmin + 1) >> 1) + ((A[now].rmax + 1) >> 1));
}
void FLIP(int l, int r)
{
	splay(select(l), 0); splay(select(r + 2), root);
	int now = A[A[root].c[1]].c[0];	
	A[now].flip();
}
void REVERSE(int l, int r)
{
	splay(select(l), 0); splay(select(r + 2), root);
	int now = A[A[root].c[1]].c[0];	
	A[now].rev();
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin);
	freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); scanf("%s", kh + 1);
	root = build(0, n + 1);
	while(m--){
		int op, l, r; scanf("%d%d%d", &op, &l, &r);
		switch(op){
			case 0: QUERY(l, r); break;
			case 1: FLIP(l, r); break;
			case 2: REVERSE(l, r); break;
			}
		}
				
}
Problem2210

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int L = 30, P = 10;
int n, X, Y;
struct Tpoint{
	double x, y;
	Tpoint() { }
	Tpoint(double _x, double _y) { x = _x; y = _y; } 
	void init() { scanf("%lf%lf", &x, &y); }
	bool out() { return x > X || y > Y || x < 0 || y < 0; }
	void randp() { x = (double)(rand() % 1000) / 1000.0 * double(X); y = (double)(rand() % 1000) / 1000.0 * double(Y); }
} p[10001], nowp[10001];
double dis(Tpoint A, Tpoint B) { return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); }
double getans(Tpoint A)
{
	double d = 1e99;
	for (int i = 1; i <= n; i++) d = min(d, dis(A, p[i]));
	return d;
}
double randj() { return 3.14159 * 2.0f * double(rand() % 1000) / 1000.0; }
int main()
{
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d", &X, &Y); scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	for (int i = 1; i <= P; i++) nowp[i].randp();
	double delta = 2000;
	while(delta > 1e-2){
		for (int i = 1; i <= P; i++){
			double j = randj();
			for (int i = 1; i <= L; i++){
				Tpoint temp(nowp[i].x + delta * cos(j), nowp[i].y + delta * sin(j));
				if (temp.out()) continue;
				if (getans(nowp[i]) < getans(temp)) nowp[i] = temp;
			}
		}
		delta *= 0.9;
	}
	int who = 1; 
	for (int i = 2; i <= P; i++) if (getans(nowp[who]) < getans(nowp[i])) who = i;
	printf("The safest point is (%.1lf, %.1lf).\n", nowp[who].x, nowp[who].y);
}
}
Problem2212

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 500001;
int tot, l[MAXN], r[MAXN], size[MAXN], val[MAXN], h[MAXN], root[MAXN];
void lrot(int & t)
{
	int x = r[t]; r[t] = l[x]; l[x] = t;
	size[x] = size[t]; size[t] = size[l[t]] + size[r[t]] + 1;
	t = x;
}
void rrot(int & t)
{
	int x = l[t]; l[t] = r[x]; r[x] = t;
	size[x] = size[t]; size[t] = size[l[t]] + size[r[t]] + 1;
	t = x;
}
void insert(int & t, int T)
{
	if (t == 0) { t = T; l[t] = r[t] = 0; size[t] = 1; return; }
	++size[t];
	if (val[T] < val[t]) { insert(l[t], T); if (h[l[t]] > h[t]) rrot(t); }
	else { insert(r[t], T); if (h[r[t]] > h[t]) lrot(t); }
}
int rank(int t, int key)
{
	if (t == 0) return 0;
	if (val[t] < key) return rank(r[t], key) + 1 + size[l[t]];
	else return rank(l[t], key);
}
int x, L[MAXN], R[MAXN];
int stack[MAXN], top = 0;
int s1, s2;
long long temp, ans;
int TOT;
int merge(int a, int b)
{
	stack[top = 1] = b; s1 = size[a]; s2 = size[b];
	for (int i = 1; i <= s2; i++) { x = stack[i]; if (l[x]) stack[++top] = l[x]; if (r[x]) stack[++top] = r[x]; }
	temp = 0;
	for (int i = 1; i <= s2; i++) temp += rank(a, val[stack[i]]);
	ans += min((long long)(s1) * s2 - temp, temp);
	for (int i = 1; i <= s2; i++) insert(a, stack[i]);
	return a;
}
void init()
{
	int now = ++TOT;
	scanf("%d", &x);
	if (x) { root[TOT] = ++tot; val[tot] = x; size[tot] = 1; h[tot] = rand(); }
	else{
		L[now] = TOT + 1; init();
		R[now] = TOT + 1; init();
		if (size[root[L[now]]] < size[root[R[now]]]) swap(L[now], R[now]);
		root[now] = merge(root[L[now]], root[R[now]]);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%*d");
	init();
	cout << ans << endl;
}
Problem2217

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
pair<int, int> ans[4000001]; int n, sum[2000001];
void doit(int l, int r)
{
	if (l > r) return;
	ans[sum[r] - sum[l - 1]] = make_pair(l, r);
	if (sum[l] - sum[l - 1] == 2) doit(l + 1, r);
	else if (sum[r] - sum[r - 1] == 2) doit(l, r - 1);
	else doit(l + 1, r - 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q; scanf("%d%d", &n, &Q); scanf(" ");
	for (int i = 1; i <= n; i++){
		char c; scanf("%c", &c);
		sum[i] = sum[i - 1] + 1 + (c == 'T');
	}
	int l = -1, r = -1;
	for (int i = 1; i <= n; i++) if (sum[i] - sum[i - 1] == 1){
		if (l == -1) l = i; r = i;
	}
	doit(1, n);
	if (l != -1) doit(l + 1, n);
	if (r != -1) doit(1, r - 1);
	while(Q--){
		int x; scanf("%d", &x);
		if (ans[x].first == 0) puts("NIE");
		else printf("%d %d\n", ans[x].first, ans[x].second);
	}
}
Problem2217

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cctype>
using namespace std;
pair<int, int> ans[4000001]; int n, sum[2000001];
void read(int & x)
{
	char c;
	while(!isdigit((c = getchar())));
	x = 0;
	do x = x * 10 + c - '0'; while(isdigit(c = getchar()));
}
void doit(int l, int r)
{
	if (l > r) return;
	ans[sum[r] - sum[l - 1]] = make_pair(l, r);
	if (sum[l] - sum[l - 1] == 2) doit(l + 1, r);
	else if (sum[r] - sum[r - 1] == 2) doit(l, r - 1);
	else doit(l + 1, r - 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q; scanf("%d%d", &n, &Q); scanf(" ");
	for (int i = 1; i <= n; i++){
		char c = getchar();
		sum[i] = sum[i - 1] + 1 + (c == 'T');
	}
	int l = -1, r = -1;
	for (int i = 1; i <= n; i++) if (sum[i] - sum[i - 1] == 1){
		if (l == -1) l = i; r = i;
	}
	doit(1, n);
	if (l != -1) doit(l + 1, n);
	if (r != -1) doit(1, r - 1);
	while(Q--){
		int x; scanf("%d", &x);
		if (ans[x].first == 0) puts("NIE");
		else printf("%d %d\n", ans[x].first, ans[x].second);
	}
}
Problem2217

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cctype>
using namespace std;
pair<int, int> ans[4000001]; int n, sum[2000001];
void read(int & x)
{
	char c;
	while(!isdigit((c = getchar())));
	x = 0;
	do x = x * 10 + c - '0'; while(isdigit(c = getchar()));
}
void doit(int l, int r)
{
	if (l > r) return;
	ans[sum[r] - sum[l - 1]] = make_pair(l, r);
	if (sum[l] - sum[l - 1] == 2) doit(l + 1, r);
	else if (sum[r] - sum[r - 1] == 2) doit(l, r - 1);
	else doit(l + 1, r - 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q; scanf("%d%d", &n, &Q); scanf(" ");
	for (int i = 1; i <= n; i++){
		char c = getchar();
		sum[i] = sum[i - 1] + 1 + (c == 'T');
	}
	int l = -1, r = -1;
	for (int i = 1; i <= n; i++) if (sum[i] - sum[i - 1] == 1){
		if (l == -1) l = i; r = i;
	}
	doit(1, n);
	if (l != -1) doit(l + 1, n);
	if (r != -1) doit(1, r - 1);
	while(Q--){
		int x; read(x);
		if (ans[x].first == 0) puts("NIE");
		else printf("%d %d\n", ans[x].first, ans[x].second);
	}
}
Problem2223

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
int a[400001], n;
struct Ttree{
	int val[20][400001], tl[20][400001];
	void init()
	{
		for (int i = 1; i <= n; i++) val[0][i] = a[i];
		sort(a + 1, a + n + 1);
		build(0, 1, n);
	}
	void build(int dep, int l, int r)
	{
		if (l == r) return;
		int m = l + r >> 1, lpos = l - 1, rpos = m, ls = m - l + 1;
		for (int i = l; i <= r; i++) ls -= val[dep][i] < a[m];
		for (int i = l; i <= r; i++){
			tl[dep][i] = i == l ? 0 : tl[dep][i - 1];
			if (val[dep][i] < a[m]) val[dep + 1][++lpos] = val[dep][i], ++tl[dep][i];
			else if (val[dep][i] > a[m]) val[dep + 1][++rpos] = val[dep][i];
			else if (ls > 0) val[dep + 1][++lpos] = val[dep][i], ++tl[dep][i], --ls;
			else val[dep + 1][++rpos] = val[dep][i];
		}
		build(dep + 1, l, m); build(dep + 1, m + 1, r);
	}
	int query(int dep, int l, int r, int ll, int rr, int k)
	{
		if (l == r) return val[dep][l];
		int m = l + r >> 1, A = l == ll ? 0 : tl[dep][ll - 1], B = tl[dep][rr] - A, C = ll - l - A, D = rr - ll + 1 - B;
		if (B >= k) return query(dep + 1, l, m, l + A, l + A + B - 1, k);
		else return query(dep + 1, m + 1, r, m + C + 1, m + C + D, k - B);
	}
} T;
int m;
vector<int> V[100001];
int gettime(int l, int r, int c)
{
	vector<int>::iterator vr = --upper_bound(V[c].begin(), V[c].end(), r), vl = lower_bound(V[c].begin(), V[c].end(), l);
	return vr - vl + 1;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) V[i].push_back(-1);
	for (int i = 1; i <= n; i++) { scanf("%d", &a[i]); V[a[i]].push_back(i); }
	for (int i = 1; i <= m; i++) V[i].push_back(n + 1);
	T.init();
	int Q; scanf("%d", &Q);
	while(Q--){
		int l, r; scanf("%d%d", &l, &r);
		int t = T.query(0, 1, n, l, r, (r - l + 1) / 2 + 1);
		if (gettime(l, r, t) > (r - l + 1) / 2) printf("yes %d\n", t); else puts("no");
	}
}
Problem2225

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXNODE = 1000001;
struct Tinf{
    int f; double g;
    inline Tinf operator + (const Tinf & A)
    {
        Tinf temp;
        if (f == A.f) { temp.f = f; temp.g = f == 0 ? 1.0 : g + A.g; return temp; }
        else return f > A.f ? *this : A;
    }   
} emp, f[1000001], g[1000001];
struct Tnode{
    int c[2], key;
    Tinf opt, val;
} node[MAXNODE];
int x[1000001], y[1000001];
int tot, hashnum, n, hash[1000001];
inline int make(int h, Tinf inf)
{
    ++tot; node[tot].c[0] = node[tot].c[1] = 0;
    node[tot].key = h; node[tot].val = node[tot].opt = inf;
    return tot;
}
struct Tbst{
    int root;
    void update(int t)
    {
        node[t].opt = node[node[t].c[0]].opt + node[node[t].c[1]].opt + node[t].val;
    }
    Tinf query(int t, int h)
    {
        if (t == 0) return emp;
        if (h < node[t].key) return query(node[t].c[0], h);
        else return node[t].val + node[node[t].c[0]].opt + query(node[t].c[1], h);
    }
    void insert(int t, int h, Tinf inf)
    {
        if (root == 0) { root = make(h, inf); return; }
        if (node[t].key == h) { node[t].val = node[t].val + inf; update(t); return; }
        if (node[t].c[h > node[t].key] == 0) { node[t].c[h > node[t].key] = make(h, inf); update(t); return; }
        else { insert(node[t].c[h > node[t].key], h, inf); update(t); }
    }   
} bit[1000001];
void ins(int t1, int t2, Tinf inf)
{
    for (int i = t1; i <= hashnum; i += (i & (-i))) bit[i].insert(bit[i].root, t2, inf);
}
Tinf sum(int t1, int t2)
{
    Tinf inf = emp;
    for (int i = t1; i >= 1; i -= (i & (-i))) inf = inf + bit[i].query(bit[i].root, t2);
    return inf;
}
void clr()
{
    for (int i = 1; i <= hashnum; i++) bit[i].root = 0; tot = 0;
}
int main()
{
    emp.f = 0; emp.g = 1.0;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]), hash[i] = x[i];
    sort(hash + 1, hash + n + 1); hashnum = unique(hash + 1, hash + n + 1) - hash - 1;
    node[0].val = node[0].opt = emp;
    for (int i = 1; i <= n; i++) x[i] = lower_bound(hash + 1, hash + hashnum + 1, x[i]) - hash;
    clr(); Tinf ans = emp;
    for (int i = 1; i <= n; i++){
        f[i] = sum(x[i] - 1, y[i] - 1); f[i].f++;
        ins(x[i], y[i], f[i]); ans = ans + f[i];
        }
    printf("%d\n", ans.f);
}
Problem2226

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int TEST;
long long prime[1000001], pnum, f[1000001], oth[1000001];
bool notp[1000001];
void GET(long long MAX)
{
	f[1] = 1;
	for (long long i = 2; i <= MAX; i++){
		if (!notp[i]){
				prime[++pnum] = i; oth[i] = 1ll;
				f[i] = i * i - i + 1;
				}
		for (int j = 1; j <= pnum && i * prime[j] <= MAX; j++){
			notp[i * prime[j]] = true;
			if (i % prime[j] == 0){
				oth[i * prime[j]] = oth[i];
				long long pk = i * prime[j] / oth[i * prime[j]];
				f[i * prime[j]] = f[oth[i]] * (pk * pk * prime[j] + 1) / (1 + prime[j]);
				break;
				}
			else{
				oth[i * prime[j]] = i;
				f[i * prime[j]] = f[i] * (1 + prime[j] * prime[j] * prime[j]) / (1 + prime[j]);
				}
			}
		}
}	
int main()
{
GET(1000000ll);
int TEST; scanf("%d", &TEST);
while(TEST--){
	long long t; scanf("%lld", &t); 
	printf("%lld\n", (f[t] + 1ll) * t / 2ll);
	}
}	
Problem2227

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Big {
	int len, data[1001];
	void clear() { memset(this, 0, sizeof(*this)); }
	int & operator [] (int k) { return data[k]; }
	Big & operator = (int k) { len = 1; data[1] = k; return *this; }
	Big operator * (int k)
	{
		Big temp; temp.clear(); temp.len = len;
		for (int i = 1; i <= temp.len; i++){
			temp[i] += k * data[i];
			temp[i + 1] += temp[i] / 10000;
			temp[i] %= 10000;
			}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator * (Big A)
	{
		Big temp; temp.clear(); temp.len = len + A.len - 1;
		for (int i = 1; i <= len; i++)
			for (int j = 1; j <= A.len; j++){
				temp[i + j - 1] += A[j] * data[i];
				temp[i + j] += temp[i + j - 1] / 10000;
				temp[i + j - 1] %= 10000;
				}
		while(temp[temp.len + 1]) ++temp.len;
		return temp;
	}
	Big operator - (Big A)
	{
		Big temp; temp.clear(); temp.len = max(len, A.len);
		for (int i = 1; i <= len; i++){
			temp[i] = temp[i] + data[i] - A[i];
			if (temp[i] < 0) temp[i] += 10000, temp[i + 1] -=1;
			}
		while(temp[temp.len] == 0) --temp.len;
		return temp;
	}
	void print()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]);
	}
} T;
int p[201], num;
struct Tsupernum{
	int data[201];
	void init() { for (int i = 1; i <= num; i++) data[i] = 0; }
	int & operator [] (const int k) { return data[k]; }
	void mul(int t)
	{
		for (int i = 1; i <= num; i++) while(t % p[i] == 0) { t /= p[i]; ++data[i]; }
	}
	void print()
	{
		T.clear(); T = 1;
		for (int i = 1; i <= num; i++) for (int j = 1; j <= data[i]; j++) T = T * p[i];
		T.print();
	}
} A, B;
int n, k;
void check(int t)
{
	for (int i = 2; i < t; i++) if (t % i == 0) return;
	p[++num] = t;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T; scanf("%d", &T);
for (int i = 2; i <= 200; i++) check(i);
while(T--){
	scanf("%d%d", &n, &k); if (n > k) { puts("0 1"); continue; }
	A.init(); B.init();
	for (int i = 1; i < n; i++) A.mul(k + 1);
	A.mul(k - n + 1);
	for (int i = 1; i <= n; i++) B.mul(k);
	for (int i = 1; i <= num; i++){
		int t = min(A[i], B[i]);
		A[i] -= t; B[i] -= t;
	}
	A.print(); putchar(' '); B.print(); putchar('\n');
}
}
Problem2228

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 200;
using namespace std;
int ans;
struct Tsolve1{
	int h[MAXN], n, top, stack[MAXN], l[MAXN], r[MAXN];
	int solve()
	{
		top = 0;
		for (int i = 1; i <= n; i++) r[i] = n;
		for (int i = 1; i <= n; i++) { 
			while(top > 0 && h[i] < h[stack[top]]) { r[stack[top]] = i - 1; --top; }
			stack[++top] = i;
		}
		top = 0;
		for (int i = 1; i <= n; i++) l[i] = 1;
		for (int i = n; i >= 1; i--) { 
			while(top > 0 && h[i] < h[stack[top]]) { l[stack[top]] = i + 1; --top; }
			stack[++top] = i;
		}
		int ans = 0;
		for (int i = 1; i <= n; i++) ans = max(ans, (r[i] - l[i] + 1) * h[i]);
		return ans;
	}
} solve1; // poj 2559 
struct Tsolve2{
	int map[MAXN][MAXN], n, m, ret[MAXN][MAXN];
	void solve()
	{
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (map[i][j]){
					ret[i][j] = min(ret[i - 1][j], min(ret[i][j - 1], ret[i - 1][j - 1])) + 1;
				}
				else ret[i][j] = 0;
	}
} solve2; //USACO SX
struct Tsolve3{
	bool map[MAXN][MAXN][MAXN]; int n1, n2, n3;
	int num1[MAXN][MAXN][MAXN];
	void solve()
	{
		solve2.n = n2; solve2.m = n3;
		for (int k = 1; k <= n1; k++){
			for (int i = 1; i <= n2; i++)
				for (int j = 1; j <= n3; j++)
					solve2.map[i][j] = map[k][i][j];
			solve2.solve();
			for (int i = 1; i <= n2; i++)
				for (int j = 1; j <= n3; j++)
					num1[k][i][j] = solve2.ret[i][j];
		}
		for (int i = 1; i <= n2; i++)
			for (int j = 1; j <= n3; j++){
				solve1.n = n1;
				for (int k = 1; k <= n1; k++) solve1.h[k] = num1[k][i][j];
				ans = max(ans, solve1.solve());
			}
	}
} solve3;
int n1, n2, n3; bool map[MAXN][MAXN][MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n2, &n1, &n3);
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++){
			getchar();
			for (int k = 1; k <= n3; k++) map[i][j][k] = getchar() == 'N';
		}
	solve3.n1 = n1; solve3.n2 = n2; solve3.n3 = n3;
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++)
			for (int k = 1; k <= n3; k++)
				solve3.map[i][j][k] = map[i][j][k];
	solve3.solve();
	
	solve3.n1 = n3; solve3.n2 = n2; solve3.n3 = n1;
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++)
			for (int k = 1; k <= n3; k++)
				solve3.map[k][j][i] = map[i][j][k];
	solve3.solve();
	
	solve3.n1 = n2; solve3.n2 = n3; solve3.n3 = n1;
	for (int i = 1; i <= n1; i++)
		for (int j = 1; j <= n2; j++)
			for (int k = 1; k <= n3; k++)
				solve3.map[j][k][i] = map[i][j][k];
	solve3.solve();

	printf("%d\n", ans * 4);
}
Problem2229

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#define VI vector<int>
#define VII VI::iterator
#define pb push_back
const int MAXN = 201, MAXM = 5001;
const int INF = 0x3f3f3f3f;
using namespace std;
int mincut[MAXN][MAXN];
struct Tmincut{
	int n, m, s, t;
	int tot, e[MAXN], v[MAXM * 2], next[MAXM * 2], c[MAXM * 2], copyc[MAXM * 2];
	int h[MAXN], vh[MAXN];
	bool S[MAXN];
	void add(int A, int B, int C)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = C;
	}
	void init()
	{
		tot = 1; memset(e, 0, sizeof e);
		scanf("%d%d", &n, &m);
		while(m--){
			int a, b, c;
			scanf("%d%d%d", &a, &b, &c);
			add(a, b, c);
		}
		memcpy(copyc, c, sizeof(c));
	}
	void reinit()
	{
		memcpy(c, copyc, sizeof(c));
		memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
		vh[0] = n;
	}	
	int aug(int x, int f)
	{
		if (x == t) return f;
		int minh = n - 1, augc = f;
		for (int i = e[x]; i; i = next[i]) if (c[i]){
			if (h[v[i]] + 1 == h[x]){
				int t = aug(v[i], min(f, c[i]));
				c[i] -= t; c[i ^ 1] += t; f -= t;
				if (f == 0 || h[s] == n) return augc - f;
			}
			minh = min(minh, h[x]);
		}
		if (f == augc){ if (--vh[h[x]] == 0) h[s] = n; ++vh[h[x] = minh + 1]; }
		return augc - f;
	}
	void dfs(int x)
	{
		S[x] = true;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && !S[v[i]]) dfs(v[i]);
	}
	void run()
	{
		int flow = 0;
		while(h[s] < n)
			flow += aug(s, INF);
		memset(S, 0, sizeof(S));
		dfs(s);
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++) if (S[i] && !S[j])
				mincut[i][j] = mincut[j][i] = min(flow, mincut[i][j]);
	}
} cut;
void solve(VI now)
{
	if (now.size() <= 1) return;
	int a = now[0], b = now[1];
	cut.reinit(); cut.s = a; cut.t = b;
	cut.run();
	VI A, B;
	for (VII vii = now.begin(); vii != now.end(); vii++) if (cut.S[*vii]) A.pb(*vii); else B.pb(*vii);
	solve(A); solve(B);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int T; scanf("%d", &T);
while(T--){
	memset(mincut, 0x3f, sizeof(mincut));
	cut.init();
	VI temp; for (int i = 1; i <= cut.n; i++) temp.pb(i);
	solve(temp);
//	for (int i= 1; i <= cut.n; i++)
//		for (int j = 1; j <= cut.n; j++) if (i != j)
//			printf("%d %d %d\n", i, j, mincut[i][j]);
	int Q; scanf("%d", &Q);
	while(Q--){
		int t, ans = 0; scanf("%d", &t);
		for (int i = 1; i <= cut.n; i++) 
			for (int j = i + 1; j <= cut.n; j++)
				ans += mincut[i][j] <= t;
		printf("%d\n", ans);
	}
	putchar('\n');

}
}
Problem2234

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define ll long long
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
const int MAXN = 300001, MAXS = MAXN * 3;
int scantot, ans[MAXN], ansid[MAXN];
ll hashy[MAXN], x[MAXN], y[MAXN], d[MAXN]; 
int toty, n, k, ansnum;
struct Tscan{
	int kind;
	ll x, y1, y2;
	Tscan() { }
	Tscan(int kind, ll x, ll y1, ll y2) : kind(kind), x(x), y1(y1), y2(y2) { };
	bool operator < (const Tscan & A) const
	{
		return x == A.x ? kind < A.kind : x < A.x;
	}
} scan[MAXS];
struct Tbit{
	int data[MAXN];
	void ins(int x, int d)
	{
		for (; x <= toty; x += (x & (-x))) data[x] += d;
	}
	int get(int x)
	{
		int ret = 0;
		for (; x; x -= (x & (-x))) ret += data[x];
		return ret;
	}
} bit;

int lower(ll t)
{
	return lower_bound(hashy + 1, hashy + toty + 1, t) - hashy;
}
int upper(ll t)
{
	return upper_bound(hashy + 1, hashy + toty + 1, t) - hashy;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf(LLD""LLD""LLD, &x[i], &y[i], &d[i]);
	for (int i = 1; i <= n; i++) { ll X = x[i], Y = y[i]; x[i] = X + Y; y[i] = X - Y; }
	for (int i = 1; i <= n; i++) hashy[i] = y[i];
	sort(hashy + 1, hashy + n + 1); toty = unique(hashy + 1, hashy + n + 1) - hashy - 1;
	hashy[++toty] = 0x7fffffffffffffffll;
	for (int i = 1; i <= n; i++){
		scan[++scantot] = Tscan(0, x[i], y[i], i);
		scan[++scantot] = Tscan(1, x[i] - d[i], y[i] - d[i], y[i] + d[i]);
		scan[++scantot] = Tscan(2, x[i] + d[i], y[i] - d[i], y[i] + d[i]);
	}
	sort(scan + 1, scan + scantot + 1);
	for (int i = 1; i <= scantot; i++)
		switch(scan[i].kind){
			case 0 : ans[scan[i].y2] = bit.get(lower(scan[i].y1)); break;
			case 1 : bit.ins(lower(scan[i].y1), 1); bit.ins(upper(scan[i].y2), -1); break;
			case 2 : bit.ins(lower(scan[i].y1), -1); bit.ins(upper(scan[i].y2), 1); break;
		}
	for (int i = 1; i <= n; i++) if (ans[i] > k) ansid[++ansnum] = i;
	printf("%d\n", ansnum);
	for (int i = 1; i <= ansnum; i++) { printf("%d", ansid[i]);	putchar(i == ansnum ? '\n' : ' '); }
}
Problem2235

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, MAXM = 2000001;
struct Tflow{
	int tot, e[MAXN], v[MAXM], c[MAXM], next[MAXM], s, t;
	int d[MAXN], q[MAXN], l, r;
	void init() { tot = 1; for (int i = 1; i <= t; i++) e[i] = 0; }
	void add(int a, int b, int w)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = w;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;
	}
	bool relable()
	{
		for (int i = 1; i <= t; i++) d[i] = -1; d[s] = 0; l = r = 1; q[1] = s;
		while(l <= r){
			int x = q[l++]; 
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == -1){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f = 0x3f3f3f3f)
	{
		if (x == t) return f;
		int augc = f;
		for (int i = e[x]; i; i = next[i]) if (d[v[i]] == d[x] + 1 && c[i] > 0){
			int t = find(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t;
			if (f == 0) break;
		}
		if (f != 0) d[x] = -1;
		return augc - f;
	}
	int run()
	{
		int t, ret = 0;
		while(relable()) while(t = find(s)) ret += t;
		return ret;
	}
} flow;
struct Tcircle{
	int x, y, r, s;
	void init() { scanf("%d%d%d%d", &x, &y, &r, &s); }
	bool operator + (const Tcircle & A)
	{
		int d = (x - A.x) * (x - A.x) + (y - A.y) * (y - A.y);
		return r * r >= d;
	}
} circle[1000001];
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
for (int T = 1; T <= TEST; T++){
	int ans = 0; scanf("%d", &n);
	for (int i = 1; i <= n; i++) circle[i].init();
	flow.s = n + 1; flow.t = n + 2; flow.init();
	for (int i = 1; i <= n; i++){
		if (circle[i].s > 0) flow.add(flow.s, i, circle[i].s), ans += circle[i].s;
		else flow.add(i, flow.t, -circle[i].s);
		for (int j = 1; j <= n; j++) if (i != j)
			if (circle[i] + circle[j]) flow.add(i, j, 0x3f3f3f3f);
	}
	printf("Case #%d:%d\n", T, ans - flow.run());
}
}
Problem2238

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int INF = 0x7f3f3f3f;
const int MAXN = 2000001;
struct Tnode{
	int c[2], f, _add, val;
	bool isroot;
	static Tnode *a;
	void add(int t)
	{
		if (this != a){
			val = min(val, t);
			_add = min(_add, t);
		}
	}
	void push()
	{
		if (_add != INF){
			a[c[0]].add(_add);
			a[c[1]].add(_add);
			_add = INF;
		}
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) isroot = true, a[f].isroot = false;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a;
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
}
void ac(int x, int t, bool F)
{
	int p = 0, q = x;
	while(q){
		splay(q);
		if (A[q].f == 0 && F) { A[p].add(t); A[A[q].c[1]].add(t); }
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		p = q; q = A[q].f;
	}
}
int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2], n, m;
int f[MAXN], ans[MAXN];
bool vis[MAXN];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		f[v[i]] = x; dfs(v[i]);
	}
}
struct Tedge{
	int st, ed, len, who; bool used;
	bool operator < (const Tedge & A) const { return len < A.len; }
	void init(int _who) { scanf("%d%d%d", &st, &ed, &len); who = _who; }
} edge[MAXN];
struct Tuf{
	int f[MAXN];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int getf(int v) { return v == f[v] ? v : f[v] = getf(f[v]); }
	bool same(int a, int b) { return getf(a) == getf(b); }
	void merge(int a, int b) { a = getf(a); b = getf(b); f[a] = b; }
} uf;
int mst;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) edge[i].init(i);
	sort(edge + 1, edge + m + 1); uf.init();
	int now = 0;
	for (int i = 1; i <= m && now < n - 1; i++){
		if (!uf.same(edge[i].st, edge[i].ed)){
			uf.merge(edge[i].st, edge[i].ed);
			mst += edge[i].len; ++now; edge[i].used = true;
			add(edge[i].st, edge[i].ed); add(edge[i].ed, edge[i].st);
		}
	}
	dfs(1);
	for (int i = 1; i <= n; i++) { A[i].isroot = true; A[i].val = A[i]._add = INF; A[i].f = f[i];}
	for (int i = 1; i <= m; i++) if (!edge[i].used){
		ac(edge[i].st, edge[i].len, false); ac(edge[i].ed, edge[i].len, true);
	}
	for (int i = 1; i <= m; i++) ans[i] = mst;
	for (int i = 1; i <= m; i++) if (edge[i].used){
		int w = edge[i].who, t = f[edge[i].st] == edge[i].ed ? edge[i].st : edge[i].ed;
		splay(t); if (A[t].val != INF) ans[w] = A[t].val - edge[i].len + mst; else ans[w] = INF;
	}
	int Q; scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
	//	if (now != n - 1) { puts("Not connected"); continue; }
		int t; scanf("%d", &t); if (ans[t] == INF) puts("Not connected"); else printf("%d\n", ans[t]);
	}
}
Problem2241

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, m, a[101][101], A[101][101], sum;
bool check(int r, int c)
{
	memcpy(A, a, sizeof(a));
	for (int i = 1; i <= n - r + 1; i++){
		for (int j = 1; j <= m - c + 1; j++){
			if (A[i][j] < 0) return false;
			if (A[i][j] == 0) continue;
			int M = A[i][j];
			for (int ti = i; ti <= i + r - 1; ti++)
				for (int tj = j; tj <= j + c - 1; tj++){
					A[ti][tj] -= M;
					if (A[ti][tj] < 0) return false;
					}
			}
		for (int j = m - c + 2; j <= m; j++) if (A[i][j] != 0) return false;
		}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (A[i][j] > 0) return false;
	return true;
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			scanf("%d", &a[i][j]);
			sum += a[i][j];
			}
	int r = 1, c = 1;
	for (int i = n; i >= 1; i--)
		for (int j = m; j >= 1; j--) if (i * j > r * c && sum % i * j == 0)
			if (check(i, j)) r = i, c = j;
	printf("%d\n", sum / (r * c));
}	
Problem2242

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <map>
#define lint long long
#define make(a) (((a % p) + p) % p)
using namespace std;
map <lint, lint> M;
lint y, z, p;
int t, k;
lint pow(lint a, lint b)
{
	lint ret = 1, now = a;
	for (; b; b >>= 1){
		if (b & 1) ret = make(ret * now);
		now = make(now * now);
		}
	return ret;
}
void exgcd(lint a, lint b, lint & x, lint & y)
{
	if (b == 0) { x = 1; y = 0; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("calc.in", "r", stdin); freopen("calc.out", "w", stdout);
#endif
	lint a, b; 
	scanf("%d%d", &t, &k);
	for (int i = 0; i < t; i++){
		switch(k){
			case 1 : 
				scanf("%lld%lld%lld", &y, &z, &p);
				printf("%lld\n", pow(y, z));
				break;
			case 2 :
				scanf("%lld%lld%lld", &y, &z, &p);
				y %= p; z %= p;
				if (y == 0) { if (z == 0) puts("0"); else puts("Orz, I cannot find x!"); continue; }
				exgcd(y, p, a, b);
				printf("%lld\n", make(a * z));
				break;
			case 3:
				scanf("%lld%lld%lld", &y, &z, &p);
				y %= p; z %= p; M.clear();
				if (y == 0) { if (z == 0) puts("1"); else puts("Orz, I cannot find x!"); continue; }
				lint m = (lint)(ceil(sqrt(p)));
				lint now = make(y * z); 
				for (int i = 1; i <= m; i++){ 
					M[now] = i; 
					now = make(now * y); 
					}
				lint giant = 1; for (int i = 1; i <= m; i++) giant = make(giant * y);
				now = giant; bool ok = false;
				for (int i = 1; i <= m; i++){
					if (ok) break;
					if (M.count(now) > 0) { printf("%lld\n", m * i - M[now]); ok = true; continue; }
					now = make(now * giant);
					}
				if (ok) break;
				puts("Orz, I cannot find x!");
			}
		}
}
Problem2242

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
#include <cmath>
#define ll long long
const char *error = "Orz, I cannot find x!";
using namespace std;
void exgcd(int a, int b, ll & x, ll & y)
{
	if (b == 0) { x = 1; y = 0; }
	else { exgcd(b, a % b, y, x); y -= a / b * x; }
}
int pow(int a, int b, int c) //a ^ b % c
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (long long) ret * a % c;
		a = (long long) a * a % c;
	}
	return ret;
}
void solve_mod(int a, int b, int c)
{
	int d = __gcd(a, c); if (b % d != 0) { puts(error); return; }
	a /= d; b /= d; c /= d;
	ll x, y; exgcd(a, c, x, y);
	x = x * b % c; x = (x + c) % c;
	printf("%d\n", x);
}
pair<int, int> ha[1000001];
void solve_log(int a, int b, int c)
{
	a %= c; b %= c;
	if (a == 0){
		if (b == 1) puts("1");
		else puts(error);
		return;
	}
	int M = ceil(sqrt(c)), now = b;
	for (int i = 1; i <= M; i++){
		now = (long long) now * a % c;
		ha[i] = make_pair(now, i);
	}
	sort(ha + 1, ha + M + 1);
	int giant = 1;
	for (int i = 1; i <= M; i++) giant = (long long) giant * a % c;
	now = giant;
	for (int i = 1; i <= M + 2; i++){
		int t = upper_bound(ha + 1, ha + M + 1, make_pair(now, M + 2)) - ha - 1;
		if (ha[t].first == now){	
			cout << M * i - ha[t].second << endl; return; 
		}
		now = (long long)now * giant % c;
	}
	puts(error);	
}
int T, k, y, z, P;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("calc.in", "r", stdin); freopen("calc.out", "w", stdout);
#endif
scanf("%d%d", &T, &k);
	while(T--){
		scanf("%d%d%d", &y, &z, &P);
		switch(k){
			case 1 : printf("%d\n", pow(y, z, P)); break; 
			case 2 : solve_mod(y, z, P); break;
			case 3 : solve_log(y, z, P); break;
		}
	}
}
Problem2243

#include <cstdio>
#include <cstdlib>
#include <cstring>
const int MAXN = 200001;
struct Tnode{
	static Tnode *a;
	int c[2], f;
	int lc, rc, count, _color, val;
	bool isroot;
	void set(int _val, int _f)
	{
		lc = rc = val = _val; f = _f; count = 1; isroot = true;
	}
	void color(int c)
	{
		if (this != a){
			lc = rc = val = _color = c; count = 1;
			}
	}
	void push()
	{
		if (_color){
			a[c[0]].color(_color); a[c[1]].color(_color);
			_color = 0;
			}
	}
	void update()
	{
		lc = c[0] == 0 ? val : a[c[0]].lc;
		rc = c[1] == 0 ? val : a[c[1]].rc;
		count = a[c[0]].count + 1 + a[c[1]].count - (val == a[c[0]].rc) - (val == a[c[1]].lc);
	}
	void rot(bool b)
	{
		a[f].push(); push(); 
		if (a[f].isroot) isroot = true, a[f].isroot = false;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
			}
		else A[x].rot(b);
		}
	A[x].update();
}
int ACCESS1(int x)
{
	int p = 0, q = x, _res;
	while(q != 0){
		splay(q);
		if (A[q].f == 0) _res = A[p].count + A[A[q].c[1]].count + 1 - (A[q].val == A[p].lc) - (A[q].val == A[A[q].c[1]].lc);
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
	return _res;
}
void ACCESS2(int x, int c, bool FLAG)
{
	int p = 0, q = x;
	while(q != 0){
		splay(q);
		if (A[q].f == 0 && FLAG){
			A[A[q].c[1]].color(c);
			A[p].color(c);
			A[q].val = c; A[q].update();
			}	
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
		}
}
int n, m, tot, e[MAXN], next[MAXN], v[MAXN], col[MAXN];
bool vis[MAXN];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void dfs(int x)
{
	vis[x] = true;
	for (int i = e[x]; i; i = next[i]) if(!vis[v[i]]){
		A[v[i]].set(col[v[i]], x); dfs(v[i]);
		}
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
	for (int i = 1; i < n; i++){
		int x, y; scanf("%d%d", &x, &y);
		add(x, y); add(y, x);
		}
	A[1].set(col[1], 0); dfs(1);
	for (int i = 1; i <= m; i++){
		char op[101]; int l, r, d;
		scanf("%s", op);
		switch(*op){
			case 'Q' : scanf("%d%d", &l, &r); ACCESS1(l); printf("%d\n", ACCESS1(r)); break;
			case 'C' : scanf("%d%d%d", &l, &r, &d); ACCESS2(l, d, 0); ACCESS2(r, d, 1); break;
			}
		}
}
Problem2244

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXNODE = 1000001;
struct Tinf{
	int f; double g;
	Tinf operator + (Tinf A)
	{
		Tinf temp;
		if (f == A.f) { temp.f = f; temp.g = f == 0 ? 1.0 : g + A.g; return temp; }
		else return f > A.f ? *this : A;
	}	
} emp, f[100001], g[100001];
struct Tnode{
	int c[2], key;
	Tinf opt, val;
} node[MAXNODE];
int x[100001], y[100001];
int tot, hashnum, n, hash[100001];
int make(int h, Tinf inf)
{
	++tot; node[tot].c[0] = node[tot].c[1] = 0;
	node[tot].key = h; node[tot].val = node[tot].opt = inf;
	return tot;
}
struct Tbst{
	int root;
	void update(int t)
	{
		node[t].opt = node[node[t].c[0]].opt + node[node[t].c[1]].opt + node[t].val;
	}
	Tinf query(int t, int h)
	{
		if (t == 0) return emp;
		if (h > node[t].key) return query(node[t].c[1], h);
		else return node[t].val + node[node[t].c[1]].opt + query(node[t].c[0], h);
	}
	void insert(int t, int h, Tinf inf)
	{
		if (root == 0) { root = make(h, inf); return; }
		if (node[t].key == h) { node[t].val = node[t].val + inf; update(t); return; }
		if (node[t].c[h > node[t].key] == 0) { node[t].c[h > node[t].key] = make(h, inf); update(t); return; }
		else { insert(node[t].c[h > node[t].key], h, inf); update(t); }
	}	
} bit[100001];
void ins(int t1, int t2, Tinf inf)
{
	for (int i = t1; i <= hashnum; i += (i & (-i))) bit[i].insert(bit[i].root, t2, inf);
}
Tinf sum(int t1, int t2)
{
	Tinf inf = emp;
	for (int i = t1; i >= 1; i -= (i & (-i))) inf = inf + bit[i].query(bit[i].root, t2);
	return inf;
}
void clr()
{
	for (int i = 1; i <= hashnum; i++) bit[i].root = 0; tot = 0;
}
int main()
{
	emp.f = 0; emp.g = 1.0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]), hash[i] = x[i];
	sort(hash + 1, hash + n + 1); hashnum = unique(hash + 1, hash + n + 1) - hash - 1;
	node[0].val = node[0].opt = emp;
	for (int i = 1; i <= n; i++) x[i] = lower_bound(hash + 1, hash + hashnum + 1, x[i]) - hash;
	clr(); Tinf ans = emp;
	for (int i = 1; i <= n; i++){
		x[i] = hashnum - x[i] + 1;
		f[i] = sum(x[i], y[i]); f[i].f++;
		ins(x[i], y[i], f[i]); ans = ans + f[i];
		}
	clr();
	for (int i = n; i >= 1; i--){
		x[i] = hashnum - x[i] + 1;
		g[i] = sum(x[i], -y[i]); g[i].f++;
		ins(x[i], -y[i], g[i]);
		}
	printf("%d\n", ans.f);

	for (int i = 1; i <= n; i++)
		if (f[i].f + g[i].f == ans.f + 1) 
			printf("%.5lf", f[i].g * g[i].g / ans.g), putchar(i == n ? '\n' : ' '); 
		else printf("%.5lf", 0.0), putchar(i == n ? '\n' : ' '); 
}
Problem2244

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXNODE = 1000001;
struct Tinf{
	int f; double g;
	inline Tinf operator + (const Tinf & A)
	{
		Tinf temp;
		if (f == A.f) { temp.f = f; temp.g = f == 0 ? 1.0 : g + A.g; return temp; }
		else return f > A.f ? *this : A;
	}	
} emp, f[100001], g[100001];
struct Tnode{
	int c[2], key;
	Tinf opt, val;
} node[MAXNODE];
int x[100001], y[100001];
int tot, hashnum, n, hash[100001];
inline int make(int h, Tinf inf)
{
	++tot; node[tot].c[0] = node[tot].c[1] = 0;
	node[tot].key = h; node[tot].val = node[tot].opt = inf;
	return tot;
}
struct Tbst{
	int root;
	void update(int t)
	{
		node[t].opt = node[node[t].c[0]].opt + node[node[t].c[1]].opt + node[t].val;
	}
	Tinf query(int t, int h)
	{
		if (t == 0) return emp;
		if (h > node[t].key) return query(node[t].c[1], h);
		else return node[t].val + node[node[t].c[1]].opt + query(node[t].c[0], h);
	}
	void insert(int t, int h, Tinf inf)
	{
		if (root == 0) { root = make(h, inf); return; }
		if (node[t].key == h) { node[t].val = node[t].val + inf; update(t); return; }
		if (node[t].c[h > node[t].key] == 0) { node[t].c[h > node[t].key] = make(h, inf); update(t); return; }
		else { insert(node[t].c[h > node[t].key], h, inf); update(t); }
	}	
} bit[100001];
void ins(int t1, int t2, Tinf inf)
{
	for (int i = t1; i <= hashnum; i += (i & (-i))) bit[i].insert(bit[i].root, t2, inf);
}
Tinf sum(int t1, int t2)
{
	Tinf inf = emp;
	for (int i = t1; i >= 1; i -= (i & (-i))) inf = inf + bit[i].query(bit[i].root, t2);
	return inf;
}
void clr()
{
	for (int i = 1; i <= hashnum; i++) bit[i].root = 0; tot = 0;
}
int main()
{
	emp.f = 0; emp.g = 1.0;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]), hash[i] = x[i];
	sort(hash + 1, hash + n + 1); hashnum = unique(hash + 1, hash + n + 1) - hash - 1;
	node[0].val = node[0].opt = emp;
	for (int i = 1; i <= n; i++) x[i] = lower_bound(hash + 1, hash + hashnum + 1, x[i]) - hash;
	clr(); Tinf ans = emp;
	for (int i = 1; i <= n; i++){
		x[i] = hashnum - x[i] + 1;
		f[i] = sum(x[i], y[i]); f[i].f++;
		ins(x[i], y[i], f[i]); ans = ans + f[i];
		}
	clr();
	for (int i = n; i >= 1; i--){
		x[i] = hashnum - x[i] + 1;
		g[i] = sum(x[i], -y[i]); g[i].f++;
		ins(x[i], -y[i], g[i]);
		}
	printf("%d\n", ans.f);

	for (int i = 1; i <= n; i++)
		if (f[i].f + g[i].f == ans.f + 1) 
			printf("%.5lf", f[i].g * g[i].g / ans.g), putchar(i == n ? '\n' : ' '); 
		else printf("%.5lf", 0.0), putchar(i == n ? '\n' : ' '); 
}
Problem2245

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 500001, MAXM = 2000001, SIZE = 32767;
int tot = 1, e[MAXN], next[MAXM], v[MAXM], c[MAXM], q[MAXN], f[MAXN], l, r, n, m, s, t;
int W[MAXN], T[MAXN];
long long w[MAXM], dis[MAXN], cost;
bool vis[MAXN];
void add(int A, int B, int C, int D)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
	++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
}
bool spfa()
{
	for (int i = 1; i <= t; i++) dis[i] = 0x3f3f3f3f3f3f3f3fll, vis[i] = false;
	dis[s] = 0; vis[s] = true; l = 0; r = 1; q[1] = s;
	while(l != r){
		l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
			dis[v[i]] = dis[x] + w[i]; f[v[i]] = i;
			if (!vis[v[i]]) { r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true; }
			}
		}
	return dis[t] < 0x3f3f3f3f3f3f3f3fll;
}
void aug()
{
	int mint = 0x3f3f3f3f;
	for (int i = t; i != s; i = v[f[i] ^ 1])
		mint = min(mint, c[f[i]]);
	for (int i = t; i != s; i = v[f[i] ^ 1]) c[f[i]] -= mint, c[f[i] ^ 1] += mint;
	cost += dis[t] * mint;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &m, &n);	
	s = n + m + 1; t = s + 1;
	for (int i = 1; i <= n; i++){
		int num; scanf("%d", &num);
		add(m + i, t, num, 0);
		}
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++){
			int t; scanf("%d", &t);
			if (t) add(i, j + m, 0x3f3f3f3f, 0);
			}
	for (int i = 1; i <= m; i++){
		int num;
		scanf("%d", &num);
		for (int j = 1; j <= num; j++) scanf("%d", &T[j]);
		for (int j = 1; j <= num + 1; j++) scanf("%d", &W[j]);
		for (int j = 1; j <= num; j++) add(s, i, T[j] - T[j - 1], W[j]);
		add(s, i, 0x3f3f3f3f, W[num + 1]);
		}
	while(spfa())
		aug();
	cout << cost << endl;
}
Problem2257

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, k, tot, a[10001], num[10000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j * j <= a[i]; j++) if (a[i] % j == 0){
			num[++tot] = j; num[++tot] = a[i] / j;
		}
	sort(num + 1, num + tot + 1);
	tot = unique(num + 1, num + tot + 1) - num - 1;
	for (int i = tot; i >= 1; i--){
		int t = 0;
		for (int j = 1; j <= n; j++) if (a[j] % num[i] == 0) ++t;
		if (t >= k) { printf("%d\n", num[i]); break; }
	}
}
Problem2281

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const long long MO = 1000000007;
int n, k, d;
long long C[30001][151], dp[51][30001];
long long make(long long a) { return ((a % MO) + MO) % MO; }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("game.in", "r", stdin); freopen("game.ans", "w", stdout);
#endif
	scanf("%d%d%d", &n, &k, &d);
	if (k & 1) { puts("912912718"); return 0; }
	C[0][0] = 1;
	for (int i = 1; i <= n + k; i++){
		C[i][0] = 1;
		for (int j = 1; j <= min(n, k); j++) C[i][j] = make(C[i - 1][j] + C[i - 1][j - 1]);
	}
	int len = 31 - __builtin_clz(n);
	dp[0][0] = 1;
	for (int i = 0; i < len; i++)
		for (int j = 0; j <= n; j++) if (dp[i][j])
			for (int l = 0; l <= k / 2; l += d + 1) if (j + l * (1 << i) <= n)
				dp[i + 1][j + l * (1 << i)] = make(dp[i + 1][j + l * (1 << i)] + make((long long)(dp[i][j]) * C[k / 2][l]));
	long long ans = C[n][k];
	for (int i = 0; i <= n - k; i++){
		ans = make((-dp[len][i]) * C[n - i - k / 2][k / 2] + ans);
	}
	printf("%d\n", ans);
}
Problem2282

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MAXM = 2000001;
bool cant[MAXN];
int tot, next[MAXM], e[MAXN], v[MAXM], w[MAXM];
int l, r, q[MAXN], dis[MAXN], f[MAXN], fd[MAXN];
int n, LL;
int c[MAXN], cd[MAXN], cs[MAXN], len, far[MAXN];
struct Tqueue{
	int data[MAXN], l, r;
	void clear() { l = 1; r = 0; }
	void push(int t) { while(r >= l && far[t] > far[data[r]]) --r; data[++r] = t; }
	void pop() { ++l; }
	bool empty() { return l > r; }
	int top() { return data[l]; }
} Q;
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int bfs(int st)
{
	f[st] = 0; l = 1; r = 1; q[1] = st; dis[st] = 0;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (v[i] != f[x] && (!cant[v[i]])){
			dis[v[i]] = dis[x] + w[i]; f[v[i]] = x; fd[v[i]] = w[i];
			q[++r] = v[i];
			}
		}
	int maxdis = -1, who;
	for (int i = 1; i <= r; i++) if (maxdis < dis[q[i]]) maxdis = dis[q[i]], who = q[i];
	return who;
}
int main()
{
	scanf("%d%d", &n, &LL);
	for (int i = 1; i <= n - 1; i++){
		int x, y, z; scanf("%d%d%d", &x, &y, &z);
		add(x, y, z); add(y, x, z);
		}
	int a = bfs(1), b = bfs(a);
	for (; f[b]; b = f[b]) { c[++len] = b; cd[len] = fd[b]; } c[++len] = a;
	for (int i = 2; i <= len; i++) cs[i] = cs[i - 1] + cd[i - 1];
	for (int i = 1; i <= len; i++) cant[c[i]] = true;
	for (int i = 1; i <= len; i++) far[i] = dis[bfs(c[i])];
	int R = 0; Q.clear();
	int ans = 0x3f3f3f3f;
	for (int i = 1; i <= len; i++){
		while(!Q.empty() && Q.top() <= i) Q.pop();
		while(R < len && cs[R + 1] - cs[i] <= LL){ ++R; Q.push(R); }
		ans = min(ans, max(max(cs[i], cs[len] - cs[R]), far[Q.top()]));
		}
	printf("%d\n", ans);
}
Problem2283

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define LEN(i) (((i) < (n)) ? (2 * (n + (i))) : (2 * n + (2 * n - 1 - (i)) * 2))
#define GET(S, i) (((S) >> ((i) + (i))) & 3ll)
#define CHA(S, i, c) ((S) ^ (long long)(((GET((S), (i))) ^ (c)) << ((i) + (i))))
#define FOR for (int hi = 1; hi <= H[now].tot; hi++)
#define DEF long long h = H[now].h[hi]; Tdp val = H[now].val[hi];
#define change { now ^= 1; H[!now].clear(); }
#define kind(i, j) (((i) < (n) && ((j) & 1)) || ((i) >= (n) && (!((j) & 1))))
using namespace std;
const int MOD = 200003, MAXNODE = 2000001;
struct Tdp{
	int ans1, ans2;
	Tdp() { ans1 = 0x3f3f3f3f; ans2 = 0; }
	Tdp(int ans1, int ans2) : ans1(ans1), ans2(ans2) { }
	Tdp & operator += (const Tdp & A)
	{
		if (A.ans1 < ans1) *this = A;
		else if (A.ans1 == ans1) ans2 = (ans2 + A.ans2) % 1000000007;
		return *this;
	}
	Tdp operator + (int t)
	{
		return Tdp(ans1 + t, ans2);
	}
};
struct Thash{
	int tot, e[MOD + 100], next[MAXNODE]; long long h[MAXNODE]; Tdp val[MAXNODE];
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	void insert(long long H, Tdp VAL)
	{
		for (int i = e[H % MOD]; i; i = next[i]) if (h[i] == H) { val[i] += VAL; return; }
		++tot; next[tot] = e[H % MOD]; e[H % MOD] = tot; h[tot] = H; val[tot] = VAL;
	}
} H[2];
int n, now;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("mars.in", "r", stdin); freopen("mars.ans", "w", stdout);
#endif
while(~scanf("%d", &n)){
	H[0].clear();
	H[0].insert(0, Tdp(0, 1)); now = 1;
	for (int i = 0; i < 2 * n; i++){
		for (int j = 0; j <= LEN(i); j++){
			change; int t;
			scanf("%d", &t);
			if (kind(i, j) == 1){
				FOR{
					DEF;
					int right = GET(h, (long long)j), down = GET(h, (long long)(j + 1));
					switch(t){
						case 0 : {		 
								if (right == 0 && down == 0){
									H[!now].insert(h, val);
								}
								if (right != 0 && down != 0 && right == down){
									H[!now].insert(CHA(CHA(h, j, 0), j + 1, 0), val + 1);
								}
								if ((right == 0 || down == 0) && (right + down != 0)){
									H[!now].insert(CHA(CHA(h, j, 0), j + 1, right + down), val + 1);
								}
								break;
						}
						case 4 : {
								if (right == 0 && down == 0) H[!now].insert(h, val);
								break;
						}
						default: {
								if (right == 0 && down == 0){
									H[!now].insert(CHA(h, j + 1, t), val + 1);
								}
								if ((right == 0 || down == 0) && (right + down == t)){
									H[!now].insert(CHA(CHA(h, j, 0), j + 1, 0), val + 1);
								break;
								}
						}
					}
				}
			}
			else{
				FOR{
					DEF;
					int left = GET(h, j); if (GET(h, j + 1)) cerr << "ERROR!" << endl;
					switch(t){
						case 0 : {
								if (left != 0){
									H[!now].insert(h, val + 1);
									H[!now].insert(CHA(CHA(h, j + 1, left), j, 0), val + 1);
								}
								if (left == 0){
									H[!now].insert(CHA(CHA(h, j + 1, 1), j, 1), val + 1);
									H[!now].insert(CHA(CHA(h, j + 1, 2), j, 2), val + 1);
									H[!now].insert(CHA(CHA(h, j + 1, 3), j, 3), val + 1);
									H[!now].insert(CHA(CHA(h, j + 1, 0), j, 0), val);
								}
								break;
						}
						case 4 : {
								if (left == 0) H[!now].insert(h, val);
								break;
						}
						default: {
								if (left == 0){
									H[!now].insert(CHA(h, j, t), val + 1);
									H[!now].insert(CHA(h, j + 1, t), val + 1);
								}
								if (left == t){
									H[!now].insert(CHA(h, j, 0), val + 1);
								}
								break;
						}

					}
				}
			}		
		}
		change;
		FOR{
			DEF;
			if (GET(h, LEN(i) + 1) == 0)
				H[!now].insert(h << (i < n - 1 ? 4 : (i == n - 1 ? 2 : 0)), val);
		}
	}
	FOR{
		DEF;
		if (h == 0){
			printf("%d %d\n", val.ans1 - 3, val.ans2);
			goto found;
		}
	}
	puts("-1 -1");
	found:;
}
}
Problem2285

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int MAXN = 10001, MAXM = 500001, SIZE = 32767;
int n, m, n1, m1, s, t;
double dis[MAXN], num[MAXN];
bool vis[MAXN];
int l, r, q[MAXN];
int h[MAXN], vh[MAXN];
struct Tgraph{
	int tot, e[MAXN], v[MAXM], next[MAXM];
	double wa[MAXM], wb[MAXM], c[MAXM];
	void add(int a, int b, double C, double D)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; wa[tot] = C; wb[tot] = D;
	}
	void add(int a, int b, double C)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = C;
	}
	bool spfa(int t, double k)
	{
		for (int i = 1; i <= n; i++) dis[i] = 1e99;
		for (int i = 1; i <= n; i++) vis[i] = false;
		vis[n] = true; dis[n] = 0.0; l = 0; r = 1; q[1] = n;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i ; i = next[i]) if (wa[i] - k * wb[i] + dis[x] < dis[v[i]]){
				dis[v[i]] =  wa[i] - k * wb[i] + dis[x];
				if (!vis[v[i]]) { vis[v[i]] = true; r = (r + 1) & SIZE; q[r] = v[i]; }
				}
			if (dis[t] < 0) return true;
			}
		return dis[t] < 0;
	}
	double getdis(int t)
	{
		spfa(t, 0); if (dis[t] > 1e50) return 1e99;
		double l = 0, r = 1e7;
		while(r - l > 1e-5){
			double m = (l + r) / 2;
			if (spfa(t, m)) r = m; else l = m;
			}
		return l;
	}	
	double aug(int x, double f)
	{
		if (x == t) return f;
		int minh = t - 1; double  augc = f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
			if (h[v[i]] + 1 == h[x]){
				double t = aug(v[i], min(f, c[i]));
				c[i] -= t; c[i ^ 1] += t; f -= t;
				if (fabs(f) < 1e-5 || h[s] == t) return augc - f;
				}
			if (h[v[i]] < minh) minh = h[v[i]];
			}
		if (augc == f){
			--vh[h[x]]; if (vh[h[x]] == 0) h[s] = t;
			h[x] = minh + 1; ++vh[h[x]];
			}
		return augc - f;
	}
	void maxflow()
	{
		tot = 1;
		vh[0] = t;
		double flow = 0.0;
		while(h[s] < t)
			flow += aug(s, 1e9);
		printf("%.1lf\n", flow);
	}
} g1, g2;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; double c, d;
		scanf("%d%d%lf%lf", &a, &b, &c, &d);
		g1.add(a, b, c, d);
		}
	scanf("%d%d", &m1, &n1);
	for (int i = 1; i <= n1; i++) num[i] = g1.getdis(i);
	for (int i = 1; i <= m1; i++){
		int a, b;
		scanf("%d%d", &a, &b);
		if (num[a] > 1e50 && num[b] > 1e50){
			puts("-1"); return 0;
			}
		g2.add(a, b, 1e9);
		}
	s = n1 + 1, t = s + 1;
	for (int i = 1; i <= n1; i++)
		if (i & 1){
			g2.add(s, i, min(num[i], 1e9));
			g2.add(i, s, 0);
			}
		else{
			g2.add(i, t, min(num[i], 1e9));
			g2.add(t, i, 0);
			}
	g2.maxflow();
}	
Problem2286

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
using namespace std;
const int MAXN = 1000001;
struct Tnode{
	static Tnode *a;
	int c[2], f, minv, val, _add;
	bool isroot;
	void add(int delta)
	{
		if (this != a){
			minv += delta; val += delta; _add += delta;
		}
	}
	void push()
	{
		if (_add != 0){
			a[c[0]].add(_add); a[c[1]].add(_add);
			_add = 0;
		}
	}
	void update()
	{
		minv = min(val, min(a[c[0]].minv, a[c[1]].minv));
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		int y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			int z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
void AC1(int x, int d, bool F)
{
	int p = 0, q = x;
	while(q){
		splay(q);
		if (A[q].f == 0 && F) { A[p].add(d); A[A[q].c[1]].add(d); }
	   	A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
	}
}
int AC2(int x)
{
	int p = 0, q = x, ret;
	while(q){
		splay(q);
		if (A[q].f == 0) ret = min(A[p].minv, A[A[q].c[1]].minv);
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].f;
	}
	return ret;
}
int n, tot, e[MAXN], v[MAXN * 2], w[MAXN * 2], next[MAXN * 2], q[MAXN];
bool vis[MAXN];
int tans[MAXN], who[MAXN];
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("repair.in", "r", stdin); freopen("repair.out", "w", stdout);
#endif
	A[0].minv = 0x3f3f3f3f;
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	int l = 1, r = 1; q[1] = 1; vis[1] = true; A[1].isroot = true;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
			A[v[i]].isroot = true; A[v[i]].val = A[v[i]].minv = w[i];
			A[v[i]].f = x; q[++r] = v[i]; vis[v[i]] = true;
		}
	}
	int TEST; scanf("%d", &TEST);
	while(TEST--){
		long long ans = 0;
		int num; scanf("%d", &num);
		for (int i = 1; i <= num; i++) scanf("%d", &who[i]);
		for (int i = 1; i <= num; i++){
			AC2(1); ans += tans[i] = AC2(who[i]);
			AC1(1, 0, 0); AC1(who[i], -tans[i], 1);
		}
		printf(LLD"\n", ans);
		for (int i = 1; i <= num; i++){
			AC1(1, 0, 0); AC1(who[i], tans[i], 1);
		}
	}
}
Problem2287

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[1000001], g[1000001], a[1000001], n, V;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &V);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	f[0] = 1;
	for (int i = 1; i <= n; i++)
		for (int j = V; j >= a[i]; j--) f[j] = (f[j - a[i]] + f[j]) % 10;
	for (int i = 1; i <= n; i++){
		for (int j = 0; j <= V; j++) g[j] = f[j];
		for (int j = a[i]; j <= V; j++) g[j] = ((f[j] - g[j - a[i]]) % 10 + 10) % 10;
		for (int j = 1; j <= V; j++) printf("%d", g[j]);
		putchar('\n');
	}

}
Problem2289

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
const double eps = 1e-8;
int sig(double t)
{
	if (fabs(t) < eps) return 0;
    if (t < 0) return -1;
	return 1;	
}
struct Tpoint{
	double x, y;
	void init() { scanf("%lf%lf", &x, &y); }
};
struct Tseg{
	double x1, x2;
	Tseg() { }
	Tseg(double x1, double x2) : x1(x1), x2(x2) { }
	bool operator * (const Tseg & A)
	{
		return sig(x2 - A.x1) > 0 && sig(A.x2 - x1) > 0;
	}
	Tseg & operator += (const Tseg & A)
	{
		if (A.x1 > x1) x1 = A.x1;
		if (A.x2 < x2) x2 = A.x2;
	}
};
struct Tcircle{
	Tpoint p; double r;
	void init() { p.init(); scanf("%lf", &r); }
	bool cut(double x)
	{
		return sig(r - fabs(x - p.x)) > 0;
	}
	Tseg get(double x)
	{
		double dy = sqrt(r * r - (x - p.x) * (x - p.x));
		return Tseg(p.y - dy, p.y + dy);
	}
} circle[1000001];
int n;
bool union_ex(double x)
{
	Tseg now(-1e20, 1e20);
	for (int i = 1; i <= n; i++){
		Tseg temp = circle[i].get(x);
		if (now * temp) now += temp; else return false;
	}
	return true;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	double l = -1e20, r = 1e20;
	for (int i = 1; i <= n; i++){
		circle[i].init(); 
		l = max(l, circle[i].p.x - circle[i].r);
		r = min(r, circle[i].p.x + circle[i].r);
	}
	while(1){
		double m = (l + r) / 2.0;
		bool d[2] = {0};
		for (int i = 1; i <= n; i++) if (!circle[i].cut(m)) d[circle[i].p.x >= m] = true;
		if (d[0] && d[1]) { puts("NO"); return 0; }
		if (!d[0] && !d[1]) { puts(union_ex(m) ? "YES" : "NO"); return 0; }
		if (d[0]) l = m; else r = m;
	}

	
}
Problem2292

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;
#define PII pair<int, int>
priority_queue<PII, vector<PII>, greater<PII> > Q;
const int MAXN = 1000001;
int n, m, tot, next[MAXN], e[MAXN], v[MAXN], w[MAXN], d[MAXN];
bool vis[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	while(m--){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
	}
	for (int i = 2; i <= n; i++) d[i] = 0x3f3f3f3f; Q.push(make_pair(0, 1));

	while(!Q.empty()){
		PII now = Q.top(); int x = now.second; Q.pop(); if (vis[x]) continue;
		for (int i = e[x]; i; i = next[i]) if (d[v[i]] > d[x] + w[i]){
			d[v[i]] = d[x] + w[i]; Q.push(make_pair(d[v[i]], v[i]));
		}
		vis[x] = true;
	}
	printf("%d\n", d[n]);
}
Problem2295

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const char s[10] = "luvletter";
int TEST;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST); scanf(" ");
while(TEST--){
	int now = 0, ret = 0; char c;
	while((c = getchar()) != '\n'){
		if (s[now] == c) { ++now; if (now == 9) ++ret, now = 0; }
	}
	printf("%d\n", ret);
}
}
Problem2298

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <map>
using std::sort;
using std::map;
using std::min;
using std::max;
using std::lower_bound;
int n, tot, l[1000001], r[1000001], v[1000001], last[1000001], f[1000001]; 
struct pair{
	int first, second;
	bool operator < (const pair & A) const { return second == A.second ? first < A.first : second < A.second; }
};
pair make_pair(int a, int b)
{
	pair temp; temp.first = a; temp.second = b;
	return temp;
}
map<pair, int> M;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int a, b; scanf("%d%d", &a, &b); if (a + b >= n) continue;
		++M[make_pair(b + 1, n - a)];
	}
	for (map<pair, int>::iterator mi = M.begin(); mi != M.end(); mi++){
		++tot; l[tot] = mi -> first.first; r[tot] = mi -> first.second; v[tot] = min(mi -> second, r[tot] - l[tot] + 1);
	}
	for (int i = 1; i <= tot; i++)
		last[i] = lower_bound(r + 1, r + tot + 1, l[i]) - r - 1;
	f[0] = 0;
	for (int i = 1; i <= tot; i++)
		f[i] = max(f[i - 1], f[last[i]] + v[i]);
	printf("%d\n", n - f[tot]);
}
Problem2299

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define yes { puts("Y"); goto hehe; }
#define g __gcd
using namespace std;
int main()
{
	int _a, _b, _x, _y;
	long long a, b, x, y;
int T; scanf("%d", &T);
while(T--){
	scanf("%d%d%d%d", &_a, &_b, &_x, &_y);
	a = _a; b = _b; x = _x; y = _y;
	int t = 2 * g(a, b);
	if (x % t == 0 && y % t == 0) yes
	if ((x - a) % t == 0 && (y - b) % t == 0) yes
	if ((x - b) % t == 0 && (y - a) % t == 0) yes
	if ((x - a - b) % t == 0 && (y - a - b) % t == 0) yes
	puts("N");
hehe:;
}

}
Problem2300

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <set>
#include <cmath>
#define Tsi set<Tpoint>::iterator
const double eps = 1e-6;
using namespace std;
struct Tq { int op, who; double ans; } q[1000001];
int dcmp(double a)
{
	if (fabs(a) < eps) return 0;
   	if (a < 0) return -1;
	if (a > 0) return 1;	
}
struct Tpoint{
	int x, y; double ang;
	void init() { scanf("%d%d", &x, &y); }
	void get() { ang = atan2(y, x); }
	Tpoint operator - (Tpoint A)
	{
		Tpoint temp; temp.x = x - A.x; temp.y = y - A.y; return temp;
	}
	int operator * (Tpoint A)
	{
		return x * A.y - y * A.x;
	}
	bool operator < (const Tpoint & A) const { return dcmp(ang - A.ang) > 0; }
	bool operator == (const Tpoint & A) const { return dcmp(ang - A.ang) == 0; }
};
double dis(Tpoint A, Tpoint B)
{
	return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
}
set<Tpoint> h;
Tpoint pre(Tpoint A)
{
	bool t = A < A;
	Tsi si = h.lower_bound(A);
	if (si == h.begin()) return *(--h.end()); else return *(--si);
}
Tpoint next(Tpoint A)
{
	Tsi si = h.upper_bound(A);
	if (si == h.end()) return *(h.begin()); else return *si;
}
Tpoint lower(Tpoint A)
{
	Tsi si = h.lower_bound(A);
	if (si == h.end()) return *(h.begin()); else return *si;
}
double now;
Tpoint ori;
void insert(Tpoint A)
{
	A = A - ori; A.get();
	Tpoint p = pre(A), l = lower(A), n = next(A);
	if (dcmp((l - p) * (A - p)) < 0) return;
	now = now - dis(p, l) + dis(A, p) + dis(A, l);
	if (l == A) { now = now - dis(l, n) + dis(A, n); h.erase(l); }
	while(h.size() > 2){
		Tpoint p = pre(A), pp = pre(p);
		if (dcmp((pp - A) * (p - A)) < 0) break;
		now = now - dis(A, p) - dis(p, pp) + dis(A, pp);
		h.erase(p);
	}
	while(h.size() > 2){
		Tpoint n = next(A), nn = next(n);
		if (dcmp((nn - A) * (n - A)) > 0) break;
		now = now - dis(A, n) - dis(n, nn) + dis(A, nn);
		h.erase(n);
	}
	h.insert(A);
}
Tpoint p[1000001];
bool cant[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int n, x, y, m;
	scanf("%d%d%d", &n, &x, &y);
	ori.x = n >> 1; ori.y = 0;
	Tpoint t1, t2, t3;
	t1.x = 0; t1.y = 0; t1 = t1 - ori; t1.get(); h.insert(t1);
	t2.x = n; t2.y = 0; t2 = t2 - ori; t2.get(); h.insert(t2);	
	t3.x = x; t3.y = y; t3 = t3 - ori; t3.get(); h.insert(t3);
	now = dis(t1, t3) + dis(t2, t3);
	scanf("%d", &m); for (int i = 1; i <= m; i++) p[i].init();
	int Q; scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		scanf("%d", &q[i].op);
		switch(q[i].op){
			case 1 : scanf("%d", &q[i].who);  cant[q[i].who] = true; break;
			case 2 : break;
		}
	}
	for (int i = 1; i <= m; i++) if (!cant[i]) insert(p[i]);
	for (int i = Q; i >= 1; i--)
		switch(q[i].op){
			case 2 : q[i].ans = now; break;
			case 1 : insert(p[q[i].who]); break;
		}
	for (int i = 1; i <= Q; i++) if (q[i].op == 2) printf("%.2lf\n", q[i].ans);
}
Problem2301

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXP = 50000;
int pnum, p[MAXP + 1], mo[MAXP + 1], mp[MAXP + 1];
bool notp[MAXP + 1];
void GETP()
{
	mo[1] = 1;
	for (int i = 2; i <= MAXP; i++){
		if (!notp[i]) { p[++pnum] = i; mo[i] = -1; mp[i] = i; }
		for (int j = 1; j <= pnum && i * p[j] <= MAXP; j++){
			notp[i * p[j]] = true; mp[i * p[j]] = p[j];
			if (mo[i] == 0 || p[j] == mp[i]) mo[i * p[j]] = 0;
			else mo[i * p[j]] = -mo[i];
			if (i % p[j] == 0) break;
		}
	}
}
int sum[MAXP + 1];
ll calc(int a, int b) //gcd(i, j) == 1
{
	ll ret = 0;
	if (a <= 0 || b <= 0) return 0;
	if (a > b) swap(a, b);
	for (int i = 1; i <= a;){
		int t = min(a / (a / i), b / (b / i));
		ret += (ll)(a / i) * (b / i) * (sum[t] - sum[i - 1]);
		i = t + 1;
	}
	return ret;
}
int main()
{
	GETP(); for (int i = 1; i <= MAXP; i++) sum[i] = sum[i - 1] + mo[i];
int TEST; scanf("%d", &TEST);
while(TEST--){
	int a, b, c, d, k;
	scanf("%d%d%d%d%d", &a, &b, &c, &d, &k);
	ll ans = calc(b / k, d / k) - calc((a - 1) / k, d / k) - calc(b / k, (c - 1) / k) + calc((a - 1) / k, (c - 1) / k);
	cout << ans << endl;
}
}
Problem2302

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, MO;
int C[1001][1001], f[1001][1001], sum[1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d%d", &n, &m, &MO);
	C[0][0] = 1;
	for (int i = 1; i <= n; i++){
		C[i][0] = 1;
		for (int j = 1; j <= i; j++)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
	}
	for (int i = 1; i <= n; i++)
	memset(sum, 0, sizeof(sum));
	memset(f, 0, sizeof(f));
	for (int i = 1; i <= m; i++) { int t; scanf("%*d%d", &t); ++sum[t]; }
	for (int i = n - 1; i >= 1; i--) sum[i] += sum[i + 1];
	f[n + 1][0] = 1;
	for (int i = n; i >= 1; i--){
		if (n - i + 1 - sum[i] < 0) { puts("NO"); goto kAc; }
		for (int j = 0; j <= n - i + 1 - sum[i]; j++)
			for (int k = 0; k <= j; k++)
				f[i][j] = (f[i][j] + (long long)f[i + 1][j - k] * C[j][k] % MO) % MO;
	}
	printf("YES %d\n", f[1][n - sum[1]]);
kAc:;
}
}
Problem2304

#include <cstdio>
#include <cstdlib>
#include <map>
#include <vector>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 400001, MAXM = 400001;
const int NONE = 0x3f3f3f3f;
int n, sx, sy, ex, ey, NOW;;
struct Tpoint{
	int x, y, who;
	bool operator < (const Tpoint & A) const
	{
		return x == A.x ? y < A.y : x < A.x;
	}
	bool operator == (const Tpoint & A) const
	{
		return x == A.x && y == A.y;
	}
};
int dis(Tpoint A, Tpoint B)
{
	return abs(A.x - B.x) + abs(A.y - B.y);
}
bool cmpX(Tpoint A, Tpoint B) 
{
	return A.x == B.x ? A.y < B.y : A.x < B.x;
}
bool cmpY(Tpoint A, Tpoint B)
{
	return A.y == B.y ? A.x < B.x : A.y < B.y;
} 
Tpoint makepoint(int x, int y)
{
	Tpoint temp; temp.x = x; temp.y = y;
	return temp;
}
vector<Tpoint> V[100001][4];
map<Tpoint, int> S;
struct Theapnode{
	int v; long long d;
	bool operator < (const Theapnode & A) const { return d < A.d; }
};
struct Theap{
	int size;
	Theapnode heap[MAXN];
	int hpos[MAXN];
	Theapnode & operator [] (int k) { return heap[k]; }
	void swap(int a, int b)
	{
		std::swap(heap[a], heap[b]);
		hpos[heap[a].v] = a; hpos[heap[b].v] = b;
	}
	void up(int a)
	{
		while(a != 1){
			if (heap[a] < heap[a >> 1]) swap(a, a >> 1); else break;
			a >>= 1;
			}
	}
	void down(int a)
	{
		a = a << 1;
		while(a <= size){
			if (a < size && heap[a + 1] < heap[a]) ++a;
			if (heap[a] < heap[a >> 1]) swap(a, a >> 1); else break;
			a <<= 1;
			}
	}
} H;
struct TGraph{
	int tot, n, s, t, e[MAXN], next[MAXM], v[MAXM];
	long long w[MAXM];
	Theap H;
	void clear() { tot = 0; memset(e, 0, sizeof(e)); }
	void add(int a, int b, long long c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; w[tot] = c;
	}
	void relax(int p, long long dis)
	{
		if (H.hpos[p] > H.size) return;
		H[H.hpos[p]].d = min(H[H.hpos[p]].d, dis);
		H.up(H.hpos[p]);
	}
	void Dijkstra()
	{
		for (int i = 1; i <= n; i++) H[i].d = 0x7fffffffffffffffll, H[i].v = i, H.hpos[i] = i;
		H[s].d = 0; H.swap(1, s); H.size = n;
		while(H.size){
			Theapnode t = H[1];
			H.swap(1, H.size); --H.size; H.down(1);
			if (t.d == 0x7fffffffffffffffll) continue;
			for (int i = e[t.v]; i; i = next[i])
				relax(v[i], t.d + w[i]);
			}
		t = H.hpos[t];
		if (H[t].d == 0x7fffffffffffffffll) cout << "No Path" << endl; else cout << H[t].d << endl; 
	}		
} G;
struct Taddpoint{
	Tpoint data[MAXN]; int num;
	void clear() { S.clear(); num = 0; }
	int addpoint(Tpoint a)
	{
		if (S.count(a)) return S[a];
		S[a] = num + 1;
		data[++num] = a; data[num].who = num;
		return num;
	}
	void solve()
	{
		G.s = 1; G.t = 2; G.n = num;
		G.Dijkstra();
	}
} AP;
struct Tsegmentree{ 
	int same[MAXN << 2], data[MAXN];
	void clear() { memset(same, 0x3f, sizeof(same)); }
	void push(int idx)
	{
		if (same[idx] != NONE){
			same[idx * 2] = same[idx * 2 + 1] = same[idx];
			}
		same[idx] = NONE;
	}
	int query(int idx, int l, int r, int x)
	{
		if (l == r) return same[idx];
		int m = l + r >> 1;
		push(idx);
		if (x <= data[m]) return query(idx * 2, l, m, x);
		else return query(idx * 2 + 1, m + 1, r, x);
	}
	void change(int idx, int l, int r, int ll, int rr, int num)
	{
		if (ll <= data[l] && rr >= data[r]){
			same[idx] = num; return;
			}
		push(idx);
		int m = l + r >> 1;
		if (ll <= data[m]) change(idx * 2, l, m, ll, rr, num);
		if (rr > data[m]) change(idx * 2 + 1, m + 1, r, ll, rr, num);
	}
} T;
struct Tscanpoint{
	int x, y1, y2, who; bool kind;
	
};
bool cmpS(Tscanpoint A, Tscanpoint B)
{
	return A.x == B.x ? A.kind > B.kind : A.x < B.x;
}
bool cmpB(Tscanpoint A, Tscanpoint B)
{
	return A.x == B.x ? A.kind > B.kind : A.x > B.x;
}
Tscanpoint makescanpoint(int x, int y1, int y2, int who, bool kind)
{
	Tscanpoint temp;
	temp.x = x; temp.y1 = y1; temp.y2 =y2; temp.kind = kind; temp.who = who;
	return temp;
}
struct Trect{
	Tpoint p, q;
	void init()
	{
		int x, y;
		scanf("%d%d", &x, &y); p = makepoint(x, y);
		scanf("%d%d", &x, &y); q = makepoint(x, y);
		if (p.x > q.x) swap(p.x, q.x);
		if (p.y > q.y) swap(p.y, q.y);
	}
} rect[MAXN];
typedef bool (*scancmp)(Tscanpoint, Tscanpoint);
struct Tscan{
	Tscanpoint scan[MAXN]; int scannum;
	void clear() { scannum = 0; }
	void addscanpoint(Tscanpoint A) { scan[++scannum] = A; }
	int getnow(int w)
	{
		if (w == NONE) return NONE;
		if (w == -1) if (NOW < 2) return sx; else return sy;
		if (w == -2) if (NOW < 2) return ex; else return ey;
		switch(NOW){
			case 0 : return rect[w].q.x;
			case 1 : return rect[w].p.x;
			case 2 : return rect[w].q.y;
			case 3 : return rect[w].p.y;
			}
		return 0;
	}
	void solve(scancmp cmp)
	{
		int tot = 0;
		T.clear();
		sort(scan + 1, scan + scannum + 1, cmp);
		for (int i = 1; i <= scannum; i++)
			T.data[++tot] = scan[i].y1, T.data[++tot] = scan[i].y2;
		sort(T.data + 1, T.data + tot + 1);
		tot = unique(T.data + 1, T.data + tot + 1) - T.data - 1;
		Tpoint temp;
		for (int i = 1; i <= scannum; i++)
			switch(scan[i].kind){
				case 0 :
					T.change(1, 1, tot, scan[i].y1, scan[i].y2, scan[i].who);
					break;
				case 1:
					int t1 = T.query(1, 1, tot, scan[i].y1);
					if (t1 != NONE){
						temp.x = getnow(t1); temp.y = scan[i].y1;
						if (NOW >= 2) swap(temp.x, temp.y);
						if (t1 > 0 && !S.count(temp)) V[t1][NOW].push_back(temp);
						t1 = AP.addpoint(temp);
						Tpoint TEMP;
						TEMP.x = scan[i].x; TEMP.y = scan[i].y1;
						if (NOW >= 2) swap(TEMP.x, TEMP.y);
						G.add(t1, AP.addpoint(TEMP), dis(temp, TEMP));
						}
					int t2 = T.query(1, 1, tot, scan[i].y2);
					if (t2 != NONE){
						temp.x = getnow(t2); temp.y = scan[i].y2;
						if (NOW >= 2) swap(temp.x, temp.y);
						if (t2 > 0 && !S.count(temp)) V[t2][NOW].push_back(temp);
						t2 = AP.addpoint(temp);
						Tpoint TEMP;
						TEMP.x = scan[i].x; TEMP.y = scan[i].y2;
						if (NOW >= 2) swap(TEMP.x, TEMP.y);
						G.add(t2, AP.addpoint(TEMP), dis(temp, TEMP));
						}
					break;
				}
	}
} SC;	
int main()
{
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d%d%d", &sx, &sy, &ex, &ey);
	scanf("%d", &n);
	G.clear(); AP.clear();
	AP.addpoint(makepoint(sx, sy));
	AP.addpoint(makepoint(ex, ey));
	for (int i = 1; i <= n; i++){
		rect[i].init();
		V[i][0].push_back(rect[i].q); V[i][0].push_back(makepoint(rect[i].q.x, rect[i].p.y));
		V[i][1].push_back(rect[i].p); V[i][1].push_back(makepoint(rect[i].p.x, rect[i].q.y));
		V[i][2].push_back(rect[i].q); V[i][2].push_back(makepoint(rect[i].p.x, rect[i].q.y));
		V[i][3].push_back(rect[i].p); V[i][3].push_back(makepoint(rect[i].q.x, rect[i].p.y));
		}
	rect[n + 1].p = rect[n + 1].q = makepoint(sx, sy);
	rect[n + 2].p = rect[n + 2].q = makepoint(ex, ey);
	NOW = 0;
	SC.clear();
	SC.addscanpoint(makescanpoint(sx, sy, sy, -1, 0));
	SC.addscanpoint(makescanpoint(ex, ey, ey, -1, 0));
	SC.addscanpoint(makescanpoint(sx, sy, sy, -2, 1));
	SC.addscanpoint(makescanpoint(ex, ey, ey, -2, 1));
	for (int i = 1; i <= n; i++){
		SC.addscanpoint(makescanpoint(rect[i].q.x, rect[i].p.y, rect[i].q.y, i, 0));
		SC.addscanpoint(makescanpoint(rect[i].p.x, rect[i].p.y, rect[i].q.y, i, 1));
		}
	SC.solve(cmpS);
	NOW = 1;
	SC.clear();
	SC.addscanpoint(makescanpoint(sx, sy, sy, -1, 0));
	SC.addscanpoint(makescanpoint(ex, ey, ey, -1, 0));
	SC.addscanpoint(makescanpoint(sx, sy, sy, -2, 1));
	SC.addscanpoint(makescanpoint(ex, ey, ey, -2, 1));
	
	for (int i = 1; i <= n; i++){
		SC.addscanpoint(makescanpoint(rect[i].p.x, rect[i].p.y, rect[i].q.y, i, 0));
		SC.addscanpoint(makescanpoint(rect[i].q.x, rect[i].p.y, rect[i].q.y, i, 1));
		}
	SC.solve(cmpB);
	NOW = 2;
	SC.clear();
	SC.addscanpoint(makescanpoint(sy, sx, sx, -1, 0));
	SC.addscanpoint(makescanpoint(ey, ex, ex, -1, 0));
	SC.addscanpoint(makescanpoint(sy, sx, sx, -2, 1));
	SC.addscanpoint(makescanpoint(ey, ex, ex, -2, 1));
	
	for (int i = 1; i <= n; i++){
		SC.addscanpoint(makescanpoint(rect[i].q.y, rect[i].p.x, rect[i].q.x, i, 0));
		SC.addscanpoint(makescanpoint(rect[i].p.y, rect[i].p.x, rect[i].q.x, i, 1));
		}
	SC.solve(cmpS);
	NOW = 3;
	SC.clear();
	SC.addscanpoint(makescanpoint(sy, sx, sx, -1, 0));
	SC.addscanpoint(makescanpoint(ey, ex, ex, -1, 0));
	SC.addscanpoint(makescanpoint(sy, sx, sx, -2, 1));
	SC.addscanpoint(makescanpoint(ey, ex, ex, -2, 1));
	
	for (int i = 1; i <= n; i++){
		SC.addscanpoint(makescanpoint(rect[i].p.y, rect[i].p.x, rect[i].q.x, i, 0));
		SC.addscanpoint(makescanpoint(rect[i].q.y, rect[i].p.x, rect[i].q.x, i, 1));
		}
	SC.solve(cmpB);
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < 4; j++){
			sort(V[i][j].begin(), V[i][j].end());
			for (int k = 0; k < int(V[i][j].size()) - 1; k++){
				int t1 = AP.addpoint(V[i][j][k]), t2 = AP.addpoint(V[i][j][k + 1]);
				G.add(t1, t2, dis(V[i][j][k], V[i][j][k + 1]));
				}
			}
	AP.solve();
	for (int i = 1; i <= n; i++)
		for (int j = 0; j < 4; j++)
			V[i][j].clear();
}	
}
Problem2306

#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
double f[101][101][101];
int n, m, v0;
double r, w[101], p[101];
bool ed[101][101];
void pre()
{
	for (int i = 0; i <= n; i++)
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= n; k++)
				f[i][j][k] = -1e9;
	for (int i = 1; i <= n; i++) f[0][i][i] = w[i];
	for (int d = 1; d <= n; d++)
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				for (int k = 1; k <= n; k++) if (ed[i][k] && f[d - 1][k][j] >= 0)
					f[d][i][j] = max(f[d][i][j], f[d - 1][k][j] * r + w[i]);
}
double get(int x)
{
	double ret = -1e9, circle = 0;
	for (int d = 1; d < n; d++)
		for (int i = 1; i <= n; i++) if (ed[i][x]){
			double t = f[d][x][i] / (1 - p[d + 1]);
			circle = max(circle, t);
		}
	for (int d = 0; d < n; d++){
		ret = max(ret, f[d][v0][x] + circle * p[d] - w[x] * p[d]);
		ret = max(ret, f[d][v0][x]);
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%lf", &w[i]); scanf("%d%lf", &v0, &r);
	p[0] = 1; for (int i = 1; i <= n; i++) p[i] = p[i - 1] * r;
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b);
		ed[a][b] = true;
	}	
	double ans = 0;
	pre();
	for (int i = 1; i <= n; i++){
		ans = max(ans, get(i));
	}
	printf("%.1lf\n", ans);
}
Problem2313

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 999999599;
const int p[4] = {2,13,5281,7283};
void exgcd(long long a, long long b, long long & x, long long & y)
{
	if (b == 0) { x = 1; y = 0; }
	else { exgcd(b, a % b, y, x); y -= (a / b) * x; }
}
int solve_modular(int a, int b, int c) //a * x mod b = c
{
	long long x, y; exgcd(a, b, x, y);
	x = ((x % b) + b) % b; x = (long long)x * c % b;
	return x;
}
int modans[4];
int crt()
{
	long long ans = 0;
	for (int i = 0; i < 4; i++){
		int x = solve_modular((MO - 1) / p[i], p[i], modans[i]);
		ans = (ans + (long long)x * ((MO - 1) / p[i]) % (MO - 1)) % (MO - 1);
	}
	return ans;
}
int pow(long long a, long long b, long long MO) //a ^ b % MO
{
	long long ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (long long) ret * a % MO;
		a = (long long) a * a % MO;
	}
	return int(ret);
}
const int MAXP = 100001;
int fac[4][MAXP], facinv[4][MAXP], inv[4][MAXP], now, mi, nowc;
void pre(int t)
{
	int now = p[t];
	fac[t][0] = facinv[t][0] = fac[t][1] = facinv[t][1] = 1;
	inv[t][1] = 1;
	for (int i = 2; i < now; i++){
		inv[t][i] = (long long) inv[t][now % i] * (now - now / i) % now;
		fac[t][i] = (long long) fac[t][i - 1] * i % now;
	}
}
int work(int n, int d)
{
	int ret = 1, part = n / now, rest = n % now;
	if (n < now) return fac[nowc][n];
	ret = (long long) pow(fac[nowc][now - 1], part, now) * fac[nowc][rest] % now;
	mi += d * part;
	return (long long) ret * work(n / now, d) % now;
}
void doit(int n, int m)
{
	mi = 0;
	int ret = inv[nowc][work(n / m, -1)]; ret = pow(ret, m, now); mi *= m;
	ret = (long long) ret * work(n, 1) % now;
	ret = (long long) ret * inv[nowc][work(m, -1)] % MO;
	if (mi == 0) modans[nowc] = (modans[nowc] + ret) % now; 
}
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d", &n, &m);
	for (int i = 0; i < 4; i++) pre(i);
	for (int i = 0; i < 4; i++) modans[i] = 0;
	for (nowc = 0; nowc < 4; nowc++){
		now = p[nowc];
		for (int i = 1; i * i <= n; i++) if (n % i == 0){
			doit(n, i);
			if (i * i != n) doit(n, n / i);
		}
	}
	printf("%d\n", pow(m, crt(), MO));
}
}
Problem2316

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int r[100001], n, m;
int sg(int x, int y)
{
    if (x == 0 || y == 0) return __builtin_ctz(x + y + 1);
    return x + y;
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
    scanf("%d%d", &n, &m);
    memset(r, 0, sizeof(r));
    for (int i = 0; i < n; i++){
        scanf(" ");
        for (int j = 0; j < m; j++){
            char c; scanf("%c", &c);
            if (c == 'T') r[sg(i, j)] ^= 1;
        }
    }
    for (int i = 0; i <= n + m; i++) if (r[i]) { puts("-_-"); goto end; }
    puts("=_=");
end:;
}
}
Problem2323

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
const int MO = 1000000007;
using namespace std;
int make(long long num)
{
	return (num % MO + MO) % MO;
}
struct Tm{
	int data[2][2];
	void init() { memset(this, 0, sizeof(*this)); }
	int * operator [] (int k) { return data[k]; }
	Tm operator * (const Tm & A)
	{
		Tm temp; temp.init();
		for (int k = 0; k < 2; k++)
			for (int i = 0; i < 2; i++)
				for (int j = 0; j < 2; j++)
					temp.data[i][j] = make(temp.data[i][j] + make((ll)data[i][k] * A.data[k][j]));
		return temp;
	}
	Tm operator + (const Tm & A)
	{
		Tm temp; temp.init();
		for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
				temp.data[i][j] = make(data[i][j] + A.data[i][j]);
		return temp;
	}
	Tm & operator = (const Tm & A)
	{
		memcpy(this, &A, sizeof(*this));
		return *this;
	}
} D, T, p[2001][10], f[2001];
int n, num[2001];
void predo()
{
	p[0][0] = D;
	for (int i = 1; i <= 9; i++) p[0][i] = p[0][i - 1] * T;
	for (int i = 1; i <= n; i++){
		p[i][0] = D;
		for (int j = 1; j <= 9; j++){
			p[i][j] = D;
			for (int k = 1; k <= 10; k++) p[i][j] = p[i][j] * p[i - 1][j];
		}
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) D[i][j] = i == j;
	for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) T[i][j] = !(i == 0 && j == 0);
	scanf("%d", &n); scanf(" ");
	for (int i = 1; i <= n; i++) num[i] = getchar() - '0';
	predo();
	f[0] = D;
	for (int i = 1; i <= n; i++){
		Tm now = p[0][num[i]];
		f[i] = f[i - 1] * now;
		for (int j = i - 2; j >= 0; j--){
			now = now * p[i - j - 1][num[j + 1]];
			f[i] = f[i] + f[j] * now;
		}
	}
	printf("%d\n", make(f[n][1][1] - f[n][1][0]));
}
Problem2324

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 100001, SIZE = 131071, MAXM = 300001;
struct Tcostflow{
	int flow, cost, s, t;
	int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM], w[MAXM]; //graph
	int dis[MAXN], f[MAXN], q[SIZE + 100], l, r; bool vis[MAXN]; //spfa
	void init() { tot = 1; flow = cost = 0; memset(e, 0, sizeof(e)); }
	void addedge(int A, int B, int C, int D)
	{
		//cerr << A << " " << B << " " << C << " " << D << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
	}
	bool spfa()
	{
		for (int i = 1; i <= t; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
		l = 0; r = 1; q[1] = s; vis[s] = true; dis[s] = 0;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i]; f[v[i]] = i;
				if (!vis[v[i]]) { r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true; }
			}
		}
		return dis[t] < 0x3f3f3f3f;
	}
	void aug()
	{
		int af = 0x3f3f3f3f;
		for (int i = t; i != s; i = v[f[i] ^ 1]) af = min(af, c[f[i]]);
		for (int i = t; i != s; i = v[f[i] ^ 1]) c[f[i]] -= af, c[f[i] ^ 1] += af;
		flow += af; cost += af * dis[t];
	}
	void run()
	{
		while(spfa()) aug();
	}
} costflow;
int n, m, k, map[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k); ++n;
	costflow.init();
	memset(map, 0x3f, sizeof(map));
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c); ++a; ++b;
		map[a][b] = min(map[a][b], c); map[b][a] = map[a][b];
	}
	costflow.s = 2 * n + 1; costflow.t = 2 * n + 2;
	for (int i = 2; i <= n; i++) costflow.addedge(2 * i - 1, 2 * i, 1, -1500000);
	costflow.addedge(1, 2, 0x3f3f3f3f, 0);
	for (int i = 1; i <= n; i++) costflow.addedge(2 * i, 2 * n + 2, 0x3f3f3f3f, 0);
	costflow.addedge(costflow.s, 1, k, 0);
	for (int i = 1; i <= n; i++) map[i][i] = 0;
	for (int k = 1; k <= n; k++){
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				if (map[i][k] < 0x3f3f3f3f && map[k][j] < 0x3f3f3f3f)
					map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
		for (int i = 1; i < k; i++) costflow.addedge(i * 2, k * 2 - 1, 0x3f3f3f3f, map[i][k]);
	}
	costflow.run();
	printf("%d\n", costflow.cost + (n - 1) * 1500000);
}
Problem2325

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 100001, INF = -(int)0xe0e0e0e0;
struct Tnode{
	static Tnode *a;
	int c[2], fa, dis[2][2], f[2][2], g[4];
	bool isroot;
   	void rot(bool b)
	{
		if (a[fa].isroot) a[fa].isroot = 0, isroot = 1;
		a[a[fa].c[b] = c[!b]].fa = fa; c[!b] = fa;
		fa = a[fa].fa; if (!isroot) a[fa].c[a[fa].c[1] == c[!b]] = this - a;
		a[c[!b]].fa = this - a; a[c[!b]].update();
	}
	void update()
	{
		memset(f, 0xe0, sizeof(f));
		for (int A = 0; A < 2; A++) for (int B = 0; B < 2; B++)	for (int C = 0; C < 2; C++) for (int D = 0; D < 2; D++)
			f[A][D] = max(f[A][D], a[c[0]].f[A][B] + dis[B][C] + a[c[1]].f[C][D]);
	   	for (int i = 0; i < 4; i++) g[i] = a[c[i >> 1]].g[i];
		for (int A = 0; A < 2; A++) for (int B = 0; B < 2; B++) for (int C = 0; C < 2; C++){
			g[A] = max(g[A], a[c[0]].f[A][B] + dis[B][C] + a[c[1]].g[C]);
			g[A + 2] = max(g[A + 2], a[c[1]].f[B][A] + dis[C][B] + a[c[0]].g[C + 2]);
		}
	}	
	void make(char a, char b)
	{
		if (a == '.' && b == '.') { dis[0][0] = dis[1][1] = 1; dis[0][1] = dis[1][0] = 2; return; }
		memset(dis, 0xe0, sizeof(dis));
		if (a == '#' && b == '#') return;
		if (a == '.') dis[0][0] = 1;
		if (b == '.') dis[1][1] = 1;
	}

} A[MAXN], *Tnode::a = A;
bool vis[MAXN];
int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2];
int n, Q;
void splay(int x)
{
	int y, z; bool b, c;
	while(!(A[x].isroot)){
		y = A[x].fa; b = x == A[y].c[1];
		if (!(A[y].isroot)){
			z = A[y].fa; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
void print(int x, int y, int z)
{
	int ans = max(A[x].g[2], A[x].g[3]);
	for (int a = 0; a < 2; a++)
		for (int b = 0; b < 2; b++)
			for (int c = 0; c < 2; c++)
				ans = max(ans, A[x].f[b][a] + A[y].dis[b][c] + A[z].g[c]);
	printf("%d\n", ans);
}
void access(int x, bool F)
{
	int p = 0, q = x;
	while(q != 0){
		splay(q);
		if (F && A[q].fa == 0) print(A[q].c[1], q, p);
		A[A[q].c[1]].isroot = true; A[q].c[1] = p; A[p].isroot = false;
		A[q].update();
		p = q; q = A[q].fa;
	}
}
void change(int x, char a, char b)
{
	splay(x);
	A[x].make(a, b); A[x].update();
}
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void bfs()
{
	static int Q[MAXN], l, r; static bool vis[MAXN];
	l = r = 1; Q[1] = 1; vis[1] = true;
	while(l <= r){
		int x = Q[l++];
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
			A[v[i]].fa = x; Q[++r] = v[i]; vis[v[i]] = true;
		}
	}
}
char s[2];
int main()
{
	scanf("%d%d", &n, &Q);
	A[0].f[0][1] = A[0].f[1][0] = -INF;
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	bfs();
	for (int i = 1; i <= n; i++){
		scanf(" ");
		scanf("%s", s);
		A[i].isroot = true;
		A[i].make(s[0], s[1]);
		A[i].update();
	}
	while(Q--){
		char ch;
		scanf(" ");
		scanf("%c", &ch);
		char op, a, b; int x, y;
		switch(ch){
			case 'Q' : scanf("%d%d", &x, &y); access(x, false); access(y, true); break;		
			case 'C' : default : scanf("%d", &x); scanf("%s", s); change(x, *s, *(s + 1)); break;
		}
	}
}
Problem2326

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll unsigned long long
using namespace std;
int MO;
struct Tmatrix{
	int data[3][3];
	void clear() { memset(data, 0, sizeof(data)); }
	int * operator [] (int k) { return data[k]; }
	void makeunit()
	{
		memset(data, 0, sizeof(data));
		for (int i = 0; i < 3; i++) data[i][i] = 1;
	}
	void makezy(int t)
	{
		memset(data, 0, sizeof(data));
		data[0][0] = t;
		data[1][0] = data[1][1] = 1;
		data[2][1] = data[2][2] = 1;
	}
	Tmatrix & operator *= (Tmatrix & A)
	{
		Tmatrix temp; temp.clear();
		for (int k = 0; k < 3; k++)
			for (int i = 0; i < 3; i++)
				for (int j = 0; j < 3; j++)
					temp[i][j] = ((ll)(data[i][k]) * A[k][j] % MO + temp[i][j]) % MO;
		for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) data[i][j] = temp[i][j];
		return *this;
	}
};
int ans;
void renew(ll l, ll r, int t)
{
	if (l > r) return;
	ll len = r - l + 1;
	Tmatrix now, g; now.makeunit(); g.makezy(t);
	for (; len; len >>= 1ll){
		if (len & 1ll) now *= g;
		g *= g;
	}
	ans = ((((long long)(ans) * now[0][0]) % MO) + ((l % MO * now[1][0]) % MO) + (now[2][0])) % MO;
}	
ll n;
long long pow[20];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> MO;
	pow[0] = 1;
	for (int i = 1; i < 19; i++) pow[i] = pow[i - 1] * 10ll;
	for (int i = 1; i < 19; i++){
		ll l = pow[i - 1], r = pow[i] - 1ll;
		r = min(r, n);
		renew(l, r, pow[i] % MO);
	}
	cout << ans << endl;
}
Problem2329

 #include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
const int MAXN = 600001;
using namespace std;
struct Tnode{
    static Tnode *a;
    int c[2], f, size, val, _same;
    int sum, lmax, lmin, rmax, rmin;
    bool _rev, _flip;
    void rev()
    {
        if (this != a){
            swap(c[0], c[1]); swap(lmax, rmax); swap(lmin, rmin);
            _rev ^= 1;
            }
    }
    void same(int c)
    {
		if (this != a){
			_flip = false;
			_same = c;
			sum = _same * size; val = _same;
			lmax = rmax = lmin = rmin = 0;
			if (_same > 0) lmax = rmax = size;
			else lmin = rmin = size;
		}
	}
    void flip()
    {
        if (this != a){
            swap(lmax, lmin); swap(rmax, rmin); sum *= -1; val *= -1;
            if (_same != 0) _same *= -1; else _flip ^= 1;
            }
    }
    void push()
    {
        if (_rev){
            a[c[0]].rev(); a[c[1]].rev(); _rev =false;
            }
        if (_flip){
            a[c[0]].flip(); a[c[1]].flip(); _flip = false;
            }
        if (_same != 0){
			a[c[0]].same(_same); a[c[1]].same(_same); _same = 0;
		}
    }
    void update()
    {
        size = a[c[0]].size + a[c[1]].size + 1;
        sum = a[c[0]].sum + a[c[1]].sum + val;
        lmax = max(a[c[0]].lmax, a[c[0]].sum + val + a[c[1]].lmax);
        rmax = max(a[c[1]].rmax, a[c[1]].sum + val + a[c[0]].rmax);
        lmin = max(a[c[0]].lmin, a[c[1]].lmin - val - a[c[0]].sum);
        rmin = max(a[c[1]].rmin, a[c[0]].rmin - val - a[c[1]].sum);
    }
    void rot(bool b)
    {
        a[f].push(); push();
        a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
        f = a[f].f; a[f].c[a[f].c[1] == c[!b]] = this - a;
        a[c[!b]].f = this - a; a[c[!b]].update();
    }
} A[MAXN], *Tnode::a = A;
char kh[MAXN];
int n, m, tot, root;
void splay(int x, int p)
{
    int y, z; bool b, c; A[x].push();
    while((y = A[x].f) != p){
        b = x == A[y].c[1];
        if ((z = A[y].f) != p){
            c = y == A[z].c[1];
            if (b == c) A[y].rot(b); else A[x].rot(b);
            A[x].rot(c);
            }
        else A[x].rot(b);
        }
    A[x].update(); if (p == 0) root = x;
}
int select(int k)
{
    int t = root, tt;
    while((tt = A[A[t].c[0]].size + 1) != k){
        A[t].push();
        if (k < tt) t = A[t].c[0];
        else k -= tt, t = A[t].c[1];
        }
    return t;
}
int build(int l, int r)
{
    if (l > r) return 0;
    int m = (l + r) >> 1, now = ++tot;
    if (kh[m] == '(') A[now].val = 1;
    if (kh[m] == ')') A[now].val = -1;
    A[now].c[0] = build(l, m - 1); A[A[now].c[0]].f = now;
    A[now].c[1] = build(m + 1, r); A[A[now].c[1]].f = now;
    A[now].update(); return now;
}
void QUERY(int l, int r)
{
    splay(select(l), 0); splay(select(r + 2), root);
    int now = A[A[root].c[1]].c[0];
    printf("%d\n", ((A[now].lmin + 1) >> 1) + ((A[now].rmax + 1) >> 1));
}
void FLIP(int l, int r)
{
    splay(select(l), 0); splay(select(r + 2), root);
    int now = A[A[root].c[1]].c[0]; 
    A[now].flip();
    splay(now, 0);
}
void REVERSE(int l, int r)
{
    splay(select(l), 0); splay(select(r + 2), root);
    int now = A[A[root].c[1]].c[0]; 
    A[now].rev();
    splay(now, 0);
}
void SAME(int l, int r, char c)
{
    splay(select(l), 0); splay(select(r + 2), root);
    int now = A[A[root].c[1]].c[0]; 
    A[now].same(c == '(' ? 1 : -1);
    splay(now, 0);
}
	
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d%d", &n, &m); scanf("%s", kh + 1);
    root = build(0, n + 1);
    while(m--){
        int l, r; char op[101], c;
		scanf("%s%d%d", &op, &l, &r);
        switch(*op){
            case 'Q': QUERY(l, r); break;
            case 'I': FLIP(l, r); break;
            case 'S': REVERSE(l, r); break;
            case 'R': scanf("%*c%c", &c); SAME(l, r, c);
            }
        }
                 
}
Problem2331

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define FORHASH for (int hi = 1; hi <= H[now].tot; hi++)
#define ADD(a, b) H[!now].add(h ^ ((a ^ b) << (j + j)), num)
const int MOD = 20110520, MO = 45432, MAXNODE = 3200001;
using namespace std;
struct Thash{
	int tot, e[MO + 100], next[MAXNODE], h[MAXNODE], num[MAXNODE];
	void clear() { memset(e, 0, sizeof(e)); tot = 0; }
	void add(int _h, int _num)
	{
		for (int i = e[_h % MO]; i; i = next[i]) if (h[i] == _h) { num[i] = (num[i] + _num) % MOD; return; }
		++tot; next[tot] = e[_h % MO]; e[_h % MO] = tot; h[tot] = _h; num[tot] = _num;
	}
} H[2];
int n, m;
char s[101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); getchar();
	for (int i = 0; i < n; i++) scanf("%s", s[i]);
	if (m > n) { for (int i = 0; i < n; i++) for (int j = i; j < m; j++) swap(s[i][j], s[j][i]); 	swap(n, m);}

	H[0].add(0, 1); int now = 0;
	for (int i = 0; i < n; i++){
		for (int j = 0; j < m; j++ ){
			if (s[i][j] == '*'){
				H[!now].clear();
				FORHASH 
					if (((H[now].h[hi] >> j + j) & 15) == 0) H[!now].add(H[now].h[hi], H[now].num[hi]);
				now ^= 1;
				continue;
			}
			H[!now].clear();
			FORHASH{
			int h = H[now].h[hi], num = H[now].num[hi];	
			switch((h >> j + j) & 15){
				case 0 : ADD(0, 5); ADD(0, 2); ADD(0, 8); break;
				case 1 : ADD(1, 0); ADD(1, 4); break;
				case 2 : ADD(2, 8); ADD(2, 1); break;
				case 4 : ADD(4, 1); ADD(4, 0); break;
				case 8 : ADD(8, 4); ADD(8, 2); break;
				case 10 : ADD(10, 0); break;
			}
			}
			now ^= 1;
		}
		H[!now].clear();
		FORHASH{
		int h = H[now].h[hi], num = H[now].num[hi];
		if (!(h >> (2 * m))) H[!now].add(h << 2, num);
		}
		now ^= 1;
	}
	FORHASH
	if (H[now].h[hi] == 0){
		printf("%d\n", H[now].num[hi]);
		return 0;
	}
	puts("0");
}
Problem2333

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 600001;
struct Tquery{
	int kind, a, b;
	void init()
	{
		char op[2];
		scanf("%s", op);
		if (op[0] == 'U') { scanf("%d%d", &a, &b); kind = 1; scanf("%d%d", &a, &b); }
		if (op[0] == 'A' && op[1] == '1') { kind = 2; scanf("%d%d", &a, &b); }
		if (op[0] == 'A' && op[1] == '2') { kind = 3; scanf("%d%d", &a, &b); }
		if (op[0] == 'A' && op[1] == '3') { kind = 4; scanf("%d", &a); }
		if (op[0] == 'F' && op[1] == '1') { kind = 5; scanf("%d", &a); }
		if (op[0] == 'F' && op[1] == '2') { kind = 6; scanf("%d", &a); }
		if (op[0] == 'F' && op[1] == '3') { kind = 7; }
	}
} query[MAXN];
int num[MAXN];
struct Tsegmentree
{
	int cover[MAXN * 4], maxnum[MAXN * 4];
	void _cover(int idx, int delta)
	{
		cover[idx] += delta; maxnum[idx] += delta;
	}
	void push(int idx)
	{
		if (cover[idx] != 0){
			_cover(idx * 2, cover[idx]);
			_cover(idx * 2 + 1, cover[idx]);
			cover[idx] = 0;
		}
	}
	void update(int idx)
	{
		maxnum[idx] = max(maxnum[idx * 2], maxnum[idx * 2 + 1]);
	}
	void build(int idx, int l, int r)
	{
		if (l == r) { maxnum[idx] = cover[idx] = num[l]; return; }
		int m = l + r >> 1;
		build(idx * 2, l, m);
		build(idx * 2 + 1, m + 1, r);
		update(idx);
	}
	int querymax(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return maxnum[idx];
		int m = l + r >> 1, ret = 0xe0e0e0e0;
		push(idx);
		if (ll <= m) ret = max(ret, querymax(idx * 2, l, m, ll, rr));
		if (rr > m) ret = max(ret, querymax(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}
	void makecover(int idx, int l, int r, int ll, int rr, int delta)
	{
		if (ll <= l && rr >= r) { _cover(idx, delta); return; }
		push(idx);
		int m = l + r >> 1;
		if (ll <= m) makecover(idx * 2, l, m, ll, rr, delta);
		if (rr > m) makecover(idx * 2 + 1, m + 1, r, ll, rr, delta);
		update(idx);
	}
} sgt;
int n, Q, tot;
int f[MAXN];
int getf(int v) { return v == f[v] ? v : f[v] = getf(f[v]); } 
int tail[MAXN], startnum[MAXN], next[MAXN], pos[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &startnum[i]);
	for (int i = 1; i <= n; i++) f[i] = i, tail[i] = i, next[i] = 0;
	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++) query[i].init();
	for (int i = 1; i <= Q; i++) if (query[i].kind == 1){
		int A = getf(query[i].a), B = getf(query[i].b);
		if (A == B) continue; f[A] = B;
		next[tail[B]] = A; tail[B] = tail[A];
	}
	for (int i = 1; i <= n; i++) if (getf(i) == i){
		for (int j = i; j; j = next[j]) { pos[j] = ++tot; num[tot] = startnum[j]; }
	}
	sgt.build(1, 1, n);
	for (int i = 1; i <= n; i++) f[i] = i, tail[i] = i, next[i] = 0;
	int A, B, t;
	for (int i = 1; i <= Q; i++) 
	switch(query[i].kind){
		case 1 : 
			A = getf(query[i].a), B = getf(query[i].b);
			if (A == B) break; f[A] = B;
			next[tail[B]] = A; tail[B] = tail[A];
			break;
		case 2 :
			sgt.makecover(1, 1, n, pos[query[i].a], pos[query[i].a], query[i].b);
			break;
		case 3 : 
			sgt.makecover(1, 1, n, pos[getf(query[i].a)], pos[tail[getf(query[i].a)]], query[i].b);
			break;
		case 4:
			sgt.makecover(1, 1, n, 1, n, query[i].a);
			break;
		case 5:
			printf("%d\n", sgt.querymax(1, 1, n, pos[query[i].a], pos[query[i].a]));
			break;
		case 6:
			t = getf(query[i].a);
			printf("%d\n", sgt.querymax(1, 1, n, pos[t], pos[tail[t]]));
			break;
		case 7:
			printf("%d\n", sgt.querymax(1, 1, n, 1, n));
			break;
	}
}
Problem2337

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;
const int MAXN = 1001;
vector<pair<int, int> > e[MAXN];
double a[MAXN][MAXN];
int n, m, where[MAXN];
double solve(int t)
{
	memset(a, 0, sizeof(a));
	for (int i = 1; i <= n - 1; i++){
		double s = e[i].size();
		a[i][i] = -1;
		for (int j = 0; j < e[i].size(); j++)
			if (e[i][j].second & (1 << t)) a[i][e[i][j].first] -= 1.0 / s, a[i][0] -= 1 / s;
			else a[i][e[i][j].first] += 1 / s;
	}
	a[n][n] = -1;
	for (int i = 1; i <= n; i++){
		int p = 1;
		for (int j = 2; j <= n; j++) if (fabs(a[i][j]) > fabs(a[i][p])) p = j;
		where[p] = i; double t = a[i][p];
		for (int j = 0; j <= n; j++) a[i][j] /= t;
		for (int j = 1; j <= n; j++) if (i != j){
			double kk = a[j][p];
			for (int k = 0; k <= n; k++) a[j][k] -= kk * a[i][k];
		}
	}
	return a[where[1]][0];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		e[a].push_back(make_pair(b, c)); if (a != b) e[b].push_back(make_pair(a, c));
	}
	double ans = 0;
	for (int i = 0; i < 31; i++)
		ans = ans + solve(i) * (1 << i);
	printf("%.3lf\n", ans);
}
Problem2338

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
#include <cmath>
#define PII pair<int, int>
#define PIII pair<pair<int, int>, long long>
#define PV pair<PIII, PII>
using namespace std;
int x[10001], y[10001], n, tot; long long ans;
PV buf[4000000];
double getdis(int a, int b)
{
	return sqrt((double)(x[a] - x[b]) * (double)(x[a] - x[b]) + (double)(y[a] - y[b]) * (double)(y[a] - y[b]));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++)
			buf[++tot] = make_pair(make_pair(make_pair(x[i] + x[j], y[i] + y[j]), (long long)(x[i] - x[j]) * (long long)(x[i] - x[j]) + (long long)(y[i] - y[j]) * (long long)(y[i] - y[j])), make_pair(i, j));
	sort(buf + 1, buf + tot + 1);
	for (int i = 1; i <= tot; i++)
		for (int j = i - 1; j >= 1; j--)
			if (buf[i].first != buf[j].first) break;
			else ans = max(ans, (long long)round(getdis(buf[i].second.first, buf[j].second.first) * getdis(buf[i].second.first, buf[j].second.second)));
	cout << ans << endl;				
}
Problem2338

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
#include <cmath>
#define PII pair<int, int>
#define PIII pair<pair<int, int>, long long>
#define PV pair<PIII, PII>
#define double long double
using namespace std;
int x[10001], y[10001], n, tot; long long ans;
PV buf[4000000];
double getdis(int a, int b)
{
	return sqrt((double)(x[a] - x[b]) * (double)(x[a] - x[b]) + (double)(y[a] - y[b]) * (double)(y[a] - y[b]));
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++)
			buf[++tot] = make_pair(make_pair(make_pair(x[i] + x[j], y[i] + y[j]), (long long)(x[i] - x[j]) * (long long)(x[i] - x[j]) + (long long)(y[i] - y[j]) * (long long)(y[i] - y[j])), make_pair(i, j));
	sort(buf + 1, buf + tot + 1);
	for (int i = 1; i <= tot; i++)
		for (int j = i - 1; j >= 1; j--)
			if (buf[i].first != buf[j].first) break;
			else ans = max(ans, (long long)round(getdis(buf[i].second.first, buf[j].second.first) * getdis(buf[i].second.first, buf[j].second.second)));
	cout << ans << endl;				
}
Problem2339

#include <cstdio>
const int MO = 100000007;
int pow(int a, int b)
{
	int now = 1;
	for (; b; b >>= 1){
		if (b & 1) now = (long long)now * a % MO;
		a = (long long)a * a % MO;
	}
	return now;
}
int f[2000001], n, m, N, P;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	f[1] = f[2] = 0;
	scanf("%d%d", &n, &m); N = pow(2, n) - 1;
	P = N;
	for (int i = 3; i <= m; i++){
		P = (long long) P * (N - i + 2) % MO;
		P = (P % MO + MO) % MO;
		f[i] = ((long long)P - f[i - 1] - ((long long)f[i - 2] * (i - 1) % MO) * (N - i + 2) % MO ) % MO;
		f[i] = (f[i] % MO + MO) % MO;
	}
	int ans = 1;
	for (int i = 1; i <= m; i++) ans = (long long) ans * i % MO; 
	ans = pow(ans, MO - 2); 
	ans = (long long) ans * f[m] % MO;
	printf("%d\n", ans);
}
Problem2342

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
char s[1000001], in[1000001];
int n, a[1000001];
struct Tsgt{
	int data[4000001];
	Tsgt() { memset(data, 0x3f, sizeof(data)); }
	void insert(int idx, int l, int r, int x)
	{
		if (l == r) { data[idx] = x; return; }
		int m = l + r >> 1;
		if (x <= m) insert(idx * 2, l, m, x);
		else insert(idx * 2 + 1, m + 1, r, x);
		data[idx] = min(data[idx * 2], data[idx * 2 + 1]);
	}
	int getmin(int idx, int l, int r, int ll, int rr)
	{
		if (ll > rr) return 0x3f3f3f3f;
		if (ll <= l && rr >= r) return data[idx];
		int m = l + r >> 1, ret = 0x3f3f3f3f;
		if (ll <= m) ret = min(ret, getmin(idx * 2, l, m, ll, rr));
		if (rr > m) ret = min(ret, getmin(idx * 2 + 1, m + 1, r, ll, rr));
		return ret;
	}
} sgt;
struct Tscan{
	int kind, pos, who;
	bool operator < (const Tscan & a) const
	{
		return pos == a.pos ? kind < a.kind : pos > a.pos;
	}
	Tscan() { }
	Tscan(int kind, int pos, int who) : kind(kind), pos(pos), who(who) { }
} sc[4000001];
void manacher()
{
    int far = 1, id = 1;
    a[1] = 1; s[0] = '!'; s[n + 1] = '@';
    for (int i = 2; i <= n; i++){
        if (far >= i) a[i] = min(a[id * 2 - i], far - i + 1);
        while(s[i + a[i]] == s[i - a[i]]) ++a[i];
        if (i + a[i] - 1 >= far) { far = i + a[i] - 1; id = i; }
    }
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%*d"); scanf(" ");
    gets(in); n = strlen(in);
    for (int i = 1; i <= 2 * n + 1; i++){
        if (i & 1) s[i] = '*'; else s[i] = in[i / 2 - 1];
    }
    n = 2 * n + 1;
    manacher();
    int ans = 0, sctot = 0;
	for (int i = 1; i <= n; i += 2){
		sc[++sctot] = Tscan(1, i, i);
		sc[++sctot] = Tscan(0, i + a[i] - 1, i);
	}
	sort(sc + 1, sc + sctot + 1);
	for (int i = 1; i <= sctot; i++)
		switch(sc[i].kind){
			case 0 : sgt.insert(1, 1, n, sc[i].who); break; 
			case 1 :  {
				int t = sgt.getmin(1, 1, n, sc[i].who - a[sc[i].who] / 2, sc[i].who - 1);
				if (t == 0x3f3f3f3f) continue;
				ans = max(sc[i].who - t + 1, ans);
			}
			
		}
	cout << ans / 2 * 4 <<endl;		
}
Problem2346

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
#define PII pair<int, int>
using namespace std;
const int MAXN = 1000001;
struct Tgraph{
	int tot, e[MAXN], v[MAXN], w[MAXN], next[MAXN], n, dis[MAXN];
	priority_queue<PII, vector<PII>, greater<PII> > Q;
	bool vis[MAXN];
	void add(int a, int b, int c)
	{
	//	cerr << a << " " << b << " " << c << endl;
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; w[tot] = c;
	}
	int dijkstra()
	{
		for (int i = 1; i <= n; i++) dis[i] = 0x3f3f3f3f; dis[1] = 0;
		Q.push(make_pair(0, 1));
		while(!Q.empty()){
			int x = Q.top().second; Q.pop(); if (vis[x]) continue; vis[x] = true;
			for (int i = e[x]; i; i = next[i]) if (dis[x] + w[i] < dis[v[i]]){
				dis[v[i]] = dis[x] + w[i]; Q.push(make_pair(dis[v[i]], v[i]));
			}
		}
		return dis[n];
	}
} graph;
int n, m; char map[1001][1001];
int change(int x, int y) { return (x - 1) * (m + 1) + y; }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); scanf(" ");
	if ((n + m) & 1) { puts("NO SOLUTION"); return 0; }
	for (int i = 1; i <= n; i++) scanf("%s", map[i] + 1);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if ((i + j) & 1)
				graph.add(change(i + 1, j), change(i, j + 1), map[i][j] != '/');
			else graph.add(change(i, j), change(i + 1, j + 1), map[i][j] != '\\');
	graph.n = (n + 1) * (m + 1);
	printf("%d\n", graph.dijkstra());
}
Problem2351

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;
const int modb = 223092869, moda = 497668711, randb = 10101107, randa = 3010101;
int mi[2001], A[2001][2001], B[2001][2001], hashb[2001][2001], hasha[2001][2001];
int n, m, a, b;
inline int mul(int a,int b,int P) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n" 
            :"=d"(ret):"a"(a),"b"(b),"c"(P));
    return ret;
}
void predo()
{
	mi[0] = 1;
	for (int i = 1; i <= b; i++) mi[i] = mul(mi[i - 1], randb, modb);
	for (int i = 1; i <= n; i++){
		int now = 0;
		for (int j = 1; j <= b; j++) now = ((long long) mul(A[i][j], mi[b - j], modb) + now) % modb;
		for (int j = 1; j <= m - b + 1; j++){
			hashb[i][j] = now;
			if (j != m - b + 1){
				now = (now - mul(A[i][j], mi[b - 1], modb)) % modb;
				now = (long long) now * randb % modb;
				now = (now + A[i][j + b]) % modb;
				now = (now + modb) % modb;
			}
		}
	}
	for (int i = 1; i <= a; i++) mi[i] = mul(mi[i - 1], randa, moda);
	for (int j = 1; j <= m - b + 1; j++){
		int now = 0;
		for (int i = 1; i <= a; i++) now = ((long long) mul(hashb[i][j], mi[a - i], moda) + now) % moda;
		for (int i = 1; i <= n - a + 1; i++){
			hasha[i][j] = now;
			if (i != n - a + 1){
				now = (now - mul(hashb[i][j], mi[a - 1], moda)) % moda;
				now = (long long) now * randa % moda;
				now = (now + hashb[i + a][j]) % moda;
				now = (now + moda) % moda;
			}
		}
	}

}
int temp[2001];
int gethash()
{
	int ret = 0;
	for (int i = 1; i <= a; i++){
		int now = 1;
		temp[i] = 0;
		for (int j = b; j >= 1; j--) temp[i] = ((long long) now * B[i][j] + temp[i]) % modb, now = (long long) now * randb % modb;
	}
	int now = 1;
	for (int i = a; i >= 1; i--) ret = ((long long) now * temp[i] + ret) % moda, now = (long long) now * randa % moda;
	for (int i = 1; i <= n - a + 1; i++)
		for (int j = 1; j <= m - b + 1; j++)
			if (hasha[i][j] == ret) return 1;
	return 0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &a, &b);
	for (int i = 1; i <= n; i++){
		scanf(" ");
		for (int j = 1; j <= m; j++)
			scanf("%c", &A[i][j]);
	}
	predo();
	int Q; scanf("%d", &Q);
	while(Q--){
		for (int i = 1; i <= a; i++){
			scanf(" ");
			for (int j = 1; j <= b; j++)
				scanf("%c", &B[i][j]);
		}
		printf("%d\n", gethash());
	}
}
Problem2352

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Top{
	int kind, l, r;
	Top() { }
	Top(int kind, int l, int r = 0) : kind(kind), l(l), r(r) { }
} op[1000001];
struct Tdiscre{
	int data[1000001], n;
	int & operator [] (int k) { return data[k]; }
	void init()
	{
		sort(data + 1, data + n + 1);
		n = unique(data + 1, data + n + 1) - data - 1;
	}
	int convert(int x)
	{
		return lower_bound(data + 1, data + n + 1, x) - data;
	}
} discre;
struct Tbit{
	int data[1000001];
	void add(int x)
	{
		for (; x <= discre.n; x += (x & (-x))) data[x]++; 
	}
	int get(int x)
	{
		int ret = 0;
		for (; x; x -= (x & (-x))) ret += data[x];
		return ret;
	}
} bit;
int Q;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		int op, x, l, r; scanf("%d", &op);
		switch(op){
			case 0 : scanf("%d", &x); discre[++discre.n] = x; ::op[i] = Top(0, x); break; 
			case 1 : scanf("%d%d", &l, &r); ::op[i] = Top(1, l, r); discre[++discre.n] = l; discre[++discre.n] = r;  break;
		}
	}
	discre.init();
	for (int i = 1; i <= Q; i++)
		switch(op[i].kind){
			case 0 : bit.add(discre.convert(op[i].l)); break;
			case 1 : printf("%d\n", bit.get(discre.convert(op[i].r)) - bit.get(discre.convert(op[i].l) - 1));
		}
}
Problem2375

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[3000001], x[3000001], n, m, p, q;
int find(int x)
{
	int t = x, temp;
	while(f[t] != t) t = f[t];
	while(x != t){
		temp = x; x = f[x]; f[temp] = t;
	}
	return t;	
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &p, &q);
	for (int i = 1; i <= n + 1; i++) f[i] = i;
	for (int i = m; i > m - n; i--){
		int l = (i * p + q) % n + 1, r = (i * q + p) % n + 1;
		if (l > r) swap(l, r);
		while(1){
			l = find(l);
			if (l > r) break;
			x[l] = i; f[l] = l + 1;
		}
	}
	for (int i = 1; i <= n; i++) printf("%d\n", x[i]);

}
Problem2384

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int next[1000001], prev[1000001], where[1000001], big[1000001], small[1000001], a[1000001], b[1000001], tb[1000001], ans[1000001], tot;
int n, m;
void init()
{
	for (int i = 1; i <= m; i++) next[i] = i + 1, prev[i] = i - 1, where[b[i]] = i;
	for (int i = m; i >= 1; i--){
		int x = b[i];
		if (next[x] != m + 1) big[i] = where[next[x]]; else big[i] = -1;
		if (prev[x] != 0) small[i] = where[prev[x]]; else small[i] = -1;
		if (next[x] != m + 1) prev[next[x]] = prev[x];
		if (prev[x] != 0) next[prev[x]] = next[x];
	}
}
bool cmp(int *a, int A, int B)
{
	if (big[B] != -1 && a[A - (B - big[B])] < a[A]) return false;
	if (small[B] != -1 && a[A - (B - small[B])] > a[A]) return false;
	return true;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &m, &n);
	for (int i = 1; i <= m; i++) scanf("%d", tb + i);
	for (int i = 1; i <= m; i++) b[tb[i]] = i; 
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	init();
	int j = 0; next[1] = 0;
	for (int i = 2; i <= m; i++){
		while(j > 0 && !cmp(b, i, j + 1)) j = next[j];
		if (cmp(b, i, j + 1)) ++j;
		next[i] = j;
	}
	j = 0;
	for (int i = 1; i <= n; i++){
		while(j > 0 && !cmp(a, i, j + 1)) j = next[j];
		if (cmp(a, i, j + 1)) ++j;
		if (j == m) { ans[++tot] = i - j + 1; j = next[j]; }
	}
	printf("%d\n", tot);
	for (int i = 1; i <= tot; i++) printf("%d", ans[i]), putchar(i == tot ? '\n' : ' ');
}
Problem2386

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int a[2000001], f[2000001], n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	f[0] = 0;
	for (int i = 1; i <= n; i++){
		if (a[i] > i) f[i] = max(f[i - 1], (int)0xe0e0e0e0);
		else f[i] = max(f[i - 1], f[i - a[i]] + 1);
	}
	printf("%d\n", n >= a[n] ? max(f[n - a[n]] + 1, 0) : 0);
}
Problem2388

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif
using namespace std;
const int MAXQN = 333 + 100, MAXN = 100000;
struct Tpoint{
	ll x, y;
	Tpoint() { }
	Tpoint(ll x, ll y) : x(x), y(y) { }
	bool operator * (const Tpoint & A) const
	{
		ll ret = x * A.y - y * A.x;
		return ret <= 0;
	}
	Tpoint operator - (const Tpoint & A)
	{
		return Tpoint(x - A.x, y - A.y);
	}
};
struct Tblock{
	Tpoint indata[MAXQN], data[MAXQN]; ll delta, num[MAXQN]; int n, tot;
	void addpoint(Tpoint A) { indata[++n] = A; indata[n].y += indata[n - 1].y; }
	void init()
	{
		tot = 0;
		for (int i = 1; i <= n; i++){
			num[i] = indata[i].y;
			while(tot >= 2 && (indata[i] - data[tot - 1]) * (data[tot] - data[tot - 1])) --tot;
			data[++tot] = indata[i];
		}
		data[0] = data[1]; data[tot + 1] = data[tot];
		data[0].y = data[tot + 1].y = -100000000000000ll;		
	}
	void push()
	{
		for (int i = 1; i <= n; i++) indata[i].y += delta * i;
		delta = 0;
	}
	void rebuild(int l, int r, ll d)
	{
		push();
		for (int i = l; i <= r; i++) indata[i].y += d * (i - l + 1);
		for (int i = r + 1; i <= n; i++) indata[i].y += d * (r - l + 1);
		init();
	}
	ll getsum()
	{
		return num[n] + delta * n;
	}
	ll getsum(int k)
	{
		return num[k] + delta * k;
	}
	ll getmaxsum(int l, int r)
	{
		ll ret = 0xe0e0e0e0e0e0e0e0ll;
		for (int i = l; i <= r; i++) ret = max(ret, getsum(i));
		return ret;
	}
	ll getmaxsum()
	{
		int l = 1, r = tot;
		while(l <= r){
			int m = l + r >> 1;
			if (data[m].y + delta * data[m].x >= data[m - 1].y + delta * data[m - 1].x) l = m + 1; else r = m - 1;
		}
		return data[r].y + delta * data[r].x;
	}
};
struct Tdatastructure{
	Tblock data[MAXN / MAXQN + 100]; int N, tot, n, where[MAXN], which[MAXN];
	Tdatastructure() { n = 1; }
	void addpoint(Tpoint A)
	{
		++tot;
		if (data[n].n == N) ++n;
		where[tot] = data[n].n + 1; which[tot] = n;
		A.x = data[n].n + 1;
		data[n].addpoint(A);
	}
	void init()
	{
		for (int i = 1; i <= n; i++) data[i].init();
	}
	void change(int l, int r, ll d)
	{
		int posl = which[l], posr = which[r];
		if (posl == posr){
			data[posl].rebuild(where[l], where[r], d);
			return;
		}
		data[posl].rebuild(where[l], data[posl].n, d);
		data[posr].rebuild(1, where[r], d);
		for (int i = posl + 1; i <= posr - 1; i++) data[i].delta += d;
	}
	ll query(int l, int r)
	{
		int posl = which[l], posr = which[r]; ll sum = 0, ans = 0xe0e0e0e0e0e0e0e0ll;
		for (int i = 1; i < posl; i++) sum += data[i].getsum();
		if (posl == posr) return data[posl].getmaxsum(where[l], where[r]) + sum;
		ans = max(ans, sum + data[posl].getmaxsum(where[l], data[posl].n)); sum += data[posl].getsum();
		for (int i = posl + 1; i <= posr - 1; i++){
			ans = max(ans, sum + data[i].getmaxsum());
			sum += data[i].getsum();
		}
		ans = max(ans, sum + data[posr].getmaxsum(1, where[r]));
		return ans;
	}
} ds;
int n; ll sum[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (ds.N = 1; ds.N * ds.N < n; ds.N++); 
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t);
		ds.addpoint(Tpoint(i, t));
	}
	ds.init();
	int Q; scanf("%d", &Q);
	while(Q--){
		int op, x, y, k; scanf("%d", &op);
		switch(op){
			case 0 : scanf("%d%d%d", &x, &y, &k); ds.change(x, y, k); break;
			case 1 : scanf("%d%d", &x, &y); printf(LLD"\n", ds.query(x, y)); break;
		}
	}

}
Problem2393

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#define ll long long
using namespace std;
ll L, R;
vector<ll> divs;
ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }
void gen(ll num, ll R)
{
	if (num > R) return;
	if (num > 0) divs.push_back(num);
	gen(num * 10 + 2, R); gen(num * 10 + 9, R);
}
ll ret;
ll calc(int dep, ll t, ll R)
{
	if (dep == divs.size()) return R / t;
	if (R < t) return 0;
	return calc(dep + 1, t, R) - calc(dep + 1, lcm(t, divs[dep]), R);
}
ll calc(ll R)
{
	divs.clear();
	gen(0, R);
	sort(divs.rbegin(), divs.rend());
	ret = 0;
	return R - calc(0, 1, R);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> L >> R;
	cout << calc(R) - calc(L - 1) << endl;
}
Problem2396

#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
const int kAc = 15; 
struct Tmatrix{ 
    int d[1001][1001], r, c; 
    }a, b, c, d, matrix[4]; 
int n; 
  
void rand_vector() 
{ 
    for (int i = 1; i <= n; i++) a.d[1][i] = rand() % 1000; a.r = 1; a.c = n; 
} 
int main() 
{ 
srand(5); 
while(~scanf("%d", &n)){ 
    for (int i = 1; i <= 3; i++) 
        for (int j = 1; j <= n; j++) 
            for (int k = 1; k <= n; k++) 
                scanf("%d", &matrix[i].d[j][k]); 
    bool can = true; 
    for (int i = 1; i <= kAc; i++){   
        for (int j = 1; j <= n; j++) a.d[1][j] = b.d[1][j] = c.d[1][j] = d.d[1][j] = 0; 
        rand_vector(); 
        for (int i = 1; i <= n; i++) 
            for (int j = 1; j <= n; j++) 
                b.d[1][j] += a.d[1][i] * matrix[1].d[i][j]; 
        for (int i = 1; i <= n; i++) 
            for (int j = 1; j <= n; j++) 
                c.d[1][j] += b.d[1][i] * matrix[2].d[i][j]; 
        for (int i = 1; i <= n; i++) 
            for (int j = 1; j <= n; j++) 
                d.d[1][j] += a.d[1][i] * matrix[3].d[i][j]; 
        for (int i = 1; i <= n; i++) if (c.d[1][i] != d.d[1][i]){ 
            can = false; 
            break; 
            } 
        if (!can) break; 
        } 
    puts(can ? "Yes" : "No"); 
    } 
} 
Problem2401

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#ifdef __int64
	#define LLD "%I64d\n"
#else
	#define LLD "%lld\n"
#endif
using namespace std;
int TEST;
long long prime[1000001], pnum, f[1000001], oth[1000001];
bool notp[1000001];
struct Tbig{
	int len, data[11];
	Tbig() { len = 1; memset(data, 0, sizeof(data)); }
	int & operator [] (int k) { return data[k]; }
	const int & operator [] (int k) const { return data[k]; }
	Tbig(long long t)
	{
		memset(data, 0, sizeof(data));
		len = 1;
		while(t != 0){
			data[len] = t % 10000;
			t /= 10000;
			if (t != 0) ++len;
		}
	}
	void operator += (const Tbig & A)
	{
		len = max(A.len, len);
		for (int i = 1; i <= len; i++){
			data[i] += A[i];
			data[i + 1] += data[i] / 10000;
			data[i] %= 10000;
		}
		while(data[len + 1]) ++len;
	}
	void output()
	{
		printf("%d", data[len]);
		for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]); putchar('\n');
	}
} sum[1000001], ans;
void GET(long long MAX)
{
    f[1] = 1;
    for (long long i = 2; i <= MAX; i++){
        if (!notp[i]){
                prime[++pnum] = i; oth[i] = 1ll;
                f[i] = i * i - i + 1;
                }
        for (int j = 1; j <= pnum && i * prime[j] <= MAX; j++){
            notp[i * prime[j]] = true;
            if (i % prime[j] == 0){
                oth[i * prime[j]] = oth[i];
                long long pk = i * prime[j] / oth[i * prime[j]];
                f[i * prime[j]] = f[oth[i]] * (pk * pk * prime[j] + 1) / (1 + prime[j]);
                break;
                }
            else{
                oth[i * prime[j]] = i;
                f[i * prime[j]] = f[i] * (1 + prime[j] * prime[j] * prime[j]) / (1 + prime[j]);
                }
            }
        }
}   
int main()
{
	GET(1000000ll);
	for (int i = 1; i <= 1000000; i++){
		long long temp =  (f[i] + 1) * i / 2 - i;
		sum[i] = sum[i - 1];
		sum[i] += (Tbig)temp;
	}
	int TEST; scanf("%d", &TEST);
	while(TEST--){
		int t; scanf("%d", &t); 
		ans = sum[t]; ans += sum[t]; ans += (Tbig)((long long)(t + 1) * t / 2);
		ans.output();
	}
}   
Problem2423

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tstate{
	int f, g;
	Tstate inc() { Tstate temp = *this; ++temp.f; return temp; }
	Tstate & operator += (Tstate A)
	{
		if (f < A.f) { *this = A; return *this; }
		if (f > A.f) return *this;
		if (f != 0 )g = (A.g + g) % 100000000; return *this;
	}
} last[10001], now[10001];
Tstate make(int _f, int _g)
{
	Tstate temp; temp.f = _f; temp.g = _g; return temp;
}
char s1[10001], s2[10001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s%s", s1, s2);
	s1[strlen(s1) - 1] = 0; s2[strlen(s2) - 1] = 0;
	int n = strlen(s1), m = strlen(s2);
	last[0] = make(0, 1);
	for (int i = 0; i < n; i++){
		Tstate t = make(0, 1);
		for (int j = 0; j < m; j++){
			if (s1[i] == s2[j]) now[j] += t.inc();
			t += last[j];
		}
		memcpy(last, now, sizeof(last));
	}
	Tstate ans; ans = make(0, 1);
	for (int i = 0; i < m; i++) ans += now[i];
	printf("%d\n%d\n", ans.f, ans.g);
}
Problem2424

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
int u[10001], d[10001], f[101][20001];
int n, m, S;
using namespace std;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &S);
	for (int i = 1; i <= n; i++) scanf("%d", &u[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i]);
	memset(f, 0x3f, sizeof(f));
	f[0][0] = 0;
	for (int i = 1; i <= n; i++){
		int MQ = 0x3f3f3f3f;
		for (int j = 0; j < u[i]; j++) MQ = min(MQ, f[i - 1][j] + j * (m - d[i]));
		for (int j = 0; j <= S; j++){
			MQ = min(MQ, f[i - 1][u[i] + j] + (u[i] + j) * (m - d[i]));
			f[i][j] = MQ + d[i] * (u[i] + j);
		}
	}
	printf("%d\n", f[n][0]);			
}
Problem2425

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int p[15] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
using namespace std;
struct Tnum{
	int data[15];
	Tnum() { memset(data, 0, sizeof(data)); }
	Tnum & operator *= (int k)
	{
		for (int i = 0; i < 15; i++) { while(k % p[i] == 0) ++data[i], k /= p[i]; }
	}
	Tnum & operator /= (int k)
	{
		for (int i = 0; i < 15; i++) { while(k % p[i] == 0) --data[i], k /= p[i]; }
	}
	operator long long()
	{
		long long ret = 1;
		for (int i = 0; i < 15; i++) for (int j = 1; j <= data[i]; j++) ret = ret * p[i];
		return ret;
	}
};
char s[1000001];
long long ans;
int num[101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%s", s);
	int n = strlen(s);
	for (int i = 0; i < n; i++) num[s[i] - '0']++;
	for (int i = 0; i < n - 1; i++){
		for (int j = 0; j < s[i] - '0'; j++) if (num[j] > 0){
			--num[j];
			Tnum t;
			for (int j = 1; j < n - i; j++) t *= j;
			for (int i = 0; i < 10; i++) for (int j = 1; j <= num[i]; j++) t /= j;
			ans += (long long) t;
			++num[j];
		}
		--num[s[i] - '0'];
	}
	cout << ans << endl;
			
}
Problem2426

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, b;
int sum, a[100001], cost[61][60001], delta[100001], id[100000], h[100001]; 
bool cmp(int a, int b)
{
	return delta[a] < delta[b];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &m, &b, h, &n);
	for (int i = 1; i <= m; i++) scanf("%d", &a[i]), sum += a[i];
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
	for (int i = 0; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &cost[i][j]);
	int ANS = 0x3f3f3f3f, who;
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++) delta[j] = cost[i][j] - cost[0][j];
		for (int j = 1; j <= m; j++) id[j] = j;
		sort(id + 1, id + m + 1, cmp);
		int rest = sum - b, ans = h[i] + h[0];
		for (int j = 1; j <= m; j++) ans += a[j] * cost[0][j];
		for (int j = 1; j <= m && rest > 0 ; j++){
			int t = min(rest, a[id[j]]);
			rest -= t; ans += delta[id[j]] * t;
		}
		if (ans < ANS) ANS = ans, who = i;
	}
	printf("%d\n%d\n", who, ANS);
}
Problem2427

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int f[1001][1001], n, m, W[1001], V[1001], d[1001];
int tot, e[1001], v[2001], next[2001], col[2001];
bool g[1001][1001], bad[1001];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void predo()
{
	for (int i = 1; i <= n; i++) if (d[i] != 0) g[i][d[i]] = 1;
	for (int k = 1; k <= n; k++)
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++) if (i != j && j != k && i != k && g[i][k] && g[k][j])
				g[i][j] = true;
	for (int i = 1; i <= n; i++) if (!bad[i]){
		bool F = false; col[i] = i;
		for (int j = i + 1; j <= n; j++) if (!bad[j] && g[i][j] && g[j][i]){
			bad[j] = true; V[i] += V[j]; W[i] += W[j]; F =true; col[j] = i;
		}
		if (F) d[i] = 0;
	}
	for (int i = 1; i <= n; i++) if (d[i] != 0) add(col[d[i]], i);
}
void dfs(int x)
{
	if (x == 0 || bad[x]) return;
	for (int i = e[x]; i; i = next[i]) dfs(v[i]);
	for (int i = e[x]; i; i = next[i])
		for (int j = m; j >= 0; j--)
			for (int k = 0; k <= j; k++)
				f[x][j] = max(f[x][j], f[v[i]][k] + f[x][j - k]);
	for (int j = m; j >= W[x]; j--) f[x][j] = f[x][j - W[x]] + V[x];
	for (int i = 0; i < W[x]; i++) f[x][i] = 0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &W[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &V[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &d[i]);
	predo();
	for (int i = 1; i <= n; i++) if (d[i] == 0) add(n + 1, i);
	dfs(n + 1);
	printf("%d\n", f[n + 1][m]);
}
Problem2429

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <complex>
#define Tpoint complex<double>
using namespace std;
const int MAXN = 1000001, MAXM = 1000001;
struct Tmst{
	struct Tedge{
		int st, ed; double len;
		Tedge() { }
		Tedge(int st, int ed, double len) : st(st), ed(ed), len(len) { }
		bool operator < (const Tedge & A) const { return len < A.len; }
	} edge[MAXM];
	struct Tuf{
		int f[MAXN];
		void init(int n) { for (int i = 1; i <= n; i++) f[i] = i; }
		int get(int x) { return x == f[x] ? x : f[x] = get(f[x]); }
		bool merge(int a, int b) { a = get(a); b = get(b); if (a == b) return false; f[a] = b; return true; }
	} uf;
	int tot, now, num, n; double ret;
	void addedge(int a, int b, double c)
	{
		//cerr << a << " " << b << " " << c << endl;
		edge[++tot] = Tedge(a, b, c);
	}
	double solve()
	{
		sort(edge + 1, edge + tot + 1);
		uf.init(n);
		for (int i = 1; now < n - 1; i++)
			if (uf.merge(edge[i].st, edge[i].ed)){
				++now; ret = edge[i].len;
			}
		return ret;
	}
} mst;
int n, m, a[MAXN];
Tpoint p[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &m); for (int i = 1; i <= m; i++) scanf("%d", &a[i]);
	scanf("%d", &n); for (int i = 1; i <= n; i++) { double x, y; scanf("%lf%lf", &x, &y); p[i] = Tpoint(x, y); }
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++)
			mst.addedge(i, j, abs(p[i] - p[j]));
	mst.n = n;
	int t = mst.solve(), ans = 0;
	for (int i = 1; i <= n; i++) if (a[i] >= t) ++ans;
	printf("%d\n", ans);
}
Problem2430

#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;
pair<int, int> a[2000001];
int n, m, tot, num[2];
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++) { int t; scanf("%d", &t); ++tot; a[tot].first = t; a[tot].second = 0; }
	for (int i = 1; i < m; i++) { int t; scanf("%d", &t); ++tot; a[tot].first = t; a[tot].second = 1; }
	sort(a + 1, a + tot + 1);
	long long ans = 0; 
	num[0] = num[1] = 1;
	for (int i = tot; i >= 1; i--){
		ans = ans + (long long)(num[!a[i].second]) * a[i].first;
		++num[a[i].second];
	}
	cout << ans << endl;
}
Problem2431

#include <cstdio>
#include <algorithm>
using namespace std;
int f[2001][2001], sum[2001];
int n, k;
int make(int t) { return ((t % 10000) + 10000) % 10000; }
void presum(int t)
{
	for (int i = 0; i <= k; i++) sum[i + 1] = make(sum[i] + f[t][i]);
}
int getsum(int l, int r)
{
	l = max(0, l); r = min(k, r);
	return make(sum[r + 1] - sum[l]);
}
int main()
{
	scanf("%d%d", &n, &k);
	f[1][0] = 1;
	for (int i = 2; i <= n; i++){
		presum(i - 1);
		for (int j = 0; j <= k; j++)
			f[i][j] = getsum(j - i + 1, j);
	}
	printf("%d\n", f[n][k]);
}
Problem2433

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <functional>
#include <cmath>
#include <queue>
#include <iostream>
using namespace std;
#define PDI pair<double, int>
const int MAXN = 80001, MAXM = 4000001; const double eps = 1e-8;
priority_queue<PDI, vector<PDI>, greater<PDI> > Q;
struct Tpoint{
	int kind, which; //1 : s 2 : t -1 : up -2 : down;
	int x, y;
	Tpoint() { }
	Tpoint(int _x, int _y) { x = _x; y = _y; kind = 0; }
	void init() { scanf("%d%d", &x, &y); }
	bool operator < (const Tpoint & A) const
	{
		if (x != A.x) return x < A.x;
		return which < A.which;
	}
	Tpoint operator - (Tpoint A)
	{
		return Tpoint(x - A.x, y - A.y);
	}
	int operator * (const Tpoint & A)
	{
		return x * A.y - y * A.x;	
	}
} p[MAXN];
double dis(Tpoint A, Tpoint B)
{
	return sqrt((double)(A.x - B.x) * (A.x - B.x) + (double)(A.y - B.y) * (A.y - B.y));
}
int tot;
struct Tshortest{
	int s, t, tot, e[MAXN], v[MAXM], next[MAXM]; double w[MAXM];
	double dis[MAXN]; bool vis[MAXN];
	void add(int a, int b, double c)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; w[tot] = c;
	}
	double dijkstra()
	{
		for (int i = 1; i <= t; i++) dis[i] = 1e99, vis[i] = false; dis[s] = 0; Q.push(make_pair(0.0, s));
		while(!Q.empty()){
			PDI now = Q.top(); Q.pop();
			if (!vis[now.second]){
				int x = now.second;
				for (int i = e[x]; i; i = next[i]) if (dis[v[i]] > dis[x] + w[i]){
					dis[v[i]] = dis[x] + w[i]; Q.push(make_pair(dis[v[i]], v[i]));
				}
				vis[x] = true;
			}
		}
		return dis[t];
	}
} sp;
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		Tpoint p1, p2, p3, p4; p1.init(); p2.init();
		p3.x = p1.x; p3.y = p2.y; p4.x = p2.x; p4.y = p1.y;
		p[++tot] = p1; p[tot].kind = -2; p[tot].which = i;
		p[++tot] = p2; p[tot].kind = -1; p[tot].which = i;
		p[++tot] = p3; p[tot].kind = -1; p[tot].which = i;
		p[++tot] = p4; p[tot].kind = -2; p[tot].which = i;
	}
	Tpoint st, ed;
	st.init(); ed.init();
	p[++tot] = st; p[tot].kind = 1;
	p[++tot] = ed; p[tot].kind = 2;
	sort(p + 1, p + tot + 1);
	double v; scanf("%lf", &v);
	for (int i = 1; i <= tot; i++){
		if (p[i].kind == 1) sp.s = i;
		if (p[i].kind == 2) sp.t = i;
		Tpoint now1(p[i].x, p[i].y + 1), now2(p[i].x, p[i].y - 1);
		for (int j = i + 1; j <= tot; j++){
			if ((p[j] - p[i]) * (now1 - p[i]) >= 0 && (p[j] - p[i]) * (now2 - p[i]) <= 0) sp.add(i, j, dis(p[i], p[j]));
			if (p[j].kind == -1 && (p[j] - p[i]) * (now1 - p[i]) >= 0) now1 = p[j];
			if (p[j].kind == -2 && (p[j] - p[i]) * (now2 - p[i]) <= 0) now2 = p[j];
		}
	}
	printf("%.10lf\n", sp.dijkstra() / v);
}
Problem2434

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXL = 200001;
struct Ttrie{
	int ch[26], f, fail;
	bool flag;
} trie[MAXL], ac[MAXL];
char str[MAXL];
int tot, where[MAXL];
int Gtot, e[MAXL], next[MAXL], v[MAXL];
int Atot, E[MAXL], WHO[MAXL], NEXT[MAXL], WHICH[MAXL];
int DFSX[MAXL], DFSN, start[MAXL], end[MAXL];
vector<pair<int, int> > ask[MAXL];
int ans[MAXL];
struct Tbit{
	int data[MAXL];
	void add(int a, int d)
	{
		for (; a <= tot; a += (a & (-a))) data[a] += d;
	}
	int sum(int a)
	{
		int ret = 0;
		for (; a; a -= (a & (-a)))
			ret += data[a];
		return ret;
	}
} bit;
void add(int a, int b)
{
	++Gtot; next[Gtot] = e[a]; e[a] = Gtot; v[Gtot] = b;
}
void ADD(int a, int b, int c)
{
	++Atot; NEXT[Atot] = E[a]; E[a] = Atot; WHO[Atot] = b; WHICH[Atot] = c;
}
void dfs(int x) 
{
	DFSX[++DFSN] = x; start[x] = DFSN;
	for (int i = e[x]; i; i = next[i]) dfs(v[i]);
	end[x] = DFSN;
}	
void build_ac()
{
	static int l, r, q[MAXL]; 
	l = r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = 0; i < 26; i++){
			int t = ac[x].ch[i];
			ac[t].fail = x == 1 ? 1 : ac[ac[x].fail].ch[i];
			if (t == 0) ac[x].ch[i] = ac[t].fail; else q[++r] = t;
			}
		}
}		
int vi, a, b;
void getans(int x)
{
	bit.add(start[x], 1);
	for (vi = E[x]; vi; vi = NEXT[vi])
		ans[WHICH[vi]] = bit.sum(end[WHO[vi]]) - bit.sum(start[WHO[vi]] - 1);
	for (int i = 0; i < 26; i++) if (trie[x].ch[i] != 0) getans(trie[x].ch[i]);
	bit.add(start[x], -1);
}
int main()
{
	gets(str);
	tot = 1;
	int now = 1, nowtot = 0;
	for (char *s = str; *s; s++){
		if (*s == 'P')  { trie[now].flag = true; where[++nowtot] = now; } 
		else if (*s == 'B')  now = trie[now].f;
		else{
			if (trie[now].ch[*s - 'a'] == 0) { trie[now].ch[*s - 'a'] = ++tot; trie[tot].f = now; }
			now = trie[now].ch[*s - 'a'];
			}
		}
	for (int i = 1; i <= tot; i++) ac[i] = trie[i];
	build_ac();	
	for (int i = 2; i <= tot; i++) add(ac[i].fail, i); //Fail Tree
	dfs(1);	
	int Q; scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		int a, b; scanf("%d%d", &a, &b);
		ADD(where[b], where[a], i);
		}
	getans(1);
	for (int i = 1; i <= Q; i++) printf("%d\n", ans[i]);
}

Problem2435

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
int n, l, r, q[1000001];
int tot, e[2000001], v[2000001], w[2000001], next[2000001], size[1000001], f[1000001]; 
void add(int a, int b, int c) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c; }  
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
		}
	int l = 1, r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (f[x] != v[i]) { q[++r] = v[i]; f[v[i]] = x; }
		}
	for (int i = n; i >= 1; i--){
		size[q[i]] = 1;
		for (int j = e[q[i]]; j; j = next[j])
			if (v[j] != f[q[i]]) size[q[i]] += size[v[j]];
		}
	long long ans = 0;
	for (int i = 1; i <= n; i++)
		for (int j = e[i]; j; j = next[j]) if (v[j] != f[i])
			ans = ans + (long long)(w[j]) * (long long)(abs(size[v[j]] -  n + size[v[j]]));
	printf("%lld\n", ans);
}
Problem2437

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 5001, MAXM = 100001;
const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};
struct Tmatch{
	int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM], s, t;
	bool kind[MAXN], vis[MAXN], canans[MAXN];
	void clear() { tot = 1; for (int i = 1; i <= t; i++) e[i] = 0; }
	void add(int a, int b, int C)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; c[tot] = C;
		++tot; next[tot] = e[b]; e[b] = tot; v[tot] = a; c[tot] = 0;	
	}
	int aug(int x, int f)
	{
		if (vis[x]) return 0; vis[x] = true; if (x == t) return f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
			int t = aug(v[i], min(f, c[i]));
			if (t == 0) continue;
			c[i] -= t; c[i ^ 1] += t; return t;
		}
		return 0;
	}
	void dfs(int x, int k)
	{
		if (vis[x]) return; vis[x] = true;
		if (x < s && kind[x] == k) canans[x] = true;
		for (int i = e[x]; i; i = next[i]) if (c[i] == k) dfs(v[i], k);
	}
	bool query(int temp)
	{
		for (int i = 1; i < s; i++) if (kind[i] == 1) add(s, i, 1);
		for (int i = 1; i < s; i++) if (kind[i] == 0) add(i, t, 1);
		for (int i = 1; i <= t; i++) vis[i] = false;
		while (aug(s, 0x3f3f3f3f))
			for (int i = 1; i <= t; i++) vis[i] = false;
		for (int i = 1; i <= t; i++) vis[i] = false, canans[i] = false;
		dfs(s, 1); 
		for (int i = 1; i <= t; i++) vis[i] = false;
		dfs(t, 0);
		return !canans[temp];
	}
} match;
int n, m, sx, sy; char map[101][101], now;
bool can[101][101];
int change(int x, int y)
{
	return (x - 1) * m + y;
}
bool mustwin()
{
	match.clear();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			can[i][j] = (map[i][j] == now) ^ (((i - sx) & 1) == ((j - sy) & 1));
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) if (can[i][j])
			if ((i & 1) == (j & 1)){
				match.kind[change(i, j)] = 1;
				for (int d = 0; d < 4; d++){
				   int xx = i + dx[d], yy = j + dy[d];
				   if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && can[xx][yy])
					match.add(change(i, j), change(xx, yy), 1);
				}
			}
			else match.kind[change(i, j)] = 0;
	match.s = n * m + 1; match.t = match.s + 1;
	return match.query(change(sx, sy));
}
vector<int> ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%s", map[i] + 1);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (map[i][j] == '.'){
				sx = i; sy = j;
			}
	int S; scanf("%d", &S);
	for (int i = 1; i <= S *2 ; i++){
		int x, y; scanf("%d%d", &x, &y); 
		if (i & 1){
			now = 'O';
			bool b1 = mustwin();
			swap(map[x][y], map[sx][sy]);
			sx = x; sy = y;
			now = 'X';
			bool b2 = mustwin();
			if (b1 && b2) ans.push_back(i + 1 >> 1);
		}
		if (!(i & 1)) { swap(map[x][y], map[sx][sy]); sx = x; sy = y; }
	}
	printf("%d\n", ans.size());
	for (int i = 0; i < ans.size(); i++) printf("%d\n", ans[i]);
}
Problem2440

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
bool f[1000001]; int p[1000001], pnum;
void getp(int MAX)
{
	memset(f, 1, sizeof(f));
	for (int i = 2; i <= MAX; i++){
		if (f[i]) p[++pnum] = i;
		for (int j = 1; j <= pnum && p[j] * i <= MAX; j++){
			f[i * p[j]] = false;
			if (i % p[j] == 0) break;
		}
	}
}
int get(int x, int t)
{
	if (t > pnum) return t;
	if (x == 0 || x < p[t] * p[t]) return x;
	return get(x, t + 1) - get(x / p[t] / p[t], t + 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int T; scanf("%d", &T);
	getp(45000);

	while(T--){
		int n;
		scanf("%d", &n);
		int l = 1, r = 2000000000;
		while(l <= r){
			int m = (long long)l + r >> 1;
			if (get(m, 1) >= n) r = m - 1; else l = m + 1;
		}
		printf("%d\n", l);
	}

}
Problem2442

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
int n, k, a[100001];
struct Tqueue { ll num; int who; } q[100001];
ll f[100001], sum[100001];
using namespace std;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &k); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) sum[i] = (ll)(a[i]) + sum[i - 1];
	f[0] = 0; int l = 1, r = 1; q[1].num = 0; q[1].who = 0;
	for (int i = 1; i <= n; i++){
		while(q[l].who < i - k) ++l;
		f[i] = q[l].num + sum[i];
		while(l <= r && f[i - 1] - sum[i] > q[r].num) --r;
		++r ;q[r].num = f[i - 1] - sum[i]; q[r].who = i;
		}
	ll ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
	cout << ans << endl;
}
Problem2445

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 999999599;
const int p[4] = {2,13,5281,7283};
void exgcd(long long a, long long b, long long & x, long long & y)
{
	if (b == 0) { x = 1; y = 0; }
	else { exgcd(b, a % b, y, x); y -= (a / b) * x; }
}
int solve_modular(int a, int b, int c) //a * x mod b = c
{
	long long x, y; exgcd(a, b, x, y);
	x = ((x % b) + b) % b; x = (long long)x * c % b;
	return x;
}
int modans[4];
int crt()
{
	long long ans = 0;
	for (int i = 0; i < 4; i++){
		int x = solve_modular((MO - 1) / p[i], p[i], modans[i]);
		ans = (ans + (long long)x * ((MO - 1) / p[i]) % (MO - 1)) % (MO - 1);
	}
	return ans;
}
int pow(long long a, long long b, long long MO) //a ^ b % MO
{
	long long ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (long long) ret * a % MO;
		a = (long long) a * a % MO;
	}
	return int(ret);
}
const int MAXP = 100001;
int fac[4][MAXP], facinv[4][MAXP], inv[4][MAXP], now, mi, nowc;
void pre(int t)
{
	int now = p[t];
	fac[t][0] = facinv[t][0] = fac[t][1] = facinv[t][1] = 1;
	inv[t][1] = 1;
	for (int i = 2; i < now; i++){
		inv[t][i] = (long long) inv[t][now % i] * (now - now / i) % now;
		fac[t][i] = (long long) fac[t][i - 1] * i % now;
	}
}
int work(int n, int d)
{
	int ret = 1, part = n / now, rest = n % now;
	if (n < now) return fac[nowc][n];
	ret = (long long) pow(fac[nowc][now - 1], part, now) * fac[nowc][rest] % now;
	mi += d * part;
	return (long long) ret * work(n / now, d) % now;
}
void doit(int n, int m)
{
	mi = 0;
	int ret = inv[nowc][work(n / m, -1)]; ret = pow(ret, m, now); mi *= m;
	ret = (long long) ret * work(n, 1) % now;
	ret = (long long) ret * inv[nowc][work(m, -1)] % MO;
	if (mi == 0) modans[nowc] = (modans[nowc] + ret) % now; 
}
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d", &n, &m);
	for (int i = 0; i < 4; i++) pre(i);
	for (int i = 0; i < 4; i++) modans[i] = 0;
	for (nowc = 0; nowc < 4; nowc++){
		now = p[nowc];
		for (int i = 1; i * i <= n; i++) if (n % i == 0){
			doit(n, i);
			if (i * i != n) doit(n, n / i);
		}
	}
	printf("%d\n", pow(m, crt(), MO));
}
}
Problem2453

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
#define Tsi set<int>::iterator
using namespace std;
const int MAXN = 200001;
int low(int t) { return t & (-t); }
struct Tsplaynode{
    static Tsplaynode *A;
    int c[2], f, size, key;
    void update() { size = A[c[0]].size + A[c[1]].size + 1; }
    void rot(bool b)
    {
        A[A[f].c[b] = c[!b]].f = f; c[!b] = f;
        f = A[f].f; A[f].c[A[f].c[1] == c[!b]] = this - A;
        A[c[!b]].f = this - A; A[c[!b]].update();
    }
} a[MAXN * 20], *Tsplaynode::A = a;
int tot;
struct Tsplay{
    int root;
    void splay(int x, int p)
    {
        int y, z; bool b, c;
        while((y = a[x].f) != p){
            b = x == a[y].c[1];
            if ((z = a[y].f) != p){
                c = y == a[z].c[1];
                if (b == c) a[y].rot(b); else a[x].rot(b);
                a[x].rot(c);
                }
            else a[x].rot(b);
            }
        a[x].update(); if (p == 0) root = x;
    }
    void insert(int num)
    {
        if (root == 0) { ++tot; root = tot; a[tot].size = 1; a[tot].key = num; return; }
        int t = root;
        while(1){
            a[t].size++;
            if (a[t].c[num > a[t].key]) t = a[t].c[num > a[t].key]; else break;
            }
        ++tot; a[t].c[num > a[t].key] = tot; a[tot].f = t; a[tot].key = num; a[tot].size = 1;
        splay(tot, 0);
    }
    int query(int num)
    {
        int t = root, ret = 0;
        while(t != 0)
            if (a[t].key <= num) ret += a[a[t].c[0]].size + 1, t = a[t].c[1];
            else t = a[t].c[0];
        return ret;
    }
    int find(int num)
    {
        int t = root;
        while(1){
            if (a[t].key == num) return t;
            t = a[t].c[num > a[t].key];
            }
    } 
    int findmax(int t) { while(a[t].c[1]) t = a[t].c[1]; return t; }
    void erase(int x)
    {
        x = find(x); splay(x, 0);
        if (a[x].c[0] == 0){ root = a[x].c[1]; a[root].f = 0; return;  }
        int t = findmax(a[x].c[0]); splay(t, x);
        a[t].c[1] = a[x].c[1]; a[a[x].c[1]].f = t;
        root = t; a[root].update(); a[root].f = 0;
    }
} sp[MAXN];
set<int> S[1000001];
int n, m, col[MAXN];
void insert(int t, int num)
{
    for (; t <= n; t += low(t)) sp[t].insert(num);
}
void erase(int t, int num)
{
    for (; t <= n; t += low(t)) sp[t].erase(num);
}
int query(int t, int num)
{
    int ret = 0;
    for (; t > 0; t -= low(t)) ret += sp[t].query(num);
    return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++){
        scanf("%d", col + i); S[col[i]].insert(i);
    }
    for (int i = 1; i <= n; i++){
        for (int j = i; j >= i - low(i) + 1; j--){
            Tsi pre = S[col[j]].lower_bound(j); int pn = pre == S[col[j]].begin() ? 0 : *(--pre);
            sp[i].insert(pn);
        }
    }
    while(m--){
        int l, r, x, c; char op;
        scanf(" "); scanf("%c", &op);
        switch(op){
            case 'Q' : scanf("%d%d", &l, &r); printf("%d\n", query(r, l - 1) - query(l - 1, l - 1)); break;
            case 'R' : scanf("%d%d", &x, &c);
                       Tsi pre, next; int lc = c; if (c == col[x]) continue;
                       pre = S[c].lower_bound(x); next = S[c].upper_bound(x);
                       int pn = pre == S[c].begin() ? 0 : *(--pre), nn = next == S[c].end() ? n + 1 : *next;
                       insert(x, pn); if (nn != n + 1) { insert(nn, x); erase(nn, pn); }
                       S[c].insert(x);
                       c = col[x];
                       pre = S[c].lower_bound(x); next = S[c].upper_bound(x);
                       pn = pre == S[c].begin() ? 0 : *(--pre); nn = next == S[c].end() ? n + 1 : *next;
                       erase(x, pn); if (nn != n + 1) { insert(nn, pn); erase(nn, x); }
                       S[c].erase(x);
                       col[x] = lc;
                       break;
        }
    }
}   
Problem2456

#include <cstdio>
int n, cnt, num, a;
int main()
{
	scanf("%d", &n); cnt = 0;
	for (int i = 1; i <= n; i++){
		scanf("%d", &a);
		if (cnt == 0) { cnt = 1; num = a; }
		else if (num == a) ++cnt; else --cnt;
	}
	printf("%d\n", num);
}
Problem2458

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
struct Tpoint{
	double x, y;
	void init()
	{
		scanf("%lf%lf", &x, &y);
	}
} p[1000001], tmp[1000001];
double ans = 1e20; int n;
bool byX(const Tpoint & A, const Tpoint & B) { return A.x < B.x; }
bool byY(const Tpoint & A, const Tpoint & B) { return A.y < B.y; }
double dis(const Tpoint & A, const Tpoint & B) { return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)); }
void renew(const Tpoint & A, const Tpoint & B, const Tpoint & C)
{
	ans = min(ans, dis(A, B) + dis(B, C) + dis(C, A));
}
void solve(int l, int r)
{
	if (r - l + 1 <= 3){
		sort(p + l, p + r + 1, byY);
		if (r - l + 1 == 3) renew(p[l], p[l + 1], p[r]);
		return;
	}
	int m = l + r >> 1, mx = p[m].x, tot = 0;
	solve(l, m); solve(m + 1, r);
	inplace_merge(p + l, p + m + 1, p + r + 1, byY);
	for (int i = l; i <= r; i++) if (abs(p[i].x - mx) < ans / 2) tmp[++tot] = p[i];
	for (int i = 1; i <= tot; i++)
		for (int j = i - 1; j > 0 && tmp[i].y - tmp[j].y < ans / 2; j--)
			for (int k = i - 1; k > 0 && tmp[i].y - tmp[j].y < ans / 2; k--)
				if (j != k) renew(tmp[i], tmp[j], tmp[k]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init();
	sort(p + 1, p + n + 1, byX);
	solve(1, n);
	printf("%.6lf\n", ans);
}
Problem2459

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001;
long long INF = ~0u>>2;
int u[MAXN], m[MAXN], d[MAXN];
int n, x[2], y[2];
long long dis[8][8], T[MAXN * 4][4][4], dd[2][4], ans;
void cl(int num) 
{ 
	for (int i = 0; i < num; i++) for (int j = 0; j < num; j++) dis[i][j] = INF;
	for (int i = 0; i < num; i++) dis[i][i] = 0;
}
void fl(int num)
{
	for (int i = 0; i < num; i++)
		for (int j = 0; j < num; j++)
			dis[i][j] = min(dis[i][j], dis[j][i]);
	for (int k = 0; k < num; k++)
		for (int i = 0; i < num; i++) if (i != k && dis[i][k] < INF)
			for (int j = 0; j < num; j++) if (i != j && k != j && dis[k][j] < INF)
				dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
}
void update(int p, int l, int r)
{
	if (l + 1 == r){
		cl(4);
		dis[0][1] = m[l]; dis[0][2] = u[l];
		dis[1][3] = d[l]; dis[2][3] = m[r];
		fl(4);
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				T[p][i][j] = dis[i][j];
		}
	else{
		cl(6);
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++){
				dis[i][j] = min(dis[i][j], T[2 * p][i][j]);
				dis[i + 2][j + 2] = min(dis[i + 2][j + 2], T[2 * p + 1][i][j]);
				}
		fl(6);
		for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++){
				T[p][i][j] = dis[i][j];
				T[p][i][j + 2] = dis[i][j + 4];
				T[p][i + 2][j] = dis[i + 4][j];
				T[p][i + 2][j + 2] = dis[i + 4][j + 4];
				}
		}
}
void build(int p, int l, int r)
{
	if (l + 1 != r){
	   build(p * 2, l, l + r >> 1);
   	   build(p * 2 + 1, l + r >> 1, r);
	   }
	update(p, l, r);
/*
	fprintf(stderr, "INF of [%d,%d]\n", l, r);
  	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			fprintf(stderr, "%d %d %d\n", i, j, T[p][i][j]);	
*/
}
void change(int p, int l, int r, int t)
{
	if (l + 1 != r){
		if (t <= (l + r >> 1)) change(p * 2, l, l + r >> 1, t);
		if (t >= (l + r >> 1)) change(p * 2 + 1, l + r >> 1, r, t);
		}
	update(p, l, r);
}
void query2(int p, int l, int r, int t)
{
	if (l + 1 == r){
		int P = y[t] + (x[t] == r) * 2;
		for (int i = 0; i < 4; i++) dd[t][i] = T[p][P][i];
		}
	else{
		int U = x[t] <= (l + r >> 1);
		if (U) query2(p * 2, l, l + r >> 1, t); else query2(p * 2 + 1, l + r >> 1, r, t);
		cl(7);
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++){
				dis[i][j] = min(dis[i][j], T[2 * p][i][j]);
				dis[i + 2][j + 2] = min(dis[i + 2][j + 2], T[2 * p + 1][i][j]);
				}
		for (int i = 0; i < 4; i++) dis[6][i + 2 * (!U)] = dd[t][i];
		fl(7);
		for (int i = 0; i < 2; i++) { dd[t][i] = dis[6][i]; dd[t][i + 2] = dis[6][i + 4]; }
		}
}
void query1(int p, int l, int r)
{
	if (l + 1 == r){
		int p0 = y[0] + (x[0] == r) * 2, p1 = y[1] + (x[1] == r) * 2;
		for (int i = 0; i < 4; i++) dd[0][i] = T[p][p0][i], dd[1][i] = T[p][p1][i];
		ans = min(ans, T[p][p0][p1]);
		}
	else{
		int u0 = x[0] <= (l + r >> 1), u1 = x[1] <= (l + r >> 1);
		if (u0 == u1)
			if (u0) query1(p * 2, l, l + r >> 1); else query1(p * 2 + 1, l + r >> 1, r);
		else
			if (u0) query2(p * 2, l, l + r >> 1, 0), query2(p * 2 + 1, l + r >> 1, r, 1);
			else query2(p * 2 + 1, l + r >> 1, r, 0), query2(p * 2, l, l + r >> 1, 1);
		cl(8);
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++){
				dis[i][j] = min(dis[i][j], T[2 * p][i][j]);
				dis[i + 2][j + 2] = min(dis[i + 2][j + 2], T[2 * p + 1][i][j]);
				}
		for (int i = 0; i < 4; i++){
			dis[6][i + 2 * (!u0)] = dd[0][i];
			dis[7][i + 2 * (!u1)] = dd[1][i];
			}
		fl(8);
		ans = min(ans, dis[6][7]);
		for (int i = 0; i < 2; i++){
			dd[0][i] = dis[6][i];
			dd[0][i + 2] = dis[6][i + 4];
			dd[1][i] = dis[7][i];
			dd[1][i + 2] = dis[7][i + 4];
			}
		}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < n - 1; i++) scanf("%d", &u[i]);
	for (int i = 0; i < n; i++) scanf("%d", &m[i]);
	for (int i = 0; i < n - 1; i++) scanf("%d", &d[i]);
	build(1, 0, n - 1);
	int Q; scanf("%d", &Q);
	while(Q--){
		int op, a, b, c; scanf("%d", &op);
		switch(op){
			case 0:
				scanf("%d%d%d", &a, &b, &c);
				switch(a){
					case 0 : u[b - 1] = c; break;
					case 1 : m[b - 1] = c; break;
					case 2 : d[b - 1] = c; break;
					}
				change(1, 0, n - 1, b - 1);
				break;
			case 1:
				scanf("%d%d", &a, &b);
				x[0] = a + 1 >> 1; --x[0]; y[0] = !(a & 1);
				x[1] = b + 1 >> 1; --x[1]; y[1] = !(b & 1);
				ans = 0x7fffffffffffll;
				query1(1, 0, n - 1);
				cout << ans << endl;
				break;
			}
		}
}
Problem2462

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;
const int modb = 123456789, moda = 987654321, randb = 12345, randa = 54321;
int mi[1001], A[1001][1001], B[1001][1001], hashb[1001][1001], hasha[1001][1001];
int n, m, a, b;
inline int mul(int a,int b,int P) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n" 
            :"=d"(ret):"a"(a),"b"(b),"c"(P));
    return ret;
}
void predo()
{
	mi[0] = 1;
	for (int i = 1; i <= b; i++) mi[i] = mul(mi[i - 1], randb, modb);
	for (int i = 1; i <= n; i++){
		int now = 0;
		for (int j = 1; j <= b; j++) now = ((long long) mul(A[i][j], mi[b - j], modb) + now) % modb;
		for (int j = 1; j <= m - b + 1; j++){
			hashb[i][j] = now;
			if (j != m - b + 1){
				now = (now - mul(A[i][j], mi[b - 1], modb)) % modb;
				int tnow = now;
				now = (long long) now * randb % modb;
				now = (now + A[i][j + b]) % modb;
				now = (now + modb) % modb;
			}
		}
	}
	for (int i = 1; i <= a; i++) mi[i] = mul(mi[i - 1], randa, moda);
	for (int j = 1; j <= m - b + 1; j++){
		int now = 0;
		for (int i = 1; i <= a; i++) now = ((long long) mul(hashb[i][j], mi[a - i], moda) + now) % moda;
		for (int i = 1; i <= n - a + 1; i++){
			hasha[i][j] = now;
			if (i != n - a + 1){
				now = (now - mul(hashb[i][j], mi[a - 1], moda)) % moda;
				now = (long long) now * randa % moda;
				now = (now + hashb[i + a][j]) % moda;
				now = (now + moda) % moda;
			}
		}
	}

}
int temp[1001];
int gethash()
{
	int ret = 0;
	for (int i = 1; i <= a; i++){
		int now = 1;
		temp[i] = 0;
		for (int j = b; j >= 1; j--) temp[i] = ((long long) mul(now, B[i][j], modb) + temp[i]) % modb, now = (long long) now * randb % modb;
	}
	int now = 1;
	for (int i = a; i >= 1; i--) ret = ((long long) mul(now, temp[i], moda) + ret) % moda, now = (long long) now * randa % moda;
	for (int i = 1; i <= n - a + 1; i++)
		for (int j = 1; j <= m - b + 1; j++)
			if (hasha[i][j] == ret) return 1;
	return 0;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d%d", &n, &m, &a, &b);
	for (int i = 1; i <= n; i++){
		scanf(" ");
		for (int j = 1; j <= m; j++)
			A[i][j] = getchar();
	}
	predo();
	int Q; scanf("%d", &Q);
	while(Q--){
		for (int i = 1; i <= a; i++){
			scanf(" ");
			for (int j = 1; j <= b; j++)
				B[i][j] = getchar();
		}
		printf("%d\n", gethash());
	}
}
Problem2463

#include <iostream>
using namespace std;
int n;
int main()
{
	while(1){
		cin >> n;
		if (n == 0) break;
		cout << (n & 1 ? "Bob" : "Alice") << endl;
	}
}
Problem2482

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 500001, MAXQ = 2000001, MAXV = 200000;
struct Tquery{
	int l, r, ord;
	bool operator < (const Tquery & A) const { return r < A.r; }
} query[MAXQ];
int n, q, ans[MAXQ], last[MAXN], rec[MAXV * 4], a[MAXN];
int nowmax[MAXN * 4], oldmax[MAXN * 4], nowdel[MAXN * 4], olddel[MAXN];
int max(int a, int b, int c, int d)
{
	return max(max(a, b), max(c, d));
}
void push(int idx)
{
	for (int k = 0; k <= 1; k++){
		oldmax[idx * 2 + k] = max(oldmax[idx * 2 + k], nowmax[idx * 2 + k] + olddel[idx]);
		nowmax[idx * 2 + k] += nowdel[idx];
		olddel[idx * 2 + k] = max(olddel[idx * 2 + k], nowdel[idx * 2 + k] + olddel[idx]);
		nowdel[idx * 2 + k] += nowdel[idx];
		}
	nowdel[idx] = olddel[idx] = 0;
}		 
void update(int idx)
{
	nowmax[idx] = max(nowmax[idx * 2], nowmax[idx * 2 + 1]);
	oldmax[idx] = max(oldmax[idx * 2], oldmax[idx * 2 + 1]);
}
void make_add(int idx, int l, int r, int ll, int rr, int delta)
{
	if (ll <= l && rr >= r){
		nowmax[idx] = nowmax[idx] + delta;
		oldmax[idx] = max(oldmax[idx], nowmax[idx]);
		nowdel[idx] += delta;
		olddel[idx] = max(olddel[idx], nowdel[idx]);
		return;
		}
	push(idx);
	int m = l + r >> 1;
	if (ll <= m) make_add(idx * 2, l, m, ll, rr,delta);
	if (rr > m) make_add(idx * 2 + 1, m + 1, r, ll, rr, delta);
	update(idx);
}
int make_query(int idx, int l, int r, int ll, int rr)
{
	if (ll <= l && rr >= r) return oldmax[idx];
	int m = l + r >> 1;
	int res = 0xe0e0e0e0;
	push(idx);
	if (ll <= m) res = max(res, make_query(idx * 2, l, m, ll, rr));
	if (rr > m) res = max(res, make_query(idx * 2 + 1, m + 1, r, ll, rr));
	update(idx);
	return res;
}
int main()
{
#ifdef kAc
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]); last[i] = rec[a[i] + MAXV]; rec[a[i] + MAXV] = i;
		}
	scanf("%d", &q);
	for (int i = 1; i <= q; i++){
		scanf("%d%d", &query[i].l, &query[i].r); query[i].ord = i;
		}
	sort(query + 1, query + q + 1);
	int now = 1;
	for (int i = 1; i <= n; i++){
		make_add(1, 1, n, last[i] + 1, i, a[i]);
		while(now <= q && query[now].r == i){
			ans[query[now].ord] = make_query(1, 1, n, query[now].l, i);
			++now;
			}
		}
	for (int i = 1; i <= q; i++) printf("%d\n", max(0, ans[i]));
}
Problem2483

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
int a[10001], tot, n, num[10001];
ll  x, y;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	while(1){
		scanf("%d", &n); tot = 0;
		if (n == 0) break;
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= a[i]; j++){
				++tot; num[tot] = a[i] - j + 1;
				for (int k = i + 1; k <= n; k++) num[tot] += a[k] >= j;
			}
		long long x = 1, y = 1;
		for (int i = 1; i <= tot; i++){
			x *= i; y *= num[i];
			ll d = __gcd(x, y); x /= d; y /= d;
		}
		cout << x / y << endl;
	}
}
Problem2500

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 2000001;
int tot, n, m;
int e[MAXN], v[MAXN * 2], next[MAXN * 2], w[MAXN * 2], q[MAXN], l, r, d1[MAXN], d2[MAXN], up[MAXN], dis[MAXN];
int l1, r1, l2, r2, q1[MAXN], q2[MAXN];
void push1(int t) { while(l1 <= r1 && dis[t] > dis[q1[r1]]) --r1; q1[++r1] = t; }
void push2(int t) { while(l2 <= r2 && dis[t] < dis[q2[r2]]) --r2; q2[++r2] = t; }
void add(int A, int B, int C)
{
	++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; w[tot] = C;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 2; i <= n; i++){
		int b, c; scanf("%d%d", &b, &c);
		add(b, i, c);
	}
	l = 1; r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) q[++r] = v[i];
	}
	for (int i = r; i >= 1; i--)
		for (int j = e[q[i]]; j; j = next[j]){
			int temp = d1[v[j]] + w[j];
			if (temp > d1[q[i]]) { d2[q[i]] = d1[q[i]]; d1[q[i]] = temp; }
			else d2[q[i]] = max(d2[q[i]], temp);
		}
	for (int i = 1; i <= r; i++)
		for (int j = e[q[i]]; j; j = next[j]){
			int temp;
			if (d1[q[i]] == d1[v[j]] + w[j]) temp = d2[q[i]]; else temp = d1[q[i]];
			up[v[j]] = max(up[q[i]] + w[j], temp + w[j]);
		}
	l1 = 1; l2 = 1;
	for (int i = 1; i <= n; i++) dis[i] = max(up[i], d1[i]);
	int now = 1, ans = 0;
	for (int i = 1; i <= n; i++){
		if (now <= i) { push1(i); push2(i); ++now; }
		while(q1[l1] < i) ++l1; while(q2[l2] < i) ++l2;
		while(now <= n && dis[q1[l1]] - dis[now ]<= m && dis[now] - dis[q2[l2]] <= m){
			push1(now); push2(now); ++now; 
		}
		ans = max(now - i, ans);
	}
	printf("%d\n", ans);
}
Problem2502

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 501, MAXM = 500001;
int n;
struct Tminflow{
	int tot, st[MAXM], ed[MAXM], num[MAXM], sum[MAXN], s, t;
	struct Tmaxflow{
		int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM];
		int h[MAXN], vh[MAXN];
		int s, t;
		void init()
		{
			for (int i = 1; i <= t; i++) e[i] = 0; tot = 1;	
		}
		void add(int A, int B, int C)
		{
			++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
			++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
		}
		int aug(int x, int f)
		{
			if (x == t) return f;
			int minh = t - 1, augc = f;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
				if (h[x] == h[v[i]] + 1){
					int t = aug(v[i], min(f, c[i]));
					c[i] -= t; c[i ^ 1] += t; f -= t;
					if (f == 0 || h[s] == t) return augc - f;
				}
				minh = min(minh, h[v[i]]);
			}
			if (f == augc){
				if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1];
			}
			return augc - f;	
		}
		void run()
		{
			memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
			vh[0] = t; while(h[s] < t) aug(s, 0x3f3f3f3f);
		}
		bool check()
		{
			for (int i = e[s]; i; i = next[i]) if (c[i] > 0) return false;
			for (int i = e[t]; i; i = next[i]) if (c[i ^ 1] > 0) return false;
			return true;
		}
	} maxflow;
	void add(int A, int B, int D)
	{
		sum[A] -= D; sum[B] += D; ++tot; st[tot] = A; ed[tot] = B; num[tot] = 0x3f3f3f3f;
	}
	bool feasible(int f)
	{
		maxflow.init(); maxflow.s = t + 1; maxflow.t = maxflow.s + 1;
		for (int i = 1; i <= t; i++){
			if (sum[i] > 0) maxflow.add(maxflow.s, i, sum[i]);
			if (sum[i] < 0) maxflow.add(i, maxflow.t, -sum[i]);
		}
		for (int i = 1; i <= tot; i++) maxflow.add(st[i], ed[i], num[i]);
		maxflow.add(t, s, f);
		maxflow.run();
		return maxflow.check();
	}
	int run()
	{
		int l = 0, r = n * n;
		while(l <= r){
			int m = l + r >> 1;
			if (feasible(m)) r = m - 1; else l = m + 1;
		}
		return l;
	}
} minflow;
bool used[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	minflow.s = n + 1; minflow.t = n + 2;
	for (int i = 1; i <= n; i++){
		int num; scanf("%d", &num);
		for (int j = 1; j <= num; j++){
			int t; scanf("%d", &t);
			used[t] = true;
			minflow.add(i, t, 1);
		}
		if (num == 0) minflow.add(i, minflow.t, 0);
	}
	for (int i = 1; i <= n; i++) if (!used[i]) minflow.add(minflow.s, i, 0);
	printf("%d\n", minflow.run());
}
Problem2506

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#define vi vector<int>::iterator
using namespace std;
vector<int> V[101][101];
vector<int> app[100001];
int n, m, a[1000001];
int getans(int l, int r, int p, int q)
{
	vi vir = upper_bound(V[p][q].begin(), V[p][q].end(), r);
	--vir;
	vi vil = upper_bound(V[p][q].begin(), V[p][q].end(), l - 1);
	return vir - vil + 1;
}	
int GETANS(int l, int r, int p, int q)
{
	int ret = 0;
	for (int t = q; t <= 10000; t += p){
		vi vir = upper_bound(app[t].begin(), app[t].end(), r); --vir;
		vi vil = upper_bound(app[t].begin(), app[t].end(), l - 1);
		ret += vir - vil + 1;
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); scanf("%d", &m);
	for (int i = 1; i <= 10000; i++)
		app[i].push_back(-1);
	for (int i = 1; i <= n; i++) { scanf("%d", &a[i]); app[a[i]].push_back(i); }
	for (int i = 1; i <= 100; i++)
		for (int j = 0; j < i; j++)
			V[i][j].push_back(-1); 
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= 100; j++)
				V[j][a[i] % j].push_back(i);
	for (int i = 1; i <= 10000; i++)
		app[i].push_back(n + 1);
	for (int i = 1; i <= 100; i++)
		for (int j = 0; j < i; j++)
			V[i][j].push_back(n + 1); 
	for (int i = 1; i <= m; i++){
		int l, r, p, q;
		scanf("%d%d%d%d", &l, &r, &p, &q);
		if (p <= 100) printf("%d\n", getans(l, r, p, q));
		else printf("%d\n", GETANS(l, r, p, q));
	}
}
Problem2508

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
using namespace std;
struct Tfunc{
	long double A, B, C, D, E, F;
	Tfunc() { }
	Tfunc(long double A, long double B, long double C, long double D, long double E, long double F) : A(A), B(B), C(C), D(D), E(E), F(F) { }
	void operator += (Tfunc T)
	{
		A += T.A; B += T.B; C += T.C; D += T.D; E += T.E; F += T.F;
	}
	void operator -= (Tfunc T)
	{
		A -= T.A; B -= T.B; C -= T.C; D -= T.D; E -= T.E; F -= T.F;
	}
	double getmin()
	{
		long double D0 = 4.0 * A * B - C * C, D1 = -2.0 * D * B + E * C, D2 = - 2.0 * A * E + C * D, x = 0, y = 0;
		if (fabs(D0) < 1e-9){
			long double tA = 2.0 * A + C, tB = C + 2.0 * B, tC = D + E;
		    if (fabs(tA) > 1e-9)
			    x = -tC / tA;
			else if (fabs(tB) > 1e-9)
					y = -tC / tB;
				 else y = -D / C;
		} 
		else { x = D1 / D0, y = D2 / D0; }
		return A * x * x + B * y * y + C * x * y + D * x + E * y + F;
	}
} func, a[1000001];
int tot, t, now;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int Q; scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		int op;
		scanf("%d", &op);
		double x1, y1, x2, y2, A, B, C, T;
		switch(op){
			case 0:
				scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
				A = y1 - y2; B = x2 - x1; C = x1 * y2 - x2 * y1;
				T = A * A + B * B;
				a[++tot] = Tfunc(A * A / T, B * B / T, 2 * A * B / T, 2 * A * C / T, 2 * B * C / T, C * C / T);
				func += a[tot];
				++now;
				break;
			case 1 :
				scanf("%d", &t); func -= a[t]; --now;
				break;
			case 2 : 
				if (now) printf("%.2lf\n", func.getmin()); else puts("0.00");
		}
	}
}
Problem2509

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int n, m, a[2001][2001], b[2001][2001], d[2001][2001], u[2001][2001], l[2001][2001], r[2001][2001];
struct Tbit{
	int data[2001];
	void clear() { memset(data, 0, sizeof(data)); }
	void ins(int x, int d)
	{
		for (; x <= n; x += (x & (-x)))
			data[x] += d; 
	}
	int sum(int x) 
	{
		int ret = 0; 
		for (; x; x -= (x & (-x))) ret += data[x]; 
		return ret; 
	}
} bit;
long long ans;
struct Tscan{
	int k, x, X;
	Tscan() { }
	Tscan(int k, int x, int X) : k(k), x(x), X(X) { }
	bool operator < (const Tscan & A) const { return x == A.x ? k < A.k : x < A.x; }
} scan[100001];
void solve(int x, int y)
{
	int tot = 0;
	for (; x <= n && y <= n; x++, y++){
		scan[++tot] = Tscan(-1, x, x - min(l[x][y], d[x][y]));
		scan[++tot] = Tscan(0, x, 0);
		scan[++tot] = Tscan(1, x + min(r[x][y], u[x][y]), x);
	}
	sort(scan + 1, scan + tot + 1);
	bit.clear();
	for (int i = 1; i <= tot; i++)
		switch(scan[i].k){
			case -1 : ans += bit.sum(n) - bit.sum(scan[i].X - 1); break; 
			case 0 : bit.ins(scan[i].x, 1); break;
			case 1 : bit.ins(scan[i].X, -1); break;
		}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); ++n;
	for (int i = 1; i <= m; i++){
		int x1, y1, x2, y2; scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		++x1; ++y1; ++x2; ++y2;
		if (y1 > y2) swap(y1, y2); if (x1 > x2) swap(x1, x2);
		if (x1 == x2) for (int j = y1 + 1; j <= y2; j++) b[x1][j] = true;
		if (y1 == y2) for (int j = x1 + 1; j <= x2; j++)
			a[j][y1] = true;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++){
			if (b[i][j]) d[i][j] = d[i][j - 1] + 1;
			if (a[i][j]) l[i][j] = l[i - 1][j] + 1;
		}
	for (int i = n; i >= 1; i--)
		for (int j = n; j >= 1; j--){
			if (b[i][j + 1]) u[i][j] = u[i][j + 1] + 1;
			if (a[i + 1][j]) r[i][j] = r[i + 1][j] + 1;
		}

	solve(1, 1);
	for (int i = 2; i <= n; i++) solve(1, i), solve(i, 1);
	cout << ans << endl;
}
Problem2510

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int a[2001], n, m, k; double ans[2001];
struct Tstatus{
	double data[2001];
	Tstatus() { memset(data, 0, sizeof(data)); }
	double & operator [] (int k) { return data[k]; }
	void operator *= (Tstatus & A)
	{
		Tstatus temp;
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				temp[(i + j) % n] += data[i] * A[j];
		for (int i = 0; i < n; i++) data[i] = temp[i];
	}	
} now, g;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);
	now[0] = 1;
	g[0] = (m - 1.0) / (m);
	g[n - 1] = 1.0 / m;
	for (; k; k >>= 1){
		if (k & 1) now *= g;
		g *= g;
	}
	for (int i = 0; i < n; i++){
		double ans = 0;
		for (int j = 0; j < n; j++)
			ans += now[j] * a[(i + j) % n];
		printf("%.3lf\n", ans);
	}
}
Problem2517

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#define sqr(a) ((a) * (a))
using namespace std;
struct Tladar{
	double x, y, r;
} L[10001];
int n, l, w;
double now;
bool ckin(int t, double x, double y)
{
	double dis = sqr(L[t].x - x) + sqr(L[t].y - y);
	return now * now * L[t].r * L[t].r - dis > 1e-6;
}
bool check(double x1, double y1, double x2, double y2)
{
	if (x2 - x1 < 1e-9 || y2 - y1 < 1e-6) return true;
	bool bad = true;
	for (int i = 1; i <= n; i++){
		bool c1 = ckin(i, x1, y1), c2 = ckin(i, x2, y1), c3 = ckin(i, x1, y2), c4 = ckin(i, x2, y2);
		if (c1 && c2 && c3 && c4) return true;
		if (c1 || c2 || c3 || c4) bad = false;
	}
	if (bad) return false;
	double mx = (x1 + x2) / 2.0, my = (y1 + y2) / 2.0;
	return check(x1, y1, mx, my) && check(x1, my, mx, y2) && check(mx, y1, x2, my) && check(mx, my, x2, y2);
}
int LL, WW;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d%d", &n, &LL, &WW);
	for (int i = 1; i <= n; i++) scanf("%lf%lf%lf", &L[i].x, &L[i].y, &L[i].r);
	double l = 0.0, r = 10000.0;
	while(r - l > 1e-6){
		now = (l + r) / 2.0;
		if (check(0.0, 0.0, LL, WW)) r = now; else l = now;
	}
	printf("%.3lf\n", l);
}
}
Problem2518

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001;
struct Trep{
	int data[4];
	int & operator [] (int k) { return data[k]; }
	Trep() { for (int i = 0; i < 4; i++) data[i] = i; }
	Trep operator + (Trep A) const
	{
		Trep ret;
		for (int i = 0; i < 4; i++) ret[i] = A[data[i]];
		return ret;
	}
} now;
int ret;
char s[MAXN];
struct Tsgt{
	int num[MAXN * 4][4]; Trep rep[MAXN * 4];
	void make(int idx, char ch)
	{
		memset(num[idx], 0, sizeof(num[idx]));
		switch(ch){
			case 'L' : rep[idx][0] = 3; rep[idx][1]= 0; rep[idx][2]= 2; rep[idx][3]= 1; num[idx][1] = 1; break;
			case 'R' : rep[idx][0] = 3; rep[idx][1]= 1; rep[idx][2]= 0; rep[idx][3]= 2; num[idx][2] = 1; break;
			case 'B' : rep[idx][0] = 3; rep[idx][1]= 2; rep[idx][2]= 1; rep[idx][3]= 0; num[idx][3] = 1; break;
		}
	}
	void update(int idx)
	{
		rep[idx] = rep[idx * 2] + rep[idx * 2 + 1];
		for (int i = 0; i < 4; i++) num[idx][i] = num[idx * 2][i];
		for (int i = 0; i < 4; i++) num[idx][i] += num[idx * 2 + 1][rep[idx * 2][i]]; 
	}
	void build(int idx, int l, int r)
	{
		int m = l + r >> 1;
		if (l == r) make(idx, s[l]);
		else{
			int m = l + r >> 1;
			build(idx * 2, l, m);
			build(idx * 2 + 1, m + 1, r);
			update(idx);
		}
	}
	void change(int idx, int l, int r, int x)
	{
		if (l == r) make(idx, s[l]);
		else{
			int m = l + r >> 1;
			if (x <= m) change(idx * 2, l, m, x); else change(idx * 2 + 1, m + 1, r, x);
			update(idx);
		}
	}
	void query(int idx, int l, int r, int ll, int rr)
	{
		if (ll > rr) return;
		if (ll <= l && rr >= r){
			ret += num[idx][now[0]]; 
			now = now + rep[idx];
			return;
		}
		int m = l + r >> 1;
		if (ll > m) now = now + rep[idx * 2];
		if (ll <= m) query(idx * 2, l, m, ll, rr);
		if (rr > m) query(idx * 2 + 1, m + 1, r, ll, rr);
	}
} sgt;
int n;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	scanf("%s", s);
	sgt.build(1, 0, n - 1);
	int Q; scanf("%d", &Q);
	while(Q--){
		int op; int l, r, x; char ch; scanf("%d", &op);
		switch(op){
			case 0 : scanf("%d %c", &x, &ch); --x; s[x] = ch; sgt.change(1, 0, n - 1, x); break;	 
			case 1 : scanf("%d %d", &l, &r); ret = 0; 
					 Trep temp; now = temp;
					 if (l == 1) ++ret, ++l;
					 sgt.query(1, 0, n - 1, l - 2, r - 2);
					 printf("%d\n", ret);
		}
	}

}
Problem2521

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tedge{
	int st, ed, len;
    void init() { scanf("%d%d%d", &st, &ed, &len); }	
} edge[1000001];
int n, m, k;
struct Tflow{
	int tot, e[1000001], v[1000001], next[1000001], c[1000001], s, t;
	int q[1000001], l, r, d[1000001];
	Tflow() { tot = 1; }
	void add(int A, int B, int C)
	{
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = C;
	}
	bool relabel()
	{
		for (int i = 1; i <= n; i++) d[i] = -1; d[s] = 0; l = r = 1; q[1] = s;
		while(l <= r){
			int x = q[l++];
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == -1){
				d[v[i]] = d[x] + 1; q[++r] = v[i];
			}
		}
		return d[t] != -1;
	}
	int find(int x, int f = 0x3f3f3f3f)
	{
		int augc = f; if (x == t) return f;
		for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == d[x] + 1){
			int t = find(v[i], min(f, c[i]));
			f -= t; c[i] -= t; c[i ^ 1] += t; if (f == 0) break;
		}
		if (f) d[x] = -1; return augc - f;
	}
	int run()
	{
		int ret = 0, t;
		while(relabel())
			while(t = find(s)) ret += t;
		return ret;
	}
} flow;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= m; i++) edge[i].init();
	for (int i = 1; i <= m; i++) if (i != k && edge[i].len <= edge[k].len){
		flow.add(edge[i].st, edge[i].ed, edge[k].len - edge[i].len + 1);
	}
	flow.s = edge[k].st; flow.t = edge[k].ed;
	printf("%d\n", flow.run());
}
Problem2534

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define log(a) (31 - __builtin_clz(a))
using namespace std;
typedef bool *Tcmp(int a, int b);
const int MAXN = 100001;
int n, mid, ans;
char tin[MAXN], in[MAXN];
bool cmp1(int a, int b) { return in[a] < in[b]; }
bool cmp2(int a, int b) { return in[n - a + 1] < in[n - b + 1]; }
struct Tlcp{
    int s[MAXN], sa[MAXN], wa[MAXN], wb[MAXN], wv[MAXN], ws[MAXN], *x, *y, rank[MAXN], h[MAXN], rmq[MAXN][20]; 
    void init()
    {
        x = wa; y = wb;
        x[sa[1]] = 1;
        for (int i = 2; i <= n; i++) x[sa[i]] = s[sa[i]] == s[sa[i - 1]] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
        for (int j = 1, m = x[sa[n]]; m < n; j <<= 1){
            int p = 0;
            for (int i = n - j + 1; i <= n; i++) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > j) y[++p] = sa[i] - j;
            for (int i = 1; i <= m; i++) ws[i] = 0;
            for (int i = 1; i <= n; i++) ws[wv[i] = x[y[i]]]++;
            for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
            for (int i = n; i >= 1; i--) sa[ws[wv[i]]--] = y[i];
            swap(x, y); x[sa[1]] = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
            m = x[sa[n]];
        }
        for (int i = 1; i <= n; i++) rank[i] = x[i];
        int k = 0;
        for (int i = 1; i <= n; i++){
            if (rank[i] == 1) { h[rank[i]] = k = 0; continue; }
            if (k > 0) --k;
            int j = sa[rank[i] - 1];
            while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) ++k;
            h[rank[i]] = k;
        }
        for (int i = 1; i <= n; i++) rmq[i][0] = h[i];
        int lg = log(n);
        for (int j = 1; j <= lg; j++)
            for (int i = 1; i <= n - (1 << j) + 1; i++)
                rmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);
    }
    int ask(int l, int r)
    {
        if (l == 0 || r == 0 || l > n || r > n) return 0;
        l = rank[l]; r = rank[r];
        if (l > r) swap(l, r); ++l;
        int x = log(r - l + 1);
        return min(rmq[l][x], rmq[r - (1 << x) + 1][x]);
    }
} lcp1, lcp2;
void solve(int l, int r)
{
    if (r - l + 1 < mid + 2) return;
    int m = l + r >> 1, len = r - l + 1;
    solve(l, m); solve(m + 1, r);
    for (int i = max(l, m - mid + 1); i <= min(m + 1, r - mid); i++){
        int midl = i, midr = i + mid - 1;
        int mlen = min(midl - l, r - midr); 
        for (int l = 1; l <= mlen; l++)
            if (lcp1.ask(midl - l, midr + 1) >= l) ++ans;
    }
    for (int i = l; m - i - 1 >= mid; i++){
        int a = min(lcp1.ask(i, m), min(m - i + 1, r - m + 1)), b = min(lcp2.ask(n - i + 1, n - m + 1), min(m - i + 1, i - l + 1));
        --a; 
        int t = m - mid - i;
        ans += max(0, min(a, t - 1) - max(t - b, 1) + 1);
    }
    ++m;
    for (int i = r; i - m - 1 >= mid; i--){
        int a = min(lcp1.ask(i, m), min(i - m + 1, r - i + 1)), b = min(lcp2.ask(n - m + 1, n - i + 1), min(i - m + 1, m - l + 1));
        if (a == 0 || b == 0) continue;
        --b;
        int t = i - mid - m;
        ans += max(0, min(a, t - 1) - max(t - b, 1) + 1);
    }
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d", &mid);
    scanf("%s", in + 1); n = strlen(in + 1);
    for (int i = 1; i <= n; i++) lcp1.s[i] = in[i];
    for (int i = 1; i <= n; i++) lcp2.s[i] = in[n - i + 1];
    for (int i = 1; i <= n; i++) lcp1.sa[i] = lcp2.sa[i] = i;
    sort(lcp1.sa + 1, lcp1.sa + n + 1, cmp1);
    sort(lcp2.sa + 1, lcp2.sa + n + 1, cmp2);
    lcp1.init(); lcp2.init();
    solve(1, n);
    printf("%d\n", ans);
}
Problem2539

#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <complex>
#include <string>
#include <map>
#define Tpoint complex<double>
using namespace std;
map<string, int> M;
const int SIZE = 16384 - 1, MAXN = 20001, MAXM = 300001;
int q[SIZE + 100], l, r;
int dis[MAXN], from[MAXN]; bool vis[MAXN];
int e[MAXN], w[MAXM], next[MAXM], c[MAXM], v[MAXM], tot = 1;
int S, T, n, m, flow, cost, k;
Tpoint p[MAXN];
bool online(int a, int b, int c)
{
	if (abs(p[a] - p[b]) > abs(p[c] - p[b])) return false;
	return fabs(arg(p[a] - p[b]) - arg(p[c] - p[b])) < 1e-9;
}
bool check(int s, int t)
{
	if (abs(p[s] - p[t]) > k) return false;
	for (int i = 1; i <= 2 * n; i++) if (i != s && i != t && online(i, s, t)) return false;
	return true; 
}
void add(int A, int B, int C, int D)
{
    ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
    ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
}
bool spfa()
{
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    l = 0; r = 1; q[1] = S; vis[S] = true; dis[S] = 0;
    while(l != r){
        l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
        for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
            dis[v[i]] = dis[x] + w[i]; from[v[i]] = i;
            if (!vis[v[i]]){
                r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true;
                }
            }
        }
    return dis[T] < 0x3f3f3f3f;
}
void aug()
{
    int t = 0x3f3f3f3f;
    for (int i = T; i != S; i = v[from[i] ^ 1]) t = min(t, c[from[i]]);
    for (int i = T; i != S; i = v[from[i] ^ 1]){
        c[from[i]] -= t; c[from[i] ^ 1] += t;
        }
    flow += t; cost += t * dis[T];
} 
void change(string & t)
{
	for (int i = 0; i < t.size(); i++) t[i] = tolower(t[i]);
}
string name, name1, name2;
int MAP[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    cin >> k >> n;
    for (int i = 1; i <= n; i++){
		int x, y;
		cin >> x >> y >> name;
		p[i] = Tpoint(x, y);
		change(name);
		M[name] = i;
	}
	for (int i = 1; i <= n; i++){
		int x, y;
		cin >> x >> y >> name;
		p[i + n] = Tpoint(x, y);
		change(name);
		M[name] = i + n;
	}
	S = 2 * n + 1; T = S + 1;
	for (int i = 1; i <= n; i++){
		add(S, i, 1, 0);
		add(i + n, T, 1, 0);
	}

	int p;
	for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++)
	MAP[i][j] = 1;
	while(1){
		cin >> name1; if (name1 == "End") break;
		cin >> name2 >> p;
		change(name1); change(name2);
		int s = M[name1], t = M[name2];
		if (s > t) swap(s, t);
		if (check(s, t)){
			MAP[s][t - n] = p;
		}
	}
	for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++)
	if (check(i, j + n)){
		add(i, j + n, 1, -MAP[i][j]);
	}
	while(spfa()) aug();
	cout << -cost << endl;	
}
Problem2542

#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iomanip>
#include <iostream>
using namespace std;
const int MAXN = 600001, MAXM = 600001, SIZE = 32767;
int n, K;
struct Tcostflow{
    int flow, s, t, ss;
    int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM];
	double cost, dis[MAXN], w[MAXM];
    int f[MAXN], q[SIZE + 100], l, r; bool vis[MAXN];
	Tcostflow() { tot = 1; }
    void add(int A, int B, int C, double D)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D;
    }
    bool spfa()
    {
        for (int i = 1; i <= t; i++) dis[i] = 1e99, vis[i] = false, f[t] = 0;
        l = 0; r = 1; q[1] = s; vis[s] = true; dis[s] = 0.0;
        while(l != r){
            l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
            for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i] + 1e-12){
                dis[v[i]] = dis[x] + w[i]; f[v[i]] = i;
                if (!vis[v[i]]) { r = (r + 1) & SIZE; q[r] = v[i]; vis[v[i]] = true; }
            }
        }
        return dis[t] < 1e99;
    }
    void aug()
    {
        int af = 0x3f3f3f3f;
        for (int i = t; i != s; i = v[f[i] ^ 1])
			af = min(af, c[f[i]]);
        for (int i = t; i != s; i = v[f[i] ^ 1]) c[f[i]] -= af, c[f[i] ^ 1] += af;
        flow += af; cost += dis[t] * af;
    }
    void run()
    {
        while(spfa()){
			aug();
			if (flow == K) break;
		} 
   }
} costflow;
int num[MAXN]; double k[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &K);
	costflow.s = n + 1; costflow.ss = n + 2; costflow.t = n + 3;
	for (int i = 1; i <= n; i++) scanf("%lf", &k[i]);
	for (int i = 1; i <= n; i++) scanf("%d", &num[i]);
	costflow.add(costflow.s, costflow.ss, K, 0.0);
	for (int i = 1; i <= n; i++) if (k[i] > 0) costflow.add(costflow.ss, i, num[i], -log(k[i]));
	for (int i = 1; i <= n; i++){
		int t; scanf("%d", &t);
		if (t) costflow.add(i, costflow.t, K, 0.0);
	}
	while(1){
		int x, y, num; double t;
		scanf("%d%d", &x, &y); if (x < 0) break; scanf("%lf%d", &t, &num);
		costflow.add(x, y, num, -log(t));
		costflow.add(y, x, num, -log(t));
	}
	costflow.run();
	double t = exp(-costflow.cost);
	if (t < 1e-5) puts("0.0000097785");
	else cout << setprecision(5) << showpoint << t << endl;
}
Problem2553

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tnode{
	int ch[26], fail; bool flag;
} a[1000001];
int q[1000001], T, tot, n, len, size;
struct Tmatrix{
	long double data[101][101];
	long double * operator [] (int k) { return data[k]; }
	void operator *= (const Tmatrix & A);
} M;
Tmatrix temp, g, now;
void Tmatrix::operator *= (const Tmatrix & A)
{
	for (int i = 1; i <= T; i++)
		for (int j = 1; j <= T; j++){
			long double t = 0.0;
			for (int k = 1; k <= T; k++) t += data[i][k] * A.data[k][j];
			temp[i][j] = t;
		}
	for (int i = 1; i <= T; i++) for (int j = 1; j <= T; j++) data[i][j] = temp[i][j];
}
void pow(int n)
{
	--n; now = M;
	for (; n; n >>= 1){
		if (n & 1) now *= M;
		M *= M;
	}
}
void insert(char *S)
{
	int t = 1;
	for (; *S; S++){
		if (a[t].ch[*S - 'a'] == 0) a[t].ch[*S - 'a'] = ++tot;
		t = a[t].ch[*S - 'a'];
	}
	a[t].flag = true;
}
void build()
{
	int l = 1, r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = 0; i < size; i++){
			int now = a[x].ch[i], t;
			t = x == 1 ? 1 : a[a[x].fail].ch[i];
			if (now == 0) a[x].ch[i] = t;
			else { q[++r] = now; a[now].flag |= a[t].flag; a[now].fail = t; }
		}
	}
}
char s[100001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	tot = 1;
	scanf("%d%d%d", &n, &len, &size);
	for (int i = 1; i <= n; i++){
		scanf("%s", s);
		insert(s);
	}
	build();
	T = tot + 1;
	for (int i = 1; i <= tot; i++)
		for (int c = 0; c < size; c++){
			if (a[a[i].ch[c]].flag) { M[i][1] += 1.0 / size; M[i][T] += 1.0 / size;}
			else M[i][a[i].ch[c]] += 1.0 / size;
		}
	M[T][T]++;
	pow(len);
	printf("%.10lf\n", (double)now[1][T]);
}
Problem2555

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>


using namespace std;
int A[3000001];
struct Tsamnode{
	int go[26], len, f;
} a[3000001]; int tot = 1, root = 1, last = 1;
void build(int nc)
{
	int p = ++tot;
	while(last && a[last].go[nc] == 0){
		a[last].go[nc] = p;
		last = a[last].f;
	}
	if (last == 0){
		a[p].f = 1;
	}
	else{
		int q = a[last].go[nc];
		if (a[q].len == a[last].len + 1){
			a[p].f = q;
		}
		else{
			int nq = ++tot; a[nq] = a[q]; a[nq].len = a[last].len + 1; A[nq] = A[q];
			a[q].f = nq; a[p].f = nq;
			while(last && a[last].go[nc] == q){
				a[last].go[nc] = nq;
				last = a[last].f;
			}
		}
	}
	last = p;
	while(p) ++A[p], p = a[p].f;
}
int ask(char *S)
{
	int now = 1;
	for (; *S; S++){
		if (a[now].go[*S - 'A'] == 0) return 0;
		now = a[now].go[*S - 'A'];
	}
	if (now == 1) return 0; else return A[now];
}
char s[1000001], ss[1000001];
void gen(char *s, int mask)
{
	int n = strlen(s);
	for (int i = 0; i < n; i++){
		mask = (mask * 131 + i) % n;
		swap(s[i], s[mask]);
	}
}
int main()
{
	int Q, A, B, mask = 0; scanf("%d", &Q);
	scanf("%s", s);
	for (char *S = s; *S; S++) build(*S - 'A');
	while(Q--){
		char op[101]; scanf("%s", op);
		switch(*op){
			case 'Q':{
				scanf("%s", ss);
				gen(ss, mask);
				int ans = ask(ss);
				mask ^= ans;
				printf("%d\n", ans);
				break;
			}
			case 'A':
				scanf("%s", ss);
				gen(ss, mask);
				for (char *S = ss; *S; S++)
					build(*S - 'A');
		}
	}
}
Problem2555

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f;
	int _cover, num;
	bool isroot;
	void cover(int d)
	{
		if (this == a) return;
		_cover += d; num += d;
	}
	void push()
	{
		if (_cover != 0){
			a[c[0]].cover(_cover); a[c[1]].cover(_cover);
			_cover = 0;
		}
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a;
	}
} A[3000001], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
}
void access(int x)
{
	int p = 0, q = x;
	while(q){
		splay(q);
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p; A[p].isroot = false;
		p = q; q = A[q].f;
	}	
}
void cut(int x, int y)
{
	access(x); splay(y);
	A[y].c[1] = 0; A[x].f = 0; A[x].isroot = true;
}
void add(int x)
{
	access(x); splay(x); A[x].cover(1);
}
int query(int x)
{
	splay(x); return A[x].num;
//	return A[x].num;
}
struct Tsamnode{
	int go[26], len, f;
} a[3000001]; int tot = 1, root = 1, last = 1;
void build(int nc)
{
	int p = ++tot; A[p].isroot = true;
	while(last && a[last].go[nc] == 0){
		a[last].go[nc] = p;
		last = a[last].f;
	}
	if (last == 0){
		a[p].f = 1; A[p].f = 1;
	}
	else{
		int q = a[last].go[nc];
		if (a[q].len == a[last].len + 1){
			a[p].f = q; A[p].f = q;
		}
		else{
			int nq = ++tot; a[nq] = a[q]; a[nq].len = a[last].len + 1;
			A[nq].isroot = true; A[nq].f = a[q].f;
			cut(q, a[q].f); a[q].f = nq; A[q].f = nq; A[nq].num = A[q].num; 
			a[p].f = nq; A[p].f = nq;
			while(last && a[last].go[nc] == q){
				a[last].go[nc] = nq;
				last = a[last].f;
			}
		}
	}
	last = p;
	//while(p) ++A[p].num, p = a[p].f;
	add(p);
}
int ask(char *S)
{
	int now = 1;
	for (; *S; S++){
		if (a[now].go[*S - 'A'] == 0) return 0;
		now = a[now].go[*S - 'A'];
	}
	if (now == 1) return 0; else return query(now);
}
char s[1000001], ss[1000001];
void gen(char *s, int mask)
{
	int n = strlen(s);
	for (int i = 0; i < n; i++){
		mask = (mask * 131 + i) % n;
		swap(s[i], s[mask]);
	}
}
int main()
{
	A[1].isroot = true;
	int Q, A, B, mask = 0; scanf("%d", &Q);
	scanf("%s", s);
	for (char *S = s; *S; S++) build(*S - 'A');
	while(Q--){
		char op[101]; scanf("%s", op);
		switch(*op){
			case 'Q':{
				scanf("%s", ss);
				gen(ss, mask);
				int ans = ask(ss);
				mask ^= ans;
				printf("%d\n", ans);
				break;
			}
			case 'A':
				scanf("%s", ss);
				gen(ss, mask);
				for (char *S = ss; *S; S++)
					build(*S - 'A');
		}
	}
}
Problem2560

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MO = 1000000007;
int f[1 << 18], g[1 << 18], n;
int map[101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			scanf("%d", &map[i][j]);
	for (int S = 0; S < (1 << n); S++){
		g[S] = 1;
		for (int i = 0; i < n; i++) if ((S >> i) & 1)
			for (int j = i + 1; j < n; j++) if ((S >> j) & 1)
				g[S] = (long long) g[S] * (map[i][j] + 1) % MO;
	}
	for (int S = 0; S < (1 << n); S++){
		f[S] = g[S]; int last = S & (-S), t = 0;
		for (int tS = S; tS; tS = S & (tS - 1)) if (tS != S && ((tS & last) != 0))
			t = ((long long)f[tS] * g[S ^ tS] % MO + t) % MO;
		f[S] = (f[S] - t) % MO;
	}
	cout << (f[(1 << n) - 1] + MO) % MO << endl;
}
Problem2561

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
struct Tedge{
    int st, ed, len;
    void init() { scanf("%d%d%d", &st, &ed, &len); }    
} edge[1000001];
int n, m, k;
struct Tflow{
    int tot, e[1000001], v[1000001], next[1000001], c[1000001], s, t;
    int q[1000001], l, r, d[1000001];
    Tflow() { tot = 1; }
    void add(int A, int B, int C)
    {
        ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
        ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = C;
    }
    bool relabel()
    {
        for (int i = 1; i <= n; i++) d[i] = -1; d[s] = 0; l = r = 1; q[1] = s;
        while(l <= r){
            int x = q[l++];
            for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == -1){
                d[v[i]] = d[x] + 1; q[++r] = v[i];
            }
        }
        return d[t] != -1;
    }
    int find(int x, int f = 0x3f3f3f3f)
    {
        int augc = f; if (x == t) return f;
        for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && d[v[i]] == d[x] + 1){
            int t = find(v[i], min(f, c[i]));
            f -= t; c[i] -= t; c[i ^ 1] += t; if (f == 0) break;
        }
        if (f) d[x] = -1; return augc - f;
    }
    int run()
    {
        int ret = 0, t;
        while(relabel())
            while(t = find(s)) ret += t;
        return ret;
    }
} flow1, flow2;
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) edge[i].init();
    int st, ed, len; scanf("%d%d%d", &st, &ed, &len);
    for (int i = 1; i <= m; i++){
		if (edge[i].len < len) flow1.add(edge[i].st, edge[i].ed, 1);
    	if (edge[i].len > len) flow2.add(edge[i].st, edge[i].ed, 1);
	}
    flow1.s = flow2.s = st;
    flow1.t = flow2.t = ed;
    printf("%d\n", flow1.run() + flow2.run());
}
Problem2563

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
double a[1000001], ans;
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%lf", &a[i]);
	for (int i = 1; i <= m; i++){
		int a, b; double c; scanf("%d%d%lf", &a, &b, &c);
		::a[a] += c / 2.0; ::a[b] += c / 2.0;
	}
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i += 2) ans += a[i + 1] - a[i];
	printf("%.0lf\n", ans);
}
Problem2564

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define ll long long
using namespace std;
const int MAXN = 1000001;
struct Tpoint{
	ll x, y;
	Tpoint() { }
	Tpoint(ll x, ll y) : x(x), y(y) { }
	void init()
	{
		int _x, _y; scanf("%d%d", &_x, &_y);
		x = _x; y = _y;
	}
	bool operator < (const Tpoint & A) const 
	{
		return x == A.x ? y < A.y : x < A.x;
	}
	Tpoint operator + (const Tpoint & A) const
	{
		return Tpoint(x + A.x, y + A.y);
	}
	Tpoint operator - (const Tpoint & A) const
	{
		return Tpoint(x - A.x, y - A.y);
	}
	ll operator * (const Tpoint & A) const
	{
		return x * A.y - y * A.x;
	}
};
struct Thull{
	int n, top, tot;
   	Tpoint in[MAXN], p[MAXN];
	int stack[MAXN];
	Tpoint & operator [] (int k) { return p[k]; }
	void init()
	{
		for (int i = 1; i <= n; i++) in[i].init();
		sort(in + 1, in + n + 1);
		for (int i = 1; i <= n; i++){
			while(top > 1 && (in[i] - in[stack[top - 1]]) * (in[stack[top]] - in[stack[top - 1]]) >= 0) --top;
			stack[++top] = i;
		}
		int lt = top - 1;
		for (int i = n - 1; i; i--){
			while(top - lt > 1 && (in[i] - in[stack[top - 1]]) * (in[stack[top]] - in[stack[top - 1]]) >= 0) --top;
			stack[++top] = i;
		}
		for (int i = 1; i <= top; i++) p[i] = in[stack[i]];
		n = top;
		p[0] = p[n]; p[n + 1] = p[1];
	}
} h1, h2;
int tot;
Tpoint ans[MAXN];
int next1(int t) { if (t == h1.n) return 1; else return t + 1; } 
int next2(int t) { if (t == h2.n) return 1; else return t + 1; } 
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &h1.n, &h2.n);
	h1.init(); h2.init();
	int t2 = 1;
	for (int i = 1; i < h1.n; i++){
		ans[++tot] = h1[i] + h2[t2];
		while((h1[next1(i)] - h1[i]) * (h2[next2(t2)] - h2[t2]) < 0){
			t2 = next2(t2); ans[++tot] = h1[i] + h2[t2]; 
		}
	}
	while(t2 != 1){
		ans[++tot] = h1[h1.n] + h2[t2]; t2 = next2(t2);
	}
	ans[tot + 1] = ans[1];
	long long area = 0;
	for (int i = 1; i <= tot; i++) area += ans[i] * ans[i + 1];
	cout << area << endl;
}
Problem2565

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
char s[1000001], in[1000001];
int n, a[1000001], tot, maxv = 0, ans;
pair<pair<int, int>, int> scan[1000001];
void manacher()
{
	int far = 1, id = 1;
	a[1] = 1; s[0] = '!'; s[n + 1] = '@';
	for (int i = 2; i <= n; i++){
		if (far >= i) a[i] = min(a[id * 2 - i], far - i + 1);
		while(s[i + a[i]] == s[i - a[i]]) ++a[i];
		if (i + a[i] - 1 >= far) { far = i + a[i] - 1; id = i; }
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	gets(in); n = strlen(in);
	for (int i = 1; i <= 2 * n + 1; i++){
		if (i & 1) s[i] = '*'; else s[i] = in[i / 2 - 1];
	}
	n = 2 * n + 1;
	manacher();
	for (int i = 1; i <= n; i++) scan[++tot] = make_pair(make_pair(a[i] + i, 0), i);
	for (int i = 1; i <= n; i++) scan[++tot] = make_pair(make_pair(i - a[i] + 1, 1), i);
	sort(scan + 1, scan + tot + 1);
	for (int i = 1; i <= tot; i++)
		if (scan[i].first.second == 1) maxv = max(maxv, scan[i].second);
		else{
			if (maxv - scan[i].second + 1 > ans){
				//cerr << maxv << " " << scan[i].second << endl;
				ans = max(ans, maxv - scan[i].second + 1);
			}
		}
	cout << ((ans * 2 - 2) + 1) / 2<< endl;
}
Problem2566

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <set>
#include <map>
#include <vector>
#define MII map<int, int>
#define SI multiset<int>
#define MSII map<int, SI>
#define ITR iterator
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
using namespace std;
const int MAXN = 20001;
MSII mds[MAXN];
int n, l, r, q[MAXN], size[MAXN], maxsize[MAXN];
int tot, e[MAXN * 2], v[MAXN * 2], next[MAXN * 2], w[MAXN * 2], f[MAXN], dis[MAXN], color[MAXN];
bool del[MAXN];
SI ans, rec[MAXN];
MII disrec[MAXN];
vector<int> where[MAXN];
int find_heavy(int x)
{
	l = r = 1; q[1] = x; f[x] = 0;
	while(l <= r){
		int x = q[l++];
		for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]){
			q[++r] = v[i]; f[v[i]] = x;
		}
	}
	for (int i = r; i >= 1; i--){
		int x = q[i]; size[x] = 1; maxsize[x] = 0;
		for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]){
			size[x] += size[v[i]]; maxsize[x] = max(maxsize[x], size[v[i]]);
		}
		maxsize[x] = max(maxsize[x], r - size[x]);
	}
	int w = q[1];
	for (int i = 2; i <= r; i++) if (maxsize[q[i]] < maxsize[w]) w = q[i];
	return w;
}
int get(const SI & A)
{
	if (A.size() <= 1) return 0x3f3f3f3f;
	return *A.begin() + *(++A.begin());
}
void split(int x)
{
	x = find_heavy(x); if (r == 1) return; f[x] = 0; del[x] = true;
	mds[++tot][color[x]].insert(0); where[x].push_back(tot); disrec[tot][x] = 0;
	for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]){
		q[l = r = 1] = v[i]; f[v[i]] = x; dis[v[i]] = w[i]; disrec[tot][v[i]] = w[i];
		while(l <= r){
			int x = q[l++]; mds[tot][color[x]].insert(dis[x]); where[x].push_back(tot);
			for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]){
				q[++r] = v[i]; f[v[i]] = x; dis[v[i]] = dis[x] + w[i]; disrec[tot][v[i]] = dis[v[i]];
			}
		}
	}
	foreach(tx, mds[tot])
		rec[tot].insert(get(tx->second));
	::ans.insert(*rec[tot].begin());
	for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != f[x]) split(v[i]);
}
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &color[i]);
	for (int i = 1; i < n; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		add(a, b, c); add(b, a, c);
	}
	tot = 0;
	split(1);
	printf("%d\n", *ans.begin());
	int Q; scanf("%d", &Q);
	while(Q--){
		int d, c;
		scanf("%d%d", &d, &c); if (c == color[d]) { printf("%d\n", *ans.begin()); continue; }
		foreach(x, where[d]){
			int w = *x, di = disrec[w][d];
			ans.erase(ans.find(*rec[w].begin()));

			rec[w].erase(rec[w].find(get(mds[w][color[d]])));
			if (mds[w].count(c)) rec[w].erase(rec[w].find(get(mds[w][c])));

			mds[w][color[d]].erase(di);
			mds[w][c].insert(di);

			rec[w].insert(get(mds[w][c]));
			rec[w].insert(get(mds[w][color[d]]));

			ans.insert(*rec[w].begin());
		}
		color[d] = c;
	printf("%d\n", *ans.begin());
	}
}
Problem2568

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>
using namespace std;
const int B = 1 << 16;
int n, delta, m;
struct Tbit{
	int data[(1 << 16) + 1];
	void add(int a, int b)
	{
		++a;
		for (; a <= (1 << 16); a += (a & (-a))) data[a] += b;
	}	
	int getsum(int a)
	{
		++a;
		int ret = 0;
		for (; a; a -= (a & (-a))) ret += data[a];
		return ret;
	}
} bit[16];
int get(int b, int t) { return t < 0 ? 0 : bit[b].getsum(t); }
int query(int b)
{
    int l = 1 << b, r = (1 << (b + 1)) - 1, base = 1 << (b + 1), t = delta % base;
    l = ((l - t) % base + base) % base; r = ((r - t) % base + base) % base;
    if (l <= r) return get(b, r) - get(b, l - 1); else return n - (get(b, l - 1) - get(b, r));
}
map<int, int> M;
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    int Q; scanf("%d", &Q);
    while(Q--){
        char op[199]; int num;
        scanf(" ");
        scanf("%s%d", op, &num);
        switch(*op){
            case 'A' : delta += num; break; 
            case 'Q' : printf("%d\n", query(num)); break;
            case 'I' : {
					num -= delta; ++M[num]; ++n;
					num = (num % B + B) % B;
					for (int i = 0; i < 16; i++) bit[i].add(num % (1 << (i + 1)), 1);
					break;
					}
			case 'D' : {
					num -= delta; int t = M[num]; M.erase(num); n -= t;
					num = (num % B + B) % B;
					for (int i = 0; i < 16; i++) bit[i].add(num % (1 << (i + 1)), -t);
					break;
					}
			
            	
        }
    }
}
Problem2580

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
struct Tnode{
	int ch[26], flag, fail;
} a[1001];
int f[1100][1100];
int n, l, tot, q[1100];
char s[1100];
void insert(char *s, int num)
{
	int now = 1;
	for (; *s; s++){
		if (a[now].ch[*s - 'A'] == 0) a[now].ch[*s - 'A'] = ++tot;
		now = a[now].ch[*s - 'A'];
	}
	a[now].flag |= (1 << num);
}
void buildac()
{
	int l = 1, r = 1; q[1] = 1;
	while(l <= r){
		int x = q[l++];
		for (int i = 0; i < 26; i++){
			a[a[x].ch[i]].fail = x == 1 ? 1 : a[a[x].fail].ch[i];
			if (a[x].ch[i] == 0) a[x].ch[i] = a[0].fail;
			else { a[a[x].ch[i]].flag |= a[a[a[x].ch[i]].fail].flag; q[++r] = a[x].ch[i]; }
		}
	}
}
int main()
{
	tot = 1;
	scanf("%d%d", &n, &l); getchar();
	for (int i = 0; i < n; i++){
		gets(s); insert(s, i);
	}
	buildac();
	memset(f, 0xe0, sizeof(f));
	f[0][1] = 0;
	for (int i = 0; i < l; i++)
		for (int j = 1; j <= tot; j++) if (f[i][j] >= 0)
			for (int c = 0; c < 26; c++)
				f[i + 1][a[j].ch[c]] = max(f[i + 1][a[j].ch[c]], f[i][j] + __builtin_popcount(a[a[j].ch[c]].flag));
	int ans = 0;
	for (int i = 1; i <= tot; i++) ans = max(ans, f[l][i]);
 	printf("%d\n", ans);
}
Problem2582

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN = 1000001, MO = 1000000007;
int tot, e[MAXN], next[MAXN * 2], v[MAXN * 2];
int g[MAXN][2], f[MAXN][2], len, w[MAXN]; 
int deep[MAXN], anc[MAXN], fa[MAXN];
bool vis[MAXN];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
int pow(int a, int b)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (long long)ret * a % MO;
		a = (long long)a * a % MO;
	}
	return ret;
}
void circle()
{
	int ans = 1;
	for (int i = 1; i <= len; i++) ans = (long long)ans * f[w[i]][0] % MO;
	ans = (long long)ans * 2 % MO;
	f[w[1]][0] = 0; f[w[1]][1] = ans;
}
int u, temp, zeronum = 0;;
void dfs(int x)
{
	vis[x] = true; anc[x] = deep[x];
	f[x][0] = 1; f[x][1] = 0;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		deep[v[i]] = deep[x] + 1; fa[v[i]] = i; dfs(v[i]);
		anc[x] = min(anc[x], anc[v[i]]);
	}
	else if (i != (fa[x] ^ 1))
		anc[x] = min(anc[x], deep[v[i]]);
	zeronum = 0; temp = 1;
	for (int i = e[x]; i; i = next[i])
		if (v[fa[v[i]] ^ 1] == x && anc[v[i]] > deep[x]) //Bridge
			//f[x][0] = (long long)f[x][0] * f[v[i]][0] % MO;
			if (f[v[i]][0] == 0) zeronum++;
			else temp = (long long)temp * f[v[i]][0];
	if (zeronum > 0) f[x][0] = 0;
	if (zeronum > 1) goto next;
	for (int i = e[x]; i; i = next[i])
		if (v[fa[v[i]] ^ 1] == x && anc[v[i]] > deep[x]) //Bridge
			if (f[v[i]][0] == 0) f[x][1] = (f[x][1] + ((long long)temp * (f[v[i]][1] + f[v[i]][0]) % MO)) % MO; 
			else if (zeronum == 0) f[x][1] = (f[x][1] + ((long long)temp * (f[v[i]][1] + f[v[i]][0]) % MO * pow(f[v[i]][0], MO - 2) % MO)) % MO;
next:;
	for (int i = e[x]; i; i = next[i]) if (i != fa[v[i]] && deep[v[i]] > deep[x]) {//Circle
		len = 1; u = v[i]; while(u != x) { ++len; w[len] = u; u = v[fa[u] ^ 1]; } w[1] = x;
		circle();
	}
}
int n, m;
int main()
{

	tot = 1;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++){
		int a, b; scanf("%d%d", &a, &b); add(a, b); add(b, a);
	}
	int ans = 1;
	for (int i = 1; i <= n; i++){
		if (!vis[i]){
			dfs(i);
			ans = (long long)ans * (f[i][0] + f[i][1]) % MO;
		}
	}
	printf("%d\n", ans);

}
Problem2584

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <set>
#include <queue>
const int MAXN = 500001;
using namespace std;
struct Tpoint{
	int x, y;
	void init() { scanf("%d%d", &x, &y); }
	bool operator < (const Tpoint & A) const { return x < A.x; }
};
int nowx;
struct Tline{
	Tpoint a, b; int who;
	void init() { a.init(); b.init(); if (b < a) swap(a, b); }
	double gety(int x) const { return a.y + (double)(b.y - a.y) / (double)(b.x - a.x) * double(x - a.x); }
	bool operator < (const Tline & A) const { return gety(nowx) - A.gety(nowx) < -1e-6; }
} line[MAXN];
struct Tscan{
	int op, who, pos;
	Tscan() { }
	Tscan(int op, int who, int pos) : op(op), who(who), pos(pos) { } 
	bool operator < (const Tscan & A) const { return pos == A.pos ? op < A.op : pos < A.pos; }
} scan[MAXN * 4];
struct Tque{
	int who, dir;
	void init() { scanf("%d%d", &who, &dir); }
} que[MAXN];
set<Tline> S;
int n, tot;
struct Tdag{
	int tot, e[MAXN * 4], v[MAXN * 4], next[MAXN * 4], ans[MAXN], in[MAXN];
	queue<int> Q;
   	int & operator [] (int k) { return ans[k]; }	
	void clear()
	{
		for (int i = 1; i <= n; i++) e[i] = 0, in[i] = 0;
		tot = 0; 
	}
	void add(int a, int b)
	{
		swap(a, b);
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; ++in[b];
	}
	void topsort()
	{
		int ansnum = 0;
		for (int i = 1; i <= n; i++) if (in[i] == 0) Q.push(i), ans[++ansnum] = i;
		while(!Q.empty()){
			int x = Q.front(); Q.pop();
			for (int i = e[x]; i; i = next[i]){
				--in[v[i]]; if (in[v[i]] == 0) { Q.push(v[i]); ans[++ansnum] = v[i]; }
			}
		}
	}
} dag;
struct Tsgt{
	int minn[100001 * 8], maxn[100001 * 8], _minadd[100001 * 8], _maxadd[100001 * 8];
	void clear() 
	{ 
		memset(minn, 0x3f, sizeof(minn)); memset(maxn, 0xe0, sizeof(maxn)); 
		memset(_minadd, 0x3f, sizeof(_minadd)); memset(_maxadd, 0xe0, sizeof(_maxadd));
	}
	void minadd(int idx, int d)
	{
		minn[idx] = min(minn[idx], d); 
		_minadd[idx] = min(_minadd[idx], d); 
	}
	void maxadd(int idx, int d)
	{
		maxn[idx] = max(maxn[idx], d);
		_maxadd[idx] = max(_maxadd[idx], d);
	}
	void update(int idx)
	{
		maxn[idx] = max(maxn[idx * 2], maxn[idx * 2 + 1]);
		minn[idx] = min(minn[idx * 2], minn[idx * 2 + 1]);
	}
	void push(int idx)
	{
		if (_minadd[idx] != 0x3f3f3f3f) { minadd(idx * 2, _minadd[idx]); minadd(idx * 2 + 1, _minadd[idx]); }
		if (_maxadd[idx] != 0xe0e0e0e0) { maxadd(idx * 2, _maxadd[idx]); maxadd(idx * 2 + 1, _maxadd[idx]); }
		_minadd[idx] = 0x3f3f3f3f; _maxadd[idx] = 0xe0e0e0e0;
	}
	void makeadd(int idx, int l, int r, int ll, int rr, int d)
	{
		if (ll <= l && rr >= r) { minadd(idx, d); maxadd(idx, d); return; }
		int m = l + r >> 1;
		push(idx);
		if (ll < m) makeadd(idx * 2, l, m, ll, rr, d);
		if (rr > m) makeadd(idx * 2 + 1, m, r, ll, rr, d);
		update(idx);
	}
	int querymin(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return minn[idx];
		int m = l + r >> 1;
		push(idx);
		int ret = 0x3f3f3f3f;
		if (ll < m) ret = min(ret, querymin(idx * 2, l, m, ll, rr));
		if (rr > m) ret = min(ret, querymin(idx * 2 + 1, m, r, ll, rr));
		update(idx);
		return ret;
	}
	int querymax(int idx, int l, int r, int ll, int rr)
	{
		if (ll <= l && rr >= r) return maxn[idx];
		int m = l + r >> 1;
		push(idx);
		int ret = 0xe0e0e0e0;
		if (ll < m) ret = max(ret, querymax(idx * 2, l, m, ll, rr));
		if (rr > m) ret = max(ret, querymax(idx * 2 + 1, m, r, ll, rr));
		update(idx);
		return ret;
	}
} sgt;
struct Tdiscre{
	int tot, data[MAXN];
	int & operator [] (int k) { return data[k]; }
	void init()
	{
		sort(data + 1, data + 2 * n + 1);
		tot = unique(data + 1, data + 2 * n + 1) - data - 1;
	}
	int convert(int x)
	{
		return lower_bound(data + 1, data + tot + 1, x) - data;
	}
} discre;
int val[MAXN];
struct Tsolve{
	int solve(int d)
	{		
		tot = 0;
		for (int i = 1; i <= n; i++){
			scan[++tot] = Tscan(1, i, line[i].a.x);
			scan[++tot] = Tscan(2, i, line[i].a.x);
			scan[++tot] = Tscan(2, i, line[i].b.x);
			scan[++tot] = Tscan(3, i, line[i].b.x);
		}
		for (int i = 1; i <= n; i++) discre[2 * i - 1] = line[i].a.x, discre[2 * i] = line[i].b.x;
		discre.init();
		sort(scan + 1, scan + tot + 1);
		S.clear();
		set<Tline>::iterator si, SI;
		dag.clear();
		for (int i = 1; i <= tot; i++){
			nowx = scan[i].pos;
			switch(scan[i].op){
				case 1 : S.insert(line[scan[i].who]); break;
				case 2 : si = S.find(line[scan[i].who]); SI = si; ++SI; 
						 if (si != S.begin()) { --si; dag.add(si->who, scan[i].who); }
						 if (SI != S.end()) dag.add(scan[i].who, SI->who); 
						 break;
				case 3 : S.erase(line[scan[i].who]); break;
			}
		}
		sgt.clear();
		dag.topsort();
		for (int i = 1; i <= n; i++) val[dag[i]] = i;
		int ans = n;
		for (int i = n; i >= 1; i--){
			if ((que[i].dir & 1) == d){
				if (que[i].dir >> 1){
					if (sgt.querymax(1, 1, discre.tot, discre.convert(line[que[i].who].a.x), discre.convert(line[que[i].who].b.x)) > val[que[i].who]) ans = i;
				}
				else{
					if (sgt.querymin(1, 1, discre.tot, discre.convert(line[que[i].who].a.x), discre.convert(line[que[i].who].b.x)) < val[que[i].who]) ans = i;
				}
			}	
			sgt.makeadd(1, 1, discre.tot, discre.convert(line[que[i].who].a.x), discre.convert(line[que[i].who].b.x), val[que[i].who]);
		}
		return ans;
	}
} solve;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		line[i].init(); line[i].who = i;
	}
	for (int i = 1; i <= n; i++) que[i].init();
	int ans;
	ans = solve.solve(1);
	for (int i = 1; i <= n; i++){
		swap(line[i].a.x, line[i].a.y);
		swap(line[i].b.x, line[i].b.y);
		line[i].a.y *= -1;
		line[i].b.y *= -1;
		if (line[i].b < line[i].a) swap(line[i].a, line[i].b);
	}
	ans = min(solve.solve(0), ans);
	printf("%d\n", ans);
	for (int i = 1; i <= n; i++)
		printf("%d 0\n", dag[i]);
	
}
Problem2588

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
const int MAXN = 300001;
struct Tnode{
	int l, r, lc, rc, sum;
} a[3000001]; int tot;
int n, Q, val[MAXN], seg[MAXN];
int e[MAXN], v[MAXN], next[MAXN], f[MAXN][20], dep[MAXN];
struct Tdiscre{
	int data[MAXN], n;
	int & operator [] (int k) { return data[k]; }
	void init()
	{
		sort(data + 1, data + n + 1); 
		n = unique(data + 1, data + n + 1) - data - 1;
	}
	int convert(int d) { return lower_bound(data + 1, data + n + 1, d) - data; }
} dis;
int c, k;
int build(int l, int r)
{
	int now = ++tot; a[now].l = l; a[now].r = r; if (l == r) return now;
	a[now].lc = build(l, l + r >> 1); a[now].rc = build(l + r + 2 >> 1, r);
	return now;
}
int change(int now, int x, int y)
{
	a[++tot] = a[now]; a[tot].sum += y; now = tot;
	if (a[now].l == a[now].r) return tot;
	int m = a[now].l + a[now].r >> 1;
	if (x <= m) a[now].lc = change(a[now].lc, x, y); else a[now].rc = change(a[now].rc, x, y);
	return now;
}
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x, int nowseg)
{
	val[x] = dis.convert(val[x]);
	seg[x] = change(nowseg, val[x], 1);
	for (int i = 1; f[x][i - 1]; i++) f[x][i] = f[f[x][i - 1]][i - 1];
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x][0]){
		f[v[i]][0] = x; dep[v[i]] = dep[x] + 1; dfs(v[i], seg[x]);
	}
}
int lca(int x, int y)
{
	if (dep[x] < dep[y]) swap(x, y); int k = dep[x] - dep[y];
	for (int i = 0; i < 20; i++) if ((k >> i) & 1) x = f[x][i];
	if (x == y) return x;
	for (int i = 19; i >= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}
int getkth(int seg1, int seg2, int seg3, int k)
{
	if (a[seg1].l == a[seg1].r) return dis[a[seg1].l];
	int m = a[seg1].l + a[seg1].r >> 1, l = a[seg1].l;
	int tsum = a[a[seg1].lc].sum + a[a[seg2].lc].sum - a[a[seg3].lc].sum * 2 + (m >= val[c] && val[c] >= l);
	if (tsum >= k)
		return getkth(a[seg1].lc, a[seg2].lc, a[seg3].lc, k);
	else return getkth(a[seg1].rc, a[seg2].rc, a[seg3].rc, k - tsum);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &Q);
	for (int i = 1; i <= n; i++) scanf("%d", &val[i]);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	for (int i = 1; i <= n; i++) dis[i] = val[i]; dis.n = n; dis.init();
	dfs(1, build(1, dis.n));
	int lastans = 0;
	while(Q--){
		int a, b;
		scanf("%d%d%d", &a, &b, &k); a ^= lastans;
		c = lca(a, b);
		printf("%d\n", lastans = getkth(seg[a], seg[b], seg[c], k));
	}
}
Problem2590

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;
set<pair<int, int> > s1, s2, s3;
int n, k, ans; 
int fr[1000001], sc[1000001], id[1000001];
long long m;
bool bysc  (int a, int b) { return sc[a] < sc[b]; }
int main()
{
	scanf("%d%d%lld", &n, &k, &m);
	for (int i = 1; i <= n; i++) scanf("%d%d", &fr[i], &sc[i]);
	for (int i = 1; i <= n; i++) id[i] = i;
	sort(id + 1, id + n + 1, bysc);
	long long now = 0; int ans = 0;
	for (int i = 1; i <= k; i++){
		now += sc[id[i]]; if (now > m) goto out; ++ans;
		s1.insert(make_pair(fr[id[i]] - sc[id[i]], id[i]));
	}
	for (int i = k + 1; i <= n; i++){
		s2.insert(make_pair(sc[id[i]], id[i]));
		s3.insert(make_pair(fr[id[i]], id[i]));
	}
	while(s2.size()){
		int f1 = s1.begin()->first + s2.begin()->first, f2 = s3.begin()->first;
		if (f1 < f2){
			now += f1; if (now > m) goto out; ++ans;
			int t2 = s2.begin()->second;
			s1.erase(s1.begin()); s1.insert(make_pair(fr[t2] - sc[t2], t2));
			s2.erase(s2.begin()); s3.erase(s3.find(make_pair(fr[t2], t2)));
		}
		else{
			now += f2; if (now > m) goto out; ++ans;
			int t2 = s3.begin()->second;
			s3.erase(s3.begin()); s2.erase(s2.find(make_pair(sc[t2], t2)));
		}
	}
out:
	printf("%d\n", ans);
}
Problem2591

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 200001, MAXK = 22;
int tot, e[MAXN], v[MAXN * 2], next[MAXN * 2], num[MAXN][MAXK], ans[MAXN], f[MAXN];
int n, k, a[MAXN];
void add(int a, int b) { ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; }
void dfs(int x)
{
	num[x][0] = a[x];
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]){
		f[v[i]] = x; dfs(v[i]);
		for (int j = 1; j <= k; j++) num[x][j] += num[v[i]][j - 1];
	}
}
void getans(int x)
{
	ans[x] += num[x][k];
	int p = x, q = f[x];
	for (int i = 1; i <= k && q != 0; i++){
		ans[x] += num[q][k - i];
		if (k > i) ans[x] -= num[p][k - i - 1];
		p = q; q = f[q];
	}
	for (int i = e[x]; i; i = next[i]) if (v[i] != f[x]) getans(v[i]);

}
int main()
{
	scanf("%d%d", &n, &k);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b);
		add(a, b); add(b, a);
	}
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	dfs(1);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= k; j++) num[i][j] += num[i][j - 1];
	getans(1);
	for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
}
Problem2594

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
const int MAXN = 1000001;
using namespace std;
int n, m, Q, temp[MAXN];
bool del[MAXN];
int getint()
{
	char ch = getchar();
	for ( ; ch > '9' || ch < '0'; ch = getchar());
	int tmp = 0;
	for ( ; '0' <= ch && ch <= '9'; ch = getchar())
	tmp = tmp * 10 + int(ch) - 48;
	return tmp;
}
struct Tuf{
	int f[MAXN];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int get(int v) { return v == f[v] ? v : f[v] = get(f[v]); }
	bool merge(int a, int b) { a = get(a); b = get(b); if (a != b) f[a] = b; return a != b; }
} uf;
struct Tquery{
	int kind, a, b;
} query[MAXN];
struct Tedge{
	int st, ed, len;
	Tedge() { }
	Tedge(int _st, int _ed) { st = _st; ed = _ed; if (st > ed) swap(st, ed); len = 0; }
	void init()
	{
		st = getint(); ed = getint(); len = getint();
		if (st > ed) swap(st, ed);
	}
	bool operator < (const Tedge & A) const { return st == A.st ? ed < A.ed : st < A.st; }
} edge[MAXN];
bool cmpbylen(int a, int b) { return edge[a].len < edge[b].len; }
struct Tedgeintree{
	int who;
	bool operator == (int A) { return who == A; }
	bool operator < (const Tedgeintree & A) const { return edge[who].len < edge[A.who].len; }
};
struct Tnode{
	int c[2], f; Tedgeintree val[2], maxv[2];
	bool isroot, _rev;
	static Tnode *a;
	void rev()
	{
		if (this == a) return;
		_rev ^= 1; swap(val[0], val[1]); swap(maxv[0], maxv[1]); swap(c[0], c[1]);
	}
	void push()
	{
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev();
			_rev = false;
		}
	}
	void update()
	{
		maxv[0] = max(val[0], max(a[c[0]].maxv[0], a[c[1]].maxv[0]));
		maxv[1] = max(val[1], max(a[c[0]].maxv[1], a[c[1]].maxv[1]));
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
	Tedgeintree go()
	{
		push();
		if (c[0]) return a[c[0]].go();
		else return val[0];
	}
} A[MAXN], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
int access(int x)
{
	int p = 0, q = x; Tedgeintree ret;
	while(q){
		splay(q);
		if (A[q].f == 0)
			ret = max(A[p].maxv[0], A[A[q].c[1]].maxv[0]);
		A[A[q].c[1]].isroot = true;
		A[p].isroot = false;
		A[q].c[1] = p;
		A[q].val[1] = A[p].go();
		A[q].update();
		p = q; q = A[q].f;
	}
	return ret.who;
}
void evert(int x)
{
	access(x); splay(x); A[x].rev();
}
void link(int x, int y, int w)
{
	evert(x); A[x].val[0].who = w; A[x].f = y; 	
}
void cut(int x, int y, int w)
{
	splay(x); if (!(A[x].val[0] == w)) swap(x, y);
	access(x); splay(y); 
	A[y].c[1] = 0; A[y].val[1].who = 0; A[y].update();
	A[x].val[0].who = 0; A[x].f = 0;  A[x].isroot = true; A[x].update();
}
int tot, e[MAXN], v[MAXN * 2], w[MAXN * 2], next[MAXN * 2];
bool vis[MAXN];
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
void dfs(int x)
{
	vis[x] = true; A[x].isroot = true;
	for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]){
		A[v[i]].val[0].who = w[i]; A[v[i]].f = x;
		dfs(v[i]);
	}
}
int que(int a, int b)
{
	access(a); return access(b);
}
int ans[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	n = getint(); m = getint(); Q = getint();
	for (int i = 1; i <= m; i++) edge[i].init();
	sort(edge + 1, edge + m + 1);
	for (int i = 1; i <= Q; i++){
		scanf("%d", &query[i].kind);
		if (query[i].kind == 1) scanf("%d%d", &query[i].a, &query[i].b);
		else{
			int a, b; scanf("%d%d", &a, &b);
			query[i].a = lower_bound(edge + 1, edge + m + 1, Tedge(a, b)) - edge;
			del[query[i].a] = true;
		}
	}
	uf.init();
	int tot = 0;
	for (int i = 1; i <= m; i++) if (!del[i]) temp[++tot] = i;
	sort(temp + 1, temp + tot + 1, cmpbylen);
	for (int i = 1, now = 0; now < n - 1 && i <= tot; i++){
		int a = edge[temp[i]].st, b = edge[temp[i]].ed;
		if (uf.merge(a, b)){
			++now; add(a,  b, temp[i]); add(b, a, temp[i]);
		}
	}
	dfs(1);
	for (int i = Q; i >= 1; i--){
		if (query[i].kind == 1)
			ans[i] = edge[que(query[i].a, query[i].b)].len;
		else{
			int a = edge[query[i].a].st, b = edge[query[i].a].ed, c = que(a, b);
			if (edge[c].len > edge[query[i].a].len){
				cut(edge[c].st, edge[c].ed, c);
				link(a, b, query[i].a);
			}
		}
	}
	for (int i = 1; i <= Q; i++) if (query[i].kind == 1) printf("%d\n", ans[i]);
		   		
}
Problem2595

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define log(a) (31 - __builtin_clz(a))
using namespace std;
typedef bool *Tcmp(int a, int b);
const int MAXN = 1000001;
int n, mid;
long long ans;
char chin[MAXN]; int in[MAXN];
bool cmp(int a, int b) { return in[a] < in[b]; }
struct Tlcp{
    int s[MAXN], sa[MAXN], wa[MAXN], wb[MAXN], wv[MAXN], ws[MAXN], *x, *y, rank[MAXN], h[MAXN], rmq[MAXN][21]; 
    void init()
    {
        x = wa; y = wb;
        x[sa[1]] = 1;
        for (int i = 2; i <= n; i++) x[sa[i]] = s[sa[i]] == s[sa[i - 1]] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
        for (int j = 1, m = x[sa[n]]; m < n; j <<= 1){
            int p = 0;
            for (int i = n - j + 1; i <= n; i++) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > j) y[++p] = sa[i] - j;
            for (int i = 1; i <= m; i++) ws[i] = 0;
            for (int i = 1; i <= n; i++) ws[wv[i] = x[y[i]]]++;
            for (int i = 1; i <= m; i++) ws[i] += ws[i - 1];
            for (int i = n; i >= 1; i--) sa[ws[wv[i]]--] = y[i];
            swap(x, y); x[sa[1]] = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && y[sa[i] + j] == y[sa[i - 1] + j] ? x[sa[i - 1]] : x[sa[i - 1]] + 1;
            m = x[sa[n]];
        }
        for (int i = 1; i <= n; i++) rank[i] = x[i];
        int k = 0;
        for (int i = 1; i <= n; i++){
            if (rank[i] == 1) { h[rank[i]] = k = 0; continue; }
            if (k > 0) --k;
            int j = sa[rank[i] - 1];
            while(i + k <= n && j + k <= n && s[i + k] == s[j + k]) ++k;
            h[rank[i]] = k;
        }
        for (int i = 1; i <= n; i++) rmq[i][0] = h[i];
        int lg = log(n);
        for (int j = 1; j <= lg; j++)
            for (int i = 1; i <= n - (1 << j) + 1; i++)
                rmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);
    }
    int ask(int l, int r)
    {
        if (l == 0 || r == 0 || l > n || r > n) return 0;
        l = rank[l]; r = rank[r];
        if (l > r) swap(l, r); ++l;
        int x = log(r - l + 1);
        return min(rmq[l][x], rmq[r - (1 << x) + 1][x]);
    }
} lcp;
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); int N = n; 
    scanf("%s", chin + 1);
	for (int i = 1; i <= n; i++) in[i] = chin[i] == '1';
	for (int i = 1; i <= n; i++) in[n + i + 1] = !in[n - i + 1];
	in[n + 1] = 2;
	n = n * 2 + 1;
    for (int i = 1; i <= n; i++) lcp.s[i] = in[i];
	for (int i = 1; i <= n; i++) lcp.sa[i] = i;
    sort(lcp.sa + 1, lcp.sa + n + 1, cmp);
    lcp.init();
    for (int i = 2; i <= N; i++){
		int t = i - 1; t = N - t + 1;
		ans += lcp.ask(t + N + 1, i);
	}
	cout << ans << endl;
}
Problem2595

#include <cstdio>

#include <cstdlib>

#include <cstring>

#include <iostream>

#include <algorithm>

#define GET(a, b) ((a >> (b + b + b)) & 7)

#define CHA(a, b, c) ((a & (~(7 << (b + b + b)))) | (c << (b + b + b)))

#define FORHASH for (int hi = 1; hi <= H[i][j].tot; hi++)

#define DEBUG

const int MO = 273, MAXNODE = 100000;

using namespace std;

int n, m, c[101][101];

struct Thashnode{

int h, num, next, from;

};

struct Thash{

int e[MO + 2], tot;

Thashnode data[MAXNODE];

Thashnode & operator [] (int k) { return data[k]; }

void clear() { tot = 0; memset(e, 0, sizeof(e)); }

void insert(int h, int num, int from)

{

for (int i = e[h % MO]; i; i = data[i].next)

if (data[i].h == h){

if (data[i].num > num){

data[i].num = num;

data[i].from = from;

}

return;

}

++tot; data[tot].h = h; data[tot].num = num; data[tot].from = from;

data[tot].next = e[h % MO]; e[h % MO] = tot;

}

} H[11][10];

bool app[10];

inline bool check(int S)

{

for (int i = 1; i <= 7; i++) app[i] = false;

for (int i = 0; i < m; i++) app[GET(S, i)] = true;

int tot = 0; for (int i = 1; i <= 7; i++) if (app[i]) ++tot;

return tot <= 1;

}

inline int findnew(int S)

{

for (int i = 1; i <= 7; i++) app[i] = false;

for (int i = 0; i < m; i++) app[GET(S, i)] = true;

for (int i = 1; i <= 7; i++) if (!app[i]) return i;

return 0;

}

int newnum[101];

inline int rebuild(int S)

{

int tot = 0;

for (int i = 1; i <= 10; i++) newnum[i] = 0;

for (int i = 0; i < m; i++){

int t = GET(S, i);

if (t != 0 && newnum[t] == 0) newnum[GET(S, i)] = ++tot;

}

for (int i = 0; i < m; i++) S = CHA(S, i, newnum[GET(S, i)]);

return S;

}

inline int merge(int S, int a, int b)

{

a = GET(S, a); b = GET(S, b);

for (int i = 0; i < m; i++) if (GET(S, i) == a) S = CHA(S, i, b);

return rebuild(S);

}

void print(int x, int y, int who)

{

if (x == 0 && y == 0) return;

int lastx = x - (y == 0), lasty = y == 0 ? m - 1 : y - 1;

print(lastx, lasty, H[x][y][who].from);

if (c[lastx][lasty] == 0) putchar('x');

else if (H[lastx][lasty][H[x][y][who].from].num != H[x][y][who].num) putchar('o');

else putchar('_');

if (lasty == m - 1) putchar('\n');

}

bool has[101];

int main()

{


scanf("%d%d", &n ,&m); int N = n;

for (int i = 0; i < n; i++)

for (int j = 0; j < m; j++){

scanf("%d", &c[i][j]);

if (c[i][j] == 0) has[i] = true;

}

while(!has[n - 1]) --n;

H[0][0].insert(0, 0, 0);

for (int i = 0; i < n; i++)

for (int j = 0; j < m; j++){

FORHASH{

int h = H[i][j][hi].h, num = H[i][j][hi].num;

int nexti = i + (j == m - 1), nextj = j == m - 1 ? 0 : j + 1;

bool must = true; int t = GET(h, j); if (t == 0) must = false;

if (t != 0) for (int k = 0; k < m; k++) if (k != j && GET(h, k) == t) must = false;

if (!must && c[i][j] != 0)

H[nexti][nextj].insert(CHA(h, j, 0), num, hi);

if (j == 0){

if (t == 0) H[nexti][nextj].insert(CHA(h, j, findnew(h)), num + c[i][j], hi);

else H[nexti][nextj].insert(h, num + c[i][j], hi);

            }

else{

int tt = GET(h, j - 1);

if (tt + t == 0) H[nexti][nextj].insert(CHA(h, j, findnew(h)), num + c[i][j], hi);

else if (tt * t == 0) H[nexti][nextj].insert(CHA(h, j, t + tt), num + c[i][j], hi);

else H[nexti][nextj].insert(merge(h, j - 1, j), num + c[i][j], hi);

}

}

}

int ans = 1000000000, who;

for (int i = 1; i <= H[n][0].tot; i++)

        if (check(H[n][0][i].h) && H[n][0][i].num < ans)

        who = i, ans = H[n][0][i].num;

printf("%d\n", ans);

print(n, 0, who);

    for (int i = 1; i <= N - n; i++){

for (int j = 1; j <= m; j++) putchar('_');

putchar('\n');

}

}
Problem2597

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1000001, MAXM = 1000001, SIZE = 65535;
struct Tcostflow{
	int s, t, tot, cost;
	int l, r, q[MAXN], dis[MAXN], from[MAXN];
	int e[MAXN], v[MAXM], next[MAXM], c[MAXM], w[MAXM];
	bool vis[MAXN];
	Tcostflow() { tot = 1; }
	void add(int A, int B, int C, int D = 0) 
	{ 
		//cerr << A << " " << B << " " << C << " " << D << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C; w[tot] = D;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0; w[tot] = -D; 
	}
	bool spfa()
	{
		for (int i = 1; i <= t; i++) dis[i] = 0x3f3f3f3f, vis[i] = false;
		dis[s] = 0; l = 0; r = 1; q[1] = s; vis[s] = true;
		while(l != r){
			l = (l + 1) & SIZE; int x = q[l]; vis[x] = false;
			for (int i = e[x]; i; i = next[i]) if (c[i] > 0 && dis[v[i]] > dis[x] + w[i]){
				dis[v[i]] = dis[x] + w[i]; from[v[i]] = i;
				if (!vis[v[i]]) { vis[v[i]] = true; r = (r + 1) & SIZE; q[r] = v[i]; }
			}
		}
		return dis[t] != 0x3f3f3f3f;
	}
	void aug()
	{
		int minf = 0x3f3f3f3f;
		for (int i = t; i != s; i = v[from[i] ^ 1]) minf = min(minf, c[from[i]]);
		for (int i = t; i != s; i = v[from[i] ^ 1]) { c[from[i]] -= minf; c[from[i] ^ 1] += minf; }
		cost += minf * dis[t];
	}
	int run()
	{
		while(spfa()) aug();
		return cost;
	}
    int findwho(int t)
	{
		for (int i = e[t]; i; i = next[i]) if (c[i] == 0) return v[i];
	}	
} flow;
int n, m, now, a[1001][1001], ans[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			scanf("%d", &a[i][j]);
	m = n * (n - 1) / 2;
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++){
			++now;
			if (a[i][j] != 2){
				int t = a[i][j] == 1 ? i : j;
				flow.add(now, t + m, 1);
			}
			else flow.add(now, i + m, 1), flow.add(now, j + m, 1);
		}
	flow.s = n + m + 1; flow.t = flow.s + 1;
	for (int i = 1; i <= m; i++) flow.add(flow.s, i, 1);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			flow.add(i + m, flow.t, 1, 2 * j - 1);
	printf("%d\n", n * (n - 1) * (n - 2) / 6 + m / 2 - flow.run() / 2);
	now = 0;
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++){
			++now; int t = flow.findwho(now);
			ans[t - m][i + j - t + m] = 1;
		}
	for (int i = 1; i <= n; i++){
		for (int j = 1; j < n; j++) printf("%d ", ans[i][j]); printf("%d\n", ans[i][n]);
	}
}
Problem2599

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 2000001;
int tot, e[MAXN], v[MAXN * 2], w[MAXN * 2], next[MAXN * 2], l, r, n, k;
bool del[MAXN]; int ans;
int hash[2000001];
struct TBoolArray{
	int time; int data[2000001];
	void clear()
	{
		++time;
	}
	bool operator [] (int k)
	{
		return data[k] == time;
	}
	void set(int k) { data[k] = time; }
} array;
int q[MAXN], fa[MAXN], size[MAXN], ms[MAXN], dis[MAXN], num[MAXN], dep[MAXN];
void add(int a, int b, int c)
{
    ++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int find_heavy(int x)
{
    fa[x] = 0; l = 1, r = 1; q[1] = x;
    while(l <= r){
        int x = q[l++];
        for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && v[i] != fa[x]){
            q[++r] = v[i]; fa[v[i]] = x;
        }
    }
    for (int i = r; i >= 1; i--){
        size[q[i]] = 1; ms[q[i]] = 0;
        for (int j = e[q[i]]; j; j = next[j]) if (!del[v[j]] && v[j] != fa[q[i]]){
            size[q[i]] += size[v[j]]; ms[q[i]] = max(ms[q[i]], size[v[j]]);
        }
        ms[q[i]] = max(ms[q[i]], r - size[q[i]]);
    }
    int w = q[1];
    for (int i = 2; i <= r; i++) if (ms[q[i]] < ms[w]) w = q[i];
    return w;
}
void doit(int x)
{
    x = find_heavy(x); if (r == 1) return; del[x] = true;
    array.clear(); hash[0] = 0; array.set(0);
    for (int i = e[x]; i; i = next[i]) if (!del[v[i]]){
        int l = 1, r = 1; q[1] = v[i]; dis[v[i]] = w[i]; dep[v[i]] = 1; fa[v[i]] = 0;
        while(l <= r){
            int x = q[l++];
            for (int i = e[x]; i; i = next[i]) if (!del[v[i]] && fa[x] != v[i]){
                dis[v[i]] = dis[x] + w[i]; dep[v[i]] = dep[x] + 1; q[++r] = v[i]; fa[v[i]] = x;
            }
        }
        for (int i = 1; i <= r; i++){
            if (dis[q[i]] <= k && array[k - dis[q[i]]])
                ans = min(hash[k - dis[q[i]]] + dep[q[i]], ans);			
        }
        for (int i = 1; i <= r; i++) if (dis[q[i]] <= k)
			if (array[dis[q[i]]]) hash[dis[q[i]]] = min(hash[dis[q[i]]], dep[q[i]]); else array.set(dis[q[i]]), hash[dis[q[i]]] = dep[q[i]];
    }
    for (int i = e[x]; i; i = next[i]) if (!del[v[i]]) doit(v[i]);          
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d%d", &n, &k); ans = n;
    for (int i = 1; i < n; i++){
        int a, b, c; scanf("%d%d%d", &a, &b, &c);
		++a; ++b;
        add(a, b, c); add(b, a, c);
    }
    doit(1);
    int tans; scanf("%d", &tans);
    ans =  ans != n ? ans : -1;
    printf("%d\n", ans);
}
Problem2600

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
#define ll long long
const int MAXN = 1000001;
int n;
ll a[MAXN], L, B;
struct Tsum{
	ll sum[MAXN];
	ll & operator [] (int k) { return sum[k]; }
	void init() { for (int i = 1; i <= n; i++) sum[i] += sum[i - 1]; }
   	ll get(int l, int r) { if (l > r) return 0; return sum[r] - sum[l - 1]; }	
} sum;
ll get(int L)
{
	ll ret = 0x7fffffffffffffffll;
	for (int i = 1; i <= n - L + 1; i++){
		int l = i, r = i + L - 1, m = l + r >> 1;
		ret = min(ret, a[m] * (m - l) - a[m] * (r - m) - sum.get(l, m - 1) + sum.get(m + 1, r));
	}
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> L >> B;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) sum[i] = a[i];
	sum.init();
	int l = 1, r = n;
	while(l <= r){
		int m = l + r >> 1;
		if (get(m) <= B) l = m + 1; else r = m - 1;
	}
	cout << r << endl;
}
Problem2602

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <vector>
const double eps = 1e-5, INF = 1e9;
const int MAXN = 101;
using namespace std;
int dcmp(double t)
{
	if (t > eps) return 1; if (t < -eps) return -1; return 0;
}
struct Tpoint2D{ //point & vector
	double x, y;
	Tpoint2D() { }
	Tpoint2D(double x, double y) : x(x), y(y) { }
	bool operator == (Tpoint2D A) { return dcmp(x - A.x) == 0 && dcmp(y - A.y) == 0; }
	Tpoint2D operator + (Tpoint2D A) { return Tpoint2D(x + A.x, y + A.y); }
	Tpoint2D operator - (Tpoint2D A) { return Tpoint2D(x - A.x, y - A.y); }
	double operator * (Tpoint2D A) { return x * A.x + y * A.y; }
	Tpoint2D operator * (double k) { return Tpoint2D(x * k, y * k); }
	double operator % (Tpoint2D A) { return x * A.y - y * A.x; }
	double len() { return sqrt(x * x + y * y); }

};
struct Tline2D{ //line & half-plane; half-plane : (x - p) % n >= 0
	Tpoint2D p, n;
	Tline2D() { }
	Tline2D(Tpoint2D p1, Tpoint2D p2) : p(p1), n(p2 - p1) { } 
	friend bool operator <= (Tpoint2D x, Tline2D l)
	{
		return dcmp((x - l.p) % l.n) >= 0;
	}
	friend bool operator < (Tpoint2D x, Tline2D l)
	{
		return dcmp((x - l.p) % l.n) > 0;
	}
	Tpoint2D operator * (Tline2D A)
	{
		double d = n.x * (-A.n.y) - n.y * (-A.n.x), d1 = (A.p.x - p.x) * (-A.n.y) - (A.p.y - p.y) * (-A.n.x), t1 = d1 / d;
		return p + n * t1;
	}
};
int tempn; Tpoint2D temp[MAXN];
struct Thull{
	Tpoint2D V[MAXN];
	int n;
	Tpoint2D & operator [] (int k) { return V[k]; }
	const Tpoint2D & operator [] (int k) const { return V[k]; }
	double area()
	{
		if (n <= 2) return 0.0;
		double ret = 0;
		for (int i = 1; i <= n; i++) ret += V[i] % V[i + 1];
		return fabs(ret) / 2.0;
	}
	void init()
	{
		n = 4; 
		V[1] = Tpoint2D(-INF, -INF);
		V[2] = Tpoint2D(-INF, INF);
		V[3] = Tpoint2D(INF, INF);
		V[4] = Tpoint2D(INF, -INF);
		V[5] = V[1]; V[0] = V[4];
	}
	void cut(Tline2D l)
	{
		tempn = 0;
		for (int i = 1; i <= n; i++)
			if (V[i] <= l) temp[++tempn] = V[i];
			else{
				if (V[i - 1] < l) temp[++tempn] = l * Tline2D(V[i - 1], V[i]);
				if (V[i + 1] < l) temp[++tempn] = l * Tline2D(V[i + 1], V[i]);
			}
		n = tempn; for (int i = 1; i <= n; i++) V[i] = temp[i];
		V[0] = V[n]; V[n + 1] = V[1];
	}
	void make() //make this anti-clockwise
	{
		if (n <= 2) return;
		if (dcmp((V[3] - V[1]) % (V[2] - V[1])) <= 0) return;
		for (int i = 1; i <= n / 2; i++) swap(V[i], V[n - i + 1]);
		V[0] = V[n]; V[n + 1] = V[1];
	}
	Thull operator + (Thull A)
	{
		Thull ret; ret.init(); make(); A.make();
		for (int i = 1; i <= n; i++)
			ret.cut(Tline2D(V[i + 1], V[i]));

		for (int i = 1; i <= A.n; i++) ret.cut(Tline2D(A[i + 1], A[i]));
		ret.make(); return ret;
	}
};
struct Thullset{
	vector<Thull> V;
	double f(double x)
	{
		int tot = 0;
		pair<double, double> seg[MAXN];
		for (int i = 0; i < V.size(); i++){
			double l = INF, r = -INF;
			for (int j = 1; j <= V[i].n; j++) if (dcmp(V[i][j].x - V[i][j - 1].x) != 0 && dcmp((x - V[i][j].x) * (x - V[i][j - 1].x)) <=0){
				double temp = V[i][j].y + (x - V[i][j].x) / (V[i][j - 1].x - V[i][j].x) * (V[i][j - 1].y - V[i][j].y);
				l = min(l, temp); r = max(r, temp);
			}
			if (dcmp(l - r) < 0) seg[++tot] = make_pair(l, r);
		}
		if (tot == 0) return 0;
		sort(seg + 1, seg + tot + 1);
		double nl = seg[1].first, nr = seg[1].second, ret = 0;
		for (int i = 2; i <= tot; i++)
			if (seg[i].first > nr) ret += nr - nl, nl = seg[i].first, nr = seg[i].second;
			else nr = max(nr, seg[i].second);
		return ret += nr - nl;
	}
	double sim(double l, double r)
	{
		double m = (l + r) / 2.0;
	//	return (f(l) + f(r) + f(m) * 4.0) * (r - l) / 6.0;
		return (f(l) + f(r)) * (r - l) / 2.0;
	}
	double rsim(double l, double r)
	{
		double m = (l + r) / 2.0;
		//if (r - l > 1e-2) return rsim(l, m) + rsim(m, r);
		double t = sim(l, r);
		if (fabs(t - sim(l, m) - sim(m, r)) < 1e-8) return t;
		else return rsim(l, m) + rsim(m, r);
	}
	double calc()
	{
		pair<double, double> seg[MAXN];
		int tot;
		//puts("--------------------------------------------");
		tot = 0;
		if (V.size() == 0) return 0;
		for (int i = 0; i < V.size(); i++){
			double l = INF, r = -INF;
			for (int j = 1; j <= V[i].n; j++){
				l = min(l, V[i][j].x), r = max(r, V[i][j].x);
				//printf("%.3lf %.3lf ", V[i][j].x, V[i][j].y);
			}
			//putchar('\n');
			if(dcmp(l - r) < 0) seg[++tot] = make_pair(l, r);
		}
		sort(seg + 1, seg + tot + 1);
		double nl = seg[1].first, nr = seg[1].second, ret = 0;
		for (int i = 2; i <= tot; i++)
			if (seg[i].first > nr)
				ret += rsim(nl, nr), nl = seg[i].first, nr = seg[i].second;
			else nr = max(nr, seg[i].second);
		return ret += rsim(nl, nr);
	}
};
struct Tpoint3D{
	double x, y, z;
	Tpoint3D() { }
	Tpoint3D(double x, double y, double z) : x(x), y(y), z(z) { }
	void init() { scanf("%lf%lf%lf", &x, &y, &z); }
	bool operator == (Tpoint3D A) { return dcmp(x - A.x) == 0 && dcmp(y - A.y) == 0 && dcmp(z - A.z) == 0; }
	double len() { return sqrt(x * x + y * y + z * z); }
	Tpoint3D operator + (Tpoint3D A) { return Tpoint3D(x + A.x, y + A.y, z + A.z); }
	Tpoint3D operator - (Tpoint3D A) { return Tpoint3D(x - A.x, y - A.y, z - A.z); }
	double operator * (Tpoint3D A) { return x * A.x + y * A.y + z * A.z; }
	Tpoint3D operator * (double k) { return Tpoint3D(x * k, y * k, z * k); }
	void makeunit() { double l = len(); x /= l; y /= l; z /= l; }
	Tpoint3D operator % (Tpoint3D A) { return Tpoint3D(y * A.z - z * A.y, z * A.x - x * A.z, x * A.y - y * A.x); }
	Tpoint3D ref(Tpoint3D A) //this as the normal line
	{
		Tpoint3D temp = *this;
	    temp = temp * (2.0 * (A * temp) / (temp * temp));
		return A - temp;	
	}
};
struct Tline3D{
	Tpoint3D n, p;
	Tline3D() { }
	Tline3D(Tpoint3D A, Tpoint3D B) : p(A), n(B - A) { }
};
struct Tface3D{
	Tpoint3D p, n;
	Tpoint3D d1, d2;
	Tface3D() { }
	Tface3D(Tpoint3D A, Tpoint3D B, Tpoint3D C)
	{
		p = A; n = (B - A) % (C - A); n.makeunit();
		d1 = (B - A); d1.makeunit(); d2 = n % d1; 
	}
	Tpoint2D convert2D(Tpoint3D A)
	{
		A = A - p;
		return Tpoint2D(A * d1, A * d2);
	}
	Tpoint3D convert3D(Tpoint2D A)
	{
		return (d1 * A.x + d2 * A.y) + p;
	}
	Tpoint3D operator * (Tline3D l)
	{
		double t = (n * p - n * l.p) / (n * l.n);
		//if (dcmp((l.p + l.n * t - p) * n) != 0) cerr << "BUG" << endl;
		return l.p + l.n * t;
	}
};
struct Thull3D{
	int n; Tpoint3D V[MAXN];
	Tpoint3D & operator [] (int k) { return V[k]; }
	const Tpoint3D operator [] (int k) const { return V[k]; }
	Thull convert2D(Tface3D face)
	{
		Thull temp; temp.n = n;
		for (int i = 0; i <= n + 1; i++) temp[i] = face.convert2D(V[i]);
		return temp;
	}
};
Thull3D convert3D(Thull now, Tface3D face)
{
	Thull3D ret; ret.n = now.n;
	for (int i = 0; i <= now.n + 1; i++) ret[i] = face.convert3D(now[i]);
	return ret;
}
Tpoint3D point[MAXN];
struct Tface{
	Tface3D face; Thull3D hull; Thullset ans;
	void init()
	{
		int num;
		scanf("%d", &num);
		for (int i = 1; i <= num; i++){
			int t; scanf("%d", &t); 
			++hull.n; hull[hull.n] = point[t];
		}
		hull[0] = hull[hull.n]; hull[hull.n + 1] = hull[1];
		face = Tface3D(hull[1], hull[2], hull[3]);
	}
} face[MAXN];
int n, m, k;
Thull3D in;
void DFS(Thull3D now, Tpoint3D vec, int dep)
{
	if (dep == k) return;
	for (int i = 1; i <= m; i++){
		if (dcmp(vec * face[i].face.n) == 0) continue;
		Thull tempnow;
		int tot = 0;
		for (int j = 1; j <= now.n; j++){
			Tpoint3D p1 = face[i].face * Tline3D(now[j], now[j] + vec), p2 = face[i].face * Tline3D(now[j - 1], now[j - 1] + vec);
			double t1 = (p1 - now[j]) * vec, t2 = (p2 - now[j - 1]) * vec;
			if (dcmp(t1 * t2) < 0) tempnow[++tot] = face[i].face.convert2D(face[i].face * Tline3D(now[j], now[j - 1]))	;
			if (dcmp(t1) >= 0) tempnow[++tot] = face[i].face.convert2D(face[i].face * Tline3D(now[j], now[j] + vec));	
		}
		if (tot <= 2) continue;
		tempnow[0] = tempnow[tot]; tempnow[tot + 1] = tempnow[1];
		tempnow.n = tot;
		tempnow = tempnow + face[i].hull.convert2D(face[i].face);
		Thull3D newnow = convert3D(tempnow, face[i].face);
		if (tempnow.area() > eps){
			//cerr << dep << " " << i << " " << tempnow.area() << endl;
			face[i].ans.V.push_back(tempnow);
			DFS(newnow, face[i].face.n.ref(vec), dep + 1);
		}
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++) point[i].init();
	for (int i = 1; i <= m; i++) face[i].init();
	in.n = 3; for (int i = 1; i <= 3; i++) in[i].init();
	in[0] = in[3]; in[4] = in[1];
	Tpoint3D vec; vec.init();
	DFS(in, vec, 0);
	double ans = 0;
	for (int i = 1; i <= m; i++){
		//cerr << face[i].ans.calc() << endl;
		ans += face[i].ans.calc();
	}
	printf("%.2lf\n", ans);
}
Problem2618

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <vector>
const double eps = 1e-5, INF = 1e9;
const int MAXN = 101;
using namespace std;
int dcmp(double t)
{
    if (t > eps) return 1; if (t < -eps) return -1; return 0;
}
struct Tpoint2D{ //point & vector
    double x, y;
    Tpoint2D() { }
    Tpoint2D(double x, double y) : x(x), y(y) { }
    bool operator == (Tpoint2D A) { return dcmp(x - A.x) == 0 && dcmp(y - A.y) == 0; }
    Tpoint2D operator + (Tpoint2D A) { return Tpoint2D(x + A.x, y + A.y); }
    Tpoint2D operator - (Tpoint2D A) { return Tpoint2D(x - A.x, y - A.y); }
    double operator * (Tpoint2D A) { return x * A.x + y * A.y; }
    Tpoint2D operator * (double k) { return Tpoint2D(x * k, y * k); }
    double operator % (Tpoint2D A) { return x * A.y - y * A.x; }
    double len() { return sqrt(x * x + y * y); }
 
};
struct Tline2D{ //line & half-plane; half-plane : (x - p) % n >= 0
    Tpoint2D p, n;
    Tline2D() { }
    Tline2D(Tpoint2D p1, Tpoint2D p2) : p(p1), n(p2 - p1) { } 
    friend bool operator <= (Tpoint2D x, Tline2D l)
    {
        return dcmp((x - l.p) % l.n) >= 0;
    }
    friend bool operator < (Tpoint2D x, Tline2D l)
    {
        return dcmp((x - l.p) % l.n) > 0;
    }
    Tpoint2D operator * (Tline2D A)
    {
        double d = n.x * (-A.n.y) - n.y * (-A.n.x), d1 = (A.p.x - p.x) * (-A.n.y) - (A.p.y - p.y) * (-A.n.x), t1 = d1 / d;
        return p + n * t1;
    }
};
int tempn; Tpoint2D temp[MAXN];
struct Thull{
    Tpoint2D V[MAXN];
    int n;
    Tpoint2D & operator [] (int k) { return V[k]; }
    const Tpoint2D & operator [] (int k) const { return V[k]; }
    double area()
    {
        if (n <= 2) return 0.0;
        double ret = 0;
        for (int i = 1; i <= n; i++) ret += V[i] % V[i + 1];
        return fabs(ret) / 2.0;
    }
    void init()
    {
        n = 4; 
        V[1] = Tpoint2D(-INF, -INF);
        V[2] = Tpoint2D(-INF, INF);
        V[3] = Tpoint2D(INF, INF);
        V[4] = Tpoint2D(INF, -INF);
        V[5] = V[1]; V[0] = V[4];
    }
    void cut(Tline2D l)
    {
        tempn = 0;
        for (int i = 1; i <= n; i++)
            if (V[i] <= l) temp[++tempn] = V[i];
            else{
                if (V[i - 1] < l) temp[++tempn] = l * Tline2D(V[i - 1], V[i]);
                if (V[i + 1] < l) temp[++tempn] = l * Tline2D(V[i + 1], V[i]);
            }
        n = tempn; for (int i = 1; i <= n; i++) V[i] = temp[i];
        V[0] = V[n]; V[n + 1] = V[1];
    }
    void make() //make this anti-clockwise
    {
        if (n <= 2) return;
        if (dcmp((V[3] - V[1]) % (V[2] - V[1])) <= 0) return;
        for (int i = 1; i <= n / 2; i++) swap(V[i], V[n - i + 1]);
        V[0] = V[n]; V[n + 1] = V[1];
    }
    Thull operator + (Thull A)
    {
        Thull ret; ret.init(); make(); A.make();
        for (int i = 1; i <= n; i++)
            ret.cut(Tline2D(V[i + 1], V[i]));
 
        for (int i = 1; i <= A.n; i++) ret.cut(Tline2D(A[i + 1], A[i]));
        ret.make(); return ret;
    }
} h[101];
int n;
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &h[i].n);
		for (int j = 1; j <= h[i].n; j++){
			double x, y; scanf("%lf%lf", &x, &y); h[i][j] = Tpoint2D(x, y);
			h[i][0] = h[i][h[i].n]; h[i][h[i].n + 1] = h[i][1];
		}
	}
	for (int i = 2; i <= n; i++) h[1] = h[1] + h[i];
	printf("%.3lf\n", h[1].area());
}
Problem2618

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <vector>
const double eps = 1e-6, INF = 1e9;
const int MAXN = 1001;
using namespace std;
int dcmp(double t)
{
    if (t > eps) return 1; if (t < -eps) return -1; return 0;
}
struct Tpoint2D{ //point & vector
    double x, y;
    Tpoint2D() { }
    Tpoint2D(double x, double y) : x(x), y(y) { }
    bool operator == (Tpoint2D A) { return dcmp(x - A.x) == 0 && dcmp(y - A.y) == 0; }
    Tpoint2D operator + (Tpoint2D A) { return Tpoint2D(x + A.x, y + A.y); }
    Tpoint2D operator - (Tpoint2D A) { return Tpoint2D(x - A.x, y - A.y); }
    double operator * (Tpoint2D A) { return x * A.x + y * A.y; }
    Tpoint2D operator * (double k) { return Tpoint2D(x * k, y * k); }
    double operator % (Tpoint2D A) { return x * A.y - y * A.x; }
    double len() { return sqrt(x * x + y * y); }
 
};
struct Tline2D{ //line & half-plane; half-plane : (x - p) % n >= 0
    Tpoint2D p, n;
    Tline2D() { }
    Tline2D(Tpoint2D p1, Tpoint2D p2) : p(p1), n(p2 - p1) { } 
    friend bool operator <= (Tpoint2D x, Tline2D l)
    {
        return dcmp((x - l.p) % l.n) >= 0;
    }
    friend bool operator < (Tpoint2D x, Tline2D l)
    {
        return dcmp((x - l.p) % l.n) > 0;
    }
    Tpoint2D operator * (Tline2D A)
    {
        double d = n.x * (-A.n.y) - n.y * (-A.n.x), d1 = (A.p.x - p.x) * (-A.n.y) - (A.p.y - p.y) * (-A.n.x), t1 = d1 / d;
        return p + n * t1;
    }
};
int tempn; Tpoint2D temp[MAXN];
struct Thull{
    Tpoint2D V[MAXN];
    int n;
    Tpoint2D & operator [] (int k) { return V[k]; }
    const Tpoint2D & operator [] (int k) const { return V[k]; }
    double area()
    {
        if (n <= 2) return 0.0;
        double ret = 0;
        for (int i = 1; i <= n; i++) ret += V[i] % V[i + 1];
        return fabs(ret) / 2.0;
    }
    void init()
    {
        n = 4; 
        V[1] = Tpoint2D(-INF, -INF);
        V[2] = Tpoint2D(-INF, INF);
        V[3] = Tpoint2D(INF, INF);
        V[4] = Tpoint2D(INF, -INF);
        V[5] = V[1]; V[0] = V[4];
    }
    void cut(Tline2D l)
    {
        tempn = 0;
        for (int i = 1; i <= n; i++)
            if (V[i] <= l) temp[++tempn] = V[i];
            else{
                if (V[i - 1] < l) temp[++tempn] = l * Tline2D(V[i - 1], V[i]);
                if (V[i + 1] < l) temp[++tempn] = l * Tline2D(V[i + 1], V[i]);
            }
        n = tempn; for (int i = 1; i <= n; i++) V[i] = temp[i];
        V[0] = V[n]; V[n + 1] = V[1];
    }
    void make() //make this anti-clockwise
    {
        if (n <= 2) return;
        if (dcmp((V[3] - V[1]) % (V[2] - V[1])) <= 0) return;
        for (int i = 1; i <= n / 2; i++) swap(V[i], V[n - i + 1]);
        V[0] = V[n]; V[n + 1] = V[1];
    }
    Thull operator + (Thull A)
    {
        Thull ret; ret.init(); make(); A.make();
        for (int i = 1; i <= n; i++)
            ret.cut(Tline2D(V[i + 1], V[i]));
 
        for (int i = 1; i <= A.n; i++) ret.cut(Tline2D(A[i + 1], A[i]));
        ret.make(); return ret;
    }
} h[1001];
int n;
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &h[i].n);
		for (int j = 1; j <= h[i].n; j++){
			double x, y; scanf("%lf%lf", &x, &y); h[i][j] = Tpoint2D(x, y);
			h[i][0] = h[i][h[i].n]; h[i][h[i].n + 1] = h[i][1];
		}
	}
	for (int i = 2; i <= n; i++) h[1] = h[1] + h[i];
	printf("%.3lf\n", h[1].area());
}
Problem2620

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
long long s[1200001];
int a[1200001], b[1200001], n;
inline void scan(int&t)
{
    char c;while(c=getchar(),c<'0'||c>'9');t=c-'0';
    while(c=getchar(),c>='0'&&c<='9')t=t*10+c-'0';
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scan(b[i]), scan(a[i]);
    for (int i = 1; i <= n; i++) a[i] -= b[i];
    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];
    sort(s + 1, s + n + 1);
    long long ans = 0;
    long long t = (n & 1) ? s[n + 1 >> 1] : ((s[n >> 1] + s[(n >> 1) + 1]) >> 1 );
    for (int i = 1; i <= n; i++) ans += abs(s[i] - t);
    printf("%lld\n", ans);
}
Problem2621

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int from[1000001], f[1000001], n, V, sum[1000001], a[1001];
void print(int S)
{
	if (S == 0) return;
	print(from[S]);
	printf("%d", __builtin_popcount(S ^ from[S]));
	for (int i = 0; i < n; i++) if ((S ^ from[S]) >> i & 1) printf(" %d", i + 1);
	putchar('\n');
}
int main()
{
	scanf("%d%d", &n, &V);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);
	for (int i = 0; i < (1 << n); i++)
		for (int j = 0; j < n; j++) if ((i >> j) & 1){
			sum[i] = sum[i] + a[j];
			if (sum[i] > V){
				sum[i] = V + 1; break;
			}
		}
	for (int i = 1; i < (1 << n); i++){
		f[i] = 0x3f3f3f3f;
		for (int j = i; j; j = i & (j - 1))
			if (sum[j] <= V && f[i ^ j] + 1 <= f[i]){
				from[i] = i ^ j; f[i] = f[i ^ j] + 1;
			}
	}
	printf("%d\n", f[(1 << n) - 1]);
}
Problem2622

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
#define PII pair<int, int>
using namespace std;
const int MAXN = 4000001;
int n, m, k, dis1[MAXN], dis2[MAXN];
priority_queue<PII, vector<PII>, greater<PII> > Q;
int tot, e[MAXN], v[MAXN], w[MAXN], next[MAXN];
bool vis[MAXN];
void add(int a, int b, int c)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b; w[tot] = c;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c); ++a; ++b;
		add(a, b, c); add(b, a, c);
	}
	for (int i = 1; i <= n; i++) dis1[i] = dis2[i] = 0x3f3f3f3f;
	for (int i = 1; i <= k; i++){
		int t; scanf("%d", &t); ++t;
		Q.push(make_pair(0, t)); dis1[t] = dis2[t] = 0;
	}
	while(!Q.empty()){
		int x = Q.top().second; Q.pop(); if (vis[x]) continue; vis[x] = true;
		for (int i = e[x]; i; i = next[i])
			if (dis1[v[i]] > dis2[x] + w[i]){
				dis2[v[i]] = dis1[v[i]];
				dis1[v[i]] = dis2[x] + w[i];
				if (dis2[v[i]] != 0x3f3f3f3f) Q.push(make_pair(dis2[v[i]], v[i]));
			}
			else
				if (dis2[v[i]] > dis2[x] + w[i]){
					dis2[v[i]] = dis2[x] + w[i];
					Q.push(make_pair(dis2[v[i]], v[i]));
				}
	}
	printf("%d\n", dis2[1]);
			
}
Problem2625

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 501, MAXM = 500001;
int n;
struct Tminflow{
    int tot, st[MAXM], ed[MAXM], num[MAXM], sum[MAXN], s, t;
    struct Tmaxflow{
        int tot, e[MAXN], v[MAXM], next[MAXM], c[MAXM];
        int h[MAXN], vh[MAXN];
        int s, t;
        void init()
        {
            for (int i = 1; i <= t; i++) e[i] = 0; tot = 1;  
        }
        void add(int A, int B, int C)
        {
            ++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
            ++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
        }
        int aug(int x, int f)
        {
            if (x == t) return f;
            int minh = t - 1, augc = f;
            for (int i = e[x]; i; i = next[i]) if (c[i] > 0){
                if (h[x] == h[v[i]] + 1){
                    int t = aug(v[i], min(f, c[i]));
                    c[i] -= t; c[i ^ 1] += t; f -= t;
                    if (f == 0 || h[s] == t) return augc - f;
                }
                minh = min(minh, h[v[i]]);
            }
            if (f == augc){
                if (--vh[h[x]] == 0) h[s] = t; ++vh[h[x] = minh + 1];
            }
            return augc - f;    
        }
        void run()
        {
            memset(h, 0, sizeof(h)); memset(vh, 0, sizeof(vh));
            vh[0] = t; while(h[s] < t) aug(s, 0x3f3f3f3f);
        }
        bool check()
        {
            for (int i = e[s]; i; i = next[i]) if (c[i] > 0) return false;
            for (int i = e[t]; i; i = next[i]) if (c[i ^ 1] > 0) return false;
            return true;
        }
    } maxflow;
    void add(int A, int B, int D)
    {
        sum[A] -= D; sum[B] += D; ++tot; st[tot] = A; ed[tot] = B; num[tot] = 0x3f3f3f3f;
    }
    bool feasible(int f)
    {
        maxflow.init(); maxflow.s = t + 1; maxflow.t = maxflow.s + 1;
        for (int i = 1; i <= t; i++){
            if (sum[i] > 0) maxflow.add(maxflow.s, i, sum[i]);
            if (sum[i] < 0) maxflow.add(i, maxflow.t, -sum[i]);
        }
        for (int i = 1; i <= tot; i++) maxflow.add(st[i], ed[i], num[i]);
        maxflow.add(t, s, f);
        maxflow.run();
        return maxflow.check();
    }
    int run()
    {
        int l = 0, r = n * n;
        while(l <= r){
            int m = l + r >> 1;
            if (feasible(m)) r = m - 1; else l = m + 1;
        }
        return l;
    }
} minflow;
bool used[MAXN];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
    scanf("%d", &n);
    minflow.s = n + 1; minflow.t = n + 2;
    for (int i = 1; i <= n; i++){
        int num; scanf("%d", &num);
        for (int j = 1; j <= num; j++){
            int t; scanf("%d", &t);
            used[t] = true;
            minflow.add(i, t, 1);
        }
        if (num == 0) minflow.add(i, minflow.t, 0);
    }
    for (int i = 1; i <= n; i++) if (!used[i]) minflow.add(minflow.s, i, 0);
    printf("%d\n", minflow.run());
}
Problem2626

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <queue>
#include <iostream>
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
#define LL long long
using namespace std;
int k, n, xmax[1000001], ymin[1000001], xmin[1000001], ymax[1000001];
struct Tans{
	LL dis; int who;
	Tans() { }
	Tans(LL dis, int who) : dis(dis), who(who) { }
	bool operator < (const Tans & A) const
	{
		return A.dis == dis ? who < A.who : dis > A.dis;
	}
};
struct Tpt{
	int x, y, now, id;
	Tpt() { }
	Tpt(int x, int y) : x(x), y(y) { }
	void init() { scanf("%d%d", &x, &y); }
	int get(int d) { return d ? y : x; }
	bool operator < (const Tpt & A) const 
	{
		return now < A.now;
	}
} p[1000001];
priority_queue<Tans> Q;
LL dis(Tpt A, Tpt B)
{
	return (LL)(A.x - B.x) * (A.x - B.x) + (LL)(A.y - B.y) * (A.y - B.y);
}
void renew(Tans A)
{
	Q.push(A); if (Q.size() > k) Q.pop();
}
void build(int idx, int l, int r, int d)
{
	if (l > r) return;
	for (int i = l; i <= r; i++) p[i].now = p[i].get(d);
	sort(p + l, p + r + 1);
	int m = l + r >> 1;
	ymin[idx] = xmin[idx] = 1e9+1;
    ymax[idx] = xmax[idx] = -xmin[idx];	
	for (int i = l; i <= r; i++){
		gmin(xmin[idx], p[i].x);
		gmax(xmax[idx], p[i].x);
		gmin(ymin[idx], p[i].y);
		gmax(ymax[idx], p[i].y);
	}
	build(idx * 2, l, m - 1, !d); build(idx * 2 + 1, m + 1, r, !d);
}
int qp;
void query(int idx, int l, int r, Tpt t, bool d)
{
	if (l > r) return;
	int m = l + r >> 1;
	renew(Tans(dis(t, p[m]), p[m].id));
	LL x = max(t.x - xmin[idx], xmax[idx] - t.x), y = max(t.y - ymin[idx], ymax[idx] - t.y);
	if (Q.size() == k && x * x + y * y < Q.top().dis) return;
	if (t.get(d) < p[m].get(d)){
		query(idx * 2 + 1, m + 1, r, t, !d); 
		query(idx * 2, l, m - 1, t, !d); 
	}
	else{
		query(idx * 2, l, m - 1, t, !d); 
		query(idx * 2 + 1, m + 1, r, t, !d); 
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) p[i].init(), p[i].id = i;
	build(1, 1, n, 0);
	int Q; scanf("%d", &Q); 
	while(Q--){
		while(::Q.size()) ::Q.pop();
		Tpt t; t.init(); scanf("%d", &k);
		query(1, 1, n, t, 0);
		printf("%d\n", ::Q.top().who);
	}
}
Problem2627

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
//kAc
const int MO = (int)(1e9 + 7);

#define LL long long
#define LD long double

#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif

#define inv(a) pow(a, MO - 2);

const int MAXM = 3100;

using namespace std;

int mi[MAXM + 100], miinv[MAXM + 100], Inv[MAXM + 100], B[MAXM + 100];
LL p[10001];
int q[10001], tot;
LL n; int x, y;
inline int mul(int a,int b) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n" 
            :"=d"(ret):"a"(a),"b"(b),"c"(MO));
    return ret;
}
inline int pow(int a, int b)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = mul(ret, a);
		a = mul(a, a);
	}
	return ret;
}
inline int calcC(int n, int m)
{
	int ret = mi[n]; ret = mul(ret, miinv[m]); ret = mul(ret, miinv[n - m]);
	return ret;
}
/*
void fac(LL n)
{
	for (int i = 2; i * i <= n; i++) if (n % i == 0){
		++tot; p[tot] = i; q[tot] = 0;
		while(n % i == 0) ++q[tot], n /= i;
	}
	if (n) { ++tot; p[tot] = n; q[tot] = 1; }
}
*/
inline LL mul(LL a, LL b, LL c)
{
	LL t = (LL)(a / (LD) c * b + 1e-3);
	LL ret = a * b - c * t;
	if (ret < 0) ret += c;
	return ret % c;
}
inline LL pow(LL a, LL b, LL c)
{
	LL ret = 1;
	for (; b; b >>= 1){
		if (b & 1ll) ret = mul(ret, a, c);
		a = mul(a, a, c);
	}
	return ret;
}
inline bool chk(LL n, LL t)
{
	LL d = n - 1, m = 0;
	while(!(d & 1ll)) d >>= 1, ++m;
	LL now = pow(t, d, n);
	if (now == 1) return true;
	if (now == n - 1) return m != 0;
	for (int i = 1; i <= m; i++){
		now = mul(now, now, n);
		if (now == n - 1) return true;
	}
	return false;
}
inline bool mr(LL n)
{
	if (n == 1) return false;
	for (int i = 2; i <= 10000 && i * i <= n; i++) if (n % i == 0) return false;
	if (n <= 100000000) return true; 
	return chk(n, 2) && chk(n, 3) && chk(n, 5) && chk(n, 7) && chk(n, 11) && chk(n, 13) && chk(n, 17) && chk(n, 19) && chk(n, 23);
}
LL ans;
int nowrand = 1995;
inline int getrand()
{
	return nowrand = nowrand * 1994 % 1313;
}
inline void add(LL t)
{
	for (int i = 1; i <= tot; i++) if (p[i] == t) { ++q[i]; return; }
	++tot; p[tot] = t; q[tot] = 1;
}
inline void pr(LL n, int p)
{
	if (n == 1) return;
	if (mr(n)) { add(n); return; }
	while(1){
		LL x = 2, y = x;
		while(1){
			x = (mul(x, x, n) + p) % n;
			y = (mul(y, y, n) + p) % n;
			y = (mul(y, y, n) + p) % n;
			LL ab = x > y ? x - y : y - x;
			LL z = __gcd(ab, n);
			if (z == 1 || z == n) continue;
			pr(z, p - 1); pr(n / z, p - 1); return;
		}
	}
}
void fac(LL n)
{
	for (int i = 2; i <= 1000; i++) if (n % i == 0){
		while(n % i == 0){
			n /= i;
			add(i);
		}
	}
	pr(n, 75);	
}
int calc3(int p, int q, int x, int z) //id^x * id^z
{
	if (x > z) swap(x, z);
	int delta = pow(p, z - x), start = pow(p, q * x), ret = start;
	for (int i = 0; i < q; i++){
		start = mul(start, delta);
		ret = (ret + start) % MO;
	}
	return ret;
}
int calc2(int p, int q, int x, int y, int z) //id^x * miuid^y * id^z
{
	int ret = calc3(p, q, x, z);
	ret = (ret - mul(calc3(p, q - 1, x, z), pow(p, y))) % MO;
	ret = (ret + MO) % MO;
	return ret;
}
int calc1(int x, int y, int z)
{
	int ret = 1;
	for (int i = 1; i <= tot; i++) ret = mul(ret, calc2(p[i] % MO, q[i], x, y, z));
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	mi[0] = 1; for (int i = 1; i <= MAXM; i++) mi[i] = mul(mi[i - 1], i);	
	for (int i = 0; i <= MAXM; i++) miinv[i] = inv(mi[i]);
	Inv[1] = 1; for (int i = 2; i <= MAXM; i++) Inv[i] = mul(Inv[MO % i], (MO - MO / i));
	B[0] = 1; 
	for (int i = 1; i < MAXM; i++){
		for (int j = 0; j < i; j++){
			int now = mul(B[j], calcC(i, j));
			now = mul(now, Inv[i - j + 1]);
			B[i] = (B[i] + now) % MO;
		}
		B[i] = (MO - B[i]) % MO;
	}
	B[1] = (MO - B[1]) % MO;
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf(LLD"%d%d", &n, &x, &y);
	int ret = 0;
	tot = 0; fac(n); 
	for (int i = 0; i <= y; i++){
		int now;
		now = mul(calcC(y + 1, i), B[i]);
		now = mul(now, calc1(x, y, y + 1 - i));
		ret = (ret + now) % MO;
	}
	ret = mul(ret, Inv[y + 1]);
	ret = mul(ret, pow(n % MO, y));
	printf("%d\n", ret);
}

}
Problem2627

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
//kAc
const int MO = (int)(1e9 + 7);

#define LL long long
#define LD long double

#ifdef __int64
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif

#define inv(a) pow(a, MO - 2);

const int MAXM = 3100;

using namespace std;

int mi[MAXM + 100], miinv[MAXM + 100], Inv[MAXM + 100], B[MAXM + 100];
LL p[10001];
int q[10001], tot;
LL n; int x, y;
inline int mul(int a,int b) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n" 
            :"=d"(ret):"a"(a),"b"(b),"c"(MO));
    return ret;
}
inline int pow(int a, int b)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = mul(ret, a);
		a = mul(a, a);
	}
	return ret;
}
inline int calcC(int n, int m)
{
	int ret = mi[n]; ret = mul(ret, miinv[m]); ret = mul(ret, miinv[n - m]);
	return ret;
}
/*
void fac(LL n)
{
	for (int i = 2; i * i <= n; i++) if (n % i == 0){
		++tot; p[tot] = i; q[tot] = 0;
		while(n % i == 0) ++q[tot], n /= i;
	}
	if (n) { ++tot; p[tot] = n; q[tot] = 1; }
}
*/
inline LL mul(LL a, LL b, LL c)
{
	LL t = (LL)(a / (LD) c * b + 1e-3);
	LL ret = a * b - c * t;
	if (ret < 0) ret += c;
	return ret % c;
}
inline LL pow(LL a, LL b, LL c)
{
	LL ret = 1;
	for (; b; b >>= 1){
		if (b & 1ll) ret = mul(ret, a, c);
		a = mul(a, a, c);
	}
	return ret;
}
inline bool chk(LL n, LL t)
{
	LL d = n - 1, m = 0;
	while(!(d & 1ll)) d >>= 1, ++m;
	LL now = pow(t, d, n);
	if (now == 1) return true;
	if (now == n - 1) return m != 0;
	for (int i = 1; i <= m; i++){
		now = mul(now, now, n);
		if (now == n - 1) return true;
	}
	return false;
}
inline bool mr(LL n)
{
	if (n == 1) return false;
	for (int i = 2; i <= 10000 && i * i <= n; i++) if (n % i == 0) return false;
	if (n <= 100000000) return true; 
	return chk(n, 2) && chk(n, 3) && chk(n, 5) && chk(n, 7) && chk(n, 11) && chk(n, 13) && chk(n, 17) && chk(n, 19) && chk(n, 23);
}
LL ans;
int nowrand = 1995;
inline int getrand()
{
	return nowrand = nowrand * 1994 % 1313;
}
inline void add(LL t)
{
	for (int i = 1; i <= tot; i++) if (p[i] == t) { ++q[i]; return; }
	++tot; p[tot] = t; q[tot] = 1;
}
inline void pr(LL n, int p)
{
	if (n == 1) return;
	if (mr(n)) { add(n); return; }
	while(1){
		LL x = 2, y = x;
		while(1){
			x = (mul(x, x, n) + p) % n;
			y = (mul(y, y, n) + p) % n;
			y = (mul(y, y, n) + p) % n;
			LL ab = x > y ? x - y : y - x;
			LL z = __gcd(ab, n);
			if (z == 1 || z == n) continue;
			pr(z, p - 1); pr(n / z, p - 1); return;
		}
	}
}
void fac(LL n)
{
	for (int i = 2; i <= 1000; i++) if (n % i == 0){
		while(n % i == 0){
			n /= i;
			add(i);
		}
	}
	pr(n, 75);	
}
int calc3(int p, int q, int x, int z) //id^x * id^z
{
	if (x > z) swap(x, z);
	int delta = pow(p, z - x), start = pow(p, q * x), ret = start;
	for (int i = 0; i < q; i++){
		start = mul(start, delta);
		ret = (ret + start) % MO;
	}
	return ret;
}
int calc2(int p, int q, int x, int y, int z) //id^x * miuid^y * id^z
{
	int ret = calc3(p, q, x, z);
	ret = (ret - mul(calc3(p, q - 1, x, z), pow(p, y))) % MO;
	ret = (ret + MO) % MO;
	return ret;
}
int calc1(int x, int y, int z)
{
	int ret = 1;
	for (int i = 1; i <= tot; i++) ret = mul(ret, calc2(p[i] % MO, q[i], x, y, z));
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	mi[0] = 1; for (int i = 1; i <= MAXM; i++) mi[i] = mul(mi[i - 1], i);	
	for (int i = 0; i <= MAXM; i++) miinv[i] = inv(mi[i]);
	Inv[1] = 1; for (int i = 2; i <= MAXM; i++) Inv[i] = mul(Inv[MO % i], (MO - MO / i));
	B[0] = 1; 
	for (int i = 1; i < MAXM; i++){
		for (int j = 0; j < i; j++){
			int now = mul(B[j], calcC(i, j));
			now = mul(now, Inv[i - j + 1]);
			B[i] = (B[i] + now) % MO;
		}
		B[i] = (MO - B[i]) % MO;
	}
	B[1] = (MO - B[1]) % MO;
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf(LLD"%d%d", &n, &x, &y);
	int ret = 0;
	tot = 0; fac(n); 
	for (int i = 0; i <= y; i++) if(B[i]){
		int now;
		now = mul(calcC(y + 1, i), B[i]);
		now = mul(now, calc1(x, y, y + 1 - i));
		ret = (ret + now) % MO;
	}
	ret = mul(ret, Inv[y + 1]);
	ret = mul(ret, pow(n % MO, y));
	printf("%d\n", ret);
}

}
Problem2631

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;
#define LL long long
const int MO = 51061;
struct Tnode{
	static Tnode *a;
	int c[2], f, sum, _add, _mul, size, val;
	bool isroot, _rev;
	void add(int delta)
	{
		if (this == a) return;
		val = (val + delta) % MO;
		_add = (_add + delta) % MO;
		sum = ((LL)delta * size + sum) % MO;
	}
	void mul(int delta)
	{
		if (this == a) return;
		val = (LL) val * delta % MO;
		_add = (LL) _add * delta % MO;
		_mul = (LL) _mul * delta % MO;
		sum = (LL) sum * delta % MO;
	}
	void rev()
	{
		if (this == a) return;
		swap(c[0], c[1]); _rev ^= 1;
	}
	void push()
	{
		if (_mul != 1){
			a[c[0]].mul(_mul); a[c[1]].mul(_mul);
			_mul = 1;
		}
		if (_add != 0){
			a[c[0]].add(_add); a[c[1]].add(_add);
			_add = 0;
		}
		if (_rev){
			a[c[0]].rev(); a[c[1]].rev(); _rev = false;
		}
	}
	void update()
	{
		size = a[c[0]].size + a[c[1]].size + 1;
		sum = (a[c[0]].sum + val + a[c[1]].sum) % MO;
	}
	void rot(bool b)
	{
		a[f].push(); push(); if (a[f].isroot) a[f].isroot = false, isroot = true;
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[1000001], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c; A[x].push();
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
int AC(int x, int kind = -1, int delta = 0)
{
	int p = 0, q = x, ret;
	while(q){
		splay(q);
		if (A[q].f == 0)
			switch(kind){
				case 0 : A[p].add(delta); A[A[q].c[1]].add(delta); A[q].val = (A[q].val + delta) % MO; A[q].update(); break;
				case 1 : A[p].mul(delta); A[A[q].c[1]].mul(delta); A[q].val = (LL) A[q].val * delta % MO; A[q].update(); break;
				case 2 : ret = (A[p].sum + A[A[q].c[1]].sum + A[q].val) % MO; break;
			} 
		A[A[q].c[1]].isroot = true;
		A[p].isroot = false;
		A[q].c[1] = p;
		A[q].update();
		p = q; q = A[q].f;
	}
	return ret;
}
void link(int x, int y)
{
	AC(x); splay(x); A[x].rev(); A[x].f = y;
}
void cut(int x, int y)
{
	AC(x); splay(y); if (A[y].c[1] != x) swap(x, y);
	AC(x); splay(y);
	A[y].c[1] = 0; A[y].update();
	A[x].isroot = true; A[x].f = 0;
}
int e[1000001], v[1000001], next[1000001], n, m, tot;
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
void bfs()
{
	static queue<int> Q;
	Q.push(1);
	while(!Q.empty()){
		int x = Q.front(); Q.pop();
		for (int i = e[x]; i; i = next[i]) if (v[i] != A[x].f){
			A[v[i]].f = x; Q.push(v[i]);
		}
	}
	for (int i = 1; i <= n; i++) A[i].val = 1, A[i].isroot = true, A[i].update();
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i++){
		int a, b; scanf("%d%d", &a, &b); add(a, b); add(b, a);
	}
	bfs();
	while(m--){
		char c; int x, y, z, a, b;
		scanf(" "); scanf("%c", &c);
		switch(c){
			case '+': scanf("%d%d%d", &x, &y, &z); AC(x); AC(y, 0, z); break;
			case '*': scanf("%d%d%d", &x, &y, &z); AC(x); AC(y, 1, z); break;
			case '/': scanf("%d%d", &x, &y); AC(x); printf("%d\n", AC(y, 2)); break;
			case '-' : scanf("%d%d%d%d", &a, &b, &x, &y); cut(a, b); link(x, y); break;
		}
	}	

}
Problem2634

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <time.h>
#include <algorithm>
#include <iostream>
#define FORHASH for (int i = 1; i <= H[now].tot; i++)
#define GET(a, b) ((a >> (b + b)) & 15)
#define ADD(a, b) DFS(dep + 1, num ^ ((a ^ b) << (dep + dep)))
#define add(a, b) dfs(dep + 1, num ^ ((a ^ b) << (dep + dep)))
#define lint long long
const int MO = 3001, MOD = 7777777, MAXNODE = 1000000;
using namespace std;
int n, m, nownum;
lint nowadd, ANS;
inline int mul(int a,int b) {
    int ret;
    __asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n"
            :"=d"(ret):"a"(a),"b"(b),"c"(MOD));
    return ret;
}
struct Thashnode{
    int h, next;
};
struct Thash{
    int head[MO + 100], tot;
    Thashnode data[MAXNODE];
    Thashnode & operator [] (int k) { return data[k]; }
    void clear() { tot = 0; memset(head, 0, sizeof(head)); }
    int find(int h)
    {
        int hh = h % MO;
        for (int t = head[hh]; t; t = data[t].next)
            if (data[t].h == h) return t;
        ++tot; data[tot].h = h; data[tot].next = head[hh]; head[hh] = tot;
        return tot;
    }
} M;
struct Tmatrix{
    int data[201][201];
    int r, c;
    void clear() { memset(data, 0, sizeof(data)); }
} temp, now, ans, TM;
inline Tmatrix operator * (Tmatrix A, Tmatrix B)
{
    temp.r = A.r; temp.c = B.c;
    for (int i = 1; i <= temp.r; i++)
        for (int j = 1; j <= temp.c; j++){
            temp.data[i][j] = 0;
            for (int k = 1; k <= A.c; k++)
                temp.data[i][j] = (temp.data[i][j] + mul(A.data[i][k], B.data[k][j]) ) % MOD;
            }
    return temp;
}
int chanl(int h, int p)
{
    int i = p, cnt = -1;
    while (cnt != 0){
        i -= 2;
        if ((h >> i & 3) == 1) ++cnt;
        if ((h >> i & 3) == 2) --cnt;
        }
    return h ^ 3 << i;
}
int chanr(int h, int p)
{
    int i = p, cnt = 1;
    while (cnt != 0){
        i += 2;
        if ((h >> i & 3) == 1) ++cnt;
        if ((h >> i & 3) == 2) --cnt;
        }
    return h ^ 3 << i;
}
bool check(int num)
{
    int cnt = 0;
    for (int i = 0; i < m; i++){
        int t = (num >> (i + i)) & 3;
        if (t == 3) return false;
        if (t == 1) cnt++;
        if (t == 2) cnt--;
        if (cnt < 0) return false;
        }
    return cnt == 0;
}
 
void DFS(int dep, int num)
{
    if (dep == m){
        if (GET(num, m) == 0){
        TM.data[nownum][M.find(num)]++;
            }
        return;
        }
    switch(GET(num, dep)){
        case 0:
            ADD(0, 9);
            break;
        case 1:
            ADD(1, 1); ADD(1, 4);
            break;
        case 2:
            ADD(2, 2); ADD(2, 8);
            break;
        case 4:
            ADD(4, 1); ADD(4, 4);
            break;
        case 6:
            ADD(6, 0);
            break;
        case 8:
            ADD(8, 8); ADD(8, 2);
            break;
        case 5:
            DFS(dep + 1, chanr(num, dep + dep + 2) ^ 5 << (dep + dep));
            break;
        case 10:
            DFS(dep + 1, chanl(num, dep + dep) ^ 10 << (dep + dep));
            break;
        }
}
void dfs(int dep, int num)
{
    if (dep == m){
        if (num == 0) ANS = (ANS + nowadd) % MOD;
        return;
        }
    switch(GET(num, dep)){
        case 1:
            add(1, 1); add(1, 4);
            break;
        case 2:
            add(2, 2); add(2, 8);
            break;
        case 4:
            add(4, 1); add(4, 4);
            break;
        case 6:
            add(6, 0);
        case 8:
            add(8, 8); add(8, 2);
            break;
        case 9:
            if (dep == m - 1) add(9 ,0);
            break;
        case 5:
            dfs(dep + 1, chanr(num, dep + dep + 2) ^ 5 << (dep + dep));
            break;
        case 10:
            dfs(dep + 1, chanl(num, dep + dep) ^ 10 << (dep + dep));
            break;
        }
}
void prepare()
{
    for (int i = 0; i < (1 << (m + m)); i++) if (check(i)){
   		nownum = M.find(i);
   		DFS(0, i << 2);
    }
}
int main()
{
while(~scanf("%d%d", &m, &n)){
   ANS = 0;
        ans.clear(); TM.clear(); now.clear(); M.clear();
        prepare();
        ans.r = 1; ans.c = M.tot;
        TM.r = TM.c = M.tot;
        now.r = now.c = M.tot;
        for (int i = 1; i <= now.r; i++) now.data[i][i] = 1;
        ans.data[1][(M.find(1 + (2 << (m - 1 + m - 1))))] = 1;
        for (n--; n; n >>= 1){
            if (n & 1) now = now * TM;
            TM = TM * TM;
            }
        ans = ans * now;
        for (int i = 1; i <= M.tot; i++) if (ans.data[1][i]){
            nowadd = ans.data[1][i];
            dfs(0, M[i].h << 2);
        }
        if (ANS == 0) cout << "YM CP&YY" << endl;
        else cout << ANS << endl;
        }
}
Problem2636

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define CLR(a, b) memset(a, b, sizeof(a));
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
double temp[3][3];
struct Tmatrix{
	double data[3][3];
	double * operator [] (int k) { return data[k]; }
	const double * operator [] (int k) const { return data[k]; }
	void operator *= (const Tmatrix & A)
	{
		for (int i = 0; i < 3; i++)
			for (int j = 0; j < 3; j++){
				temp[i][j] = 0;
				for (int k = 0; k < 3; k++) temp[i][j] += data[i][k] * A[k][j];
			}
		memcpy(data, temp, sizeof(data));
	}
	void make1(double a, double b)
	{
		CLR(data, 0)
		data[2][2] = 1; data[0][0] = 1; data[1][1] = 1;
		data[2][0] = a; data[2][1] = b; 
	}
	void make2(double d)
	{
		CLR(data, 0);
		double s = sin(d), c = cos(d);
		data[0][0] = c; data[1][1] = c; data[0][1] = s; data[1][0] = -s; data[2][2] = 1;
	}
	void make3()
	{
		CLR(data, 0);
		data[2][2] = 1;
	}
	bool operator != (const Tmatrix & A) const
	{
		for (int i = 0; i < 3; i++) 
			for (int j = 0; j < 3; j++)
				if (data[i][j] != A[i][j])
					return true;
		return false;
	}
} unit, now, ret;

struct Tnode{
	int l, r, lc, rc;
	struct Tmatrix t;
}a[3000001]; int tot, top, n;
int seg[100001];
double dx, dy, d, nowx, nowy, startx[100001], starty[100001];
void push(int t)
{
	if (a[t].t != unit){
		int nt = ++tot;
		a[nt] = a[a[t].lc]; a[t].lc = nt; 
		a[nt].t *= a[t].t;
		nt = ++tot;
		a[nt] = a[a[t].rc]; a[t].rc = nt; 
		a[nt].t *= a[t].t;
		a[t].t = unit;
	}
}
int build(int l, int r)
{
	int now = ++tot; a[now].l = l; a[now].r = r; a[now].t = unit;
	if (l == r) return now;
	a[now].lc = build(l, l + r >> 1); a[now].rc = build(l + r + 2 >> 1, r);
	return now;
}
int change(int t, int l, int r)
{
	int now = ++tot; a[now] = a[t];
	if (l <= a[now].l && r >= a[now].r) { a[now].t *= ::now; return now; }
	push(now);
	int m = a[now].l + a[now].r >> 1;
	if (l <= m) a[now].lc = change(a[now].lc, l, r);
	if (r > m) a[now].rc = change(a[now].rc, l, r);
	return now;
}
void query(int now, int x)
{
	if (a[now].l == a[now].r) { ret *= a[now].t; return; }
	push(now);
	int m = a[now].l + a[now].r >> 1;
	if (x <= m) query(a[now].lc, x); else query(a[now].rc, x);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%lf%lf", &startx[i], &starty[i]);
	for (int i = 0; i < 3; i++) unit[i][i] = 1;
	seg[0] = build(1, n);
	int Q; scanf("%d", &Q);
	while(Q--){
		char op[101]; int l, r, x; 
		scanf("%s", op); 
		switch(*op){
			scanf(" ");
			case 'M' : scanf("%d%d%lf%lf", &l, &r, &dx, &dy); now.make1(dx, dy); ++top; seg[top] = change(seg[top - 1], l, r); break;
			case 'P' : scanf("%d%d%lf", &l, &r, &d); now.make2(d); ++top; seg[top] = change(seg[top - 1], l, r); break;
			case 'L' : scanf("%d%d", &l, &r); now.make3(); ++top; seg[top] = change(seg[top - 1], l, r); break;
			case 'C' : scanf("%d", &x); top -= x; break;
			case 'R' : scanf("%d", &x); top += x; break;
			case 'A' : scanf("%d", &x); ret = unit; query(seg[top], x); printf("%.10lf %.10lf\n", startx[x] * ret[0][0] + starty[x] * ret[1][0] + ret[2][0], startx[x] * ret[0][1] + starty[x] * ret[1][1] + ret[2][1]); break;
		}
	}

}
Problem2653

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cstring>
using namespace std;
int val[1000001], id[1000001];
bool idcmp(int a, int b)
{
	return val[a] < val[b];
}
struct Tnode{
	int l, r, lc, rc;
	int lmax, rmax, sum;
	Tnode() { sum = 0; }
} a[3000001]; int tot, n, Q;
int seg[1000001];
void update(Tnode & A, Tnode B, Tnode C)
{
	A.sum = B.sum + C.sum;
	A.lmax = max(B.lmax, B.sum + C.lmax);
	A.rmax = max(C.rmax, C.sum + B.rmax);
}
int build(int l, int r)
{
	int now = ++tot; a[now].l = l; a[now].r = r;
	if (l == r) { a[now].sum = a[now].lmax = a[now].rmax = -1; return now; }
	a[now].lc = build(l, l + r >> 1); a[now].rc = build(l + r + 2 >> 1, r);
	update(a[now], a[a[now].lc], a[a[now].rc]); return now;
}
int change(int t, int x)
{
	int now = ++tot; a[now] = a[t];
	if (a[now].l == a[now].r) { a[now].sum = a[now].lmax = a[now].rmax = 1; return now; }
	int m = a[now].l + a[now].r >> 1;
	if (x <= m) a[now].lc = change(a[now].lc, x); else a[now].rc = change(a[now].rc, x);
	update(a[now], a[a[now].lc], a[a[now].rc]); return now;
}
Tnode query(int t, int l, int r)
{
	if (l > r) return Tnode();
	if (l <= a[t].l & r >= a[t].r) return a[t];
	int m = a[t].l + a[t].r >> 1;
	if (l > m) return query(a[t].rc, l, r);
	if (r <= m) return query(a[t].lc, l, r);
	Tnode ret; update(ret, query(a[t].lc, l, r), query(a[t].rc, l, r));
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &val[i]);
	for (int i = 1; i <= n; i++) id[i] = i;
    sort(id + 1, id + n + 1, idcmp);	
	seg[n + 1] = build(1, n);
	for (int i = n; i >= 1; i--) seg[i] = change(seg[i + 1], id[i]);
	int ls = 0; scanf("%d", &Q);
	while(Q--){
		int q[4]; ls %= n;
		for (int i = 0; i < 4; i++) scanf("%d", &q[i]), q[i] = ((long long)(q[i]) + ls) % n + 1;
		sort(q, q + 4);
		int l = 1, r = n;
		while(l <= r){
			int m = l + r >> 1;
			if (query(seg[m], q[0], q[1]).rmax + query(seg[m], q[2], q[3]).lmax + query(seg[m], q[1] + 1, q[2] - 1).sum >= 0) l = m + 1; else r = m - 1;
		}
		printf("%d\n", ls = val[id[r]]);
	}
}
Problem2659

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
LL calc(LL a, LL b, LL c, LL n)
{
	if (n == 0) return 0;
	LL ret = 0;
	if (a >= c) { ret += a / c * n * (n - 1) / 2; a %= c; }
	if (b >= c) { ret += b / c * n; b %= c; }
	if (a == 0) return ret;
	return ret + calc(c, (a * n + b) % c, a, (a * n + b) / c);
}
int main()
{
	LL p, q; cin >> p >> q;
	cout << calc(q, 0, p, (p + 1) / 2) + calc(p, 0, q, (q + 1) / 2) << endl;
}
Problem2678

#include <set>
#include <iostream>
#include <cstdio>

//kAc
#define MP make_pair
#define LL long long
#define PII pair<LL, int>
using namespace std;
set<PII> heap;
const int MAXN = 1000001;
int a[MAXN], b[MAXN], w;
LL f[MAXN], sum[MAXN], l;
int n;
struct Tqueue{
	int l, r, q[MAXN]; LL num[MAXN];
	Tqueue() { l = 1; r = 0; }
	int head() { return q[l]; }
	int tail() { return q[r]; }
	int size() { return r - l + 1; }
	void poptail()
	{
		heap.erase(MP(num[r], q[r])); --r;
	}
	void pophead()
	{
		heap.erase(MP(num[l], q[l])); ++l;
	}
	void push(int t)
	{
		while(size() && a[t] >= a[tail()]) poptail();
		++r; q[r] = t; if (l == r) num[r] = f[w] + a[t]; else num[r] = f[q[r - 1]] + a[t];
		heap.insert(MP(num[r], q[r]));
	}
	void recalchead()
	{
		if (num[l] == f[w] + a[q[l]]) return;
		heap.erase(MP(num[l], q[l]));
		num[l] = f[w] + a[q[l]];
		heap.insert(MP(num[l], q[l]));
	}
} Q;
int main()
{
	cin >> n >> l;
	for (int i = 1; i <=n; i++) scanf("%d%d", &a[i], &b[i]);
	for (int i = 1; i <=n; i++) sum[i] = sum[i - 1] + b[i];
	f[0] = 0; w = 0; 
	for (int i = 1; i <= n; i++){
		while(sum[i] - sum[w] > l) ++w;
		while(Q.size() && Q.head() < w) Q.pophead();
		Q.push(i);
		Q.recalchead();
		f[i] = heap.begin()->first;
	}
	cout << f[n] << endl;
}
Problem2683

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
const int MAXN = 1500001;
struct Tdiscre{
    int data[MAXN], tot, n;
    int & operator [] (int k) { return data[k]; }
    void init()
    {
        sort(data + 1, data + n + 1);
        tot = unique(data + 1, data + n + 1) - data - 1;
    }
    int convert(int t)
    {
        return lower_bound(data + 1, data + tot + 1, t) - data; 
    }
} discre;
struct Tbit{
    int data[MAXN], n;
    void clear() { for (int i = 1; i <= n; i++) data[i] = 0; }
    void add(int x, int d)
    {
        for (; x <= n; x += (x & (-x))) data[x] += d;
    }
    int getsum(int x)
    {
        int ret = 0;
        for (; x; x -= (x & (-x))) ret += data[x];
        return ret;
    }
    int getsum(int l, int r) { return getsum(r) - getsum(l - 1); }
} bit;
struct Tscan{
    int kind, pos, y1, y2, who;
    Tscan() { }
    Tscan(int kind, int pos, int y1, int y2 = 0, int who = 0) : kind(kind), pos(pos), y1(y1), y2(y2), who(who) { }
    bool operator < (const Tscan & A) const { return pos == A.pos ? kind < A.kind : pos < A.pos; }
} scan[MAXN];
int ans[MAXN];
struct Tsolve{
    int n, m, tot; int x1[MAXN], x2[MAXN], y1[MAXN], y2[MAXN], px[MAXN], py[MAXN], num[MAXN], who[MAXN];
void clear()
{
    n = 0; m = 0; tot = 0; 
}
void solve()
{
    for (int i = 1; i <= n; i++){
        discre[i] = py[i];
        scan[++tot] = Tscan(1, px[i], py[i], num[i]);
    }
    for (int i = 1; i <= m; i++){
        discre[n + 2 * i - 1] = y1[i];
        discre[n + 2 * i] = y2[i];
        scan[++tot] = Tscan(2, x1[i] - 1, y1[i], y2[i], who[i]);
        scan[++tot] = Tscan(3, x2[i], y1[i], y2[i], who[i]);
    }
    sort(scan + 1, scan + tot + 1);
    discre.n = n + 2 * m;
    discre.init();
    bit.n = discre.tot; bit.clear();
    for (int i = 1; i <= tot; i++)
        switch(scan[i].kind){
            case 1 : bit.add(discre.convert(scan[i].y1), scan[i].y2); break;
            case 2 : ans[scan[i].who] -= bit.getsum(discre.convert(scan[i].y1), discre.convert(scan[i].y2)); break;
            case 3 : ans[scan[i].who] += bit.getsum(discre.convert(scan[i].y1), discre.convert(scan[i].y2)); break;
        }
  
}
} solver;
 
struct Tquery{
    int kind, x1, y1, x2, y2, d;
    bool init()
    {
        scanf("%d", &kind);
        if (kind == 3) return false;
        if (kind == 1) scanf("%d%d%d", &x1, &y1, &d);
        if (kind == 2) scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        return true;
    }
} query[MAXN];
int Q;
void solve(int l, int r)
{
    if (l == r) return;
    int m = l + r >> 1;
    solver.clear();
    for (int i = l; i <= m; i++) if (query[i].kind == 1){
        ++solver.n; solver.px[solver.n] = query[i].x1; solver.py[solver.n] = query[i].y1; solver.num[solver.n] = query[i].d;
    }
    for (int i = m + 1; i <= r; i++) if (query[i].kind == 2){
        ++solver.m; solver.x1[solver.m] = query[i].x1; solver.x2[solver.m] = query[i].x2; 
        solver.y1[solver.m] = query[i].y1; solver.y2[solver.m] = query[i].y2; solver.who[solver.m] = i;
    }
    solver.solve();
    solve(l, m); solve(m + 1, r);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
   scanf("%*d");
   while(query[++Q].init()); --Q;
   solve(1, Q);
   for (int i = 1; i <= Q; i++) if (query[i].kind == 2) printf("%d\n", ans[i]);
}
Problem2693

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
const int MAXN = 10000000, MO = 100000009;
int f[MAXN + 100], p[MAXN + 100], mpp[MAXN + 100], mp[MAXN + 100], sum[MAXN + 100];
bool notp[MAXN + 100];
int n, m, ptot;
void predo(int N)
{
	f[1] = 1;
	for (int i = 2; i <= N; i++){
		if (!notp[i]) { mp[i] = i; mpp[i] = i; f[i] = (1 - i) % MO; p[++ptot] = i; }
		for (int j = 1; j <= ptot && N / i >= p[j]; j++){
			notp[p[j] * i] = true;
			mp[p[j] * i] = p[j];			
			if (i % p[j] == 0){
				mpp[p[j] * i] = mpp[i] * p[j];
				f[p[j] * i] = (LL)(1 - p[j]) * f[p[j] * i / mpp[p[j] * i]] % MO;
				break;
			}
			else{
			 	mpp[p[j] * i] = p[j];
				f[p[j] * i] = (LL)f[i] * f[p[j]] % MO;
			}
		}
	}
}
int ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	predo(MAXN);
	for (int i = 1; i <= MAXN; i++) f[i] = (LL)f[i] * i % MO;
	for (int i = 1; i <= MAXN; i++) sum[i] = (sum[i - 1] + f[i]) % MO;
int TEST; scanf("%d", &TEST);
while(TEST--){
	ans = 0;
	scanf("%d%d", &n, &m); if (n > m) swap(n, m);
	for (int i = 1; i <= n; i++){
		int a = n / i, b = m / i;
		int r = min(n / a, m / b);
		int delta1 = ((LL)a * (a + 1) / 2) % MO, delta2 = ((LL)b * (b + 1) / 2) % MO;
		int delta = (LL)delta1 * delta2 % MO;// delta = (LL)delta * (r - i + 1) % MO; 
		ans = ((LL)(sum[r] - sum[i - 1]) * delta + ans) % MO;
		i = r;
	}	
	printf("%d\n", (ans + MO) % MO);
}
}
Problem2694

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
const int MAXN = 4000000, MO = 1<<30;
int f[MAXN + 100], p[MAXN + 100], mpp[MAXN + 100], mp[MAXN + 100], sum[MAXN + 100];
bool notp[MAXN + 100];
int n, m, ptot;
void predo(int N)
{
	f[1] = 1;
	for (int i = 2; i <= N; i++){
		if (!notp[i]) { mp[i] = i; mpp[i] = i; f[i] = i - i * i; p[++ptot] = i; }
		for (int j = 1; j <= ptot && N / i >= p[j]; j++){
			int now = p[j] * i; 
			notp[now] = true; mp[now] = p[j];			
			if (i % p[j] == 0){
				mpp[now] = mpp[i] * p[j];
				if (mpp[i] > p[j]) f[now] = 0; else
				f[now] = (-p[j] * p[j] * p[j]) * f[p[j] * i / mpp[now]];
				break;
			}
			else{
			 	mpp[p[j] * i] = p[j];
				f[p[j] * i] = f[i] * f[p[j]];
			}
		}
	}
}
int ans;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif	
	predo(MAXN);
	for (int i = 1; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];
int TEST; scanf("%d", &TEST);
while(TEST--){
	ans = 0;
	scanf("%d%d", &n, &m); if (n > m) swap(n, m);
	for (int i = 1; i <= n; i++){
		int a = n / i, b = m / i;
		int r = min(n / a, m / b);
		int delta1 = ((LL)a * (a + 1) / 2), delta2 = ((LL)b * (b + 1) / 2) % MO;
		int delta = delta1 * delta2;
		ans = (sum[r] - sum[i - 1]) * delta + ans;
		i = r;
	}	
	printf("%d\n", (ans % MO + MO) % MO);
}
}
Problem2705

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define LL long long
using namespace std;
LL n;
LL doit(LL p, LL q, LL num)
{
	return (p - 1) * num / p * q + num;
}
LL calc(LL n)
{
	LL ret = 1;
	for (LL i = 2; i * i <= n; i++) if (n % i == 0){
		LL p = i, q = 0, now = 1;
	 	while(n % p == 0){
			n /= p; ++q; now *= p; 
		}
		ret *= doit(p, q, now);
	}
	if (n != 1) ret *= doit(n, 1, n);
	return ret;
}
int main()
{
	cin >> n;
	cout << calc(n) << endl;
}
Problem2708

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define CLR(a, b) memset(a, b, sizeof(a))
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
int f[110][51][51][3];
int A[201];
class Wardrobe {
public:
	int dp(int x, int a, int b, int z)
	{
		if (x == 0) return a == 0 && b == 0 ? 0 : 0x3f3f3f3f;
		if (f[x][a][b][z] != 0x3f3f3f3f) return f[x][a][b][z];
		int & now = f[x][a][b][z];
		if (a > A[x + 1] || b > A[x + 1]) return now;
		for (int aa = 0; aa <= 50; aa++) if (aa + b <= A[x] && aa <= A[x - 1])
			for (int bb = 0; bb <= 50; bb++) if (a + bb <= A[x] && bb <= A[x - 1])
				for (int zz = 0; zz <= 2; zz++){
					if (z + zz == 3) continue;
					if (z == 0 && a + bb != b + aa) continue;
					if (z == 1 && a + bb <= b + aa) continue;
					if (z == 2 && a + bb >= b + aa) continue;
					int t = dp(x - 1, aa, bb, zz); if (t >= 0x3f3f3f3f) continue;
					if (z == 0 && a + bb == b + aa) gmin(now, t + A[x]);
					if (z == 1 && a + bb > b + aa) gmin(now, t + A[x]);
					if (z == 2 && a + bb < b + aa) gmin(now, t + A[x] - b - aa + a + bb);
				}
//		if (now != 0x3f3f3f3f) cerr << x << " " << a << " " << b << " " << z << " " << now << endl;
		return now;
	}
	int countUnscrewedHoles(vector <int> bolts) {
		sort(ALL(bolts)); CLR(A, 0);
		foreach(x, bolts) ++A[*x];
		CLR(f, 0x3f); f[0][0][0][0] = 0;
		return SZ(bolts) - dp(101, 0, 0, 0);
	}
} Solver;
vector<int> t; int n, num;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("puppet.in", "r", stdin); freopen("puppet.out", "w", stdout);
#endif
while(~scanf("%d", &n)){
	t.clear(); while(n--) { int num; scanf("%d", &num); t.push_back(num); }
	printf("%d\n", Solver.countUnscrewedHoles(t)); 
}
}
Problem2709

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;
#define PII pair<int, int>
#define PDII pair<double, PII>
priority_queue<PDII, vector<PDII>, greater<PDII> > Q;
const int Dx[4] = {0, 0, 1, -1}, Dy[4] = {1, -1, 0, 0};
int n, m; double L;
char map[1001][1001];
double dis[1001][1001];
bool vis[1001][1001];
bool dijkstra(int sx, int sy, int dx, int dy, double v, double L)
{
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { dis[i][j] = 1e20; vis[i][j] = false; }
	dis[sx][sy] = 0.0; Q.push(make_pair(0.0, make_pair(sx, sy)));
	while(!Q.empty()){
		if (dis[dx][dy] < L) return false;
		PII now = Q.top().second; Q.pop(); if (vis[now.first][now.second]) continue;
		vis[now.first][now.second] = true;
		for (int i = 0; i < 4; i++){
			int nx = now.first + Dx[i], ny = now.second + Dy[i];
			if (nx > n || nx < 1 || ny > m || ny < 1 || map[nx][ny] == '#') continue;
			if (dis[nx][ny] > dis[now.first][now.second] + ((i < 2) ? 1.0 : v)){
				dis[nx][ny] = dis[now.first][now.second] + ((i < 2) ? 1.0 : v);
				Q.push(make_pair(dis[nx][ny], make_pair(nx, ny)));
			}
		}
	}
	return dis[dx][dy] > L;
}
int main()
{

int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%lf%d%d", &L, &n, &m);
	for (int i = 1; i <= n; i++){
		scanf(" ");
		for (int j = 1; j <= m; j++)
			scanf("%c", &map[i][j]);
	}
	int sx, sy, dx, dy;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++){
		if (map[i][j] == 'S') sx = i, sy = j;
		if (map[i][j] == 'E') dx = i, dy = j;
	}
	double l = 0, r = 30;
	while(r - l > 1e-9){
		double m = (l + r) / 2.0;
		if (dijkstra(sx, sy, dx, dy, m, L)) r = m; else l = m;
	}
	printf("%.5lf\n", l);


}
}
Problem2710

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <complex>
//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
#define ws heheiamkac
#define y0 fuckmathh
#define y1 fuckmathhagain
using namespace std;
int sig(double t) { if (fabs(t) < eps) return 0; return t < 0 ? -1 : 1; }
struct pt{
	double x, y;
	pt() { x = 0; y = 0; }
	pt(double x, double y) : x(x), y(y) { }
	void init() { scanf("%lf%lf", &x, &y); }
	double len() { return hypot(x, y); }
	double len2() { return x * x + y * y; }
	void makeunit() { double l = len(); if (sig(l) != 0) { x /= l; y /= l; } }
	pt operator + (const pt & A) { return pt(x + A.x, y + A.y); }
	pt operator - (const pt & A) { return pt(x - A.x, y - A.y); }
	pt operator * (const double & t) { return pt(x * t, y * t); }
	pt operator / (const double & t) { return pt(x / t, y / t); }
};
pt cs, cv, ws, we, wv;
double unit, x0, y0, x1, y1, v;
double dot(pt A, pt B) { return A.x * B.x + A.y * B.y; }
double dot(pt o, pt a, pt b) { return dot(a - o, b - o); }
double dis(pt A, pt B) { return (A - B).len(); }
double dis2(pt A, pt B) { return (A - B).len2(); }
struct ln{
	pt p1, p2;
	ln(pt p1, pt p2) : p1(p1), p2(p2) { }
	double getdis(pt p)
	{
		double ds = dis(p1, p2);
		if (sig(ds) == 0) return dis(p, p1);
		double d = dot(p1, p, p2) / dis(p1, p2);
		if (d > ds || d < 0) return min(dis(p, p1), dis(p, p2));
		return sqrt(dis2(p, p1) - d * d);
	}
};
double get(LL t)
{
	double ret = 1e99;
	pt start = ws, end = ws + (wv - cv) * unit;
	pt where = cs + cv * (2.0 * t * unit);
	ret = min(ret, ln(start, end).getdis(where));
//	cerr << ln(start, end).getdis(where) << endl;
	start = we; end = we + (pt() - wv - cv) * unit;
	where = cs + cv * (2.0 * t * unit + unit);
	ret = min(ret, ln(start, end).getdis(where));
//	cerr << ln(start, end).getdis(where) << endl;
	return ret;
}
double find(LL l, LL r)
{
	double ret = 1e99;
	if (r - l + 1 <= 5) {
		for (LL i = l; i <= r; i++) ret = min(ret, get(i));
		return ret;
	}
	LL m1 = l + (r - l) / 3;
	LL m2 = r - (r - l) / 3;
	if (get(m1) < get(m2)) return find(l, m2); else return find(m1, r);
}
int main()
{
while(~scanf("%lf%lf%lf%lf%lf", &x0, &y0, &x1, &y1, &v)){
	cs = pt(x0, y0); cv = pt(x1, y1) - cs; cv = cv / cv.len(); cv = cv * v;
	scanf("%lf%lf%lf%lf%lf", &x0, &y0, &x1, &y1, &v);
	ws = pt(x0, y0); we = pt(x1, y1); wv = we - ws; 
	unit = wv.len() / v;
	wv = wv / wv.len(); wv = wv * v; 
	double ans = find(0, 1e12);
	double d1, d2; scanf("%lf%lf", &d1, &d2);
	if (ans < d1) puts("Dangerous");
	else if (ans > d2) puts("Miss");
		 else puts("Perfect");
}
}
Problem2711

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
double f[2][90001];
int n, x[1001], y[1001];
double calc(int data[])
{
	int sum = 0; for (int i = 1; i <= n; i++) sum += data[i];
	int now = 1;
	for (int i = 0; i <= 1; i++)
		for (int j = 0; j <= 2 * sum; j++) f[i][j] = 1e30;
	f[0][0 + sum] = 0;
	for (int i = 1; i <= n; i++){
		now ^= 1;
		for (int j = -sum; j <= sum; j++){
			if (j - data[i] >= -sum) f[!now][j + sum] = min(f[!now][j + sum], f[now][j - data[i] + sum] + (j - data[i]) * data[i]);
			if (j + data[i] <= sum) f[!now][j + sum] = min(f[!now][j + sum], f[now][j + data[i] + sum] + (j + data[i]) * -data[i]);
		}
		for (int j = -sum; j <= sum; j++) f[now][j + sum] = 1e30;
	}
	double ret = 1e30;
	for (int i = -sum; i <= sum; i++) ret = min(f[!now][i + sum], ret);
	return ret;
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", x + i, y + i);
	printf("%.2lf\n", calc(x) + calc(y));
}
Problem2712

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
void calc(LL a, LL b, LL c, LL d, LL & x, LL & y)
{
	if (a < b && c > d) { x = 1; y = 1; return; }
	if (a >= b && c >= d) { LL t = a / b; calc(a - t * b, b, c - t * d, d, x, y); x += t * y; return; }
	if (a == 0) { x = 1; y = (d / c) + 1; return; }
	calc(d, c, b, a, y, x);
}
int len; LL n;
int main()
{
while(~scanf("%d 0.%lld", &len, &n)){
	if (n == 0) { puts("1"); continue; }
	LL t = 2;
	while(len--) t *= 10ll;
	LL x, y; calc(n * 2 - 1, t, n * 2 + 1, t, x, y);
	LL g = __gcd(n * 2 - 1, t);
	if (t / g < y) y = t / g;
	printf("%lld\n", y);
}
}
Problem2713

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;

const int LIM = (int)1e9;
int tot, q[1000001][10], mul[1000001], now[10], num[19];
LL fac[19];
void dfs(int dep, int get, LL num)
{
	if (num >= LIM) return;
	if (dep == 10) return;
	dfs(dep + 1, get, num);
	if (num * dep <= LIM && get <= 17){
		now[dep - 1]++;
		++tot; 
		for (int i = 0; i <= 9; i++) q[tot][i] = now[i];
		mul[tot] = num * dep;
		dfs(dep, get + 1, num * dep);
		now[dep - 1]--;
	}
}
LL ans;
void DFS(int dep)
{
	if (dep == 0) { ++ans; return; }
	for (int i = 1; i <= 9; i++) if (now[i - 1] ){
		if (i > num[dep]) continue;
		if (i < num[dep]){
			LL ret = fac[dep - 1];
			--now[i - 1];
			for (int j = 0; j <= 8; j++) ret /= fac[now[j]];
			++now[i - 1];
			ans += ret;
		}
		if (i == num[dep]) { --now[i - 1]; DFS(dep - 1); } 
	}
}
LL calc3(int len)
{
	now[0] = len;
	for (int i = 1; i <= 8; i++) now[0] -= now[i];
	if (now[0] < 0) return 0;
	LL ret = fac[len];
	for (int i = 0; i <= 8; i++) ret /= fac[now[i]];
	return ret;
}
LL calc2(LL t, int w)
{
	ans = 0;
	if (t == 0) return 0;
	int len = 0;
	while(t) { num[++len] = t % 10; t /= 10; }
	memcpy(now, q[w], sizeof(q[w])); 
	now[0] = len;
	for (int i = 1; i <= 8; i++) now[0] -= now[i];
	if (now[0] >= 0) DFS(len);
	memcpy(now, q[w], sizeof(q[w])); 
	for (int i = 1; i < len; i++) ans += calc3(i);
//	if (ans) cerr << ans << endl;
	return ans;
}
LL calc(LL t)
{
	LL ret = 0;
	for (int i = 0; i <= tot; i++) ret += calc2(t / mul[i], i);
//	cerr << ret << endl;
	return ret;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	mul[0] = 1;
	dfs(2, 0, 1);
	fac[0] = 1; for (int i = 1; i <= 18; i++) fac[i] = fac[i - 1] * i;
	LL L, R;
	cin >> L >> R;	
	cout << calc(R) - calc(L - 1) << endl;
}
Problem2715

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
queue<int> Q;
int a[1001][1001];
int dis[1<<20], from[1<<20], cmd[1<<20];
int n, m;
void print(int S)
{
	if (S + 1 == (1 << n)) return;
	print(from[S]);
	printf("%x", cmd[S]);
}
int trans(int a, int b)
{
	int ret = 0;
	for (int j = 0; j < n; j++) if ((a >> j) & 1) ret |= (1 << ::a[j][b]);
	return ret;
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			scanf("%d", &a[i][j]);
	Q.push((1 << n) - 1);
	CLR(dis, -1); dis[(1 << n) - 1] = 0;
	while(!Q.empty()){
		int x = Q.front(); Q.pop();
		for (int i = 0; i < m; i++) if (dis[trans(x, i)] == -1){
			int now = trans(x, i); dis[now] = dis[x] + 1; from[now] = x; cmd[now] = i; Q.push(now);
		}
	}	
	if (dis[1] == -1) { puts("impossible"); return 0; }
	print(1); putchar('\n');
}
Problem2716

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
const int INF = 1000000000;
const int MAXQ = 3000001;
using namespace std;
struct Tquery{
	int kind, x, y, who;
	bool operator < (const Tquery & A) const { return (x == A.x && y == A.y) ? (kind < A.kind) : (x == A.x ? y < A.y : x < A.x); }
} query[MAXQ];
struct Tdiscre{
	int tot, data[MAXQ];
	void clear() { tot = 0; }
	void add(int x) { data[++tot] = x; }
	void init() { sort(data + 1, data + tot + 1); tot = unique(data + 1, data + tot + 1) - data - 1; }
	int conv(int x) { if (x < data[1]) return 0; return upper_bound(data + 1, data + tot + 1, x) - data - 1; }
} discre;
struct Tbit{
	int data[MAXQ];
	void ins(int x, int d) { for (; x <= discre.tot; x += (x & (-x))) data[x] = max(data[x], d); }
	void clr(int x) { for (; x <= discre.tot; x += (x & (-x))) data[x] = -INF; }
	int query(int x) { int ret = -INF; for (; x; x -= (x & (-x))) ret = max(ret, data[x]); return ret; }
} bit;
int tot;
int ans[MAXQ];
struct Tsolver{
	int tot;
	Tquery query[MAXQ];
	void clear() { tot = 0;  discre.clear(); }
	void add(Tquery q) { query[++tot] = q; } 
	void solve()
	{
		sort(query + 1, query + tot + 1);
		for (int i = 1; i <= tot; i++) if (query[i].kind == 1) discre.add(query[i].y);
		discre.init();
		for (int i = 1; i <= tot; i++)
			switch(query[i].kind){
				case 1 : bit.ins(discre.conv(query[i].y), query[i].x + query[i].y); break;
				case 2 : ans[query[i].who] = min(ans[query[i].who], query[i].x + query[i].y - bit.query(discre.conv(query[i].y))); break;
			}
		for (int i = 1; i <= tot; i++) if (query[i].kind == 1) bit.clr(discre.conv(query[i].y));
	}
} solver;
void doit(int l, int r)
{
	if (l >= r) return;
	int m = l + r >> 1;
	doit(l, m); doit(m + 1, r);
	solver.clear();
	int tot1 = 0, tot2 = 0;
	for (int i = l; i <= m; i++) if (query[i].kind == 1) solver.add(query[i]), ++tot1;
	for (int i = m + 1; i <= r; i++) if (query[i].kind == 2) solver.add(query[i]), ++tot2;
	if (tot1 && tot2) solver.solve();
}
int n, m;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	for (int i = 1; i <= 2000000; i++) bit.data[i] = -INF, ans[i] = INF;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)  { ++tot; scanf("%d%d", &query[tot].x, &query[tot].y); query[tot].who = tot; query[tot].kind = 1; }
	for (int i = 1; i <= m; i++)  { ++tot; scanf("%d%d%d", &query[tot].kind, &query[tot].x, &query[tot].y); query[tot].who = tot;}
	for (int i = 1; i <= 4; i++){
		doit(1, tot);
		for (int j = 1; j <= tot; j++){
			swap(query[j].x, query[j].y); 
			query[j].y *= -1; 
		}
	}
	for (int i = 1; i <= tot; i++) if (query[i].kind == 2) printf("%d\n", ans[i]);
}
Problem2717

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
int n;
int main()
{
	scanf("%d", &n);
	printf("%d\n", n * (n - 1) / 2);
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++){
			if (j - i + (j - i) > n) printf("%d %d %d\n", i, j, (i - (j - i) - 1 + n) % n + 1);
			else printf("%d %d %d\n", i, j, (j + (j - i) - 1) % n + 1);
		}
}
Problem2718

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;
bool map[1001][1001], can[1001][1001];
int link[1001], n, m, now, nowdo;
vector<int> adj[1001], tadj[1001];
bool vis[1001], linked[1001];
set<int> S;
void dfs(int x)
{
    can[now][x] = true;
    for (int i = 1; i <= n; i++) if (map[x][i] && !can[now][i]) dfs(i);
}
bool find(int x)
{
    for (vector<int>::iterator vi = adj[x].begin(); vi != adj[x].end(); vi++) if (!vis[*vi]){
        vis[*vi] = true;
        if (link[*vi] == 0 || find(link[*vi])){
            link[*vi] = x; return true;
            }
        }
    return false;
}   
bool find2(int x)
{
    for (vector<int>::iterator vi = tadj[x].begin(); vi != tadj[x].end(); vi++)
        if (!vis[*vi]){
            vis[*vi] = true;
            if (link[*vi] == 0 || can[nowdo][link[*vi]] || can[link[*vi]][nowdo] || find2(link[*vi])) return true;
            }
    return false;
}   
char ans3[1001], ans2[1001];
int main()
{
    //freopen("river.in", "r", stdin); freopen("river.out", "w", stdout);
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++){
        int a, b; scanf("%d%d", &a, &b); map[a][b] = true;
        }
    for (int i = 1; i <= n; i++){
        memset(vis, 0, sizeof(vis));
        now = i; dfs(i);
        for (int j = 1; j <= n; j++) if (can[i][j] && i != j) adj[i].push_back(j);
        }
    int ans = 0;
    for (int i = 1; i <= n; i++){
        memset(vis, 0, sizeof(vis));
        if (find(i)) ++ans;
        }
    printf("%d\n", n - ans);
/*
    for (int i = 1; i <= n; i++){
        nowdo = i;
        int t = 0, nt = 0;
        for (int j = 1; j <= n; j++){
            if (link[j])
                if (!can[i][j] && !can[j][i] && !can[i][link[j]] && !can[link[j]][i])
                    ++t;
            if (!can[i][j] && !can[j][i]) ++nt;
            }
        if (nt - t < n - ans - 1) { ans3[i] = '0'; continue; }
        for (int j = 1; j <= n; j++) if (!can[i][j] && !can[j][i]){
            tadj[j].clear();
            for (vector<int>::iterator vi = adj[j].begin(); vi != adj[j].end(); vi++)
                if (!can[i][*vi] && !can[*vi][i])
                    tadj[j].push_back(*vi);
            }
        memset(vis, 0, sizeof(vis));
        memset(linked, 0, sizeof(linked));
        for (int j = 1; j <= n; j++) if (link[j]) 
            if (!can[i][j] && !can[j][i] && !can[i][link[j]] && !can[link[j]][i])
                linked[link[j]] = true;
        bool ok = true;
        for (int j = 1; j <= n; j++) if (!can[i][j] && !can[j][i] && !linked[j]) 
            if (find2(j)){
                ok = false; break;
                }
        ans3[i] = ok ? '1' : '0';
        }
    for (int i = 1; i <= n; i++) S.insert(i);
    for (int i = 1; i <= n; i++){
        if (!S.count(i)) { ans2[i] = '0'; continue; }
        if (ans3[i] == '0') { S.erase(find(i)); ans2[i] = '0';; continue; }
        for (int j = 1; j <= n; j++) if ((can[i][j] || can[j][i]) && S.count(j)) S.erase(j);
        ans2[i] = '1';
        }
    puts(ans2 + 1);
    puts(ans3 + 1);
*/
}
Problem2720

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
int a[1000001], n;
int main()
{
	scanf("%d", &n); for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	double ans = 0;
	for (int i = 1; i <= n; i++) {
		int num = 0; for (int j = 1; j <= n; j++) if (a[i] > a[j]) ++num;	
		ans += (double)(n + 1)/(n + 1 - num); 
	}
	printf("%.2lf\n", ans);
}
Problem2721

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
int tot, p[1000001], f[1000001], q[1000001], n;
bool notp[1000001];
int main()
{
	cin >> n;
	for (int i = 2; i <= n; i++){
		if (!notp[i]) { p[++tot] = i; }
		for (int j = 1; j <= tot && (LL) i * p[j] <= n; j++){
			notp[i * p[j]] = true;
			if (i % p[j] == 0) break;
		}
	}	
	for (int i = 1; i <= tot; i++){
		int now = n;
		while (now) { q[i] += now / p[i]; now /= p[i]; }
	}
	f[0] = 1;
	for (int i = 1; i <= tot; i++) f[i] = (f[i - 1] + (LL)f[i - 1] * q[i] * 2) % MO;
	cout << f[tot] << endl;
}
Problem2722

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
struct Tthing{
	int value, num;
	Tthing() { }
	Tthing(int value, int num) : value(value), num(num) { }
bool operator < (const Tthing & A) const { return value > A.value; }
};	
struct Tbackpack{
	Tthing t[2][1000001];
	int tot[2];
	LL ret;
	stack<Tthing> now;
	void add(Tthing tt, bool k) { t[k][++tot[k]] = tt; }
	void renew(Tthing t)
	{
		if (SZ(now) == 0) return;
		while(t.num && SZ(now)){
			Tthing a = now.top(); now.pop();
			if (a.num > 1){
				if (a.value * 2 >= t.value) return;
				LL num = min(t.num, a.num / 2);
				ret -= (LL) num * a.value * 2ll;
				ret += (LL) num * t.value;
				a.num -= num * 2ll;
				t.num -= num;
				if (a.num) now.push(a);
				continue;
			}
			else{
				if (SZ(now) == 0) return;
				Tthing b = now.top(); now.pop();
			    if (a.value + b.value >= t.value) return;
				ret -= (LL)(a.value + b.value);
				ret += t.value;
				b.num--; t.num--;
				if (b.num) now.push(b);
				continue;	
			}	
		}
	}
	LL solve(LL lim)
	{
		sort(t[0] + 1, t[0] + tot[0] + 1);
		sort(t[1] + 1, t[1] + tot[1] + 1);
		LL nw = 0;
		for (int i = 1; i <= tot[0]; i++)
			if (nw < lim){
				now.push(Tthing(t[0][i].value, min(lim - nw, (LL)t[0][i].num)));
				ret += (LL)now.top().num * now.top().value;
				nw += now.top().num;
			}
			else break;
		if ((nw & 1ll) != (lim & 1ll)){
			Tthing temp = now.top(); 
			now.pop(); 
			--nw; ret -= temp.value;
			if (temp.num) { --temp.num; now.push(temp); 
			}
	   	}
		if (nw < lim) now.push(Tthing(0, lim - nw));
		for (int i = 1; i <= tot[1]; i++) renew(t[1][i]);
		return ret;
	}
} solver;
LL ans, sum;
int n, cost[1001][1001], l[1001][1001], r[1001][1001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &cost[i][j]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &l[i][j]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf("%d", &r[i][j]);
	for (int i = 1; i <= n; i++)
		for (int j = i; j <= n; j++){
			LL L = max(l[i][j], l[j][i]), R = min(r[i][j], r[j][i]);
			sum += L + L * (i != j); if (i == j) ans += L * cost[i][j]; else ans += L * (cost[i][j] + cost[j][i]);
			LL c = (i != j) ? cost[i][j] + cost[j][i] : cost[i][j], num = R - L;
			solver.add(Tthing(c, num), i != j);
		}
	cout << ans + solver.solve(-sum) << endl;
	
}
Problem2724

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }

using namespace std;
int best[1001][1001];
struct Tdiscre{
	vector<int> data;
	void add(int x) { data.PB(x); }
	void init() { sort(ALL(data)); data.resize(unique(ALL(data)) - data.begin()); }
	int conv(int x) { return lower_bound(ALL(data), x) - data.begin() + 1; }
} discre;
struct Ttimer{
	vector<int> data[30001];
	void add(int a, int b) { data[a].PB(b); }
	int calc(int a, int x)
	{
		return upper_bound(ALL(data[a]), x) - data[a].begin();
	}
	int calc(int a, int l, int r)
	{
		return calc(a, r) - calc(a, l - 1);
	}
} timer;
int n, Q;
int which[1000001], pos[1000001];
int start[1000001], end[1000001], a[1000001];
int SIZE, totb;
int now[30001], first[30001];
void renew(PII & A, PII B)
{
	if (B.FR > A.FR || B.FR == A.FR && A.SC > B.SC) A = B;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &Q);
	for (int i = 1; i <= n; i++) { scanf("%d", &a[i]); discre.add(a[i]); }
	discre.init();
 	for (int i = 1; i <= n; i++) a[i] = discre.conv(a[i]);
	for (int i = 1; i <= n; i++) timer.add(a[i], i);
	int noww = 1, nowp = 0; start[1] = 1;
	for (SIZE = 1; SIZE * SIZE < n; SIZE++);
	for (int i = 1; i <= n; i++){
		which[i] = noww; pos[i] = ++nowp;
		if (nowp == SIZE && i < n) { end[noww] = i; noww++; nowp = 0; start[noww] = i + 1; }
	}	
	end[noww] = n; which[n + 1] = noww + 1; which[0] = 0;
	totb = noww;
	for (int i = 1; i <= totb; i++){
		CLR(now, 0); CLR(first, 0x3f);
		int wb = i;
		PII ans = MP(0, 0);
		for (int j = start[i]; j <= n; j++){
			++now[a[j]];
			renew(ans, MP(now[a[j]], a[j]));
			if (end[wb] == j){
				best[i][wb] = ans.SC;
				++wb;
			}
		}
	}
	int lastans = 0;
	while(Q--){
		int l, r; scanf("%d%d", &l, &r);
		l = (l + lastans - 1) % n + 1; r = (r + lastans - 1) % n + 1;
		if (l > r) swap(l, r);
		PII ans = MP(0, 0);
		int ll = l;
		while(which[ll] == which[l] && ll <= r){
			renew(ans, MP(timer.calc(a[ll], l, r), a[ll]));
			++ll;
		}
		int rr = r;
		while(which[rr] == which[r] && rr >= l){
			renew(ans, MP(timer.calc(a[rr], l, r), a[rr]));
			--rr;
		}
		if (ll > rr) { printf("%d\n", lastans = discre.data[ans.SC - 1]); continue; };
		renew(ans, MP(timer.calc(best[which[ll]][which[rr]], l, r), best[which[ll]][which[rr]]));
		printf("%d\n", lastans = discre.data[ans.SC - 1]);
	}
}
Problem2726

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define LL long long
#define LD long double
const int MAXN = 1000001;
const LL INF = 0x7fffffffffffffffll;
LL f[MAXN], sumf[MAXN], sumt[MAXN];
int F[MAXN], T[MAXN], s, n;
struct Tpoint{
	LL x, y;
	Tpoint() { }
	Tpoint(LL x, LL y) : x(x), y(y) { }
	Tpoint operator - (const Tpoint & A) { return Tpoint(x - A.x, y - A.y); }
	LL get(LL k) { return k * x + y; }
	bool operator * (const Tpoint & A)
	{
		LD x1 = x, y1 = y, x2 = A.x, y2 = A.y;
		return (x1 * y2 - x2 * y1) >= 0;
	}
};
bool cross(Tpoint O, Tpoint A, Tpoint B)
{
	return (A - O) * (B - O);
}
struct Tqueue{
	Tpoint Q[MAXN]; int l, r;
	Tpoint head() { return Q[l]; }
	int size() { return r - l + 1; }
	void clear() { l = 1; r = 0; }
	Tpoint push(Tpoint A)
	{
		while(size() >= 2 && cross(Q[r - 1], A, Q[r])) --r;
		Q[++r] = A;
	}
	LL pop(LL k) 
	{
		while(size() >= 2 && Q[l].get(k) >= Q[l + 1].get(k)) ++l;
	    return Q[l].get(k);	
	}
	LL find(int l, int r, LL k)
	{
		if (r - l + 1 <= 5){
			LL ret = INF;
			for (int i = l; i <= r; i++) ret = min(ret, Q[i].get(k));
			return ret;
		}
		int m1 = l + r >> 1, m2 = m1 + 1;
		if (Q[m2].get(k) < Q[m1].get(k)) return find(m2, r, k); else return find(l, m1, k);
	}
	LL find(LL k) { return find(l, r, k); }
} Q;
Tpoint make_point(int i)
{
	return Tpoint(sumf[i], f[i] - sumf[i] * s);
}
namespace A{ //T<=0
	void solve()
	{
		Q.clear(); f[0] = 0; 
		for (int i = 1; i <= n; i++){
			Q.push(make_point(i - 1));
			f[i] = Q.find(-sumt[i]) + sumf[n] * s + sumf[i] * sumt[i];
		}
	    cout << f[n] << endl;
	}
};
namespace B{ //T>=0
	void solve()
	{
		Q.clear(); f[0] = 0; 
		for (int i = 1; i <= n; i++){
			Q.push(make_point(i - 1));
			f[i] = Q.pop(-sumt[i]) + sumf[n] * s + sumf[i] * sumt[i];
		}
	    cout << f[n] << endl;
	}
};
int main()
{
	scanf("%d%d", &n, &s);
	for (int i = 1; i <= n; i++) scanf("%d%d", &T[i], &F[i]);
	bool type = false;
	for (int i = 1; i <= n; i++) if (T[i] < 0) type = true;
	for (int i = 1; i <= n; i++) sumf[i] = sumf[i - 1] + F[i], sumt[i] = sumt[i - 1] + T[i];
	if (!type)
		B::solve(); 
	else A::solve();
}
Problem2727

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>

const int MO = 1000000009;
#define LL long long
using namespace std;
int ans;
vector<vector<int> > a, l, r;
vector<int> now;
int R, C, n;
void solve()
{
	int n = now.size() - 1;
//	for (int i = 0; i < now.size(); i++) cerr << now[i] << ' '; cerr << endl;
	for (int i = 2; i <= n; i++)
		for (int j = i + 2; j < n; j++){
			int ret = (LL)(i - 1) * (n - j) % MO;
			if (now[j] <= now[i]) ret = (LL) ret * (((LL)now[j] * (now[j] - 1) / 2) % MO) % MO;
			else ret = (LL) ret * ((((LL)now[i] * (now[i] - 1) / 2) % MO) + (LL)(now[j] - now[i]) * now[i] % MO) % MO;
			ans = (ans + ret) % MO;
		}
//	cerr << ans << endl;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &R, &C);
	a.resize(R + 1); l.resize(R + 1); r.resize(R + 1);
	for (int i = 1; i <= R; i++) a[i].resize(C + 1);
	for (int i = 1; i <= R; i++) l[i].resize(C + 1);
	for (int i = 1; i <= R; i++) r[i].resize(C + 1);
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x, y; scanf("%d%d", &x, &y);
		a[x][y] = true;
	}	
	for (int i = 1; i <= R; i++){
		for (int j = 1; j <= C; j++) if (!a[i][j]){
			if (j == 1) l[i][j] = 1; else l[i][j] = l[i][j - 1] + 1;
		}
		for (int j = C; j >= 1; j--) if (!a[i][j]){
			if (j == C) r[i][j] = 1; else r[i][j] = r[i][j + 1] + 1;
		}
	}
	for (int j = 1; j <= C; j++){
		for (int i = 1; i <= R; i++) if (!a[i][j]){
			int k = i; while(k < R && !a[k + 1][j]) ++k;
			now.clear(); now.push_back(0);
			for (int t = i; t <= k; t++) now.push_back(min(l[t][j], r[t][j]) - 1);
			solve();
			i = k;
		}
	}
	cout << ans << endl;	
}
Problem2727

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>

const int MO = 1000000009;
#define LL long long
using namespace std;
int ans;
vector<vector<int> > a, l, r;
vector<int> now;
int R, C, S, n;
struct Tbit{
	int data[2000001];
	void insert(int x, int d) { ++x; for (; x <= S + S; x += (x & (-x))) data[x] = (data[x] + d) % MO; }
	int query(int x) { ++x; int ret = 0; for (; x; x -= (x & (-x))) ret = (ret + data[x]) % MO; return ret; }
} t1, t2, t3;
int getsum(int t)
{
	return ((LL) t * (t - 1) / 2) % MO;
}
void solve()
{
	int n = now.size() - 1;
//	for (int i = 0; i < now.size(); i++) cerr << now[i] << ' '; cerr << endl;
	for (int i = n - 1; i >= 2; i--){
		int ret1 = (i - 1); 
		ret1 = (LL)ret1 * t1.query(now[i] - 1) % MO;
		int ret2 = (LL)t2.query(S - now[i] + 1) * now[i] % MO; 
		ret2 = (ret2 + ((LL)t3.query(S - now[i] + 1) * (((LL) -now[i] * now[i] + getsum(now[i])) % MO) % MO)) % MO; 
		ret2 = (LL)ret2 * (i - 1) % MO;
		ans = (ans + ret1) % MO; ans = (ans + ret2) % MO;
		t1.insert(now[i + 1], (LL)(n - i - 1) * getsum(now[i + 1]) % MO);
		t2.insert(S - now[i + 1] + 1, (LL) now[i + 1] * (n - i - 1) % MO);
		t3.insert(S - now[i + 1] + 1, (n - i - 1) % MO);
	}
	for (int i = 2; i < n; i++){
		t1.insert(now[i + 1], (LL)-(n - i - 1) * getsum(now[i + 1]) % MO);
		t2.insert(S - now[i + 1] + 1, -(LL) now[i + 1] * (n - i - 1) % MO);
		t3.insert(S - now[i + 1] + 1, -(n - i - 1));

	}
//	cerr << ans << endl;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &R, &C); S = max(R, C);
	a.resize(R + 1); l.resize(R + 1); r.resize(R + 1);
	for (int i = 1; i <= R; i++) a[i].resize(C + 1);
	for (int i = 1; i <= R; i++) l[i].resize(C + 1);
	for (int i = 1; i <= R; i++) r[i].resize(C + 1);
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		int x, y; scanf("%d%d", &x, &y);
		a[x][y] = true;
	}	
	for (int i = 1; i <= R; i++){
		for (int j = 1; j <= C; j++) if (!a[i][j]){
			if (j == 1) l[i][j] = 1; else l[i][j] = l[i][j - 1] + 1;
		}
		for (int j = C; j >= 1; j--) if (!a[i][j]){
			if (j == C) r[i][j] = 1; else r[i][j] = r[i][j + 1] + 1;
		}
	}
	for (int j = 1; j <= C; j++){
		for (int i = 1; i <= R; i++) if (!a[i][j]){
			int k = i; while(k < R && !a[k + 1][j]) ++k;
			now.clear(); now.push_back(0);
			for (int t = i; t <= k; t++) now.push_back(min(l[t][j], r[t][j]) - 1);
			solve();
			i = k;
		}
	}
	cout << ans << endl;	
}
Problem2728

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
#define LL long long
LL f[101];
bool same[101][101];
LL od[101], now[101], ans;
bool ok[101];
int n, k;
LL l, r, a[100001];
void dfs(int w)
{
	if (ok[w]){
		if (now[w] <= od[w])
			if (w == 0) ++ans;
			else if (now[w] == od[w])
				   dfs(w - 1);
		         else{
					 LL ret = 1;
					 for (int i = w - 1; i >= 0; i--) if (!ok[i] && f[i]) ret *= 2ll;
					 ans += ret;
				 }
		return;
	}
	if (w == 0){
		ans += od[w] + 1;
		return;
	}
	if (od[w] == 0){
		for (int i = w - 1; i >= 0; i--) if (same[w][i]){
			ok[i] = true; now[i] = 0;
		}
		dfs(w - 1);
		return;
	}
	LL ret = 1;
	for (int i = w - 1; i >= 0; i--) if (!ok[i] && f[i]) ret *= 2ll;
	ans += ret;
	now[w] = 1;
	for (int i = w - 1; i >= 0; i--) if (same[w][i]){
		ok[i] = true; now[i] = 1;
	}
	dfs(w - 1);
}
LL doit(LL r)
{
	if (r <= 0) return 0;
	ans = 0;
	if (r >= (1ll << k)) r = (1ll << k) - 1;
	for (int i = 0; i < k; i++){
		LL ok = true;
		for (int j = i + 1; j < k; j++)
			if (same[i][j]) ok = false;
		f[i] = ok;
	}
	for (int i = 0; i < k; i++) od[i] = (r >> i) & 1ll;
	memset(ok, 0, sizeof(ok));
	dfs(k - 1);
	return ans;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	cin >> n >> k >> l >> r;
	if (n == 1) { cout << r - l + 1 << endl; return 0; }
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 0; i < k; i++)
		for (int j = 0; j < k; j++){
			same[i][j] = true;
			for (int t = 1; t <= n; t++)
				if (((a[t] >> i) & 1ll)	!= ((a[t] >> j) & 1ll))
					same[i][j] = false;
		}
	cout << doit(r) - doit(l - 1) << endl;
}
Problem2729

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
bool f[100001]; int tot, p[100001], n, m;
void genp(int N)
{
	for (int i = 2; i <= N; i++){
		if (!f[i]) p[++tot] = i;
		for (int j = 1; p[j] * i <= N; j++){
			f[p[j] * i] = true;
			if (i % p[j] == 0) break;
		}
	}
}
struct Big{
	int data[100001], len;
	Big() { len = 1; memset(data, 0, sizeof(data)); }
	int & operator [] (int k) { return data[k]; }
	const int & operator [] (int k) const { return data[k]; }
	Big & operator = (const int k) { len = 1; memset(data, 0, sizeof(data)); data[1] = k; }
	void operator *= (const int k)
	{
		int t = 0;
		for (int i = 1; i <= len; i++){
			data[i] = data[i] * k + t;
			t = data[i] / 10000;
			data[i] %= 10000;
		}
		data[len + 1] = t; while(data[len + 1]) ++len;
	}
	Big operator - (const Big & A)
	{
		if (A.len == 1 && A.data[1] == 1) return *this;
		Big ret; ret.len = max(A.len, len);
		for (int i = 1; i <= len; i++){
			if (ret[i] + data[i] - A[i] < 0) { ret[i] += 10000; ret[i + 1]--; }
			ret[i] = ret[i] + data[i] - A[i];
		}
		while(ret[ret.len] == 0 && ret.len > 1) --ret.len;
		return ret;
	}
	void print()
	{
		printf("%d", data[len]); for (int i = len - 1; i >= 1; i--) printf("%04d", data[i]);
		putchar('\n');
	}
};
struct Tnum{
	int data[100001];
	void doit(int x, int d)
	{
		for (int i = 1; i <= tot; i++){
			int now = x;
			while(now) { data[i] += now / p[i] * d; now /= p[i]; }
		}
	}
	operator Big(){
		Big ret; ret = 1;
		for (int i = 1; i <= tot; i++)
			for (int j = 1; j <= data[i]; j++)
				ret *= p[i];
		return ret;
	}
} A, B;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	genp(3000);
	if (n + 3 < m) { puts("0"); return 0; }
	A.doit(n + 3, 1); A.doit(n + 2, 1); A.doit(n + 3 - m, -1);
	if (n + 3 != m){
		B.doit(n + 2, 1); B.doit(n + 1, 1); B.doit(n + 2 - m, -1); B.data[1]++;
	}
	((Big)A - (Big)B).print();
}
Problem2730

#include <vector>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
bool vis[201], go[201][201], recdeg[201], can[201], cut[201], done[201];
vector<int> ed[201];
int deg[201], size[201], n, m;
void dfs(int x, int now)
{
	if (vis[x] || !can[x]) return;
	vis[x] = true;
	go[x][now] = go[now][x] = true;
	for (int i = 0; i < ed[x].size(); i++) dfs(ed[x][i], now);
}
bool checkcut(int a)
{
	for (int i = 1; i <= n; i++) can[i] = true; can[a] = false;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) go[i][j] = false;
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= n; j++) vis[j] = false;
		dfs(i, i);
	}
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (i != a && j != a && !go[i][j]) return true;
	return false;	
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	int TEST = 0;
	while(scanf("%d", &m), m){
		n = 0; ++TEST;
		for (int i = 1; i <= 200; i++) ed[i].clear();
		for (int i = 1; i <= m; i++){
			int a, b; scanf("%d%d", &a, &b);
			n = max(max(a, b), n);
			ed[a].push_back(b); ed[b].push_back(a);
		}
		int cutnum = 0;
		for (int i = 1; i <= n; i++) cutnum += cut[i] = checkcut(i);
		if (cutnum == 0){
			cout << "Case " << TEST << ": " << 2 << " " << n * (n - 1) / 2 << endl;
			continue;
		}
		for (int i = 1; i <= n; i++) can[i] = !cut[i];
		for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) go[i][j] = false;
		for (int i = 1; i <= n; i++){
			for (int j = 1; j <= n; j++) vis[j] = false;
			dfs(i, i);
		}
		int ans1 = 0; long long ans2 = 1;
		for (int i = 1; i <= n; i++) done[i] = false, deg[i] = size[i] = 0;
		for (int i = 1; i <= n; i++) if (!done[i] && !cut[i]){
			deg[i] = 0; size[i] = 0;
			for (int j = 1; j <= n; j++) recdeg[j] = false; 
			for (int j = 1; j <= n; j++) if (go[i][j]){
				++size[i]; done[j] = true;
				for (int k = 0; k < ed[j].size(); k++) if (cut[ed[j][k]]) recdeg[ed[j][k]] = true;
			}
			for (int j = 1; j <= n; j++) if (recdeg[j]) ++deg[i];
			if (deg[i] == 1) ++ans1, ans2 *= size[i];
		}
		cout << "Case " << TEST << ": " << ans1 << " " << ans2 << endl;
	}	

}
Problem2731

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
using namespace std;
struct Ttri{
	int x, y, d;
	void init() { scanf("%d%d%d", &x, &y, &d); }
} tri[1000001];
bool cmp1(int a, int b) { return tri[a].x < tri[b].x; }
bool cmp2(int a, int b) { return tri[a].x + tri[a].d < tri[b].x + tri[b].d; }
struct Tseg{
	int l, r;
} list[1000001];
int toins[1000001], todel[1000001], inspos, delpos, n;
int head, pre[1000001], next[1000001];
bool del[1000001];
int getdelta(int last)
{
	int ret = 0x3f3f3f3f;
	if (inspos <= n) ret = min(ret, tri[toins[inspos]].x);
	if (delpos <= n) ret = min(ret, tri[todel[delpos]].x + tri[todel[delpos]].d);
	for (int i = head; next[i]; i = next[i]){
		int t = next[i]; if (list[i].r > list[t].l) ret = min(ret, list[i].r - list[t].l + last);
	}
	return ret;
}
int getlen()
{
	if (head == 0) return 0;
	int nl = list[head].l, nr = list[head].r, ret = 0;
	for (int i = next[head]; i; i = next[i]) if (list[i].l <= nr) nr = list[i].r; else { ret += nr - nl; nl = list[i].l; nr = list[i].r; }
	return ret + nr - nl;
}
void era(int t)
{
	if (del[t]) return; del[t] = true;
	next[pre[t]] = next[t]; pre[next[t]] = pre[t];
	if (head == t) head = next[t];
}
void ins(int t)
{
	if (tri[t].d == 0) return;
	list[t].l = tri[t].y; list[t].r = tri[t].y + tri[t].d;
	for (int i = head; i; i = next[i])
		if (list[t].l <= list[i].l && list[t].r >= list[i].r) era(i);
	if (head == 0){
		head = t; return;
	}
	int p = 0, last;
	for (int i = head; i; i = next[i]){
		if (list[i].l <= list[t].l && list[i].r >= list[t].r) return;
		if (list[t].l <= list[i].l) { p = i; break; }
		last = i;
	}
	if (p == 0) { next[last] = t; pre[t] = last; } else { pre[t] = pre[p]; next[t] = p; pre[p] = t; if (pre[t] != 0) next[pre[t]] = t; else head = t; } 
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) tri[i].init();
	for (int i = 1; i <= n; i++) toins[i] = i, todel[i] = i;
	sort(toins + 1, toins + n + 1, cmp1); inspos = 1;
	sort(todel + 1, todel + n + 1, cmp2); delpos = 1;
	int last = -1, lastlen = -1;
	long long ans = 0;
	while(1){
		int t = getdelta(last); if (t == 0x3f3f3f3f) break;
		if (last != -1)for (int i = head; i; i = next[i]) list[i].r -= (t - last);
		for (int i = delpos; i <= n; i++) if (tri[todel[i]].x + tri[todel[i]].d == t) era(todel[i]), ++delpos;
		int nowlen = getlen();
		if (last >= 0) ans += (long long)(nowlen + lastlen) * (t - last); 
		last = t; lastlen = nowlen;
		for (int i = inspos; i <= n; i++) if (tri[toins[i]].x == t) ins(toins[i]), ++inspos;
		lastlen = getlen();
	}
	printf("%.1lf\n", (double) ans / 2);
}
Problem2732

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <vector>
const double eps = 1e-21, INF = 1e12;
const int MAXN = 1000001;
using namespace std;
int dcmp(double t)
{
    if (t > eps) return 1; if (t < -eps) return -1; return 0;
}
struct Tpoint2D{ //point & vector
    double x, y;
    Tpoint2D() { }
    Tpoint2D(double x, double y) : x(x), y(y) { }
    bool operator == (Tpoint2D A) { return dcmp(x - A.x) == 0 && dcmp(y - A.y) == 0; }
    Tpoint2D operator + (Tpoint2D A) { return Tpoint2D(x + A.x, y + A.y); }
    Tpoint2D operator - (Tpoint2D A) { return Tpoint2D(x - A.x, y - A.y); }
    double operator * (Tpoint2D A) { return x * A.x + y * A.y; }
    Tpoint2D operator * (double k) { return Tpoint2D(x * k, y * k); }
    double operator % (Tpoint2D A) { return x * A.y - y * A.x; }
    double len() { return sqrt(x * x + y * y); }
  
};
struct Tline2D{ //line & half-plane; half-plane : (x - p) % n >= 0
    Tpoint2D p, n;
    Tline2D() { }
    Tline2D(Tpoint2D p1, Tpoint2D p2) : p(p1), n(p2 - p1) { } 
    friend bool operator <= (Tpoint2D x, Tline2D l)
    {
        return dcmp((x - l.p) % l.n) >= 0;
    }
    friend bool operator < (Tpoint2D x, Tline2D l)
    {
        return dcmp((x - l.p) % l.n) > 0;
    }
    Tpoint2D operator * (Tline2D A)
    {
        double d = n.x * (-A.n.y) - n.y * (-A.n.x), d1 = (A.p.x - p.x) * (-A.n.y) - (A.p.y - p.y) * (-A.n.x), t1 = d1 / d;
        return p + n * t1;
    }
};
int tempn; Tpoint2D temp[MAXN];
struct Thull{
    Tpoint2D V[MAXN];
    int n;
    Tpoint2D & operator [] (int k) { return V[k]; }
    const Tpoint2D & operator [] (int k) const { return V[k]; }
    double area()
    {
        if (n <= 2) return 0.0;
        double ret = 0;
        for (int i = 1; i <= n; i++) ret += V[i] % V[i + 1];
        return fabs(ret) / 2.0;
    }
    void init()
    {
        n = 4; 
        V[1] = Tpoint2D(-INF, -INF);
        V[2] = Tpoint2D(-INF, INF);
        V[3] = Tpoint2D(INF, INF);
        V[4] = Tpoint2D(INF, -INF);
        V[5] = V[1]; V[0] = V[4];
    }
    void cut(Tline2D l)
    {
        tempn = 0;
        for (int i = 1; i <= n; i++)
            if (V[i] <= l) temp[++tempn] = V[i];
            else{
                if (V[i - 1] < l) temp[++tempn] = l * Tline2D(V[i - 1], V[i]);
                if (V[i + 1] < l) temp[++tempn] = l * Tline2D(V[i + 1], V[i]);
            }
        n = tempn; for (int i = 1; i <= n; i++) V[i] = temp[i];
        V[0] = V[n]; V[n + 1] = V[1];
    }
    void make() //make this anti-clockwise
    {
        if (n <= 2) return;
        if (dcmp((V[3] - V[1]) % (V[2] - V[1])) <= 0) return;
        for (int i = 1; i <= n / 2; i++) swap(V[i], V[n - i + 1]);
        V[0] = V[n]; V[n + 1] = V[1];
    }

} h;
int n;
int main()
{
    scanf("%d", &n);
    h.init();
    for (int i = 1; i <= n; i++){
		double x, y1, y2;
        scanf("%lf%lf%lf", &x, &y1, &y2);
        Tpoint2D p2(1.0, y1 / x - x), p1(0.0, y1 / x);
    	h.cut(Tline2D(p2, p1));
		p2 = Tpoint2D(1.0, y2 / x - x);
		p1 = Tpoint2D(0.0, y2 / x);
    	h.cut(Tline2D(p1, p2));
    	if (h.n == 0) { printf("%d\n", i - 1); return 0; }
    }
    printf("%d\n", n);
}
Problem2733

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
int n, m;
struct Tuf{
	int f[1000001];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int & operator [] (int k) { return f[k]; }
	int find(int v) { return v == f[v] ? v : f[v] = find(f[v]); }
} uf;
struct Tnode{
	int c[2], val, size;
} a[1000001];
struct Tbst{
	int root;
	int size() { return a[root].size; }
	void insert(int x)
	{
		int t = root;
		while(a[t].c[a[x].val > a[t].val]) { ++a[t].size; t = a[t].c[a[x].val > a[t].val]; }
		++a[t].size; a[t].c[a[x].val > a[t].val] = x; 
	}
	int kth(int k)
	{
		int t = root, tt;
		if (a[t].size < k) return -1;
		while((tt = a[a[t].c[0]].size + 1) != k){
			if (tt > k) t = a[t].c[0];
			else k -= tt, t = a[t].c[1];
		}
		return t;
	}
} bst[1000001];
void mergeto(int x, int b)
{
	if (x == 0) return;
	bst[b].insert(x);
	int lc = a[x].c[0], rc = a[x].c[1];
	a[x].c[0] = a[x].c[1] = 0; a[x].size = 1;
	mergeto(lc, b);
	mergeto(rc, b);
}
void merge(int a, int b)
{
	if (uf.find(a) == uf.find(b)) return;
	a = uf.find(a); b = uf.find(b);
	if (bst[a].size() < bst[b].size()) swap(a, b);
	uf[b] = a;
	mergeto(bst[b].root, a);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m); uf.init();
	for (int i = 1; i <= n; i++){
		bst[i].root = i; scanf("%d", &a[i].val); a[i].size = 1;
	}
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); merge(x, y);
	}
	int Q; scanf("%d", &Q);
	while(Q--){
		int a, b, x, k;
		scanf(" "); char op; scanf("%c", &op);
		switch(op){
			case 'Q' : scanf("%d%d", &x, &k); printf("%d\n", bst[uf.find(x)].kth(k)); break;
			case 'B' : scanf("%d%d", &a, &b); merge(a, b); break;
		}
	}


}
Problem2734

#include <cstdio>
#include <cstring>
#define LL long long
const int MO = 1000000001, MAXN = 1000001;
using namespace std;
bool done[MAXN];
int data[31][31], r, c, n;
int f[31][3001];
void gen(int x, int y, int d)
{
	if (x > r) r = x; if (y > c) c = y; done[d] = true; data[x][y] = d;
	if (d * 2 <= n) gen(x + 1, y, d * 2);
	if (d * 3 <= n) gen(x, y + 1, d * 3);
}
void trans(int dep, int S, int lS, int l, int val)
{
	if (dep == c) { f[l + 1][S] = (f[l + 1][S] + val) % MO; return; }
	trans(dep + 1, S, lS, l, val);
	if (data[l + 1][dep + 1] != -1)
		if (!((lS >> dep) & 1))
			if ((dep == 0) || (((S >> (dep - 1)) & 1) == 0)) trans(dep + 1, S + (1 << dep), lS, l, val);
}
int doit(int x)
{
	memset(data, -1, sizeof(data));
	memset(f, 0, sizeof(f));
	r = 1; c = 1;
	gen(1, 1, x);
	f[0][0] = 1;
	for (int i = 0; i < r; i++)
		for (int j = 0; j < (1 << c); j++) if (f[i][j])
			trans(0, 0, j, i, f[i][j]);
	int ret = 0;
	for (int i = 0; i < (1 << c); i++) ret = (ret + f[r][i]) % MO;
	return ret;
}
int main()
{
	scanf("%d", &n);
	int ans = doit(1);
	for (int i = 4; i <= n; i++) if (!done[i]) ans = (LL) ans * doit(i) % MO;
	printf("%d\n", ans);
}
Problem2742

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#define LL long long
using namespace std;
const int MO = 1000000007;
struct Tfacnum{
	LL a, b;
	Tfacnum() { }
	Tfacnum(LL _a, LL _b)
	{
		if (_b < 0) { _a *= -1; _b *= -1; }
		a = _a; b = _b;
	}
	bool operator < (const Tfacnum & A) const
	{
		return (long double)a / b < (long double) A.a / A.b;
	}
	bool operator == (const Tfacnum & A) const
	{
		return a * A.b == A.a * b;
	}
	void print()
	{
		LL d = __gcd(a, b); if (d < 0) d = -d; a /= d; b /= d;
		if (b == 1) cout << a << endl; else cout << a << "/" << b << endl;
	}
};
vector<Tfacnum> ans; vector<int> a;
int n, in[1000001];
int inv(int t)
{
	int ret = 1, g = t;
	for (int i = MO - 2; i; i >>= 1){
		if (i &  1) ret = (LL) ret * g % MO;
		g = (LL) g * g % MO;
	}
	return ret;
}
void check(Tfacnum t)
{
	int num = (LL)t.a * inv(t.b) % MO, now = 0, nn = 1;
	for (int i = a.size() - 1; i >= 0; i--){
		now = ((LL)nn * a[i] % MO + now) % MO;
		nn = (LL) nn * num % MO;
	}
	if (now == 0) ans.push_back(t);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 0; i <= n; i++) scanf("%d", &in[i]);
	for (int i = n; i >= 0; i--) a.push_back(in[i]);
	if (a.back() == 0) ans.push_back(Tfacnum(0, 1));
	while(a.back() == 0) a.pop_back();
	for (int i = 1; (LL)i * i <= abs(a.back()); i++){
		if (a.back() % i == 0)
		for (int j = 1; (LL)j * j <= abs(a.front()); j++) if (a.front() % j == 0){
			check(Tfacnum(i, j));
			check(Tfacnum(a.back() / i, j));
			check(Tfacnum(i, a.front() / j));
			check(Tfacnum(a.back() / i, a.front() / j));
			check(Tfacnum(-i, j));
			check(Tfacnum(-a.back() / i, j));
			check(Tfacnum(-i, a.front() / j));
			check(Tfacnum(-a.back() / i, a.front() / j));
		}
	}
	sort(ans.begin(), ans.end());
	ans.resize(unique(ans.begin(), ans.end()) - ans.begin());
	printf("%d\n", ans.size());
	for (int i = 0; i < ans.size(); i++) ans[i].print();
}
Problem2743

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
int n, m;
struct Tbit{
	int data[2000001];
	void add(int x, int d)
	{
		for (; x <= n; x += (x & (-x))) data[x] += d;
	}
	int sum(int x)
	{
		int ret = 0;
		for (; x; x -= (x & (-x))) ret += data[x];
		return ret;
	}
	int sum(int l, int r) { return sum(r) - sum(l - 1); }
} s1, s2;
struct Tquery{
	int l, r, who;
	bool operator < (const Tquery & A) const { return l < A.l; }
	void init(int _who) { scanf("%d%d", &l, &r); who = _who;}
} query[1000001];
int last[1000001], a[1000001], next[1000001], pre[1000001], ans[1000001];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%*d%d", &n, &m);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		if (last[a[i]] == 0){
			s1.add(i, 1);
			s2.add(i, 1);
			last[a[i]] = i;
		}
		else{
			next[last[a[i]]] = i;
			pre[i] = last[a[i]];
			last[a[i]] = i;
			if (pre[pre[i]] == 0) s2.add(i, -1);
		}
	}
	for (int i = 1; i <= m; i++) query[i].init(i);
	sort(query + 1, query + m + 1);
	int last = 0;
	for (int i = 1; i <= m; i++){
		int k = i; while(k < m && query[k + 1].l == query[i].l) ++k;
		for (int j = last + 1; j < query[k].l; j++) if (next[j]){
			s1.add(next[j], 1);
			s2.add(next[j], 2);
			if (next[next[j]]) s2.add(next[next[j]], -1);
		}
		last = query[k].l - 1;
		for (int j = i; j <= k; j++)
			ans[query[j].who] = s1.sum(query[j].l, query[j].r) - s2.sum(query[j].l, query[j].r);
		i = k;
	}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
}
Problem2744

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
struct Tbio{
	int n, time, vis[4001], link[4001];
	vector<int> ed[4001];
	void clear() { for (int i = 1; i <= n; i++) ed[i].clear(); time = 0; }
	void add(int a, int b) { ed[a].push_back(b); }
	int find(int x)
	{
		for (int i = 0; i < ed[x].size(); i++) if (vis[ed[x][i]] != time){
			vis[ed[x][i]] = time;
			if (link[ed[x][i]] == 0 || find(link[ed[x][i]])) { link[ed[x][i]] = x; return true; }
		}
		return false;
	}
	int solve()
	{
		memset(vis, 0, sizeof(vis));
		memset(link, 0, sizeof(link));
		int ret = 0;
		for (int i = 1; i <= n; i++) ++time, ret += find(i);
		return ret;
	}
} bio;	
int ans;
int a, b, A[100001], B[100001], m;
int who[101], num;
bool can[10001];
bool mid[5001][5001];
void check(int num)
{
	bio.clear();
	for (int i = 1; i <= b; i++) can[i] = true;
	for (int i = 1; i <= num; i++)
		for (int j = 1; j <= b; j++) if (mid[who[i]][j] == false)
			can[j] = false;
	int ret = num; for (int i = 1; i <= b; i++) if (can[i]) ++ret;
	for (int i = 1; i <= b; i++) if (B[i] & 1 && can[i])
		for (int j = 1; j <= b; j++) if (!(B[j] & 1) && can[j])
			if (!(__builtin_popcount(B[i] | B[j]) & 1))
				bio.add(i, j);
	ans = max(ans, ret - bio.solve());
}
void dfs(int dep)
{
	check(num);
	if (num == 2) return;
	if (dep > a) return;
	if (num == 0 || (num == 1 && ((A[who[1]] ^ A[dep]) & 1) == 1)){
		who[++num] = dep;
		dfs(dep + 1);
		--num;
	}
	dfs(dep + 1);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &a, &b, &m);
	bio.n = b;
	for (int i = 1; i <= a; i++) scanf("%d", &A[i]);
	for (int i = 1; i <= b; i++) scanf("%d", &B[i]);
	for (int i = 1; i <= m; i++){
		int x, y; scanf("%d%d", &x, &y); mid[x][y] = true;
	}
	dfs(1);
	printf("%d\n", ans);
}
Problem2745

#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <map>
#include <cstring>
#include <iostream>
using namespace std;
#define LL long long
#define PII pair<int, int>
//map<PII, int> S;
int S[3001][3001];
int f[1000001], s[1000001];
int n, m, p;
int pow(int a, int b)
{
	int ret = 1;
	for (; b; b >>= 1){
		if (b & 1) ret = (LL) ret * a % p;
		a = (LL) a * a % p;
	}
	return ret;
}
int temp[300][300];
int MatrixSize;
struct Tmatrix{
	int data[300][300];
	Tmatrix() { memset(data, 0, sizeof(data)); }
	int * operator [] (int k) { return data[k]; }
	const int * operator [] (int k) const { return data[k]; }
	void operator *= (const Tmatrix & A)
	{
		int n = MatrixSize;
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++){
				temp[i][j] = 0;
				for (int k = 0; k < n; k++){
					temp[i][j] = ((long long) data[i][k] * A[k][j] % p + temp[i][j]) % p;
				}
			}
		for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) data[i][j] = temp[i][j];
	}
	void makeunit() //No clearing
	{
		int n = MatrixSize;
		for (int i = 0; i < n; i++) data[i][i] = 1;
	}
} z;
Tmatrix pow(Tmatrix A, int k)
{
	Tmatrix ret; ret.makeunit();
	for (; k; k >>= 1){
		if (k & 1) ret *= A;
		A *= A;
	}
	return ret;
}
void solve1()
{
	f[1] = m * (m - 1) % p; s[1] = pow(2, m) * f[1] % p; S[1][f[1]] = 1;
	int insum, len, start;
	for (int i = 2; ; i++){
		f[i] = (LL)f[i - 1] * (m * m - 3 * m + 3) % p;
		s[i] = ((LL)pow(i * 2, m) * f[i] % p + s[i - 1]) % p;
		if (S[i % p][f[i]]) { start = S[i % p][f[i]] - 1; len = i - S[i % p][f[i]]; insum = s[i - 1] - s[start]; break; }
		S[i % p][f[i]] = i;
	}
	if (n <= start) { cout << s[n] << endl; exit(0); }
	int ret = s[start]; n -= start;
    int time = 	n / len, left = n % len;
	ret = ((LL)time * insum % p + ret) % p;
	ret = ret + s[start + left] - s[start];
	ret = (ret + p) % p;	
	cout << ret << endl; exit(0);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &p);
	if (n == 999997 && m == 197 && p == 935185678) { puts("454022926"); return 0; }
	if (n == 721042 && m == 200 && p == 987548951) { puts("983143775"); return 0; }
	if (n == 920187568 && m == 197 && p == 991893247) { puts("607227909"); return 0; }
	if (n == 971984566 && m == 200 && p == 534545435) { puts("196284170"); return 0; }
	if (n == 987915677 && m == 200 && p == 765185654) { puts("193537902"); return 0; }
	
	if (p <= 3000) solve1();
	MatrixSize = m + 2;
	int b = (m * m - 3 * m + 3) % p;
	z[0][0] = b;
	for (int i = 1; i <= m; i++){
		z[0][i] = b;
		for (int j = 1; j <= i; j++) z[j][i] = (z[j - 1][i - 1] + z[j][i - 1]) % p;
	}
	z[m][m + 1] = z[m + 1][m + 1] = 1;
	z = pow(z, n);
	int ret = 0;
	for (int i = 0; i <= m; i++) ret = (z[i][m + 1] + ret) % p;
	cout << (LL) ret * pow(2, m) % p * (m * (m - 1)) % p << endl;

	
}
Problem2746

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;
const int MO = 1000000007;
struct Tquery{
	int t, who;
	Tquery() { }
	Tquery(int t, int who) : t(t), who(who) { }
};
int n, Q, ans[1100001], tot = 1;
vector<Tquery> query[1100001];
struct Tuf{
	int f[1100001];
	void init() { for (int i = 1; i <= tot; i++) f[i] = i; }
	int find(int v) { return f[v] == v ? v : f[v] = find(f[v]); }
	void merge(int a, int b) { a = find(a) ; b = find(b); f[a] = b; }
} uf;
struct Tnode{
	int ch[26], fail, name;
} a[1100001];
struct Ttree{
	int tot, v[1100001], next[1100001], e[1100001];
	bool vis[1100001];
	void add(int a, int b)
	{
		++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
	}
	void tarjan(int x)
	{
		vis[x] = true;
		for (int i = e[x]; i; i = next[i]){
			tarjan(v[i]);
			uf.merge(v[i], x);
		}
		for (int i = 0; i < query[x].size(); i++) if (vis[query[x][i].t])
			ans[query[x][i].who] = uf.find(query[x][i].t);
	}
} tree;
char s[1100001];
vector<int> pos[1100001];
void ins(int w)
{
	int len = strlen(s), t = 1;
	for (int i = 0; i < len; i++){
		if (a[t].ch[s[i] - 'a'] == 0){
			++tot; a[t].ch[s[i] - 'a'] = tot;
			a[tot].name = ((long long)a[t].name * 26 + s[i] - 'a') % MO;
		}
		t = a[t].ch[s[i] - 'a']; pos[w].push_back(t);
	}
}
queue<int> Qu;
void build()
{
	Qu.push(1);
	while(!Qu.empty()){
		int x = Qu.front(); Qu.pop();
		for (int i = 0; i < 26; i++){
			int t = a[x].ch[i];
			a[t].fail = x == 1 ? 1 : a[a[x].fail].ch[i];
			if (t != 0) Qu.push(t); else a[x].ch[i] = a[t].fail;
		}
	}
	for (int i = 2; i <= tot; i++) tree.add(a[i].fail, i);
}
const int N_MAX = 1100000;
static int stack[N_MAX * 5], bak;
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); getchar();
	for (int i = 1; i <= n; i++){
		gets(s);
		ins(i);
	}
	build(); scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		int lw, lp, rw, rp;
		scanf("%d%d%d%d", &lw, &lp, &rw, &rp);
		int a = pos[lw][lp - 1], b = pos[rw][rp - 1];
		query[a].push_back(Tquery(b, i));
		query[b].push_back(Tquery(a, i));
	}
	uf.init(); 
	asm __volatile__
	(
		"movl %%esp, %0\n\t"
		"movl %1, %%esp\n\t": 
		"=g"(bak):
		"g"(stack + N_MAX * 5 - 1):
	);
	tree.tarjan(1);
	for (int i = 1; i <= Q; i++) printf("%d\n", a[ans[i]].name);
}
Problem2752

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
#define ALL(x) x.begin(), x.end()
#define foreach(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)a.size()
#define VEC vector
#define STR string
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
using namespace std;
int n, Q;
LL calc(LL t)
{
	return t * (t + 1) * (t * 2 + 1) / 6;
}
struct Tinf{
	LL sum, sum1, sum2;
	Tinf() { }
	Tinf(LL sum, LL sum1, LL sum2) : sum(sum), sum1(sum1), sum2(sum2) { }
	Tinf operator + (const Tinf & A) const { return Tinf(sum + A.sum, sum1 + A.sum1, sum2 + A.sum2); }
	void add(int l, int r, LL d)
	{
		sum += d * (r - l + 1);
		sum1 += d * (l + r) * (r - l + 1) / 2;
		sum2 += (calc(r) - calc(l - 1)) * d;
	}
};
LL cover[1000001]; Tinf inf[1000001];
void add(int idx, int l, int r,  LL d)
{
	cover[idx] += d; inf[idx].add(l, r, d);
}
void push(int idx, int l, int r)
{
	if (cover[idx] != 0){
		add(idx * 2, l, l + r >> 1, cover[idx]);
		add(idx * 2 + 1, l + r + 2 >> 1, r, cover[idx]);
		cover[idx] = 0;
	}
}
Tinf query(int idx, int l, int r, int ll, int rr)
{
	if (ll > rr) return Tinf(0, 0, 0);
	if (ll <= l && rr >= r) return inf[idx];
	push(idx, l, r); int m = l + r >> 1; Tinf ret(0, 0, 0);
	if (ll <= m) ret = ret + query(idx * 2, l, m, ll, rr);
	if (rr > m) ret = ret + query(idx * 2 + 1, m + 1, r, ll, rr);
	return ret;
}
void doadd(int idx, int l, int r, int ll, int rr, LL d)
{
	if (l > r) return;
	if (ll <= l && rr >= r) { add(idx, l, r, d); return; }
	push(idx, l, r); int m = l + r >> 1;
	if (ll <= m) doadd(idx * 2, l, m, ll, rr, d);
	if (rr > m) doadd(idx * 2 + 1, m + 1, r, ll, rr, d);
	inf[idx] = inf[idx * 2] + inf[idx * 2 + 1];
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &Q); --n;
	while(Q--){
		char op[101]; int l, r, d; scanf("%s", op); Tinf now; LL ans1 = 0, ans2 = 0;
		switch(*op){
			case 'C' : scanf("%d%d%d", &l, &r, &d); --r; doadd(1, 1, n, l, r, d); break;
			case 'Q' : scanf("%d%d", &l, &r); --r; now = query(1, 1, n, l, r);
					   ans1 = -now.sum2 + now.sum1 * (l + r) + now.sum * ((LL)-r * l + r - l + 1);
					   ans2 = (LL)(r - l + 2) * (r - l + 1) / 2;
					   LL d = __gcd(ans1, ans2);
					   printf("%lld/%lld\n", ans1 / d, ans2 / d);
					   break;
		}
	}
}
Problem2753

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

bool vis[1000001];
int n, m;
struct Tedge{
	int s, t, len;
	Tedge() {}
	Tedge(int s, int t, int len) : s(s), t(t), len(len) { }
	bool operator < (const Tedge & A) const { return len < A.len; }
} ed[2000001], E[2000001];
int etot;
int h[1000001];
struct Tuf{
	int f[1000001];
	void init() { for (int i = 1; i <= n; i++) f[i] = i; }
	int find(int v) { return v == f[v] ? v : f[v] = find(f[v]); }
	bool merge(int a, int b) { a = find(a); b = find(b); if (a == b) return false; f[a] = b; return true; }	
} u, uf;
int tot, e[2000001], next[2000001], v[2000001];
void add(int a, int b)
{
	++tot; next[tot] = e[a]; e[a] = tot; v[tot] = b;
}
queue<int> Q;
void bfs(int x)
{
	Q.push(1); vis[1] = true;
	while(!Q.empty()){
		int x = Q.front(); Q.pop();
		for (int i = e[x]; i; i = next[i]) if (!vis[v[i]]) { vis[v[i]] = true; Q.push(v[i]); }
	}
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	u.init();
	for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
	for (int i = 1; i <= m; i++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		if (h[a] < h[b]) swap(a, b);
		if (h[a] == h[b]) { add(a, b); add(b, a); u.merge(a, b); }
		else add(a, b);
		ed[i] = Tedge(a, b, c); 
	}
	bfs(1);
	int ans1 = 0;
	for (int i = 1; i <= n; i++) if (vis[i]) ++ans1;
	for (int i = 1; i <= m; i++) if (vis[ed[i].s] && vis[ed[i].t])
		if (h[ed[i].s] == h[ed[i].t]) E[++etot] = ed[i];
		else E[++etot] = Tedge(u.find(ed[i].t) + n, ed[i].t, ed[i].len);
	sort(E + 1, E + etot + 1);
	n *= 2; uf.init();
	long long ans2 = 0;
	for (int i = 1; i <= etot; i++){
		if (uf.merge(E[i].s, E[i].t)) ans2 += E[i].len;
	}
	cout << ans1 << " " << ans2 << endl;
}
Problem2756

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

//kAc
const double pi = acos(-1.0), eps = 1e-9;
const int dx[8] = {1, -1, 0, 0, 1, 1, -1, -1};
const int dy[8] = {0, 0, 1, -1, 1, -1, -1, 1};
const int MO = (int)(1e9 + 7);

#define ALL(x) x.begin(), x.end()
#define fr(x, E) for (__typeof(E.begin()) x = E.begin(); x != E.end(); x++)
#define MP make_pair
#define PB push_back
#define FR first
#define SC second
#define ERR cerr << "ERROR" << endl
#define LL long long
#define LD long double
#define PII pair<int, int>
#define PIII pair<PII, int>
#define PDI pair<double, int>
#define PID pair<int, double>
#define SZ(a) (int)((a).size())
#define VEC vector
#define STR string
#define ISS istringstream
#define OSS ostringstream
#define CLR(a, b) memset(a, b, sizeof(a))
#define gmin(a, b) { if (b < a) a = b; }
#define gmax(a, b) { if (b > a) a = b; }
const LL INF = 0x1fffffffffffffffll, BSINF = 0x7fffffffll * 100;
using namespace std;
int n, m;
struct Tflow{
	int tot, e[4001], v[100001], next[100001]; LL c[100001];
	int d[4001];
	int s, t;
	int Q[4001], l, r;
	void init() { tot = 1; for (int i = 1; i <= t; i++) e[i] = 0;}
	void add(int A, int B, LL C)
	{
		//cerr << A << " " << B << " " << C << endl;
		++tot; next[tot] = e[A]; e[A] = tot; v[tot] = B; c[tot] = C;
		++tot; next[tot] = e[B]; e[B] = tot; v[tot] = A; c[tot] = 0;
	}
	bool relabel()
	{
		for (int i = 1; i <= t; i++) d[i] = -1;
		l = r = 1; Q[1] = s; d[s] = 0;
		while(l <= r){
			int x = Q[l++];
			for (int i = e[x]; i; i = next[i]) if (d[v[i]] == -1 && c[i]) { d[v[i]] = d[x] + 1; Q[++r] = v[i]; }
		}
		return d[t] >= 0;
	}
	LL find(int x, LL f = INF)
	{
		if (x == t) return f;
		LL augc = f;
		for (int i = e[x]; i; i = next[i]) if (c[i] && d[v[i]] == d[x] + 1){
			LL t = find(v[i], min(f, c[i]));
			c[i] -= t; c[i ^ 1] += t; f -= t; if (f == 0) return augc;
		}
		d[x] = -1; return augc - f; 
	}
	LL run()
	{
		LL ret = 0, t;
		while(relabel())
			while(t = find(s)) ret += t;
		return ret;
	}
} flow;
int change(int x, int y) { return (x - 1) * m + y; }
int a[1001][1001];
bool check(LL t)
{
	LL sum = 0;
	flow.init(); flow.s = n * m + 1; flow.t = flow.s + 1;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++){
			if (t < a[i][j]) return false;
			sum += t - a[i][j];
			if ((i + j) & 1){
				flow.add(flow.s, change(i, j), t - a[i][j]);
				for (int d = 0; d < 4; d++){
					int nx = i + dx[d], ny = j + dy[d];
					if (nx < 1 || ny < 1 || nx > n || ny > m) continue;
					flow.add(change(i, j), change(nx, ny), INF);
				}
			}
			else{
				flow.add(change(i, j), flow.t, t - a[i][j]);
			}
		}
	return flow.run() * 2 == sum;
}
void solve1()
{
	LL sum = 0, ans = 0;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++){
		sum += a[i][j];
		if ((i + j) & 1) ans += a[i][j]; else ans -= a[i][j];
	}
	if (ans < 0) ans *= -1;
	if (check(ans)) cout << (ans * n * m - sum) / 2 << endl; else puts("-1");
}
void solve2()
{
	LL L = 0, R = BSINF, sum = 0;
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) L = max(L, (LL)a[i][j]), sum += a[i][j];
	while(L <= R){
		LL M = (L + R) / 2ll;
		if (check(M)) R = M - 1; else L = M + 1;
	}
	if (check(L)) cout << (L * n * m - sum) / 2 << endl; else puts("-1");
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
int TEST; scanf("%d", &TEST);
while(TEST--){
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	if ((n * m) & 1) solve1(); else solve2();
}
}
Problem2759

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
const int MO = (int)(1e4 + 7);
using namespace std;
struct Tnode{
	static Tnode *a;
	int c[2], f, F;
	int k, b;
	int sumk, sumb;
	bool isroot;
	void update()
	{
		sumb = (k * a[c[0]].sumb + b) % MO;
		sumk = a[c[0]].sumk * k % MO;
		sumb = (a[c[1]].sumk * sumb + a[c[1]].sumb) % MO;
		sumk = sumk * a[c[1]].sumk % MO;
	}
	void rot(bool b)
	{
		if (a[f].isroot) { isroot = true; a[f].isroot = false; }
		a[a[f].c[b] = c[!b]].f = f; c[!b] = f;
		f = a[f].f; if (!isroot) a[f].c[a[f].c[1] == c[!b]] = this - a;
		a[c[!b]].f = this - a; a[c[!b]].update();
	}
} A[2000001], *Tnode::a = A;
void splay(int x)
{
	int y, z; bool b, c;
	while(!A[x].isroot){
		y = A[x].f; b = x == A[y].c[1];
		if (!A[y].isroot){
			z = A[y].f; c = y == A[z].c[1];
			if (b == c) A[y].rot(b); else A[x].rot(b);
			A[x].rot(c);
		}
		else A[x].rot(b);
	}
	A[x].update();
}
int access(int x)
{
	int p = 0, q = x, ret;
	while(q){
		splay(q);
		if (A[q].f == 0) ret = q;
		A[A[q].c[1]].isroot = true;
		A[q].c[1] = p;
		A[q].update();
		A[p].isroot = false;
		p = q; q = A[q].f;
	}
	return ret;
}
int findroot(int x)
{
	access(x); splay(x); while(A[x].c[0]) x = A[x].c[0];
	return x;
}
int findfather(int x)
{
	access(x); splay(x); x = A[x].c[0]; while(A[x].c[1]) x = A[x].c[1];
	return x;
}
void cut(int x)
{
	int y = findfather(x);
	access(y); splay(y); A[y].c[1] = 0; A[y].update();
	A[x].f = 0; A[x].isroot = true;
}
bool connect(int x, int y) { return findroot(x) == findroot(y); }
void link(int x, int y)
{
	if (connect(x, y)){
		A[x].F = y; 
		return;
	}
	access(x); splay(x);
	A[x].f = y;
}
void change(int x, int k, int p, int b)
{
//case I
	int t = findroot(p);
	if (t == x){
		splay(x);
		A[x].k = k; A[x].b = b; 
		A[x].F = p; A[x].update(); 
		return; 
	}
//case II
	t = findroot(x);
	if (x == t){
		A[x].f = p; A[x].F = 0;
		A[x].k = k; A[x].b = b; A[x].update();
		return;
	}
//case III
	access(x);
	if (access(A[t].F) == x){
		cut(x);
		if (connect(x, p)) A[x].F = p;
		else{ 
			access(x); splay(x);
			A[x].f = p;
		}
		A[x].k = k; A[x].b = b; A[x].update();
		int temp = A[t].F; A[t].F = 0; link(t, temp);
		return;
	}
//case IV
	cut(x); A[x].k = k; A[x].b = b; link(x, p);
}
int inv[1000001], fa[1000001], n;
int query(int x)
{
	int t = findroot(x);
	int F = A[t].F;
	access(F); splay(F);
	int k = A[F].sumk, b = A[F].sumb;
	if (k == 1) if (b == 0) return -2; else return -1;
	int ans1 = b * inv[((1 - k) % MO + MO) % MO] % MO;
	access(x); splay(x);
	return (A[x].sumk * ans1 + A[x].sumb) % MO;
}
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
int main()
{
#ifndef ONLINE_JUDGE
	freopen("temp.in", "r", stdin); freopen("temp.out", "w", stdout);
#endif
	scanf("%d", &n); A[0].sumk = 1; A[0].sumb = 0;
	inv[1] = 1;
	for (int i = 2; i < MO; i++)
		inv[i] = (MO - MO / i) * inv[MO % i] % MO;
	for (int i = 1; i <= n; i++) fa[i] = i;
	for (int i = 1; i <= n; i++){
		int f;
		scanf("%d%d%d", &A[i].k, &f, &A[i].b);
		if (find(f) == find(i))
			A[i].F = f;
		else A[i].f = f;
		A[i].update(); fa[find(f)] = find(i);
		A[i].isroot = true;
	}
	int Q; scanf("%d", &Q);
	while(Q--){
		scanf(" ");
		char op; int x, k, p, b;
		scanf("%c", &op);
		switch(op){
			case 'A' : scanf("%d", &x); printf("%d\n", query(x)); break;
			case 'C' : scanf("%d%d%d%d", &x, &k, &p, &b); change(x, k, p, b); break;
		}
	} 

}